// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// > If 'application_id' is omitted, the policy created can be reused by multiple access applications.
//
//	Any `ZeroTrustAccessApplication` resource can reference reusable policies through its `policies` argument.
//	To destroy a reusable policy and remove it from all applications' policies lists on the same apply, preemptively set the
//	lifecycle option `createBeforeDestroy` to true on the 'cloudflare_zero_trust_access_policy' resource.
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy example '<account_id>/<policy_id>'
// ```
type ZeroTrustAccessPolicy struct {
	pulumi.CustomResourceState

	// Identifier
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Number of access applications currently using this policy.
	AppCount pulumi.IntOutput `pulumi:"appCount"`
	// Administrators who can approve a temporary authentication request.
	ApprovalGroups ZeroTrustAccessPolicyApprovalGroupArrayOutput `pulumi:"approvalGroups"`
	// Requires the user to request access from an administrator at the start of each session.
	ApprovalRequired pulumi.BoolOutput   `pulumi:"approvalRequired"`
	CreatedAt        pulumi.StringOutput `pulumi:"createdAt"`
	// The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
	// Available values: "allow", "deny", "nonIdentity", "bypass".
	Decision pulumi.StringOutput `pulumi:"decision"`
	// Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
	Excludes ZeroTrustAccessPolicyExcludeArrayOutput `pulumi:"excludes"`
	// Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
	Includes ZeroTrustAccessPolicyIncludeArrayOutput `pulumi:"includes"`
	// Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
	IsolationRequired pulumi.BoolOutput `pulumi:"isolationRequired"`
	// The name of the Access policy.
	Name pulumi.StringOutput `pulumi:"name"`
	// A custom message that will appear on the purpose justification screen.
	PurposeJustificationPrompt pulumi.StringPtrOutput `pulumi:"purposeJustificationPrompt"`
	// Require users to enter a justification when they log in to the application.
	PurposeJustificationRequired pulumi.BoolOutput `pulumi:"purposeJustificationRequired"`
	// Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
	Requires ZeroTrustAccessPolicyRequireArrayOutput `pulumi:"requires"`
	Reusable pulumi.BoolOutput                       `pulumi:"reusable"`
	// The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
	SessionDuration pulumi.StringOutput `pulumi:"sessionDuration"`
	UpdatedAt       pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewZeroTrustAccessPolicy registers a new resource with the given unique name, arguments, and options.
func NewZeroTrustAccessPolicy(ctx *pulumi.Context,
	name string, args *ZeroTrustAccessPolicyArgs, opts ...pulumi.ResourceOption) (*ZeroTrustAccessPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.Decision == nil {
		return nil, errors.New("invalid value for required argument 'Decision'")
	}
	if args.Includes == nil {
		return nil, errors.New("invalid value for required argument 'Includes'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("cloudflare:index/accessPolicy:AccessPolicy"),
		},
	})
	opts = append(opts, aliases)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ZeroTrustAccessPolicy
	err := ctx.RegisterResource("cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetZeroTrustAccessPolicy gets an existing ZeroTrustAccessPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetZeroTrustAccessPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ZeroTrustAccessPolicyState, opts ...pulumi.ResourceOption) (*ZeroTrustAccessPolicy, error) {
	var resource ZeroTrustAccessPolicy
	err := ctx.ReadResource("cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ZeroTrustAccessPolicy resources.
type zeroTrustAccessPolicyState struct {
	// Identifier
	AccountId *string `pulumi:"accountId"`
	// Number of access applications currently using this policy.
	AppCount *int `pulumi:"appCount"`
	// Administrators who can approve a temporary authentication request.
	ApprovalGroups []ZeroTrustAccessPolicyApprovalGroup `pulumi:"approvalGroups"`
	// Requires the user to request access from an administrator at the start of each session.
	ApprovalRequired *bool   `pulumi:"approvalRequired"`
	CreatedAt        *string `pulumi:"createdAt"`
	// The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
	// Available values: "allow", "deny", "nonIdentity", "bypass".
	Decision *string `pulumi:"decision"`
	// Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
	Excludes []ZeroTrustAccessPolicyExclude `pulumi:"excludes"`
	// Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
	Includes []ZeroTrustAccessPolicyInclude `pulumi:"includes"`
	// Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
	IsolationRequired *bool `pulumi:"isolationRequired"`
	// The name of the Access policy.
	Name *string `pulumi:"name"`
	// A custom message that will appear on the purpose justification screen.
	PurposeJustificationPrompt *string `pulumi:"purposeJustificationPrompt"`
	// Require users to enter a justification when they log in to the application.
	PurposeJustificationRequired *bool `pulumi:"purposeJustificationRequired"`
	// Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
	Requires []ZeroTrustAccessPolicyRequire `pulumi:"requires"`
	Reusable *bool                          `pulumi:"reusable"`
	// The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
	SessionDuration *string `pulumi:"sessionDuration"`
	UpdatedAt       *string `pulumi:"updatedAt"`
}

type ZeroTrustAccessPolicyState struct {
	// Identifier
	AccountId pulumi.StringPtrInput
	// Number of access applications currently using this policy.
	AppCount pulumi.IntPtrInput
	// Administrators who can approve a temporary authentication request.
	ApprovalGroups ZeroTrustAccessPolicyApprovalGroupArrayInput
	// Requires the user to request access from an administrator at the start of each session.
	ApprovalRequired pulumi.BoolPtrInput
	CreatedAt        pulumi.StringPtrInput
	// The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
	// Available values: "allow", "deny", "nonIdentity", "bypass".
	Decision pulumi.StringPtrInput
	// Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
	Excludes ZeroTrustAccessPolicyExcludeArrayInput
	// Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
	Includes ZeroTrustAccessPolicyIncludeArrayInput
	// Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
	IsolationRequired pulumi.BoolPtrInput
	// The name of the Access policy.
	Name pulumi.StringPtrInput
	// A custom message that will appear on the purpose justification screen.
	PurposeJustificationPrompt pulumi.StringPtrInput
	// Require users to enter a justification when they log in to the application.
	PurposeJustificationRequired pulumi.BoolPtrInput
	// Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
	Requires ZeroTrustAccessPolicyRequireArrayInput
	Reusable pulumi.BoolPtrInput
	// The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
	SessionDuration pulumi.StringPtrInput
	UpdatedAt       pulumi.StringPtrInput
}

func (ZeroTrustAccessPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*zeroTrustAccessPolicyState)(nil)).Elem()
}

type zeroTrustAccessPolicyArgs struct {
	// Identifier
	AccountId string `pulumi:"accountId"`
	// Administrators who can approve a temporary authentication request.
	ApprovalGroups []ZeroTrustAccessPolicyApprovalGroup `pulumi:"approvalGroups"`
	// Requires the user to request access from an administrator at the start of each session.
	ApprovalRequired *bool `pulumi:"approvalRequired"`
	// The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
	// Available values: "allow", "deny", "nonIdentity", "bypass".
	Decision string `pulumi:"decision"`
	// Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
	Excludes []ZeroTrustAccessPolicyExclude `pulumi:"excludes"`
	// Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
	Includes []ZeroTrustAccessPolicyInclude `pulumi:"includes"`
	// Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
	IsolationRequired *bool `pulumi:"isolationRequired"`
	// The name of the Access policy.
	Name string `pulumi:"name"`
	// A custom message that will appear on the purpose justification screen.
	PurposeJustificationPrompt *string `pulumi:"purposeJustificationPrompt"`
	// Require users to enter a justification when they log in to the application.
	PurposeJustificationRequired *bool `pulumi:"purposeJustificationRequired"`
	// Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
	Requires []ZeroTrustAccessPolicyRequire `pulumi:"requires"`
	// The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
	SessionDuration *string `pulumi:"sessionDuration"`
}

// The set of arguments for constructing a ZeroTrustAccessPolicy resource.
type ZeroTrustAccessPolicyArgs struct {
	// Identifier
	AccountId pulumi.StringInput
	// Administrators who can approve a temporary authentication request.
	ApprovalGroups ZeroTrustAccessPolicyApprovalGroupArrayInput
	// Requires the user to request access from an administrator at the start of each session.
	ApprovalRequired pulumi.BoolPtrInput
	// The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
	// Available values: "allow", "deny", "nonIdentity", "bypass".
	Decision pulumi.StringInput
	// Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
	Excludes ZeroTrustAccessPolicyExcludeArrayInput
	// Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
	Includes ZeroTrustAccessPolicyIncludeArrayInput
	// Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
	IsolationRequired pulumi.BoolPtrInput
	// The name of the Access policy.
	Name pulumi.StringInput
	// A custom message that will appear on the purpose justification screen.
	PurposeJustificationPrompt pulumi.StringPtrInput
	// Require users to enter a justification when they log in to the application.
	PurposeJustificationRequired pulumi.BoolPtrInput
	// Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
	Requires ZeroTrustAccessPolicyRequireArrayInput
	// The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
	SessionDuration pulumi.StringPtrInput
}

func (ZeroTrustAccessPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*zeroTrustAccessPolicyArgs)(nil)).Elem()
}

type ZeroTrustAccessPolicyInput interface {
	pulumi.Input

	ToZeroTrustAccessPolicyOutput() ZeroTrustAccessPolicyOutput
	ToZeroTrustAccessPolicyOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyOutput
}

func (*ZeroTrustAccessPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ZeroTrustAccessPolicy)(nil)).Elem()
}

func (i *ZeroTrustAccessPolicy) ToZeroTrustAccessPolicyOutput() ZeroTrustAccessPolicyOutput {
	return i.ToZeroTrustAccessPolicyOutputWithContext(context.Background())
}

func (i *ZeroTrustAccessPolicy) ToZeroTrustAccessPolicyOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZeroTrustAccessPolicyOutput)
}

// ZeroTrustAccessPolicyArrayInput is an input type that accepts ZeroTrustAccessPolicyArray and ZeroTrustAccessPolicyArrayOutput values.
// You can construct a concrete instance of `ZeroTrustAccessPolicyArrayInput` via:
//
//	ZeroTrustAccessPolicyArray{ ZeroTrustAccessPolicyArgs{...} }
type ZeroTrustAccessPolicyArrayInput interface {
	pulumi.Input

	ToZeroTrustAccessPolicyArrayOutput() ZeroTrustAccessPolicyArrayOutput
	ToZeroTrustAccessPolicyArrayOutputWithContext(context.Context) ZeroTrustAccessPolicyArrayOutput
}

type ZeroTrustAccessPolicyArray []ZeroTrustAccessPolicyInput

func (ZeroTrustAccessPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ZeroTrustAccessPolicy)(nil)).Elem()
}

func (i ZeroTrustAccessPolicyArray) ToZeroTrustAccessPolicyArrayOutput() ZeroTrustAccessPolicyArrayOutput {
	return i.ToZeroTrustAccessPolicyArrayOutputWithContext(context.Background())
}

func (i ZeroTrustAccessPolicyArray) ToZeroTrustAccessPolicyArrayOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZeroTrustAccessPolicyArrayOutput)
}

// ZeroTrustAccessPolicyMapInput is an input type that accepts ZeroTrustAccessPolicyMap and ZeroTrustAccessPolicyMapOutput values.
// You can construct a concrete instance of `ZeroTrustAccessPolicyMapInput` via:
//
//	ZeroTrustAccessPolicyMap{ "key": ZeroTrustAccessPolicyArgs{...} }
type ZeroTrustAccessPolicyMapInput interface {
	pulumi.Input

	ToZeroTrustAccessPolicyMapOutput() ZeroTrustAccessPolicyMapOutput
	ToZeroTrustAccessPolicyMapOutputWithContext(context.Context) ZeroTrustAccessPolicyMapOutput
}

type ZeroTrustAccessPolicyMap map[string]ZeroTrustAccessPolicyInput

func (ZeroTrustAccessPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ZeroTrustAccessPolicy)(nil)).Elem()
}

func (i ZeroTrustAccessPolicyMap) ToZeroTrustAccessPolicyMapOutput() ZeroTrustAccessPolicyMapOutput {
	return i.ToZeroTrustAccessPolicyMapOutputWithContext(context.Background())
}

func (i ZeroTrustAccessPolicyMap) ToZeroTrustAccessPolicyMapOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZeroTrustAccessPolicyMapOutput)
}

type ZeroTrustAccessPolicyOutput struct{ *pulumi.OutputState }

func (ZeroTrustAccessPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ZeroTrustAccessPolicy)(nil)).Elem()
}

func (o ZeroTrustAccessPolicyOutput) ToZeroTrustAccessPolicyOutput() ZeroTrustAccessPolicyOutput {
	return o
}

func (o ZeroTrustAccessPolicyOutput) ToZeroTrustAccessPolicyOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyOutput {
	return o
}

// Identifier
func (o ZeroTrustAccessPolicyOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Number of access applications currently using this policy.
func (o ZeroTrustAccessPolicyOutput) AppCount() pulumi.IntOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.IntOutput { return v.AppCount }).(pulumi.IntOutput)
}

// Administrators who can approve a temporary authentication request.
func (o ZeroTrustAccessPolicyOutput) ApprovalGroups() ZeroTrustAccessPolicyApprovalGroupArrayOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) ZeroTrustAccessPolicyApprovalGroupArrayOutput { return v.ApprovalGroups }).(ZeroTrustAccessPolicyApprovalGroupArrayOutput)
}

// Requires the user to request access from an administrator at the start of each session.
func (o ZeroTrustAccessPolicyOutput) ApprovalRequired() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.BoolOutput { return v.ApprovalRequired }).(pulumi.BoolOutput)
}

func (o ZeroTrustAccessPolicyOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
// Available values: "allow", "deny", "nonIdentity", "bypass".
func (o ZeroTrustAccessPolicyOutput) Decision() pulumi.StringOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringOutput { return v.Decision }).(pulumi.StringOutput)
}

// Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
func (o ZeroTrustAccessPolicyOutput) Excludes() ZeroTrustAccessPolicyExcludeArrayOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) ZeroTrustAccessPolicyExcludeArrayOutput { return v.Excludes }).(ZeroTrustAccessPolicyExcludeArrayOutput)
}

// Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
func (o ZeroTrustAccessPolicyOutput) Includes() ZeroTrustAccessPolicyIncludeArrayOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) ZeroTrustAccessPolicyIncludeArrayOutput { return v.Includes }).(ZeroTrustAccessPolicyIncludeArrayOutput)
}

// Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
func (o ZeroTrustAccessPolicyOutput) IsolationRequired() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.BoolOutput { return v.IsolationRequired }).(pulumi.BoolOutput)
}

// The name of the Access policy.
func (o ZeroTrustAccessPolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// A custom message that will appear on the purpose justification screen.
func (o ZeroTrustAccessPolicyOutput) PurposeJustificationPrompt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringPtrOutput { return v.PurposeJustificationPrompt }).(pulumi.StringPtrOutput)
}

// Require users to enter a justification when they log in to the application.
func (o ZeroTrustAccessPolicyOutput) PurposeJustificationRequired() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.BoolOutput { return v.PurposeJustificationRequired }).(pulumi.BoolOutput)
}

// Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
func (o ZeroTrustAccessPolicyOutput) Requires() ZeroTrustAccessPolicyRequireArrayOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) ZeroTrustAccessPolicyRequireArrayOutput { return v.Requires }).(ZeroTrustAccessPolicyRequireArrayOutput)
}

func (o ZeroTrustAccessPolicyOutput) Reusable() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.BoolOutput { return v.Reusable }).(pulumi.BoolOutput)
}

// The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
func (o ZeroTrustAccessPolicyOutput) SessionDuration() pulumi.StringOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringOutput { return v.SessionDuration }).(pulumi.StringOutput)
}

func (o ZeroTrustAccessPolicyOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ZeroTrustAccessPolicy) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type ZeroTrustAccessPolicyArrayOutput struct{ *pulumi.OutputState }

func (ZeroTrustAccessPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ZeroTrustAccessPolicy)(nil)).Elem()
}

func (o ZeroTrustAccessPolicyArrayOutput) ToZeroTrustAccessPolicyArrayOutput() ZeroTrustAccessPolicyArrayOutput {
	return o
}

func (o ZeroTrustAccessPolicyArrayOutput) ToZeroTrustAccessPolicyArrayOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyArrayOutput {
	return o
}

func (o ZeroTrustAccessPolicyArrayOutput) Index(i pulumi.IntInput) ZeroTrustAccessPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ZeroTrustAccessPolicy {
		return vs[0].([]*ZeroTrustAccessPolicy)[vs[1].(int)]
	}).(ZeroTrustAccessPolicyOutput)
}

type ZeroTrustAccessPolicyMapOutput struct{ *pulumi.OutputState }

func (ZeroTrustAccessPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ZeroTrustAccessPolicy)(nil)).Elem()
}

func (o ZeroTrustAccessPolicyMapOutput) ToZeroTrustAccessPolicyMapOutput() ZeroTrustAccessPolicyMapOutput {
	return o
}

func (o ZeroTrustAccessPolicyMapOutput) ToZeroTrustAccessPolicyMapOutputWithContext(ctx context.Context) ZeroTrustAccessPolicyMapOutput {
	return o
}

func (o ZeroTrustAccessPolicyMapOutput) MapIndex(k pulumi.StringInput) ZeroTrustAccessPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ZeroTrustAccessPolicy {
		return vs[0].(map[string]*ZeroTrustAccessPolicy)[vs[1].(string)]
	}).(ZeroTrustAccessPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ZeroTrustAccessPolicyInput)(nil)).Elem(), &ZeroTrustAccessPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZeroTrustAccessPolicyArrayInput)(nil)).Elem(), ZeroTrustAccessPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZeroTrustAccessPolicyMapInput)(nil)).Elem(), ZeroTrustAccessPolicyMap{})
	pulumi.RegisterOutputType(ZeroTrustAccessPolicyOutput{})
	pulumi.RegisterOutputType(ZeroTrustAccessPolicyArrayOutput{})
	pulumi.RegisterOutputType(ZeroTrustAccessPolicyMapOutput{})
}
