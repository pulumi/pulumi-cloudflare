// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewLoadBalancerMonitor(ctx, "example_load_balancer_monitor", &cloudflare.LoadBalancerMonitorArgs{
//				AccountId:       pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				AllowInsecure:   pulumi.Bool(true),
//				ConsecutiveDown: pulumi.Int(0),
//				ConsecutiveUp:   pulumi.Int(0),
//				Description:     pulumi.String("Login page monitor"),
//				ExpectedBody:    pulumi.String("alive"),
//				ExpectedCodes:   pulumi.String("2xx"),
//				FollowRedirects: pulumi.Bool(true),
//				Header: pulumi.StringArrayMap{
//					"Host": pulumi.StringArray{
//						pulumi.String("example.com"),
//					},
//					"X-App-ID": pulumi.StringArray{
//						pulumi.String("abc123"),
//					},
//				},
//				Interval:  pulumi.Int(0),
//				Method:    pulumi.String("GET"),
//				Path:      pulumi.String("/health"),
//				Port:      pulumi.Int(0),
//				ProbeZone: pulumi.String("example.com"),
//				Retries:   pulumi.Int(0),
//				Timeout:   pulumi.Int(0),
//				Type:      pulumi.String("https"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor example '<account_id>/<monitor_id>'
// ```
type LoadBalancerMonitor struct {
	pulumi.CustomResourceState

	// Identifier
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure pulumi.BoolOutput `pulumi:"allowInsecure"`
	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown pulumi.IntOutput `pulumi:"consecutiveDown"`
	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp pulumi.IntOutput    `pulumi:"consecutiveUp"`
	CreatedOn     pulumi.StringOutput `pulumi:"createdOn"`
	// Object description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody pulumi.StringPtrOutput `pulumi:"expectedBody"`
	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes pulumi.StringPtrOutput `pulumi:"expectedCodes"`
	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects pulumi.BoolOutput `pulumi:"followRedirects"`
	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header pulumi.StringArrayMapOutput `pulumi:"header"`
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval pulumi.IntOutput `pulumi:"interval"`
	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method     pulumi.StringOutput `pulumi:"method"`
	ModifiedOn pulumi.StringOutput `pulumi:"modifiedOn"`
	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path pulumi.StringOutput `pulumi:"path"`
	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port pulumi.IntOutput `pulumi:"port"`
	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone pulumi.StringPtrOutput `pulumi:"probeZone"`
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries pulumi.IntOutput `pulumi:"retries"`
	// The timeout (in seconds) before marking the health check as failed.
	Timeout pulumi.IntOutput `pulumi:"timeout"`
	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewLoadBalancerMonitor registers a new resource with the given unique name, arguments, and options.
func NewLoadBalancerMonitor(ctx *pulumi.Context,
	name string, args *LoadBalancerMonitorArgs, opts ...pulumi.ResourceOption) (*LoadBalancerMonitor, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LoadBalancerMonitor
	err := ctx.RegisterResource("cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLoadBalancerMonitor gets an existing LoadBalancerMonitor resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLoadBalancerMonitor(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LoadBalancerMonitorState, opts ...pulumi.ResourceOption) (*LoadBalancerMonitor, error) {
	var resource LoadBalancerMonitor
	err := ctx.ReadResource("cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LoadBalancerMonitor resources.
type loadBalancerMonitorState struct {
	// Identifier
	AccountId *string `pulumi:"accountId"`
	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure *bool `pulumi:"allowInsecure"`
	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown *int `pulumi:"consecutiveDown"`
	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp *int    `pulumi:"consecutiveUp"`
	CreatedOn     *string `pulumi:"createdOn"`
	// Object description.
	Description *string `pulumi:"description"`
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody *string `pulumi:"expectedBody"`
	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes *string `pulumi:"expectedCodes"`
	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects *bool `pulumi:"followRedirects"`
	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header map[string][]string `pulumi:"header"`
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval *int `pulumi:"interval"`
	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method     *string `pulumi:"method"`
	ModifiedOn *string `pulumi:"modifiedOn"`
	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path *string `pulumi:"path"`
	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port *int `pulumi:"port"`
	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone *string `pulumi:"probeZone"`
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries *int `pulumi:"retries"`
	// The timeout (in seconds) before marking the health check as failed.
	Timeout *int `pulumi:"timeout"`
	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
	Type *string `pulumi:"type"`
}

type LoadBalancerMonitorState struct {
	// Identifier
	AccountId pulumi.StringPtrInput
	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure pulumi.BoolPtrInput
	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown pulumi.IntPtrInput
	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp pulumi.IntPtrInput
	CreatedOn     pulumi.StringPtrInput
	// Object description.
	Description pulumi.StringPtrInput
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody pulumi.StringPtrInput
	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes pulumi.StringPtrInput
	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects pulumi.BoolPtrInput
	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header pulumi.StringArrayMapInput
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval pulumi.IntPtrInput
	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method     pulumi.StringPtrInput
	ModifiedOn pulumi.StringPtrInput
	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path pulumi.StringPtrInput
	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port pulumi.IntPtrInput
	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone pulumi.StringPtrInput
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries pulumi.IntPtrInput
	// The timeout (in seconds) before marking the health check as failed.
	Timeout pulumi.IntPtrInput
	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
	Type pulumi.StringPtrInput
}

func (LoadBalancerMonitorState) ElementType() reflect.Type {
	return reflect.TypeOf((*loadBalancerMonitorState)(nil)).Elem()
}

type loadBalancerMonitorArgs struct {
	// Identifier
	AccountId string `pulumi:"accountId"`
	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure *bool `pulumi:"allowInsecure"`
	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown *int `pulumi:"consecutiveDown"`
	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp *int `pulumi:"consecutiveUp"`
	// Object description.
	Description *string `pulumi:"description"`
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody *string `pulumi:"expectedBody"`
	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes *string `pulumi:"expectedCodes"`
	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects *bool `pulumi:"followRedirects"`
	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header map[string][]string `pulumi:"header"`
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval *int `pulumi:"interval"`
	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method *string `pulumi:"method"`
	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path *string `pulumi:"path"`
	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port *int `pulumi:"port"`
	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone *string `pulumi:"probeZone"`
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries *int `pulumi:"retries"`
	// The timeout (in seconds) before marking the health check as failed.
	Timeout *int `pulumi:"timeout"`
	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a LoadBalancerMonitor resource.
type LoadBalancerMonitorArgs struct {
	// Identifier
	AccountId pulumi.StringInput
	// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
	AllowInsecure pulumi.BoolPtrInput
	// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
	ConsecutiveDown pulumi.IntPtrInput
	// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
	ConsecutiveUp pulumi.IntPtrInput
	// Object description.
	Description pulumi.StringPtrInput
	// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedBody pulumi.StringPtrInput
	// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
	ExpectedCodes pulumi.StringPtrInput
	// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
	FollowRedirects pulumi.BoolPtrInput
	// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
	Header pulumi.StringArrayMapInput
	// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
	Interval pulumi.IntPtrInput
	// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
	Method pulumi.StringPtrInput
	// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
	Path pulumi.StringPtrInput
	// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
	Port pulumi.IntPtrInput
	// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
	ProbeZone pulumi.StringPtrInput
	// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
	Retries pulumi.IntPtrInput
	// The timeout (in seconds) before marking the health check as failed.
	Timeout pulumi.IntPtrInput
	// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
	// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
	Type pulumi.StringPtrInput
}

func (LoadBalancerMonitorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*loadBalancerMonitorArgs)(nil)).Elem()
}

type LoadBalancerMonitorInput interface {
	pulumi.Input

	ToLoadBalancerMonitorOutput() LoadBalancerMonitorOutput
	ToLoadBalancerMonitorOutputWithContext(ctx context.Context) LoadBalancerMonitorOutput
}

func (*LoadBalancerMonitor) ElementType() reflect.Type {
	return reflect.TypeOf((**LoadBalancerMonitor)(nil)).Elem()
}

func (i *LoadBalancerMonitor) ToLoadBalancerMonitorOutput() LoadBalancerMonitorOutput {
	return i.ToLoadBalancerMonitorOutputWithContext(context.Background())
}

func (i *LoadBalancerMonitor) ToLoadBalancerMonitorOutputWithContext(ctx context.Context) LoadBalancerMonitorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancerMonitorOutput)
}

// LoadBalancerMonitorArrayInput is an input type that accepts LoadBalancerMonitorArray and LoadBalancerMonitorArrayOutput values.
// You can construct a concrete instance of `LoadBalancerMonitorArrayInput` via:
//
//	LoadBalancerMonitorArray{ LoadBalancerMonitorArgs{...} }
type LoadBalancerMonitorArrayInput interface {
	pulumi.Input

	ToLoadBalancerMonitorArrayOutput() LoadBalancerMonitorArrayOutput
	ToLoadBalancerMonitorArrayOutputWithContext(context.Context) LoadBalancerMonitorArrayOutput
}

type LoadBalancerMonitorArray []LoadBalancerMonitorInput

func (LoadBalancerMonitorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LoadBalancerMonitor)(nil)).Elem()
}

func (i LoadBalancerMonitorArray) ToLoadBalancerMonitorArrayOutput() LoadBalancerMonitorArrayOutput {
	return i.ToLoadBalancerMonitorArrayOutputWithContext(context.Background())
}

func (i LoadBalancerMonitorArray) ToLoadBalancerMonitorArrayOutputWithContext(ctx context.Context) LoadBalancerMonitorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancerMonitorArrayOutput)
}

// LoadBalancerMonitorMapInput is an input type that accepts LoadBalancerMonitorMap and LoadBalancerMonitorMapOutput values.
// You can construct a concrete instance of `LoadBalancerMonitorMapInput` via:
//
//	LoadBalancerMonitorMap{ "key": LoadBalancerMonitorArgs{...} }
type LoadBalancerMonitorMapInput interface {
	pulumi.Input

	ToLoadBalancerMonitorMapOutput() LoadBalancerMonitorMapOutput
	ToLoadBalancerMonitorMapOutputWithContext(context.Context) LoadBalancerMonitorMapOutput
}

type LoadBalancerMonitorMap map[string]LoadBalancerMonitorInput

func (LoadBalancerMonitorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LoadBalancerMonitor)(nil)).Elem()
}

func (i LoadBalancerMonitorMap) ToLoadBalancerMonitorMapOutput() LoadBalancerMonitorMapOutput {
	return i.ToLoadBalancerMonitorMapOutputWithContext(context.Background())
}

func (i LoadBalancerMonitorMap) ToLoadBalancerMonitorMapOutputWithContext(ctx context.Context) LoadBalancerMonitorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadBalancerMonitorMapOutput)
}

type LoadBalancerMonitorOutput struct{ *pulumi.OutputState }

func (LoadBalancerMonitorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoadBalancerMonitor)(nil)).Elem()
}

func (o LoadBalancerMonitorOutput) ToLoadBalancerMonitorOutput() LoadBalancerMonitorOutput {
	return o
}

func (o LoadBalancerMonitorOutput) ToLoadBalancerMonitorOutputWithContext(ctx context.Context) LoadBalancerMonitorOutput {
	return o
}

// Identifier
func (o LoadBalancerMonitorOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) AllowInsecure() pulumi.BoolOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.BoolOutput { return v.AllowInsecure }).(pulumi.BoolOutput)
}

// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
func (o LoadBalancerMonitorOutput) ConsecutiveDown() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.IntOutput { return v.ConsecutiveDown }).(pulumi.IntOutput)
}

// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
func (o LoadBalancerMonitorOutput) ConsecutiveUp() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.IntOutput { return v.ConsecutiveUp }).(pulumi.IntOutput)
}

func (o LoadBalancerMonitorOutput) CreatedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringOutput { return v.CreatedOn }).(pulumi.StringOutput)
}

// Object description.
func (o LoadBalancerMonitorOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) ExpectedBody() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringPtrOutput { return v.ExpectedBody }).(pulumi.StringPtrOutput)
}

// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) ExpectedCodes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringPtrOutput { return v.ExpectedCodes }).(pulumi.StringPtrOutput)
}

// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) FollowRedirects() pulumi.BoolOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.BoolOutput { return v.FollowRedirects }).(pulumi.BoolOutput)
}

// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) Header() pulumi.StringArrayMapOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringArrayMapOutput { return v.Header }).(pulumi.StringArrayMapOutput)
}

// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
func (o LoadBalancerMonitorOutput) Interval() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.IntOutput { return v.Interval }).(pulumi.IntOutput)
}

// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
func (o LoadBalancerMonitorOutput) Method() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringOutput { return v.Method }).(pulumi.StringOutput)
}

func (o LoadBalancerMonitorOutput) ModifiedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringOutput { return v.ModifiedOn }).(pulumi.StringOutput)
}

// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringOutput { return v.Path }).(pulumi.StringOutput)
}

// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
func (o LoadBalancerMonitorOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.IntOutput { return v.Port }).(pulumi.IntOutput)
}

// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
func (o LoadBalancerMonitorOutput) ProbeZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringPtrOutput { return v.ProbeZone }).(pulumi.StringPtrOutput)
}

// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
func (o LoadBalancerMonitorOutput) Retries() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.IntOutput { return v.Retries }).(pulumi.IntOutput)
}

// The timeout (in seconds) before marking the health check as failed.
func (o LoadBalancerMonitorOutput) Timeout() pulumi.IntOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.IntOutput { return v.Timeout }).(pulumi.IntOutput)
}

// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
func (o LoadBalancerMonitorOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *LoadBalancerMonitor) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type LoadBalancerMonitorArrayOutput struct{ *pulumi.OutputState }

func (LoadBalancerMonitorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LoadBalancerMonitor)(nil)).Elem()
}

func (o LoadBalancerMonitorArrayOutput) ToLoadBalancerMonitorArrayOutput() LoadBalancerMonitorArrayOutput {
	return o
}

func (o LoadBalancerMonitorArrayOutput) ToLoadBalancerMonitorArrayOutputWithContext(ctx context.Context) LoadBalancerMonitorArrayOutput {
	return o
}

func (o LoadBalancerMonitorArrayOutput) Index(i pulumi.IntInput) LoadBalancerMonitorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LoadBalancerMonitor {
		return vs[0].([]*LoadBalancerMonitor)[vs[1].(int)]
	}).(LoadBalancerMonitorOutput)
}

type LoadBalancerMonitorMapOutput struct{ *pulumi.OutputState }

func (LoadBalancerMonitorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LoadBalancerMonitor)(nil)).Elem()
}

func (o LoadBalancerMonitorMapOutput) ToLoadBalancerMonitorMapOutput() LoadBalancerMonitorMapOutput {
	return o
}

func (o LoadBalancerMonitorMapOutput) ToLoadBalancerMonitorMapOutputWithContext(ctx context.Context) LoadBalancerMonitorMapOutput {
	return o
}

func (o LoadBalancerMonitorMapOutput) MapIndex(k pulumi.StringInput) LoadBalancerMonitorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LoadBalancerMonitor {
		return vs[0].(map[string]*LoadBalancerMonitor)[vs[1].(string)]
	}).(LoadBalancerMonitorOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LoadBalancerMonitorInput)(nil)).Elem(), &LoadBalancerMonitor{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoadBalancerMonitorArrayInput)(nil)).Elem(), LoadBalancerMonitorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoadBalancerMonitorMapInput)(nil)).Elem(), LoadBalancerMonitorMap{})
	pulumi.RegisterOutputType(LoadBalancerMonitorOutput{})
	pulumi.RegisterOutputType(LoadBalancerMonitorArrayOutput{})
	pulumi.RegisterOutputType(LoadBalancerMonitorMapOutput{})
}
