// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// The [D1 Database](https://developers.cloudflare.com/d1/) resource allows you to manage Cloudflare D1 databases.
//
// !> When a D1 Database is replaced all the data is lost. Please ensure you have a backup of your data before replacing a D1 Database.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewD1Database(ctx, "example", &cloudflare.D1DatabaseArgs{
//				AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
//				Name:      pulumi.String("terraform-database"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import cloudflare:index/d1Database:D1Database example <account id>/<database id>
//
// ```
type D1Database struct {
	pulumi.CustomResourceState

	// The account identifier to target for the resource.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// The name of the D1 Database.
	Name pulumi.StringOutput `pulumi:"name"`
	// The backend version of the database.
	Version pulumi.StringOutput `pulumi:"version"`
}

// NewD1Database registers a new resource with the given unique name, arguments, and options.
func NewD1Database(ctx *pulumi.Context,
	name string, args *D1DatabaseArgs, opts ...pulumi.ResourceOption) (*D1Database, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource D1Database
	err := ctx.RegisterResource("cloudflare:index/d1Database:D1Database", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetD1Database gets an existing D1Database resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetD1Database(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *D1DatabaseState, opts ...pulumi.ResourceOption) (*D1Database, error) {
	var resource D1Database
	err := ctx.ReadResource("cloudflare:index/d1Database:D1Database", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering D1Database resources.
type d1databaseState struct {
	// The account identifier to target for the resource.
	AccountId *string `pulumi:"accountId"`
	// The name of the D1 Database.
	Name *string `pulumi:"name"`
	// The backend version of the database.
	Version *string `pulumi:"version"`
}

type D1DatabaseState struct {
	// The account identifier to target for the resource.
	AccountId pulumi.StringPtrInput
	// The name of the D1 Database.
	Name pulumi.StringPtrInput
	// The backend version of the database.
	Version pulumi.StringPtrInput
}

func (D1DatabaseState) ElementType() reflect.Type {
	return reflect.TypeOf((*d1databaseState)(nil)).Elem()
}

type d1databaseArgs struct {
	// The account identifier to target for the resource.
	AccountId string `pulumi:"accountId"`
	// The name of the D1 Database.
	Name string `pulumi:"name"`
}

// The set of arguments for constructing a D1Database resource.
type D1DatabaseArgs struct {
	// The account identifier to target for the resource.
	AccountId pulumi.StringInput
	// The name of the D1 Database.
	Name pulumi.StringInput
}

func (D1DatabaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*d1databaseArgs)(nil)).Elem()
}

type D1DatabaseInput interface {
	pulumi.Input

	ToD1DatabaseOutput() D1DatabaseOutput
	ToD1DatabaseOutputWithContext(ctx context.Context) D1DatabaseOutput
}

func (*D1Database) ElementType() reflect.Type {
	return reflect.TypeOf((**D1Database)(nil)).Elem()
}

func (i *D1Database) ToD1DatabaseOutput() D1DatabaseOutput {
	return i.ToD1DatabaseOutputWithContext(context.Background())
}

func (i *D1Database) ToD1DatabaseOutputWithContext(ctx context.Context) D1DatabaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(D1DatabaseOutput)
}

func (i *D1Database) ToOutput(ctx context.Context) pulumix.Output[*D1Database] {
	return pulumix.Output[*D1Database]{
		OutputState: i.ToD1DatabaseOutputWithContext(ctx).OutputState,
	}
}

// D1DatabaseArrayInput is an input type that accepts D1DatabaseArray and D1DatabaseArrayOutput values.
// You can construct a concrete instance of `D1DatabaseArrayInput` via:
//
//	D1DatabaseArray{ D1DatabaseArgs{...} }
type D1DatabaseArrayInput interface {
	pulumi.Input

	ToD1DatabaseArrayOutput() D1DatabaseArrayOutput
	ToD1DatabaseArrayOutputWithContext(context.Context) D1DatabaseArrayOutput
}

type D1DatabaseArray []D1DatabaseInput

func (D1DatabaseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*D1Database)(nil)).Elem()
}

func (i D1DatabaseArray) ToD1DatabaseArrayOutput() D1DatabaseArrayOutput {
	return i.ToD1DatabaseArrayOutputWithContext(context.Background())
}

func (i D1DatabaseArray) ToD1DatabaseArrayOutputWithContext(ctx context.Context) D1DatabaseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(D1DatabaseArrayOutput)
}

func (i D1DatabaseArray) ToOutput(ctx context.Context) pulumix.Output[[]*D1Database] {
	return pulumix.Output[[]*D1Database]{
		OutputState: i.ToD1DatabaseArrayOutputWithContext(ctx).OutputState,
	}
}

// D1DatabaseMapInput is an input type that accepts D1DatabaseMap and D1DatabaseMapOutput values.
// You can construct a concrete instance of `D1DatabaseMapInput` via:
//
//	D1DatabaseMap{ "key": D1DatabaseArgs{...} }
type D1DatabaseMapInput interface {
	pulumi.Input

	ToD1DatabaseMapOutput() D1DatabaseMapOutput
	ToD1DatabaseMapOutputWithContext(context.Context) D1DatabaseMapOutput
}

type D1DatabaseMap map[string]D1DatabaseInput

func (D1DatabaseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*D1Database)(nil)).Elem()
}

func (i D1DatabaseMap) ToD1DatabaseMapOutput() D1DatabaseMapOutput {
	return i.ToD1DatabaseMapOutputWithContext(context.Background())
}

func (i D1DatabaseMap) ToD1DatabaseMapOutputWithContext(ctx context.Context) D1DatabaseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(D1DatabaseMapOutput)
}

func (i D1DatabaseMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*D1Database] {
	return pulumix.Output[map[string]*D1Database]{
		OutputState: i.ToD1DatabaseMapOutputWithContext(ctx).OutputState,
	}
}

type D1DatabaseOutput struct{ *pulumi.OutputState }

func (D1DatabaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**D1Database)(nil)).Elem()
}

func (o D1DatabaseOutput) ToD1DatabaseOutput() D1DatabaseOutput {
	return o
}

func (o D1DatabaseOutput) ToD1DatabaseOutputWithContext(ctx context.Context) D1DatabaseOutput {
	return o
}

func (o D1DatabaseOutput) ToOutput(ctx context.Context) pulumix.Output[*D1Database] {
	return pulumix.Output[*D1Database]{
		OutputState: o.OutputState,
	}
}

// The account identifier to target for the resource.
func (o D1DatabaseOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *D1Database) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// The name of the D1 Database.
func (o D1DatabaseOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *D1Database) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The backend version of the database.
func (o D1DatabaseOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *D1Database) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

type D1DatabaseArrayOutput struct{ *pulumi.OutputState }

func (D1DatabaseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*D1Database)(nil)).Elem()
}

func (o D1DatabaseArrayOutput) ToD1DatabaseArrayOutput() D1DatabaseArrayOutput {
	return o
}

func (o D1DatabaseArrayOutput) ToD1DatabaseArrayOutputWithContext(ctx context.Context) D1DatabaseArrayOutput {
	return o
}

func (o D1DatabaseArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*D1Database] {
	return pulumix.Output[[]*D1Database]{
		OutputState: o.OutputState,
	}
}

func (o D1DatabaseArrayOutput) Index(i pulumi.IntInput) D1DatabaseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *D1Database {
		return vs[0].([]*D1Database)[vs[1].(int)]
	}).(D1DatabaseOutput)
}

type D1DatabaseMapOutput struct{ *pulumi.OutputState }

func (D1DatabaseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*D1Database)(nil)).Elem()
}

func (o D1DatabaseMapOutput) ToD1DatabaseMapOutput() D1DatabaseMapOutput {
	return o
}

func (o D1DatabaseMapOutput) ToD1DatabaseMapOutputWithContext(ctx context.Context) D1DatabaseMapOutput {
	return o
}

func (o D1DatabaseMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*D1Database] {
	return pulumix.Output[map[string]*D1Database]{
		OutputState: o.OutputState,
	}
}

func (o D1DatabaseMapOutput) MapIndex(k pulumi.StringInput) D1DatabaseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *D1Database {
		return vs[0].(map[string]*D1Database)[vs[1].(string)]
	}).(D1DatabaseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*D1DatabaseInput)(nil)).Elem(), &D1Database{})
	pulumi.RegisterInputType(reflect.TypeOf((*D1DatabaseArrayInput)(nil)).Elem(), D1DatabaseArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*D1DatabaseMapInput)(nil)).Elem(), D1DatabaseMap{})
	pulumi.RegisterOutputType(D1DatabaseOutput{})
	pulumi.RegisterOutputType(D1DatabaseArrayOutput{})
	pulumi.RegisterOutputType(D1DatabaseMapOutput{})
}
