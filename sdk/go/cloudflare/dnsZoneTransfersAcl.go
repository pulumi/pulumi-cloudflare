// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewDnsZoneTransfersAcl(ctx, "example_dns_zone_transfers_acl", &cloudflare.DnsZoneTransfersAclArgs{
//				AccountId: pulumi.String("01a7362d577a6c3019a474fd6f485823"),
//				IpRange:   pulumi.String("192.0.2.53/28"),
//				Name:      pulumi.String("my-acl-1"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/dnsZoneTransfersAcl:DnsZoneTransfersAcl example '<account_id>/<acl_id>'
// ```
type DnsZoneTransfersAcl struct {
	pulumi.CustomResourceState

	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IpRange pulumi.StringOutput `pulumi:"ipRange"`
	// The name of the acl.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewDnsZoneTransfersAcl registers a new resource with the given unique name, arguments, and options.
func NewDnsZoneTransfersAcl(ctx *pulumi.Context,
	name string, args *DnsZoneTransfersAclArgs, opts ...pulumi.ResourceOption) (*DnsZoneTransfersAcl, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.IpRange == nil {
		return nil, errors.New("invalid value for required argument 'IpRange'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DnsZoneTransfersAcl
	err := ctx.RegisterResource("cloudflare:index/dnsZoneTransfersAcl:DnsZoneTransfersAcl", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDnsZoneTransfersAcl gets an existing DnsZoneTransfersAcl resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDnsZoneTransfersAcl(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DnsZoneTransfersAclState, opts ...pulumi.ResourceOption) (*DnsZoneTransfersAcl, error) {
	var resource DnsZoneTransfersAcl
	err := ctx.ReadResource("cloudflare:index/dnsZoneTransfersAcl:DnsZoneTransfersAcl", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DnsZoneTransfersAcl resources.
type dnsZoneTransfersAclState struct {
	AccountId *string `pulumi:"accountId"`
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IpRange *string `pulumi:"ipRange"`
	// The name of the acl.
	Name *string `pulumi:"name"`
}

type DnsZoneTransfersAclState struct {
	AccountId pulumi.StringPtrInput
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IpRange pulumi.StringPtrInput
	// The name of the acl.
	Name pulumi.StringPtrInput
}

func (DnsZoneTransfersAclState) ElementType() reflect.Type {
	return reflect.TypeOf((*dnsZoneTransfersAclState)(nil)).Elem()
}

type dnsZoneTransfersAclArgs struct {
	AccountId string `pulumi:"accountId"`
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IpRange string `pulumi:"ipRange"`
	// The name of the acl.
	Name string `pulumi:"name"`
}

// The set of arguments for constructing a DnsZoneTransfersAcl resource.
type DnsZoneTransfersAclArgs struct {
	AccountId pulumi.StringInput
	// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
	IpRange pulumi.StringInput
	// The name of the acl.
	Name pulumi.StringInput
}

func (DnsZoneTransfersAclArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dnsZoneTransfersAclArgs)(nil)).Elem()
}

type DnsZoneTransfersAclInput interface {
	pulumi.Input

	ToDnsZoneTransfersAclOutput() DnsZoneTransfersAclOutput
	ToDnsZoneTransfersAclOutputWithContext(ctx context.Context) DnsZoneTransfersAclOutput
}

func (*DnsZoneTransfersAcl) ElementType() reflect.Type {
	return reflect.TypeOf((**DnsZoneTransfersAcl)(nil)).Elem()
}

func (i *DnsZoneTransfersAcl) ToDnsZoneTransfersAclOutput() DnsZoneTransfersAclOutput {
	return i.ToDnsZoneTransfersAclOutputWithContext(context.Background())
}

func (i *DnsZoneTransfersAcl) ToDnsZoneTransfersAclOutputWithContext(ctx context.Context) DnsZoneTransfersAclOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsZoneTransfersAclOutput)
}

// DnsZoneTransfersAclArrayInput is an input type that accepts DnsZoneTransfersAclArray and DnsZoneTransfersAclArrayOutput values.
// You can construct a concrete instance of `DnsZoneTransfersAclArrayInput` via:
//
//	DnsZoneTransfersAclArray{ DnsZoneTransfersAclArgs{...} }
type DnsZoneTransfersAclArrayInput interface {
	pulumi.Input

	ToDnsZoneTransfersAclArrayOutput() DnsZoneTransfersAclArrayOutput
	ToDnsZoneTransfersAclArrayOutputWithContext(context.Context) DnsZoneTransfersAclArrayOutput
}

type DnsZoneTransfersAclArray []DnsZoneTransfersAclInput

func (DnsZoneTransfersAclArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DnsZoneTransfersAcl)(nil)).Elem()
}

func (i DnsZoneTransfersAclArray) ToDnsZoneTransfersAclArrayOutput() DnsZoneTransfersAclArrayOutput {
	return i.ToDnsZoneTransfersAclArrayOutputWithContext(context.Background())
}

func (i DnsZoneTransfersAclArray) ToDnsZoneTransfersAclArrayOutputWithContext(ctx context.Context) DnsZoneTransfersAclArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsZoneTransfersAclArrayOutput)
}

// DnsZoneTransfersAclMapInput is an input type that accepts DnsZoneTransfersAclMap and DnsZoneTransfersAclMapOutput values.
// You can construct a concrete instance of `DnsZoneTransfersAclMapInput` via:
//
//	DnsZoneTransfersAclMap{ "key": DnsZoneTransfersAclArgs{...} }
type DnsZoneTransfersAclMapInput interface {
	pulumi.Input

	ToDnsZoneTransfersAclMapOutput() DnsZoneTransfersAclMapOutput
	ToDnsZoneTransfersAclMapOutputWithContext(context.Context) DnsZoneTransfersAclMapOutput
}

type DnsZoneTransfersAclMap map[string]DnsZoneTransfersAclInput

func (DnsZoneTransfersAclMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DnsZoneTransfersAcl)(nil)).Elem()
}

func (i DnsZoneTransfersAclMap) ToDnsZoneTransfersAclMapOutput() DnsZoneTransfersAclMapOutput {
	return i.ToDnsZoneTransfersAclMapOutputWithContext(context.Background())
}

func (i DnsZoneTransfersAclMap) ToDnsZoneTransfersAclMapOutputWithContext(ctx context.Context) DnsZoneTransfersAclMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsZoneTransfersAclMapOutput)
}

type DnsZoneTransfersAclOutput struct{ *pulumi.OutputState }

func (DnsZoneTransfersAclOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DnsZoneTransfersAcl)(nil)).Elem()
}

func (o DnsZoneTransfersAclOutput) ToDnsZoneTransfersAclOutput() DnsZoneTransfersAclOutput {
	return o
}

func (o DnsZoneTransfersAclOutput) ToDnsZoneTransfersAclOutputWithContext(ctx context.Context) DnsZoneTransfersAclOutput {
	return o
}

func (o DnsZoneTransfersAclOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsZoneTransfersAcl) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
func (o DnsZoneTransfersAclOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsZoneTransfersAcl) pulumi.StringOutput { return v.IpRange }).(pulumi.StringOutput)
}

// The name of the acl.
func (o DnsZoneTransfersAclOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsZoneTransfersAcl) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type DnsZoneTransfersAclArrayOutput struct{ *pulumi.OutputState }

func (DnsZoneTransfersAclArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DnsZoneTransfersAcl)(nil)).Elem()
}

func (o DnsZoneTransfersAclArrayOutput) ToDnsZoneTransfersAclArrayOutput() DnsZoneTransfersAclArrayOutput {
	return o
}

func (o DnsZoneTransfersAclArrayOutput) ToDnsZoneTransfersAclArrayOutputWithContext(ctx context.Context) DnsZoneTransfersAclArrayOutput {
	return o
}

func (o DnsZoneTransfersAclArrayOutput) Index(i pulumi.IntInput) DnsZoneTransfersAclOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DnsZoneTransfersAcl {
		return vs[0].([]*DnsZoneTransfersAcl)[vs[1].(int)]
	}).(DnsZoneTransfersAclOutput)
}

type DnsZoneTransfersAclMapOutput struct{ *pulumi.OutputState }

func (DnsZoneTransfersAclMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DnsZoneTransfersAcl)(nil)).Elem()
}

func (o DnsZoneTransfersAclMapOutput) ToDnsZoneTransfersAclMapOutput() DnsZoneTransfersAclMapOutput {
	return o
}

func (o DnsZoneTransfersAclMapOutput) ToDnsZoneTransfersAclMapOutputWithContext(ctx context.Context) DnsZoneTransfersAclMapOutput {
	return o
}

func (o DnsZoneTransfersAclMapOutput) MapIndex(k pulumi.StringInput) DnsZoneTransfersAclOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DnsZoneTransfersAcl {
		return vs[0].(map[string]*DnsZoneTransfersAcl)[vs[1].(string)]
	}).(DnsZoneTransfersAclOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DnsZoneTransfersAclInput)(nil)).Elem(), &DnsZoneTransfersAcl{})
	pulumi.RegisterInputType(reflect.TypeOf((*DnsZoneTransfersAclArrayInput)(nil)).Elem(), DnsZoneTransfersAclArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DnsZoneTransfersAclMapInput)(nil)).Elem(), DnsZoneTransfersAclMap{})
	pulumi.RegisterOutputType(DnsZoneTransfersAclOutput{})
	pulumi.RegisterOutputType(DnsZoneTransfersAclArrayOutput{})
	pulumi.RegisterOutputType(DnsZoneTransfersAclMapOutput{})
}
