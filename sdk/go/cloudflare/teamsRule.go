// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewZeroTrustGatewayPolicy(ctx, "example_zero_trust_gateway_policy", &cloudflare.ZeroTrustGatewayPolicyArgs{
//				AccountId:     pulumi.String("699d98642c564d2e855e9661899b7252"),
//				Action:        pulumi.String("allow"),
//				Name:          pulumi.String("block bad websites"),
//				Description:   pulumi.String("Block bad websites based on their host name."),
//				DevicePosture: pulumi.String("any(device_posture.checks.passed[*] in {\"1308749e-fcfb-4ebc-b051-fe022b632644\"})"),
//				Enabled:       pulumi.Bool(true),
//				Expiration: &cloudflare.ZeroTrustGatewayPolicyExpirationArgs{
//					ExpiresAt: pulumi.String("2014-01-01T05:20:20Z"),
//					Duration:  pulumi.Int(10),
//				},
//				Filters: pulumi.StringArray{
//					pulumi.String("http"),
//				},
//				Identity:   pulumi.String("any(identity.groups.name[*] in {\"finance\"})"),
//				Precedence: pulumi.Int(0),
//				RuleSettings: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsArgs{
//					AddHeaders: pulumi.StringArrayMap{
//						"My-Next-Header": pulumi.StringArray{
//							pulumi.String("foo"),
//							pulumi.String("bar"),
//						},
//						"X-Custom-Header-Name": pulumi.StringArray{
//							pulumi.String("somecustomvalue"),
//						},
//					},
//					AllowChildBypass: pulumi.Bool(false),
//					AuditSsh: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs{
//						CommandLogging: pulumi.Bool(false),
//					},
//					BisoAdminControls: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs{
//						Copy:     pulumi.String("remote_only"),
//						Dcp:      pulumi.Bool(true),
//						Dd:       pulumi.Bool(true),
//						Dk:       pulumi.Bool(true),
//						Download: pulumi.String("enabled"),
//						Dp:       pulumi.Bool(false),
//						Du:       pulumi.Bool(true),
//						Keyboard: pulumi.String("enabled"),
//						Paste:    pulumi.String("enabled"),
//						Printing: pulumi.String("enabled"),
//						Upload:   pulumi.String("enabled"),
//						Version:  pulumi.String("v1"),
//					},
//					BlockPage: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs{
//						TargetUri:      pulumi.String("https://example.com"),
//						IncludeContext: pulumi.Bool(true),
//					},
//					BlockPageEnabled: pulumi.Bool(true),
//					BlockReason:      pulumi.String("This website is a security risk"),
//					BypassParentRule: pulumi.Bool(false),
//					CheckSession: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs{
//						Duration: pulumi.String("300s"),
//						Enforce:  pulumi.Bool(true),
//					},
//					DnsResolvers: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs{
//						Ipv4s: cloudflare.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Array{
//							&cloudflare.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args{
//								Ip:                         pulumi.String("2.2.2.2"),
//								Port:                       pulumi.Int(5053),
//								RouteThroughPrivateNetwork: pulumi.Bool(true),
//								VnetId:                     pulumi.String("f174e90a-fafe-4643-bbbc-4a0ed4fc8415"),
//							},
//						},
//						Ipv6s: cloudflare.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Array{
//							&cloudflare.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args{
//								Ip:                         pulumi.String("2001:DB8::"),
//								Port:                       pulumi.Int(5053),
//								RouteThroughPrivateNetwork: pulumi.Bool(true),
//								VnetId:                     pulumi.String("f174e90a-fafe-4643-bbbc-4a0ed4fc8415"),
//							},
//						},
//					},
//					Egress: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsEgressArgs{
//						Ipv4:         pulumi.String("192.0.2.2"),
//						Ipv4Fallback: pulumi.String("192.0.2.3"),
//						Ipv6:         pulumi.String("2001:DB8::/64"),
//					},
//					ForensicCopy: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsForensicCopyArgs{
//						Enabled: pulumi.Bool(true),
//					},
//					IgnoreCnameCategoryMatches:      pulumi.Bool(true),
//					InsecureDisableDnssecValidation: pulumi.Bool(false),
//					IpCategories:                    pulumi.Bool(true),
//					IpIndicatorFeeds:                pulumi.Bool(true),
//					L4override: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs{
//						Ip:   pulumi.String("1.1.1.1"),
//						Port: pulumi.Int(0),
//					},
//					NotificationSettings: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs{
//						Enabled:        pulumi.Bool(true),
//						IncludeContext: pulumi.Bool(true),
//						Msg:            pulumi.String("msg"),
//						SupportUrl:     pulumi.String("support_url"),
//					},
//					OverrideHost: pulumi.String("example.com"),
//					OverrideIps: pulumi.StringArray{
//						pulumi.String("1.1.1.1"),
//						pulumi.String("2.2.2.2"),
//					},
//					PayloadLog: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs{
//						Enabled: pulumi.Bool(true),
//					},
//					Quarantine: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs{
//						FileTypes: pulumi.StringArray{
//							pulumi.String("exe"),
//						},
//					},
//					Redirect: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsRedirectArgs{
//						TargetUri:            pulumi.String("https://example.com"),
//						IncludeContext:       pulumi.Bool(true),
//						PreservePathAndQuery: pulumi.Bool(true),
//					},
//					ResolveDnsInternally: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs{
//						Fallback: pulumi.String("none"),
//						ViewId:   pulumi.String("view_id"),
//					},
//					ResolveDnsThroughCloudflare: pulumi.Bool(true),
//					UntrustedCert: &cloudflare.ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs{
//						Action: pulumi.String("error"),
//					},
//				},
//				Schedule: &cloudflare.ZeroTrustGatewayPolicyScheduleArgs{
//					Fri:      pulumi.String("08:00-12:30,13:30-17:00"),
//					Mon:      pulumi.String("08:00-12:30,13:30-17:00"),
//					Sat:      pulumi.String("08:00-12:30,13:30-17:00"),
//					Sun:      pulumi.String("08:00-12:30,13:30-17:00"),
//					Thu:      pulumi.String("08:00-12:30,13:30-17:00"),
//					TimeZone: pulumi.String("America/New York"),
//					Tue:      pulumi.String("08:00-12:30,13:30-17:00"),
//					Wed:      pulumi.String("08:00-12:30,13:30-17:00"),
//				},
//				Traffic: pulumi.String("http.request.uri matches \".*a/partial/uri.*\" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/teamsRule:TeamsRule example '<account_id>/<rule_id>'
// ```
//
// Deprecated: cloudflare.index/teamsrule.TeamsRule has been deprecated in favor of cloudflare.index/zerotrustgatewaypolicy.ZeroTrustGatewayPolicy
type TeamsRule struct {
	pulumi.CustomResourceState

	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
	// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
	Action    pulumi.StringOutput `pulumi:"action"`
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Indicate the date of deletion, if any.
	DeletedAt pulumi.StringOutput `pulumi:"deletedAt"`
	// Specify the rule description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	DevicePosture pulumi.StringOutput `pulumi:"devicePosture"`
	// Specify whether the rule is enabled.
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
	Expiration TeamsRuleExpirationOutput `pulumi:"expiration"`
	// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
	Filters pulumi.StringArrayOutput `pulumi:"filters"`
	// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Identity pulumi.StringOutput `pulumi:"identity"`
	// Specify the rule name.
	Name pulumi.StringOutput `pulumi:"name"`
	// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
	Precedence pulumi.IntOutput `pulumi:"precedence"`
	// Indicate that this rule is shared via the Orgs API and read only.
	ReadOnly pulumi.BoolOutput `pulumi:"readOnly"`
	// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
	RuleSettings TeamsRuleRuleSettingsOutput `pulumi:"ruleSettings"`
	// Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
	Schedule TeamsRuleScheduleOutput `pulumi:"schedule"`
	// Indicate that this rule is sharable via the Orgs API.
	Sharable pulumi.BoolOutput `pulumi:"sharable"`
	// Provide the account tag of the account that created the rule.
	SourceAccount pulumi.StringOutput `pulumi:"sourceAccount"`
	// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Traffic   pulumi.StringOutput `pulumi:"traffic"`
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// Indicate the version number of the rule(read-only).
	Version pulumi.IntOutput `pulumi:"version"`
	// Indicate a warning for a misconfigured rule, if any.
	WarningStatus pulumi.StringOutput `pulumi:"warningStatus"`
}

// NewTeamsRule registers a new resource with the given unique name, arguments, and options.
func NewTeamsRule(ctx *pulumi.Context,
	name string, args *TeamsRuleArgs, opts ...pulumi.ResourceOption) (*TeamsRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	aliases := pulumi.Aliases([]pulumi.Alias{
		{
			Type: pulumi.String("cloudflare:index/teamsRule:TeamsRule"),
		},
	})
	opts = append(opts, aliases)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TeamsRule
	err := ctx.RegisterResource("cloudflare:index/teamsRule:TeamsRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeamsRule gets an existing TeamsRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeamsRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamsRuleState, opts ...pulumi.ResourceOption) (*TeamsRule, error) {
	var resource TeamsRule
	err := ctx.ReadResource("cloudflare:index/teamsRule:TeamsRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TeamsRule resources.
type teamsRuleState struct {
	AccountId *string `pulumi:"accountId"`
	// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
	// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
	Action    *string `pulumi:"action"`
	CreatedAt *string `pulumi:"createdAt"`
	// Indicate the date of deletion, if any.
	DeletedAt *string `pulumi:"deletedAt"`
	// Specify the rule description.
	Description *string `pulumi:"description"`
	// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	DevicePosture *string `pulumi:"devicePosture"`
	// Specify whether the rule is enabled.
	Enabled *bool `pulumi:"enabled"`
	// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
	Expiration *TeamsRuleExpiration `pulumi:"expiration"`
	// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
	Filters []string `pulumi:"filters"`
	// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Identity *string `pulumi:"identity"`
	// Specify the rule name.
	Name *string `pulumi:"name"`
	// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
	Precedence *int `pulumi:"precedence"`
	// Indicate that this rule is shared via the Orgs API and read only.
	ReadOnly *bool `pulumi:"readOnly"`
	// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
	RuleSettings *TeamsRuleRuleSettings `pulumi:"ruleSettings"`
	// Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
	Schedule *TeamsRuleSchedule `pulumi:"schedule"`
	// Indicate that this rule is sharable via the Orgs API.
	Sharable *bool `pulumi:"sharable"`
	// Provide the account tag of the account that created the rule.
	SourceAccount *string `pulumi:"sourceAccount"`
	// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Traffic   *string `pulumi:"traffic"`
	UpdatedAt *string `pulumi:"updatedAt"`
	// Indicate the version number of the rule(read-only).
	Version *int `pulumi:"version"`
	// Indicate a warning for a misconfigured rule, if any.
	WarningStatus *string `pulumi:"warningStatus"`
}

type TeamsRuleState struct {
	AccountId pulumi.StringPtrInput
	// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
	// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
	Action    pulumi.StringPtrInput
	CreatedAt pulumi.StringPtrInput
	// Indicate the date of deletion, if any.
	DeletedAt pulumi.StringPtrInput
	// Specify the rule description.
	Description pulumi.StringPtrInput
	// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	DevicePosture pulumi.StringPtrInput
	// Specify whether the rule is enabled.
	Enabled pulumi.BoolPtrInput
	// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
	Expiration TeamsRuleExpirationPtrInput
	// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
	Filters pulumi.StringArrayInput
	// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Identity pulumi.StringPtrInput
	// Specify the rule name.
	Name pulumi.StringPtrInput
	// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
	Precedence pulumi.IntPtrInput
	// Indicate that this rule is shared via the Orgs API and read only.
	ReadOnly pulumi.BoolPtrInput
	// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
	RuleSettings TeamsRuleRuleSettingsPtrInput
	// Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
	Schedule TeamsRuleSchedulePtrInput
	// Indicate that this rule is sharable via the Orgs API.
	Sharable pulumi.BoolPtrInput
	// Provide the account tag of the account that created the rule.
	SourceAccount pulumi.StringPtrInput
	// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Traffic   pulumi.StringPtrInput
	UpdatedAt pulumi.StringPtrInput
	// Indicate the version number of the rule(read-only).
	Version pulumi.IntPtrInput
	// Indicate a warning for a misconfigured rule, if any.
	WarningStatus pulumi.StringPtrInput
}

func (TeamsRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamsRuleState)(nil)).Elem()
}

type teamsRuleArgs struct {
	AccountId string `pulumi:"accountId"`
	// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
	// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
	Action string `pulumi:"action"`
	// Specify the rule description.
	Description *string `pulumi:"description"`
	// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	DevicePosture *string `pulumi:"devicePosture"`
	// Specify whether the rule is enabled.
	Enabled *bool `pulumi:"enabled"`
	// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
	Expiration *TeamsRuleExpiration `pulumi:"expiration"`
	// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
	Filters []string `pulumi:"filters"`
	// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Identity *string `pulumi:"identity"`
	// Specify the rule name.
	Name string `pulumi:"name"`
	// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
	Precedence *int `pulumi:"precedence"`
	// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
	RuleSettings *TeamsRuleRuleSettings `pulumi:"ruleSettings"`
	// Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
	Schedule *TeamsRuleSchedule `pulumi:"schedule"`
	// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Traffic *string `pulumi:"traffic"`
}

// The set of arguments for constructing a TeamsRule resource.
type TeamsRuleArgs struct {
	AccountId pulumi.StringInput
	// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
	// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
	Action pulumi.StringInput
	// Specify the rule description.
	Description pulumi.StringPtrInput
	// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	DevicePosture pulumi.StringPtrInput
	// Specify whether the rule is enabled.
	Enabled pulumi.BoolPtrInput
	// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
	Expiration TeamsRuleExpirationPtrInput
	// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
	Filters pulumi.StringArrayInput
	// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Identity pulumi.StringPtrInput
	// Specify the rule name.
	Name pulumi.StringInput
	// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
	Precedence pulumi.IntPtrInput
	// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
	RuleSettings TeamsRuleRuleSettingsPtrInput
	// Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
	Schedule TeamsRuleSchedulePtrInput
	// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
	Traffic pulumi.StringPtrInput
}

func (TeamsRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamsRuleArgs)(nil)).Elem()
}

type TeamsRuleInput interface {
	pulumi.Input

	ToTeamsRuleOutput() TeamsRuleOutput
	ToTeamsRuleOutputWithContext(ctx context.Context) TeamsRuleOutput
}

func (*TeamsRule) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamsRule)(nil)).Elem()
}

func (i *TeamsRule) ToTeamsRuleOutput() TeamsRuleOutput {
	return i.ToTeamsRuleOutputWithContext(context.Background())
}

func (i *TeamsRule) ToTeamsRuleOutputWithContext(ctx context.Context) TeamsRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamsRuleOutput)
}

// TeamsRuleArrayInput is an input type that accepts TeamsRuleArray and TeamsRuleArrayOutput values.
// You can construct a concrete instance of `TeamsRuleArrayInput` via:
//
//	TeamsRuleArray{ TeamsRuleArgs{...} }
type TeamsRuleArrayInput interface {
	pulumi.Input

	ToTeamsRuleArrayOutput() TeamsRuleArrayOutput
	ToTeamsRuleArrayOutputWithContext(context.Context) TeamsRuleArrayOutput
}

type TeamsRuleArray []TeamsRuleInput

func (TeamsRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamsRule)(nil)).Elem()
}

func (i TeamsRuleArray) ToTeamsRuleArrayOutput() TeamsRuleArrayOutput {
	return i.ToTeamsRuleArrayOutputWithContext(context.Background())
}

func (i TeamsRuleArray) ToTeamsRuleArrayOutputWithContext(ctx context.Context) TeamsRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamsRuleArrayOutput)
}

// TeamsRuleMapInput is an input type that accepts TeamsRuleMap and TeamsRuleMapOutput values.
// You can construct a concrete instance of `TeamsRuleMapInput` via:
//
//	TeamsRuleMap{ "key": TeamsRuleArgs{...} }
type TeamsRuleMapInput interface {
	pulumi.Input

	ToTeamsRuleMapOutput() TeamsRuleMapOutput
	ToTeamsRuleMapOutputWithContext(context.Context) TeamsRuleMapOutput
}

type TeamsRuleMap map[string]TeamsRuleInput

func (TeamsRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamsRule)(nil)).Elem()
}

func (i TeamsRuleMap) ToTeamsRuleMapOutput() TeamsRuleMapOutput {
	return i.ToTeamsRuleMapOutputWithContext(context.Background())
}

func (i TeamsRuleMap) ToTeamsRuleMapOutputWithContext(ctx context.Context) TeamsRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamsRuleMapOutput)
}

type TeamsRuleOutput struct{ *pulumi.OutputState }

func (TeamsRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TeamsRule)(nil)).Elem()
}

func (o TeamsRuleOutput) ToTeamsRuleOutput() TeamsRuleOutput {
	return o
}

func (o TeamsRuleOutput) ToTeamsRuleOutputWithContext(ctx context.Context) TeamsRuleOutput {
	return o
}

func (o TeamsRuleOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
func (o TeamsRuleOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

func (o TeamsRuleOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Indicate the date of deletion, if any.
func (o TeamsRuleOutput) DeletedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.DeletedAt }).(pulumi.StringOutput)
}

// Specify the rule description.
func (o TeamsRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
func (o TeamsRuleOutput) DevicePosture() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.DevicePosture }).(pulumi.StringOutput)
}

// Specify whether the rule is enabled.
func (o TeamsRuleOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
func (o TeamsRuleOutput) Expiration() TeamsRuleExpirationOutput {
	return o.ApplyT(func(v *TeamsRule) TeamsRuleExpirationOutput { return v.Expiration }).(TeamsRuleExpirationOutput)
}

// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
func (o TeamsRuleOutput) Filters() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringArrayOutput { return v.Filters }).(pulumi.StringArrayOutput)
}

// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
func (o TeamsRuleOutput) Identity() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.Identity }).(pulumi.StringOutput)
}

// Specify the rule name.
func (o TeamsRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
func (o TeamsRuleOutput) Precedence() pulumi.IntOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.IntOutput { return v.Precedence }).(pulumi.IntOutput)
}

// Indicate that this rule is shared via the Orgs API and read only.
func (o TeamsRuleOutput) ReadOnly() pulumi.BoolOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.BoolOutput { return v.ReadOnly }).(pulumi.BoolOutput)
}

// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
func (o TeamsRuleOutput) RuleSettings() TeamsRuleRuleSettingsOutput {
	return o.ApplyT(func(v *TeamsRule) TeamsRuleRuleSettingsOutput { return v.RuleSettings }).(TeamsRuleRuleSettingsOutput)
}

// Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
func (o TeamsRuleOutput) Schedule() TeamsRuleScheduleOutput {
	return o.ApplyT(func(v *TeamsRule) TeamsRuleScheduleOutput { return v.Schedule }).(TeamsRuleScheduleOutput)
}

// Indicate that this rule is sharable via the Orgs API.
func (o TeamsRuleOutput) Sharable() pulumi.BoolOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.BoolOutput { return v.Sharable }).(pulumi.BoolOutput)
}

// Provide the account tag of the account that created the rule.
func (o TeamsRuleOutput) SourceAccount() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.SourceAccount }).(pulumi.StringOutput)
}

// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
func (o TeamsRuleOutput) Traffic() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.Traffic }).(pulumi.StringOutput)
}

func (o TeamsRuleOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// Indicate the version number of the rule(read-only).
func (o TeamsRuleOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.IntOutput { return v.Version }).(pulumi.IntOutput)
}

// Indicate a warning for a misconfigured rule, if any.
func (o TeamsRuleOutput) WarningStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *TeamsRule) pulumi.StringOutput { return v.WarningStatus }).(pulumi.StringOutput)
}

type TeamsRuleArrayOutput struct{ *pulumi.OutputState }

func (TeamsRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TeamsRule)(nil)).Elem()
}

func (o TeamsRuleArrayOutput) ToTeamsRuleArrayOutput() TeamsRuleArrayOutput {
	return o
}

func (o TeamsRuleArrayOutput) ToTeamsRuleArrayOutputWithContext(ctx context.Context) TeamsRuleArrayOutput {
	return o
}

func (o TeamsRuleArrayOutput) Index(i pulumi.IntInput) TeamsRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TeamsRule {
		return vs[0].([]*TeamsRule)[vs[1].(int)]
	}).(TeamsRuleOutput)
}

type TeamsRuleMapOutput struct{ *pulumi.OutputState }

func (TeamsRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TeamsRule)(nil)).Elem()
}

func (o TeamsRuleMapOutput) ToTeamsRuleMapOutput() TeamsRuleMapOutput {
	return o
}

func (o TeamsRuleMapOutput) ToTeamsRuleMapOutputWithContext(ctx context.Context) TeamsRuleMapOutput {
	return o
}

func (o TeamsRuleMapOutput) MapIndex(k pulumi.StringInput) TeamsRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TeamsRule {
		return vs[0].(map[string]*TeamsRule)[vs[1].(string)]
	}).(TeamsRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamsRuleInput)(nil)).Elem(), &TeamsRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamsRuleArrayInput)(nil)).Elem(), TeamsRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamsRuleMapInput)(nil)).Elem(), TeamsRuleMap{})
	pulumi.RegisterOutputType(TeamsRuleOutput{})
	pulumi.RegisterOutputType(TeamsRuleArrayOutput{})
	pulumi.RegisterOutputType(TeamsRuleMapOutput{})
}
