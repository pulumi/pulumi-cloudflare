// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Provides a Cloudflare Access Policy resource. Access Policies are used
// in conjunction with Access Applications to restrict access to a
// particular resource.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-cloudflare/sdk/v2/go/cloudflare"
// 	"github.com/pulumi/pulumi-cloudflare/sdk/v2/go/cloudflare/"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := cloudflare.NewAccessPolicy(ctx, "testPolicyAccessPolicy", &cloudflare.AccessPolicyArgs{
// 			ApplicationId: pulumi.String("cb029e245cfdd66dc8d2e570d5dd3322"),
// 			ZoneId:        pulumi.String("d41d8cd98f00b204e9800998ecf8427e"),
// 			Name:          pulumi.String("staging policy"),
// 			Precedence:    pulumi.Int(1),
// 			Decision:      pulumi.String("allow"),
// 			Includes: cloudflare.AccessPolicyIncludeArray{
// 				&cloudflare.AccessPolicyIncludeArgs{
// 					Emails: pulumi.StringArray{
// 						pulumi.String("test@example.com"),
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = cloudflare.NewAccessPolicy(ctx, "testPolicyIndex_accessPolicyAccessPolicy", &cloudflare.AccessPolicyArgs{
// 			ApplicationId: pulumi.String("cb029e245cfdd66dc8d2e570d5dd3322"),
// 			ZoneId:        pulumi.String("d41d8cd98f00b204e9800998ecf8427e"),
// 			Name:          pulumi.String("staging policy"),
// 			Precedence:    pulumi.Int(1),
// 			Decision:      pulumi.String("allow"),
// 			Includes: cloudflare.AccessPolicyIncludeArray{
// 				&cloudflare.AccessPolicyIncludeArgs{
// 					Emails: pulumi.StringArray{
// 						pulumi.String("test@example.com"),
// 					},
// 				},
// 			},
// 			Requires: cloudflare.AccessPolicyRequireArray{
// 				Ips: cloudflare.AccessPolicyRequireArgs{
// 					pulumi.Any(_var.Office_ip),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Access Policies can be imported using a composite ID formed of zone ID, application ID and policy ID.
//
// ```sh
//  $ pulumi import cloudflare:index/accessPolicy:AccessPolicy staging cb029e245cfdd66dc8d2e570d5dd3322/d41d8cd98f00b204e9800998ecf8427e/67ea780ce4982c1cfbe6b7293afc765d
// ```
//
//  where * `cb029e245cfdd66dc8d2e570d5dd3322` - Zone ID * `d41d8cd98f00b204e9800998ecf8427e` - Access Application ID * `67ea780ce4982c1cfbe6b7293afc765d` - Access Policy ID
type AccessPolicy struct {
	pulumi.CustomResourceState

	// The account to which the access rule should be added. Conflicts with `zoneId`.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// The ID of the application the policy is associated with.
	ApplicationId pulumi.StringOutput `pulumi:"applicationId"`
	// Defines the action Access will take if the policy matches the user.
	// Allowed values: `allow`, `deny`, `nonIdentity`, `bypass`
	Decision pulumi.StringOutput `pulumi:"decision"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Excludes AccessPolicyExcludeArrayOutput `pulumi:"excludes"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Includes AccessPolicyIncludeArrayOutput `pulumi:"includes"`
	// Friendly name of the Access Application.
	Name pulumi.StringOutput `pulumi:"name"`
	// The unique precedence for policies on a single application. Integer.
	Precedence pulumi.IntPtrOutput `pulumi:"precedence"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Requires AccessPolicyRequireArrayOutput `pulumi:"requires"`
	// The DNS zone to which the access rule should be added. Conflicts with `accountId`.
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewAccessPolicy registers a new resource with the given unique name, arguments, and options.
func NewAccessPolicy(ctx *pulumi.Context,
	name string, args *AccessPolicyArgs, opts ...pulumi.ResourceOption) (*AccessPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ApplicationId == nil {
		return nil, errors.New("invalid value for required argument 'ApplicationId'")
	}
	if args.Decision == nil {
		return nil, errors.New("invalid value for required argument 'Decision'")
	}
	if args.Includes == nil {
		return nil, errors.New("invalid value for required argument 'Includes'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	var resource AccessPolicy
	err := ctx.RegisterResource("cloudflare:index/accessPolicy:AccessPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccessPolicy gets an existing AccessPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccessPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccessPolicyState, opts ...pulumi.ResourceOption) (*AccessPolicy, error) {
	var resource AccessPolicy
	err := ctx.ReadResource("cloudflare:index/accessPolicy:AccessPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccessPolicy resources.
type accessPolicyState struct {
	// The account to which the access rule should be added. Conflicts with `zoneId`.
	AccountId *string `pulumi:"accountId"`
	// The ID of the application the policy is associated with.
	ApplicationId *string `pulumi:"applicationId"`
	// Defines the action Access will take if the policy matches the user.
	// Allowed values: `allow`, `deny`, `nonIdentity`, `bypass`
	Decision *string `pulumi:"decision"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Excludes []AccessPolicyExclude `pulumi:"excludes"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Includes []AccessPolicyInclude `pulumi:"includes"`
	// Friendly name of the Access Application.
	Name *string `pulumi:"name"`
	// The unique precedence for policies on a single application. Integer.
	Precedence *int `pulumi:"precedence"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Requires []AccessPolicyRequire `pulumi:"requires"`
	// The DNS zone to which the access rule should be added. Conflicts with `accountId`.
	ZoneId *string `pulumi:"zoneId"`
}

type AccessPolicyState struct {
	// The account to which the access rule should be added. Conflicts with `zoneId`.
	AccountId pulumi.StringPtrInput
	// The ID of the application the policy is associated with.
	ApplicationId pulumi.StringPtrInput
	// Defines the action Access will take if the policy matches the user.
	// Allowed values: `allow`, `deny`, `nonIdentity`, `bypass`
	Decision pulumi.StringPtrInput
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Excludes AccessPolicyExcludeArrayInput
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Includes AccessPolicyIncludeArrayInput
	// Friendly name of the Access Application.
	Name pulumi.StringPtrInput
	// The unique precedence for policies on a single application. Integer.
	Precedence pulumi.IntPtrInput
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Requires AccessPolicyRequireArrayInput
	// The DNS zone to which the access rule should be added. Conflicts with `accountId`.
	ZoneId pulumi.StringPtrInput
}

func (AccessPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*accessPolicyState)(nil)).Elem()
}

type accessPolicyArgs struct {
	// The account to which the access rule should be added. Conflicts with `zoneId`.
	AccountId *string `pulumi:"accountId"`
	// The ID of the application the policy is associated with.
	ApplicationId string `pulumi:"applicationId"`
	// Defines the action Access will take if the policy matches the user.
	// Allowed values: `allow`, `deny`, `nonIdentity`, `bypass`
	Decision string `pulumi:"decision"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Excludes []AccessPolicyExclude `pulumi:"excludes"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Includes []AccessPolicyInclude `pulumi:"includes"`
	// Friendly name of the Access Application.
	Name string `pulumi:"name"`
	// The unique precedence for policies on a single application. Integer.
	Precedence *int `pulumi:"precedence"`
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Requires []AccessPolicyRequire `pulumi:"requires"`
	// The DNS zone to which the access rule should be added. Conflicts with `accountId`.
	ZoneId *string `pulumi:"zoneId"`
}

// The set of arguments for constructing a AccessPolicy resource.
type AccessPolicyArgs struct {
	// The account to which the access rule should be added. Conflicts with `zoneId`.
	AccountId pulumi.StringPtrInput
	// The ID of the application the policy is associated with.
	ApplicationId pulumi.StringInput
	// Defines the action Access will take if the policy matches the user.
	// Allowed values: `allow`, `deny`, `nonIdentity`, `bypass`
	Decision pulumi.StringInput
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Excludes AccessPolicyExcludeArrayInput
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Includes AccessPolicyIncludeArrayInput
	// Friendly name of the Access Application.
	Name pulumi.StringInput
	// The unique precedence for policies on a single application. Integer.
	Precedence pulumi.IntPtrInput
	// A series of access conditions, see [Access Groups](https://www.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/access_group#conditions).
	Requires AccessPolicyRequireArrayInput
	// The DNS zone to which the access rule should be added. Conflicts with `accountId`.
	ZoneId pulumi.StringPtrInput
}

func (AccessPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accessPolicyArgs)(nil)).Elem()
}

type AccessPolicyInput interface {
	pulumi.Input

	ToAccessPolicyOutput() AccessPolicyOutput
	ToAccessPolicyOutputWithContext(ctx context.Context) AccessPolicyOutput
}

func (*AccessPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessPolicy)(nil))
}

func (i *AccessPolicy) ToAccessPolicyOutput() AccessPolicyOutput {
	return i.ToAccessPolicyOutputWithContext(context.Background())
}

func (i *AccessPolicy) ToAccessPolicyOutputWithContext(ctx context.Context) AccessPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessPolicyOutput)
}

type AccessPolicyOutput struct {
	*pulumi.OutputState
}

func (AccessPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AccessPolicy)(nil))
}

func (o AccessPolicyOutput) ToAccessPolicyOutput() AccessPolicyOutput {
	return o
}

func (o AccessPolicyOutput) ToAccessPolicyOutputWithContext(ctx context.Context) AccessPolicyOutput {
	return o
}

func init() {
	pulumi.RegisterOutputType(AccessPolicyOutput{})
}
