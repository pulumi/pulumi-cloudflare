// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewAddressMap(ctx, "example_address_map", &cloudflare.AddressMapArgs{
//				AccountId:   pulumi.String("258def64c72dae45f3e4c8516e2111f2"),
//				Description: pulumi.String("My Ecommerce zones"),
//				Enabled:     pulumi.Bool(true),
//				Ips: pulumi.StringArray{
//					pulumi.String("192.0.2.1"),
//				},
//				Memberships: cloudflare.AddressMapMembershipArray{
//					&cloudflare.AddressMapMembershipArgs{
//						Identifier: pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//						Kind:       pulumi.String("zone"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/addressMap:AddressMap example '<account_id>/<address_map_id>'
// ```
type AddressMap struct {
	pulumi.CustomResourceState

	// Identifier of a Cloudflare account.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
	CanDelete pulumi.BoolOutput `pulumi:"canDelete"`
	// If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
	CanModifyIps pulumi.BoolOutput   `pulumi:"canModifyIps"`
	CreatedAt    pulumi.StringOutput `pulumi:"createdAt"`
	// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
	DefaultSni pulumi.StringPtrOutput `pulumi:"defaultSni"`
	// An optional description field which may be used to describe the types of IPs or zones on the map.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
	Enabled pulumi.BoolOutput        `pulumi:"enabled"`
	Ips     pulumi.StringArrayOutput `pulumi:"ips"`
	// Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
	Memberships AddressMapMembershipArrayOutput `pulumi:"memberships"`
	ModifiedAt  pulumi.StringOutput             `pulumi:"modifiedAt"`
}

// NewAddressMap registers a new resource with the given unique name, arguments, and options.
func NewAddressMap(ctx *pulumi.Context,
	name string, args *AddressMapArgs, opts ...pulumi.ResourceOption) (*AddressMap, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AddressMap
	err := ctx.RegisterResource("cloudflare:index/addressMap:AddressMap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAddressMap gets an existing AddressMap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAddressMap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AddressMapState, opts ...pulumi.ResourceOption) (*AddressMap, error) {
	var resource AddressMap
	err := ctx.ReadResource("cloudflare:index/addressMap:AddressMap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AddressMap resources.
type addressMapState struct {
	// Identifier of a Cloudflare account.
	AccountId *string `pulumi:"accountId"`
	// If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
	CanDelete *bool `pulumi:"canDelete"`
	// If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
	CanModifyIps *bool   `pulumi:"canModifyIps"`
	CreatedAt    *string `pulumi:"createdAt"`
	// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
	DefaultSni *string `pulumi:"defaultSni"`
	// An optional description field which may be used to describe the types of IPs or zones on the map.
	Description *string `pulumi:"description"`
	// Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
	Enabled *bool    `pulumi:"enabled"`
	Ips     []string `pulumi:"ips"`
	// Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
	Memberships []AddressMapMembership `pulumi:"memberships"`
	ModifiedAt  *string                `pulumi:"modifiedAt"`
}

type AddressMapState struct {
	// Identifier of a Cloudflare account.
	AccountId pulumi.StringPtrInput
	// If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
	CanDelete pulumi.BoolPtrInput
	// If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
	CanModifyIps pulumi.BoolPtrInput
	CreatedAt    pulumi.StringPtrInput
	// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
	DefaultSni pulumi.StringPtrInput
	// An optional description field which may be used to describe the types of IPs or zones on the map.
	Description pulumi.StringPtrInput
	// Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
	Enabled pulumi.BoolPtrInput
	Ips     pulumi.StringArrayInput
	// Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
	Memberships AddressMapMembershipArrayInput
	ModifiedAt  pulumi.StringPtrInput
}

func (AddressMapState) ElementType() reflect.Type {
	return reflect.TypeOf((*addressMapState)(nil)).Elem()
}

type addressMapArgs struct {
	// Identifier of a Cloudflare account.
	AccountId string `pulumi:"accountId"`
	// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
	DefaultSni *string `pulumi:"defaultSni"`
	// An optional description field which may be used to describe the types of IPs or zones on the map.
	Description *string `pulumi:"description"`
	// Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
	Enabled *bool    `pulumi:"enabled"`
	Ips     []string `pulumi:"ips"`
	// Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
	Memberships []AddressMapMembership `pulumi:"memberships"`
}

// The set of arguments for constructing a AddressMap resource.
type AddressMapArgs struct {
	// Identifier of a Cloudflare account.
	AccountId pulumi.StringInput
	// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
	DefaultSni pulumi.StringPtrInput
	// An optional description field which may be used to describe the types of IPs or zones on the map.
	Description pulumi.StringPtrInput
	// Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
	Enabled pulumi.BoolPtrInput
	Ips     pulumi.StringArrayInput
	// Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
	Memberships AddressMapMembershipArrayInput
}

func (AddressMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*addressMapArgs)(nil)).Elem()
}

type AddressMapInput interface {
	pulumi.Input

	ToAddressMapOutput() AddressMapOutput
	ToAddressMapOutputWithContext(ctx context.Context) AddressMapOutput
}

func (*AddressMap) ElementType() reflect.Type {
	return reflect.TypeOf((**AddressMap)(nil)).Elem()
}

func (i *AddressMap) ToAddressMapOutput() AddressMapOutput {
	return i.ToAddressMapOutputWithContext(context.Background())
}

func (i *AddressMap) ToAddressMapOutputWithContext(ctx context.Context) AddressMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddressMapOutput)
}

// AddressMapArrayInput is an input type that accepts AddressMapArray and AddressMapArrayOutput values.
// You can construct a concrete instance of `AddressMapArrayInput` via:
//
//	AddressMapArray{ AddressMapArgs{...} }
type AddressMapArrayInput interface {
	pulumi.Input

	ToAddressMapArrayOutput() AddressMapArrayOutput
	ToAddressMapArrayOutputWithContext(context.Context) AddressMapArrayOutput
}

type AddressMapArray []AddressMapInput

func (AddressMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AddressMap)(nil)).Elem()
}

func (i AddressMapArray) ToAddressMapArrayOutput() AddressMapArrayOutput {
	return i.ToAddressMapArrayOutputWithContext(context.Background())
}

func (i AddressMapArray) ToAddressMapArrayOutputWithContext(ctx context.Context) AddressMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddressMapArrayOutput)
}

// AddressMapMapInput is an input type that accepts AddressMapMap and AddressMapMapOutput values.
// You can construct a concrete instance of `AddressMapMapInput` via:
//
//	AddressMapMap{ "key": AddressMapArgs{...} }
type AddressMapMapInput interface {
	pulumi.Input

	ToAddressMapMapOutput() AddressMapMapOutput
	ToAddressMapMapOutputWithContext(context.Context) AddressMapMapOutput
}

type AddressMapMap map[string]AddressMapInput

func (AddressMapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AddressMap)(nil)).Elem()
}

func (i AddressMapMap) ToAddressMapMapOutput() AddressMapMapOutput {
	return i.ToAddressMapMapOutputWithContext(context.Background())
}

func (i AddressMapMap) ToAddressMapMapOutputWithContext(ctx context.Context) AddressMapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AddressMapMapOutput)
}

type AddressMapOutput struct{ *pulumi.OutputState }

func (AddressMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AddressMap)(nil)).Elem()
}

func (o AddressMapOutput) ToAddressMapOutput() AddressMapOutput {
	return o
}

func (o AddressMapOutput) ToAddressMapOutputWithContext(ctx context.Context) AddressMapOutput {
	return o
}

// Identifier of a Cloudflare account.
func (o AddressMapOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
func (o AddressMapOutput) CanDelete() pulumi.BoolOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.BoolOutput { return v.CanDelete }).(pulumi.BoolOutput)
}

// If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
func (o AddressMapOutput) CanModifyIps() pulumi.BoolOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.BoolOutput { return v.CanModifyIps }).(pulumi.BoolOutput)
}

func (o AddressMapOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
func (o AddressMapOutput) DefaultSni() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.StringPtrOutput { return v.DefaultSni }).(pulumi.StringPtrOutput)
}

// An optional description field which may be used to describe the types of IPs or zones on the map.
func (o AddressMapOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
func (o AddressMapOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

func (o AddressMapOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.StringArrayOutput { return v.Ips }).(pulumi.StringArrayOutput)
}

// Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
func (o AddressMapOutput) Memberships() AddressMapMembershipArrayOutput {
	return o.ApplyT(func(v *AddressMap) AddressMapMembershipArrayOutput { return v.Memberships }).(AddressMapMembershipArrayOutput)
}

func (o AddressMapOutput) ModifiedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *AddressMap) pulumi.StringOutput { return v.ModifiedAt }).(pulumi.StringOutput)
}

type AddressMapArrayOutput struct{ *pulumi.OutputState }

func (AddressMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AddressMap)(nil)).Elem()
}

func (o AddressMapArrayOutput) ToAddressMapArrayOutput() AddressMapArrayOutput {
	return o
}

func (o AddressMapArrayOutput) ToAddressMapArrayOutputWithContext(ctx context.Context) AddressMapArrayOutput {
	return o
}

func (o AddressMapArrayOutput) Index(i pulumi.IntInput) AddressMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AddressMap {
		return vs[0].([]*AddressMap)[vs[1].(int)]
	}).(AddressMapOutput)
}

type AddressMapMapOutput struct{ *pulumi.OutputState }

func (AddressMapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AddressMap)(nil)).Elem()
}

func (o AddressMapMapOutput) ToAddressMapMapOutput() AddressMapMapOutput {
	return o
}

func (o AddressMapMapOutput) ToAddressMapMapOutputWithContext(ctx context.Context) AddressMapMapOutput {
	return o
}

func (o AddressMapMapOutput) MapIndex(k pulumi.StringInput) AddressMapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AddressMap {
		return vs[0].(map[string]*AddressMap)[vs[1].(string)]
	}).(AddressMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AddressMapInput)(nil)).Elem(), &AddressMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*AddressMapArrayInput)(nil)).Elem(), AddressMapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AddressMapMapInput)(nil)).Elem(), AddressMapMap{})
	pulumi.RegisterOutputType(AddressMapOutput{})
	pulumi.RegisterOutputType(AddressMapArrayOutput{})
	pulumi.RegisterOutputType(AddressMapMapOutput{})
}
