// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/magicTransitSiteLan:MagicTransitSiteLan example '<account_id>/<site_id>/<lan_id>'
// ```
type MagicTransitSiteLan struct {
	pulumi.CustomResourceState

	// Identifier
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        pulumi.BoolPtrOutput                       `pulumi:"haLink"`
	Name          pulumi.StringPtrOutput                     `pulumi:"name"`
	Nat           MagicTransitSiteLanNatOutput               `pulumi:"nat"`
	Physport      pulumi.IntOutput                           `pulumi:"physport"`
	RoutedSubnets MagicTransitSiteLanRoutedSubnetArrayOutput `pulumi:"routedSubnets"`
	// Identifier
	SiteId pulumi.StringOutput `pulumi:"siteId"`
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing MagicTransitSiteLanStaticAddressingOutput `pulumi:"staticAddressing"`
	// VLAN port number.
	VlanTag pulumi.IntOutput `pulumi:"vlanTag"`
}

// NewMagicTransitSiteLan registers a new resource with the given unique name, arguments, and options.
func NewMagicTransitSiteLan(ctx *pulumi.Context,
	name string, args *MagicTransitSiteLanArgs, opts ...pulumi.ResourceOption) (*MagicTransitSiteLan, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.Physport == nil {
		return nil, errors.New("invalid value for required argument 'Physport'")
	}
	if args.SiteId == nil {
		return nil, errors.New("invalid value for required argument 'SiteId'")
	}
	if args.VlanTag == nil {
		return nil, errors.New("invalid value for required argument 'VlanTag'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource MagicTransitSiteLan
	err := ctx.RegisterResource("cloudflare:index/magicTransitSiteLan:MagicTransitSiteLan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMagicTransitSiteLan gets an existing MagicTransitSiteLan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMagicTransitSiteLan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MagicTransitSiteLanState, opts ...pulumi.ResourceOption) (*MagicTransitSiteLan, error) {
	var resource MagicTransitSiteLan
	err := ctx.ReadResource("cloudflare:index/magicTransitSiteLan:MagicTransitSiteLan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MagicTransitSiteLan resources.
type magicTransitSiteLanState struct {
	// Identifier
	AccountId *string `pulumi:"accountId"`
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        *bool                             `pulumi:"haLink"`
	Name          *string                           `pulumi:"name"`
	Nat           *MagicTransitSiteLanNat           `pulumi:"nat"`
	Physport      *int                              `pulumi:"physport"`
	RoutedSubnets []MagicTransitSiteLanRoutedSubnet `pulumi:"routedSubnets"`
	// Identifier
	SiteId *string `pulumi:"siteId"`
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing *MagicTransitSiteLanStaticAddressing `pulumi:"staticAddressing"`
	// VLAN port number.
	VlanTag *int `pulumi:"vlanTag"`
}

type MagicTransitSiteLanState struct {
	// Identifier
	AccountId pulumi.StringPtrInput
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        pulumi.BoolPtrInput
	Name          pulumi.StringPtrInput
	Nat           MagicTransitSiteLanNatPtrInput
	Physport      pulumi.IntPtrInput
	RoutedSubnets MagicTransitSiteLanRoutedSubnetArrayInput
	// Identifier
	SiteId pulumi.StringPtrInput
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing MagicTransitSiteLanStaticAddressingPtrInput
	// VLAN port number.
	VlanTag pulumi.IntPtrInput
}

func (MagicTransitSiteLanState) ElementType() reflect.Type {
	return reflect.TypeOf((*magicTransitSiteLanState)(nil)).Elem()
}

type magicTransitSiteLanArgs struct {
	// Identifier
	AccountId string `pulumi:"accountId"`
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        *bool                             `pulumi:"haLink"`
	Name          *string                           `pulumi:"name"`
	Nat           *MagicTransitSiteLanNat           `pulumi:"nat"`
	Physport      int                               `pulumi:"physport"`
	RoutedSubnets []MagicTransitSiteLanRoutedSubnet `pulumi:"routedSubnets"`
	// Identifier
	SiteId string `pulumi:"siteId"`
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing *MagicTransitSiteLanStaticAddressing `pulumi:"staticAddressing"`
	// VLAN port number.
	VlanTag int `pulumi:"vlanTag"`
}

// The set of arguments for constructing a MagicTransitSiteLan resource.
type MagicTransitSiteLanArgs struct {
	// Identifier
	AccountId pulumi.StringInput
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        pulumi.BoolPtrInput
	Name          pulumi.StringPtrInput
	Nat           MagicTransitSiteLanNatPtrInput
	Physport      pulumi.IntInput
	RoutedSubnets MagicTransitSiteLanRoutedSubnetArrayInput
	// Identifier
	SiteId pulumi.StringInput
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing MagicTransitSiteLanStaticAddressingPtrInput
	// VLAN port number.
	VlanTag pulumi.IntInput
}

func (MagicTransitSiteLanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*magicTransitSiteLanArgs)(nil)).Elem()
}

type MagicTransitSiteLanInput interface {
	pulumi.Input

	ToMagicTransitSiteLanOutput() MagicTransitSiteLanOutput
	ToMagicTransitSiteLanOutputWithContext(ctx context.Context) MagicTransitSiteLanOutput
}

func (*MagicTransitSiteLan) ElementType() reflect.Type {
	return reflect.TypeOf((**MagicTransitSiteLan)(nil)).Elem()
}

func (i *MagicTransitSiteLan) ToMagicTransitSiteLanOutput() MagicTransitSiteLanOutput {
	return i.ToMagicTransitSiteLanOutputWithContext(context.Background())
}

func (i *MagicTransitSiteLan) ToMagicTransitSiteLanOutputWithContext(ctx context.Context) MagicTransitSiteLanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MagicTransitSiteLanOutput)
}

// MagicTransitSiteLanArrayInput is an input type that accepts MagicTransitSiteLanArray and MagicTransitSiteLanArrayOutput values.
// You can construct a concrete instance of `MagicTransitSiteLanArrayInput` via:
//
//	MagicTransitSiteLanArray{ MagicTransitSiteLanArgs{...} }
type MagicTransitSiteLanArrayInput interface {
	pulumi.Input

	ToMagicTransitSiteLanArrayOutput() MagicTransitSiteLanArrayOutput
	ToMagicTransitSiteLanArrayOutputWithContext(context.Context) MagicTransitSiteLanArrayOutput
}

type MagicTransitSiteLanArray []MagicTransitSiteLanInput

func (MagicTransitSiteLanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MagicTransitSiteLan)(nil)).Elem()
}

func (i MagicTransitSiteLanArray) ToMagicTransitSiteLanArrayOutput() MagicTransitSiteLanArrayOutput {
	return i.ToMagicTransitSiteLanArrayOutputWithContext(context.Background())
}

func (i MagicTransitSiteLanArray) ToMagicTransitSiteLanArrayOutputWithContext(ctx context.Context) MagicTransitSiteLanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MagicTransitSiteLanArrayOutput)
}

// MagicTransitSiteLanMapInput is an input type that accepts MagicTransitSiteLanMap and MagicTransitSiteLanMapOutput values.
// You can construct a concrete instance of `MagicTransitSiteLanMapInput` via:
//
//	MagicTransitSiteLanMap{ "key": MagicTransitSiteLanArgs{...} }
type MagicTransitSiteLanMapInput interface {
	pulumi.Input

	ToMagicTransitSiteLanMapOutput() MagicTransitSiteLanMapOutput
	ToMagicTransitSiteLanMapOutputWithContext(context.Context) MagicTransitSiteLanMapOutput
}

type MagicTransitSiteLanMap map[string]MagicTransitSiteLanInput

func (MagicTransitSiteLanMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MagicTransitSiteLan)(nil)).Elem()
}

func (i MagicTransitSiteLanMap) ToMagicTransitSiteLanMapOutput() MagicTransitSiteLanMapOutput {
	return i.ToMagicTransitSiteLanMapOutputWithContext(context.Background())
}

func (i MagicTransitSiteLanMap) ToMagicTransitSiteLanMapOutputWithContext(ctx context.Context) MagicTransitSiteLanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MagicTransitSiteLanMapOutput)
}

type MagicTransitSiteLanOutput struct{ *pulumi.OutputState }

func (MagicTransitSiteLanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MagicTransitSiteLan)(nil)).Elem()
}

func (o MagicTransitSiteLanOutput) ToMagicTransitSiteLanOutput() MagicTransitSiteLanOutput {
	return o
}

func (o MagicTransitSiteLanOutput) ToMagicTransitSiteLanOutputWithContext(ctx context.Context) MagicTransitSiteLanOutput {
	return o
}

// Identifier
func (o MagicTransitSiteLanOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
func (o MagicTransitSiteLanOutput) HaLink() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.BoolPtrOutput { return v.HaLink }).(pulumi.BoolPtrOutput)
}

func (o MagicTransitSiteLanOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.StringPtrOutput { return v.Name }).(pulumi.StringPtrOutput)
}

func (o MagicTransitSiteLanOutput) Nat() MagicTransitSiteLanNatOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) MagicTransitSiteLanNatOutput { return v.Nat }).(MagicTransitSiteLanNatOutput)
}

func (o MagicTransitSiteLanOutput) Physport() pulumi.IntOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.IntOutput { return v.Physport }).(pulumi.IntOutput)
}

func (o MagicTransitSiteLanOutput) RoutedSubnets() MagicTransitSiteLanRoutedSubnetArrayOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) MagicTransitSiteLanRoutedSubnetArrayOutput { return v.RoutedSubnets }).(MagicTransitSiteLanRoutedSubnetArrayOutput)
}

// Identifier
func (o MagicTransitSiteLanOutput) SiteId() pulumi.StringOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.StringOutput { return v.SiteId }).(pulumi.StringOutput)
}

// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
func (o MagicTransitSiteLanOutput) StaticAddressing() MagicTransitSiteLanStaticAddressingOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) MagicTransitSiteLanStaticAddressingOutput { return v.StaticAddressing }).(MagicTransitSiteLanStaticAddressingOutput)
}

// VLAN port number.
func (o MagicTransitSiteLanOutput) VlanTag() pulumi.IntOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.IntOutput { return v.VlanTag }).(pulumi.IntOutput)
}

type MagicTransitSiteLanArrayOutput struct{ *pulumi.OutputState }

func (MagicTransitSiteLanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MagicTransitSiteLan)(nil)).Elem()
}

func (o MagicTransitSiteLanArrayOutput) ToMagicTransitSiteLanArrayOutput() MagicTransitSiteLanArrayOutput {
	return o
}

func (o MagicTransitSiteLanArrayOutput) ToMagicTransitSiteLanArrayOutputWithContext(ctx context.Context) MagicTransitSiteLanArrayOutput {
	return o
}

func (o MagicTransitSiteLanArrayOutput) Index(i pulumi.IntInput) MagicTransitSiteLanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MagicTransitSiteLan {
		return vs[0].([]*MagicTransitSiteLan)[vs[1].(int)]
	}).(MagicTransitSiteLanOutput)
}

type MagicTransitSiteLanMapOutput struct{ *pulumi.OutputState }

func (MagicTransitSiteLanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MagicTransitSiteLan)(nil)).Elem()
}

func (o MagicTransitSiteLanMapOutput) ToMagicTransitSiteLanMapOutput() MagicTransitSiteLanMapOutput {
	return o
}

func (o MagicTransitSiteLanMapOutput) ToMagicTransitSiteLanMapOutputWithContext(ctx context.Context) MagicTransitSiteLanMapOutput {
	return o
}

func (o MagicTransitSiteLanMapOutput) MapIndex(k pulumi.StringInput) MagicTransitSiteLanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MagicTransitSiteLan {
		return vs[0].(map[string]*MagicTransitSiteLan)[vs[1].(string)]
	}).(MagicTransitSiteLanOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MagicTransitSiteLanInput)(nil)).Elem(), &MagicTransitSiteLan{})
	pulumi.RegisterInputType(reflect.TypeOf((*MagicTransitSiteLanArrayInput)(nil)).Elem(), MagicTransitSiteLanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MagicTransitSiteLanMapInput)(nil)).Elem(), MagicTransitSiteLanMap{})
	pulumi.RegisterOutputType(MagicTransitSiteLanOutput{})
	pulumi.RegisterOutputType(MagicTransitSiteLanArrayOutput{})
	pulumi.RegisterOutputType(MagicTransitSiteLanMapOutput{})
}
