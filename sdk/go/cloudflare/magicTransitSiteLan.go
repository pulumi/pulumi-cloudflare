// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewMagicTransitSiteLan(ctx, "example_magic_transit_site_lan", &cloudflare.MagicTransitSiteLanArgs{
//				AccountId: pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				SiteId:    pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				Physport:  pulumi.Int(1),
//				HaLink:    pulumi.Bool(true),
//				Name:      pulumi.String("name"),
//				Nat: &cloudflare.MagicTransitSiteLanNatArgs{
//					Static_prefix: "192.0.2.0/24",
//				},
//				RoutedSubnets: cloudflare.MagicTransitSiteLanRoutedSubnetArray{
//					&cloudflare.MagicTransitSiteLanRoutedSubnetArgs{
//						Next_hop: "192.0.2.1",
//						Prefix:   pulumi.String("192.0.2.0/24"),
//						Nat: &cloudflare.MagicTransitSiteLanRoutedSubnetNatArgs{
//							StaticPrefix: pulumi.String("192.0.2.0/24"),
//						},
//					},
//				},
//				StaticAddressing: &cloudflare.MagicTransitSiteLanStaticAddressingArgs{
//					Address: pulumi.String("192.0.2.0/24"),
//					Dhcp_relay: map[string]interface{}{
//						"serverAddresses": []string{
//							"192.0.2.1",
//						},
//					},
//					Dhcp_server: map[string]interface{}{
//						"dhcpPoolEnd":   "192.0.2.1",
//						"dhcpPoolStart": "192.0.2.1",
//						"dnsServer":     "192.0.2.1",
//						"dnsServers": []string{
//							"192.0.2.1",
//						},
//						"reservations": map[string]interface{}{
//							"00:11:22:33:44:55": "192.0.2.100",
//							"AA:BB:CC:DD:EE:FF": "192.168.1.101",
//						},
//					},
//					Secondary_address: "192.0.2.0/24",
//					Virtual_address:   "192.0.2.0/24",
//				},
//				VlanTag: pulumi.Int(42),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/magicTransitSiteLan:MagicTransitSiteLan example '<account_id>/<site_id>/<lan_id>'
// ```
type MagicTransitSiteLan struct {
	pulumi.CustomResourceState

	// Identifier
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        pulumi.BoolPtrOutput                       `pulumi:"haLink"`
	Name          pulumi.StringPtrOutput                     `pulumi:"name"`
	Nat           MagicTransitSiteLanNatPtrOutput            `pulumi:"nat"`
	Physport      pulumi.IntOutput                           `pulumi:"physport"`
	RoutedSubnets MagicTransitSiteLanRoutedSubnetArrayOutput `pulumi:"routedSubnets"`
	// Identifier
	SiteId pulumi.StringOutput `pulumi:"siteId"`
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing MagicTransitSiteLanStaticAddressingPtrOutput `pulumi:"staticAddressing"`
	// VLAN ID. Use zero for untagged.
	VlanTag pulumi.IntPtrOutput `pulumi:"vlanTag"`
}

// NewMagicTransitSiteLan registers a new resource with the given unique name, arguments, and options.
func NewMagicTransitSiteLan(ctx *pulumi.Context,
	name string, args *MagicTransitSiteLanArgs, opts ...pulumi.ResourceOption) (*MagicTransitSiteLan, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.Physport == nil {
		return nil, errors.New("invalid value for required argument 'Physport'")
	}
	if args.SiteId == nil {
		return nil, errors.New("invalid value for required argument 'SiteId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource MagicTransitSiteLan
	err := ctx.RegisterResource("cloudflare:index/magicTransitSiteLan:MagicTransitSiteLan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMagicTransitSiteLan gets an existing MagicTransitSiteLan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMagicTransitSiteLan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MagicTransitSiteLanState, opts ...pulumi.ResourceOption) (*MagicTransitSiteLan, error) {
	var resource MagicTransitSiteLan
	err := ctx.ReadResource("cloudflare:index/magicTransitSiteLan:MagicTransitSiteLan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MagicTransitSiteLan resources.
type magicTransitSiteLanState struct {
	// Identifier
	AccountId *string `pulumi:"accountId"`
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        *bool                             `pulumi:"haLink"`
	Name          *string                           `pulumi:"name"`
	Nat           *MagicTransitSiteLanNat           `pulumi:"nat"`
	Physport      *int                              `pulumi:"physport"`
	RoutedSubnets []MagicTransitSiteLanRoutedSubnet `pulumi:"routedSubnets"`
	// Identifier
	SiteId *string `pulumi:"siteId"`
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing *MagicTransitSiteLanStaticAddressing `pulumi:"staticAddressing"`
	// VLAN ID. Use zero for untagged.
	VlanTag *int `pulumi:"vlanTag"`
}

type MagicTransitSiteLanState struct {
	// Identifier
	AccountId pulumi.StringPtrInput
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        pulumi.BoolPtrInput
	Name          pulumi.StringPtrInput
	Nat           MagicTransitSiteLanNatPtrInput
	Physport      pulumi.IntPtrInput
	RoutedSubnets MagicTransitSiteLanRoutedSubnetArrayInput
	// Identifier
	SiteId pulumi.StringPtrInput
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing MagicTransitSiteLanStaticAddressingPtrInput
	// VLAN ID. Use zero for untagged.
	VlanTag pulumi.IntPtrInput
}

func (MagicTransitSiteLanState) ElementType() reflect.Type {
	return reflect.TypeOf((*magicTransitSiteLanState)(nil)).Elem()
}

type magicTransitSiteLanArgs struct {
	// Identifier
	AccountId string `pulumi:"accountId"`
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        *bool                             `pulumi:"haLink"`
	Name          *string                           `pulumi:"name"`
	Nat           *MagicTransitSiteLanNat           `pulumi:"nat"`
	Physport      int                               `pulumi:"physport"`
	RoutedSubnets []MagicTransitSiteLanRoutedSubnet `pulumi:"routedSubnets"`
	// Identifier
	SiteId string `pulumi:"siteId"`
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing *MagicTransitSiteLanStaticAddressing `pulumi:"staticAddressing"`
	// VLAN ID. Use zero for untagged.
	VlanTag *int `pulumi:"vlanTag"`
}

// The set of arguments for constructing a MagicTransitSiteLan resource.
type MagicTransitSiteLanArgs struct {
	// Identifier
	AccountId pulumi.StringInput
	// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
	HaLink        pulumi.BoolPtrInput
	Name          pulumi.StringPtrInput
	Nat           MagicTransitSiteLanNatPtrInput
	Physport      pulumi.IntInput
	RoutedSubnets MagicTransitSiteLanRoutedSubnetArrayInput
	// Identifier
	SiteId pulumi.StringInput
	// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
	StaticAddressing MagicTransitSiteLanStaticAddressingPtrInput
	// VLAN ID. Use zero for untagged.
	VlanTag pulumi.IntPtrInput
}

func (MagicTransitSiteLanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*magicTransitSiteLanArgs)(nil)).Elem()
}

type MagicTransitSiteLanInput interface {
	pulumi.Input

	ToMagicTransitSiteLanOutput() MagicTransitSiteLanOutput
	ToMagicTransitSiteLanOutputWithContext(ctx context.Context) MagicTransitSiteLanOutput
}

func (*MagicTransitSiteLan) ElementType() reflect.Type {
	return reflect.TypeOf((**MagicTransitSiteLan)(nil)).Elem()
}

func (i *MagicTransitSiteLan) ToMagicTransitSiteLanOutput() MagicTransitSiteLanOutput {
	return i.ToMagicTransitSiteLanOutputWithContext(context.Background())
}

func (i *MagicTransitSiteLan) ToMagicTransitSiteLanOutputWithContext(ctx context.Context) MagicTransitSiteLanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MagicTransitSiteLanOutput)
}

// MagicTransitSiteLanArrayInput is an input type that accepts MagicTransitSiteLanArray and MagicTransitSiteLanArrayOutput values.
// You can construct a concrete instance of `MagicTransitSiteLanArrayInput` via:
//
//	MagicTransitSiteLanArray{ MagicTransitSiteLanArgs{...} }
type MagicTransitSiteLanArrayInput interface {
	pulumi.Input

	ToMagicTransitSiteLanArrayOutput() MagicTransitSiteLanArrayOutput
	ToMagicTransitSiteLanArrayOutputWithContext(context.Context) MagicTransitSiteLanArrayOutput
}

type MagicTransitSiteLanArray []MagicTransitSiteLanInput

func (MagicTransitSiteLanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MagicTransitSiteLan)(nil)).Elem()
}

func (i MagicTransitSiteLanArray) ToMagicTransitSiteLanArrayOutput() MagicTransitSiteLanArrayOutput {
	return i.ToMagicTransitSiteLanArrayOutputWithContext(context.Background())
}

func (i MagicTransitSiteLanArray) ToMagicTransitSiteLanArrayOutputWithContext(ctx context.Context) MagicTransitSiteLanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MagicTransitSiteLanArrayOutput)
}

// MagicTransitSiteLanMapInput is an input type that accepts MagicTransitSiteLanMap and MagicTransitSiteLanMapOutput values.
// You can construct a concrete instance of `MagicTransitSiteLanMapInput` via:
//
//	MagicTransitSiteLanMap{ "key": MagicTransitSiteLanArgs{...} }
type MagicTransitSiteLanMapInput interface {
	pulumi.Input

	ToMagicTransitSiteLanMapOutput() MagicTransitSiteLanMapOutput
	ToMagicTransitSiteLanMapOutputWithContext(context.Context) MagicTransitSiteLanMapOutput
}

type MagicTransitSiteLanMap map[string]MagicTransitSiteLanInput

func (MagicTransitSiteLanMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MagicTransitSiteLan)(nil)).Elem()
}

func (i MagicTransitSiteLanMap) ToMagicTransitSiteLanMapOutput() MagicTransitSiteLanMapOutput {
	return i.ToMagicTransitSiteLanMapOutputWithContext(context.Background())
}

func (i MagicTransitSiteLanMap) ToMagicTransitSiteLanMapOutputWithContext(ctx context.Context) MagicTransitSiteLanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MagicTransitSiteLanMapOutput)
}

type MagicTransitSiteLanOutput struct{ *pulumi.OutputState }

func (MagicTransitSiteLanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MagicTransitSiteLan)(nil)).Elem()
}

func (o MagicTransitSiteLanOutput) ToMagicTransitSiteLanOutput() MagicTransitSiteLanOutput {
	return o
}

func (o MagicTransitSiteLanOutput) ToMagicTransitSiteLanOutputWithContext(ctx context.Context) MagicTransitSiteLanOutput {
	return o
}

// Identifier
func (o MagicTransitSiteLanOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
func (o MagicTransitSiteLanOutput) HaLink() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.BoolPtrOutput { return v.HaLink }).(pulumi.BoolPtrOutput)
}

func (o MagicTransitSiteLanOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.StringPtrOutput { return v.Name }).(pulumi.StringPtrOutput)
}

func (o MagicTransitSiteLanOutput) Nat() MagicTransitSiteLanNatPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) MagicTransitSiteLanNatPtrOutput { return v.Nat }).(MagicTransitSiteLanNatPtrOutput)
}

func (o MagicTransitSiteLanOutput) Physport() pulumi.IntOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.IntOutput { return v.Physport }).(pulumi.IntOutput)
}

func (o MagicTransitSiteLanOutput) RoutedSubnets() MagicTransitSiteLanRoutedSubnetArrayOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) MagicTransitSiteLanRoutedSubnetArrayOutput { return v.RoutedSubnets }).(MagicTransitSiteLanRoutedSubnetArrayOutput)
}

// Identifier
func (o MagicTransitSiteLanOutput) SiteId() pulumi.StringOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.StringOutput { return v.SiteId }).(pulumi.StringOutput)
}

// If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
func (o MagicTransitSiteLanOutput) StaticAddressing() MagicTransitSiteLanStaticAddressingPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) MagicTransitSiteLanStaticAddressingPtrOutput { return v.StaticAddressing }).(MagicTransitSiteLanStaticAddressingPtrOutput)
}

// VLAN ID. Use zero for untagged.
func (o MagicTransitSiteLanOutput) VlanTag() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *MagicTransitSiteLan) pulumi.IntPtrOutput { return v.VlanTag }).(pulumi.IntPtrOutput)
}

type MagicTransitSiteLanArrayOutput struct{ *pulumi.OutputState }

func (MagicTransitSiteLanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MagicTransitSiteLan)(nil)).Elem()
}

func (o MagicTransitSiteLanArrayOutput) ToMagicTransitSiteLanArrayOutput() MagicTransitSiteLanArrayOutput {
	return o
}

func (o MagicTransitSiteLanArrayOutput) ToMagicTransitSiteLanArrayOutputWithContext(ctx context.Context) MagicTransitSiteLanArrayOutput {
	return o
}

func (o MagicTransitSiteLanArrayOutput) Index(i pulumi.IntInput) MagicTransitSiteLanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MagicTransitSiteLan {
		return vs[0].([]*MagicTransitSiteLan)[vs[1].(int)]
	}).(MagicTransitSiteLanOutput)
}

type MagicTransitSiteLanMapOutput struct{ *pulumi.OutputState }

func (MagicTransitSiteLanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MagicTransitSiteLan)(nil)).Elem()
}

func (o MagicTransitSiteLanMapOutput) ToMagicTransitSiteLanMapOutput() MagicTransitSiteLanMapOutput {
	return o
}

func (o MagicTransitSiteLanMapOutput) ToMagicTransitSiteLanMapOutputWithContext(ctx context.Context) MagicTransitSiteLanMapOutput {
	return o
}

func (o MagicTransitSiteLanMapOutput) MapIndex(k pulumi.StringInput) MagicTransitSiteLanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MagicTransitSiteLan {
		return vs[0].(map[string]*MagicTransitSiteLan)[vs[1].(string)]
	}).(MagicTransitSiteLanOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MagicTransitSiteLanInput)(nil)).Elem(), &MagicTransitSiteLan{})
	pulumi.RegisterInputType(reflect.TypeOf((*MagicTransitSiteLanArrayInput)(nil)).Elem(), MagicTransitSiteLanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MagicTransitSiteLanMapInput)(nil)).Elem(), MagicTransitSiteLanMap{})
	pulumi.RegisterOutputType(MagicTransitSiteLanOutput{})
	pulumi.RegisterOutputType(MagicTransitSiteLanArrayOutput{})
	pulumi.RegisterOutputType(MagicTransitSiteLanMapOutput{})
}
