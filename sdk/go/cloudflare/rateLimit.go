// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// > `RateLimit` is in a deprecation phase until June 15th, 2025.
//
//	During this time period, this resource is still
//	fully supported but you are strongly advised to move to the
//	`Ruleset` resource. Full details can be found in the
//	developer documentation.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewRateLimit(ctx, "example_rate_limit", &cloudflare.RateLimitArgs{
//				ZoneId: pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				Action: &cloudflare.RateLimitActionArgs{
//					Mode: pulumi.String("simulate"),
//					Response: &cloudflare.RateLimitActionResponseArgs{
//						Body:        pulumi.String("<error>This request has been rate-limited.</error>"),
//						ContentType: pulumi.String("text/xml"),
//					},
//					Timeout: pulumi.Float64(86400),
//				},
//				Match: &cloudflare.RateLimitMatchArgs{
//					Headers: cloudflare.RateLimitMatchHeaderArray{
//						&cloudflare.RateLimitMatchHeaderArgs{
//							Name:  pulumi.String("Cf-Cache-Status"),
//							Op:    pulumi.String("eq"),
//							Value: pulumi.String("HIT"),
//						},
//					},
//					Request: &cloudflare.RateLimitMatchRequestArgs{
//						Methods: pulumi.StringArray{
//							pulumi.String("GET"),
//							pulumi.String("POST"),
//						},
//						Schemes: pulumi.StringArray{
//							pulumi.String("HTTP"),
//							pulumi.String("HTTPS"),
//						},
//						Url: pulumi.String("*.example.org/path*"),
//					},
//					Response: &cloudflare.RateLimitMatchResponseArgs{
//						OriginTraffic: pulumi.Bool(true),
//					},
//				},
//				Period:    pulumi.Float64(900),
//				Threshold: pulumi.Float64(60),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/rateLimit:RateLimit example '<zone_id>/<rate_limit_id>'
// ```
type RateLimit struct {
	pulumi.CustomResourceState

	// The action to perform when the threshold of matched traffic within the configured period is exceeded.
	Action RateLimitActionOutput `pulumi:"action"`
	// Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
	Bypasses RateLimitBypassArrayOutput `pulumi:"bypasses"`
	// An informative summary of the rate limit. This value is sanitized and any tags will be removed.
	Description pulumi.StringOutput `pulumi:"description"`
	// When true, indicates that the rate limit is currently disabled.
	Disabled pulumi.BoolOutput `pulumi:"disabled"`
	// Determines which traffic the rate limit counts towards the threshold.
	Match RateLimitMatchOutput `pulumi:"match"`
	// The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
	Period pulumi.Float64Output `pulumi:"period"`
	// The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
	Threshold pulumi.Float64Output `pulumi:"threshold"`
	// Identifier
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewRateLimit registers a new resource with the given unique name, arguments, and options.
func NewRateLimit(ctx *pulumi.Context,
	name string, args *RateLimitArgs, opts ...pulumi.ResourceOption) (*RateLimit, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Match == nil {
		return nil, errors.New("invalid value for required argument 'Match'")
	}
	if args.Period == nil {
		return nil, errors.New("invalid value for required argument 'Period'")
	}
	if args.Threshold == nil {
		return nil, errors.New("invalid value for required argument 'Threshold'")
	}
	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RateLimit
	err := ctx.RegisterResource("cloudflare:index/rateLimit:RateLimit", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRateLimit gets an existing RateLimit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRateLimit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RateLimitState, opts ...pulumi.ResourceOption) (*RateLimit, error) {
	var resource RateLimit
	err := ctx.ReadResource("cloudflare:index/rateLimit:RateLimit", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RateLimit resources.
type rateLimitState struct {
	// The action to perform when the threshold of matched traffic within the configured period is exceeded.
	Action *RateLimitAction `pulumi:"action"`
	// Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
	Bypasses []RateLimitBypass `pulumi:"bypasses"`
	// An informative summary of the rate limit. This value is sanitized and any tags will be removed.
	Description *string `pulumi:"description"`
	// When true, indicates that the rate limit is currently disabled.
	Disabled *bool `pulumi:"disabled"`
	// Determines which traffic the rate limit counts towards the threshold.
	Match *RateLimitMatch `pulumi:"match"`
	// The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
	Period *float64 `pulumi:"period"`
	// The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
	Threshold *float64 `pulumi:"threshold"`
	// Identifier
	ZoneId *string `pulumi:"zoneId"`
}

type RateLimitState struct {
	// The action to perform when the threshold of matched traffic within the configured period is exceeded.
	Action RateLimitActionPtrInput
	// Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
	Bypasses RateLimitBypassArrayInput
	// An informative summary of the rate limit. This value is sanitized and any tags will be removed.
	Description pulumi.StringPtrInput
	// When true, indicates that the rate limit is currently disabled.
	Disabled pulumi.BoolPtrInput
	// Determines which traffic the rate limit counts towards the threshold.
	Match RateLimitMatchPtrInput
	// The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
	Period pulumi.Float64PtrInput
	// The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
	Threshold pulumi.Float64PtrInput
	// Identifier
	ZoneId pulumi.StringPtrInput
}

func (RateLimitState) ElementType() reflect.Type {
	return reflect.TypeOf((*rateLimitState)(nil)).Elem()
}

type rateLimitArgs struct {
	// The action to perform when the threshold of matched traffic within the configured period is exceeded.
	Action RateLimitAction `pulumi:"action"`
	// Determines which traffic the rate limit counts towards the threshold.
	Match RateLimitMatch `pulumi:"match"`
	// The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
	Period float64 `pulumi:"period"`
	// The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
	Threshold float64 `pulumi:"threshold"`
	// Identifier
	ZoneId string `pulumi:"zoneId"`
}

// The set of arguments for constructing a RateLimit resource.
type RateLimitArgs struct {
	// The action to perform when the threshold of matched traffic within the configured period is exceeded.
	Action RateLimitActionInput
	// Determines which traffic the rate limit counts towards the threshold.
	Match RateLimitMatchInput
	// The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
	Period pulumi.Float64Input
	// The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
	Threshold pulumi.Float64Input
	// Identifier
	ZoneId pulumi.StringInput
}

func (RateLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rateLimitArgs)(nil)).Elem()
}

type RateLimitInput interface {
	pulumi.Input

	ToRateLimitOutput() RateLimitOutput
	ToRateLimitOutputWithContext(ctx context.Context) RateLimitOutput
}

func (*RateLimit) ElementType() reflect.Type {
	return reflect.TypeOf((**RateLimit)(nil)).Elem()
}

func (i *RateLimit) ToRateLimitOutput() RateLimitOutput {
	return i.ToRateLimitOutputWithContext(context.Background())
}

func (i *RateLimit) ToRateLimitOutputWithContext(ctx context.Context) RateLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RateLimitOutput)
}

// RateLimitArrayInput is an input type that accepts RateLimitArray and RateLimitArrayOutput values.
// You can construct a concrete instance of `RateLimitArrayInput` via:
//
//	RateLimitArray{ RateLimitArgs{...} }
type RateLimitArrayInput interface {
	pulumi.Input

	ToRateLimitArrayOutput() RateLimitArrayOutput
	ToRateLimitArrayOutputWithContext(context.Context) RateLimitArrayOutput
}

type RateLimitArray []RateLimitInput

func (RateLimitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RateLimit)(nil)).Elem()
}

func (i RateLimitArray) ToRateLimitArrayOutput() RateLimitArrayOutput {
	return i.ToRateLimitArrayOutputWithContext(context.Background())
}

func (i RateLimitArray) ToRateLimitArrayOutputWithContext(ctx context.Context) RateLimitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RateLimitArrayOutput)
}

// RateLimitMapInput is an input type that accepts RateLimitMap and RateLimitMapOutput values.
// You can construct a concrete instance of `RateLimitMapInput` via:
//
//	RateLimitMap{ "key": RateLimitArgs{...} }
type RateLimitMapInput interface {
	pulumi.Input

	ToRateLimitMapOutput() RateLimitMapOutput
	ToRateLimitMapOutputWithContext(context.Context) RateLimitMapOutput
}

type RateLimitMap map[string]RateLimitInput

func (RateLimitMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RateLimit)(nil)).Elem()
}

func (i RateLimitMap) ToRateLimitMapOutput() RateLimitMapOutput {
	return i.ToRateLimitMapOutputWithContext(context.Background())
}

func (i RateLimitMap) ToRateLimitMapOutputWithContext(ctx context.Context) RateLimitMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RateLimitMapOutput)
}

type RateLimitOutput struct{ *pulumi.OutputState }

func (RateLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RateLimit)(nil)).Elem()
}

func (o RateLimitOutput) ToRateLimitOutput() RateLimitOutput {
	return o
}

func (o RateLimitOutput) ToRateLimitOutputWithContext(ctx context.Context) RateLimitOutput {
	return o
}

// The action to perform when the threshold of matched traffic within the configured period is exceeded.
func (o RateLimitOutput) Action() RateLimitActionOutput {
	return o.ApplyT(func(v *RateLimit) RateLimitActionOutput { return v.Action }).(RateLimitActionOutput)
}

// Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
func (o RateLimitOutput) Bypasses() RateLimitBypassArrayOutput {
	return o.ApplyT(func(v *RateLimit) RateLimitBypassArrayOutput { return v.Bypasses }).(RateLimitBypassArrayOutput)
}

// An informative summary of the rate limit. This value is sanitized and any tags will be removed.
func (o RateLimitOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *RateLimit) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// When true, indicates that the rate limit is currently disabled.
func (o RateLimitOutput) Disabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *RateLimit) pulumi.BoolOutput { return v.Disabled }).(pulumi.BoolOutput)
}

// Determines which traffic the rate limit counts towards the threshold.
func (o RateLimitOutput) Match() RateLimitMatchOutput {
	return o.ApplyT(func(v *RateLimit) RateLimitMatchOutput { return v.Match }).(RateLimitMatchOutput)
}

// The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
func (o RateLimitOutput) Period() pulumi.Float64Output {
	return o.ApplyT(func(v *RateLimit) pulumi.Float64Output { return v.Period }).(pulumi.Float64Output)
}

// The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
func (o RateLimitOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v *RateLimit) pulumi.Float64Output { return v.Threshold }).(pulumi.Float64Output)
}

// Identifier
func (o RateLimitOutput) ZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *RateLimit) pulumi.StringOutput { return v.ZoneId }).(pulumi.StringOutput)
}

type RateLimitArrayOutput struct{ *pulumi.OutputState }

func (RateLimitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RateLimit)(nil)).Elem()
}

func (o RateLimitArrayOutput) ToRateLimitArrayOutput() RateLimitArrayOutput {
	return o
}

func (o RateLimitArrayOutput) ToRateLimitArrayOutputWithContext(ctx context.Context) RateLimitArrayOutput {
	return o
}

func (o RateLimitArrayOutput) Index(i pulumi.IntInput) RateLimitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RateLimit {
		return vs[0].([]*RateLimit)[vs[1].(int)]
	}).(RateLimitOutput)
}

type RateLimitMapOutput struct{ *pulumi.OutputState }

func (RateLimitMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RateLimit)(nil)).Elem()
}

func (o RateLimitMapOutput) ToRateLimitMapOutput() RateLimitMapOutput {
	return o
}

func (o RateLimitMapOutput) ToRateLimitMapOutputWithContext(ctx context.Context) RateLimitMapOutput {
	return o
}

func (o RateLimitMapOutput) MapIndex(k pulumi.StringInput) RateLimitOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RateLimit {
		return vs[0].(map[string]*RateLimit)[vs[1].(string)]
	}).(RateLimitOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RateLimitInput)(nil)).Elem(), &RateLimit{})
	pulumi.RegisterInputType(reflect.TypeOf((*RateLimitArrayInput)(nil)).Elem(), RateLimitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RateLimitMapInput)(nil)).Elem(), RateLimitMap{})
	pulumi.RegisterOutputType(RateLimitOutput{})
	pulumi.RegisterOutputType(RateLimitArrayOutput{})
	pulumi.RegisterOutputType(RateLimitMapOutput{})
}
