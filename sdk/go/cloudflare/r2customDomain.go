// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewR2CustomDomain(ctx, "example_r2_custom_domain", &cloudflare.R2CustomDomainArgs{
//				AccountId:  pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				BucketName: pulumi.String("example-bucket"),
//				Domain:     pulumi.String("domain"),
//				Enabled:    pulumi.Bool(true),
//				ZoneId:     pulumi.String("zoneId"),
//				MinTls:     pulumi.String("1.0"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type R2CustomDomain struct {
	pulumi.CustomResourceState

	// Account ID.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Name of the bucket.
	BucketName pulumi.StringOutput `pulumi:"bucketName"`
	// Name of the custom domain to be added.
	Domain pulumi.StringOutput `pulumi:"domain"`
	// Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Jurisdiction of the bucket
	Jurisdiction pulumi.StringOutput `pulumi:"jurisdiction"`
	// Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTls pulumi.StringPtrOutput     `pulumi:"minTls"`
	Status R2CustomDomainStatusOutput `pulumi:"status"`
	// Zone ID of the custom domain.
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
	// Zone that the custom domain resides in.
	ZoneName pulumi.StringOutput `pulumi:"zoneName"`
}

// NewR2CustomDomain registers a new resource with the given unique name, arguments, and options.
func NewR2CustomDomain(ctx *pulumi.Context,
	name string, args *R2CustomDomainArgs, opts ...pulumi.ResourceOption) (*R2CustomDomain, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.BucketName == nil {
		return nil, errors.New("invalid value for required argument 'BucketName'")
	}
	if args.Domain == nil {
		return nil, errors.New("invalid value for required argument 'Domain'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource R2CustomDomain
	err := ctx.RegisterResource("cloudflare:index/r2CustomDomain:R2CustomDomain", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetR2CustomDomain gets an existing R2CustomDomain resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetR2CustomDomain(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *R2CustomDomainState, opts ...pulumi.ResourceOption) (*R2CustomDomain, error) {
	var resource R2CustomDomain
	err := ctx.ReadResource("cloudflare:index/r2CustomDomain:R2CustomDomain", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering R2CustomDomain resources.
type r2customDomainState struct {
	// Account ID.
	AccountId *string `pulumi:"accountId"`
	// Name of the bucket.
	BucketName *string `pulumi:"bucketName"`
	// Name of the custom domain to be added.
	Domain *string `pulumi:"domain"`
	// Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
	Enabled *bool `pulumi:"enabled"`
	// Jurisdiction of the bucket
	Jurisdiction *string `pulumi:"jurisdiction"`
	// Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTls *string               `pulumi:"minTls"`
	Status *R2CustomDomainStatus `pulumi:"status"`
	// Zone ID of the custom domain.
	ZoneId *string `pulumi:"zoneId"`
	// Zone that the custom domain resides in.
	ZoneName *string `pulumi:"zoneName"`
}

type R2CustomDomainState struct {
	// Account ID.
	AccountId pulumi.StringPtrInput
	// Name of the bucket.
	BucketName pulumi.StringPtrInput
	// Name of the custom domain to be added.
	Domain pulumi.StringPtrInput
	// Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
	Enabled pulumi.BoolPtrInput
	// Jurisdiction of the bucket
	Jurisdiction pulumi.StringPtrInput
	// Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTls pulumi.StringPtrInput
	Status R2CustomDomainStatusPtrInput
	// Zone ID of the custom domain.
	ZoneId pulumi.StringPtrInput
	// Zone that the custom domain resides in.
	ZoneName pulumi.StringPtrInput
}

func (R2CustomDomainState) ElementType() reflect.Type {
	return reflect.TypeOf((*r2customDomainState)(nil)).Elem()
}

type r2customDomainArgs struct {
	// Account ID.
	AccountId string `pulumi:"accountId"`
	// Name of the bucket.
	BucketName string `pulumi:"bucketName"`
	// Name of the custom domain to be added.
	Domain string `pulumi:"domain"`
	// Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
	Enabled bool `pulumi:"enabled"`
	// Jurisdiction of the bucket
	Jurisdiction *string `pulumi:"jurisdiction"`
	// Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTls *string `pulumi:"minTls"`
	// Zone ID of the custom domain.
	ZoneId string `pulumi:"zoneId"`
}

// The set of arguments for constructing a R2CustomDomain resource.
type R2CustomDomainArgs struct {
	// Account ID.
	AccountId pulumi.StringInput
	// Name of the bucket.
	BucketName pulumi.StringInput
	// Name of the custom domain to be added.
	Domain pulumi.StringInput
	// Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
	Enabled pulumi.BoolInput
	// Jurisdiction of the bucket
	Jurisdiction pulumi.StringPtrInput
	// Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTls pulumi.StringPtrInput
	// Zone ID of the custom domain.
	ZoneId pulumi.StringInput
}

func (R2CustomDomainArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*r2customDomainArgs)(nil)).Elem()
}

type R2CustomDomainInput interface {
	pulumi.Input

	ToR2CustomDomainOutput() R2CustomDomainOutput
	ToR2CustomDomainOutputWithContext(ctx context.Context) R2CustomDomainOutput
}

func (*R2CustomDomain) ElementType() reflect.Type {
	return reflect.TypeOf((**R2CustomDomain)(nil)).Elem()
}

func (i *R2CustomDomain) ToR2CustomDomainOutput() R2CustomDomainOutput {
	return i.ToR2CustomDomainOutputWithContext(context.Background())
}

func (i *R2CustomDomain) ToR2CustomDomainOutputWithContext(ctx context.Context) R2CustomDomainOutput {
	return pulumi.ToOutputWithContext(ctx, i).(R2CustomDomainOutput)
}

// R2CustomDomainArrayInput is an input type that accepts R2CustomDomainArray and R2CustomDomainArrayOutput values.
// You can construct a concrete instance of `R2CustomDomainArrayInput` via:
//
//	R2CustomDomainArray{ R2CustomDomainArgs{...} }
type R2CustomDomainArrayInput interface {
	pulumi.Input

	ToR2CustomDomainArrayOutput() R2CustomDomainArrayOutput
	ToR2CustomDomainArrayOutputWithContext(context.Context) R2CustomDomainArrayOutput
}

type R2CustomDomainArray []R2CustomDomainInput

func (R2CustomDomainArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*R2CustomDomain)(nil)).Elem()
}

func (i R2CustomDomainArray) ToR2CustomDomainArrayOutput() R2CustomDomainArrayOutput {
	return i.ToR2CustomDomainArrayOutputWithContext(context.Background())
}

func (i R2CustomDomainArray) ToR2CustomDomainArrayOutputWithContext(ctx context.Context) R2CustomDomainArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(R2CustomDomainArrayOutput)
}

// R2CustomDomainMapInput is an input type that accepts R2CustomDomainMap and R2CustomDomainMapOutput values.
// You can construct a concrete instance of `R2CustomDomainMapInput` via:
//
//	R2CustomDomainMap{ "key": R2CustomDomainArgs{...} }
type R2CustomDomainMapInput interface {
	pulumi.Input

	ToR2CustomDomainMapOutput() R2CustomDomainMapOutput
	ToR2CustomDomainMapOutputWithContext(context.Context) R2CustomDomainMapOutput
}

type R2CustomDomainMap map[string]R2CustomDomainInput

func (R2CustomDomainMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*R2CustomDomain)(nil)).Elem()
}

func (i R2CustomDomainMap) ToR2CustomDomainMapOutput() R2CustomDomainMapOutput {
	return i.ToR2CustomDomainMapOutputWithContext(context.Background())
}

func (i R2CustomDomainMap) ToR2CustomDomainMapOutputWithContext(ctx context.Context) R2CustomDomainMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(R2CustomDomainMapOutput)
}

type R2CustomDomainOutput struct{ *pulumi.OutputState }

func (R2CustomDomainOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**R2CustomDomain)(nil)).Elem()
}

func (o R2CustomDomainOutput) ToR2CustomDomainOutput() R2CustomDomainOutput {
	return o
}

func (o R2CustomDomainOutput) ToR2CustomDomainOutputWithContext(ctx context.Context) R2CustomDomainOutput {
	return o
}

// Account ID.
func (o R2CustomDomainOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Name of the bucket.
func (o R2CustomDomainOutput) BucketName() pulumi.StringOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringOutput { return v.BucketName }).(pulumi.StringOutput)
}

// Name of the custom domain to be added.
func (o R2CustomDomainOutput) Domain() pulumi.StringOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringOutput { return v.Domain }).(pulumi.StringOutput)
}

// Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
func (o R2CustomDomainOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Jurisdiction of the bucket
func (o R2CustomDomainOutput) Jurisdiction() pulumi.StringOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringOutput { return v.Jurisdiction }).(pulumi.StringOutput)
}

// Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
// Available values: "1.0", "1.1", "1.2", "1.3".
func (o R2CustomDomainOutput) MinTls() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringPtrOutput { return v.MinTls }).(pulumi.StringPtrOutput)
}

func (o R2CustomDomainOutput) Status() R2CustomDomainStatusOutput {
	return o.ApplyT(func(v *R2CustomDomain) R2CustomDomainStatusOutput { return v.Status }).(R2CustomDomainStatusOutput)
}

// Zone ID of the custom domain.
func (o R2CustomDomainOutput) ZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringOutput { return v.ZoneId }).(pulumi.StringOutput)
}

// Zone that the custom domain resides in.
func (o R2CustomDomainOutput) ZoneName() pulumi.StringOutput {
	return o.ApplyT(func(v *R2CustomDomain) pulumi.StringOutput { return v.ZoneName }).(pulumi.StringOutput)
}

type R2CustomDomainArrayOutput struct{ *pulumi.OutputState }

func (R2CustomDomainArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*R2CustomDomain)(nil)).Elem()
}

func (o R2CustomDomainArrayOutput) ToR2CustomDomainArrayOutput() R2CustomDomainArrayOutput {
	return o
}

func (o R2CustomDomainArrayOutput) ToR2CustomDomainArrayOutputWithContext(ctx context.Context) R2CustomDomainArrayOutput {
	return o
}

func (o R2CustomDomainArrayOutput) Index(i pulumi.IntInput) R2CustomDomainOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *R2CustomDomain {
		return vs[0].([]*R2CustomDomain)[vs[1].(int)]
	}).(R2CustomDomainOutput)
}

type R2CustomDomainMapOutput struct{ *pulumi.OutputState }

func (R2CustomDomainMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*R2CustomDomain)(nil)).Elem()
}

func (o R2CustomDomainMapOutput) ToR2CustomDomainMapOutput() R2CustomDomainMapOutput {
	return o
}

func (o R2CustomDomainMapOutput) ToR2CustomDomainMapOutputWithContext(ctx context.Context) R2CustomDomainMapOutput {
	return o
}

func (o R2CustomDomainMapOutput) MapIndex(k pulumi.StringInput) R2CustomDomainOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *R2CustomDomain {
		return vs[0].(map[string]*R2CustomDomain)[vs[1].(string)]
	}).(R2CustomDomainOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*R2CustomDomainInput)(nil)).Elem(), &R2CustomDomain{})
	pulumi.RegisterInputType(reflect.TypeOf((*R2CustomDomainArrayInput)(nil)).Elem(), R2CustomDomainArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*R2CustomDomainMapInput)(nil)).Elem(), R2CustomDomainMap{})
	pulumi.RegisterOutputType(R2CustomDomainOutput{})
	pulumi.RegisterOutputType(R2CustomDomainArrayOutput{})
	pulumi.RegisterOutputType(R2CustomDomainMapOutput{})
}
