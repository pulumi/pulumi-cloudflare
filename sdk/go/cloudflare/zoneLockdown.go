// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewZoneLockdown(ctx, "example_zone_lockdown", &cloudflare.ZoneLockdownArgs{
//				ZoneId: pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				Configurations: cloudflare.ZoneLockdownConfigurationArray{
//					&cloudflare.ZoneLockdownConfigurationArgs{
//						Target: pulumi.String("ip"),
//						Value:  pulumi.String("198.51.100.4"),
//					},
//				},
//				Urls: pulumi.StringArray{
//					pulumi.String("shop.example.com/*"),
//				},
//				Description: pulumi.String("Prevent multiple login failures to mitigate brute force attacks"),
//				Paused:      pulumi.Bool(false),
//				Priority:    pulumi.Float64(5),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/zoneLockdown:ZoneLockdown example '<zone_id>/<lock_downs_id>'
// ```
type ZoneLockdown struct {
	pulumi.CustomResourceState

	// A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
	Configurations ZoneLockdownConfigurationArrayOutput `pulumi:"configurations"`
	// The timestamp of when the rule was created.
	CreatedOn pulumi.StringOutput `pulumi:"createdOn"`
	// An informative summary of the rule. This value is sanitized and any tags will be removed.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The timestamp of when the rule was last modified.
	ModifiedOn pulumi.StringOutput `pulumi:"modifiedOn"`
	// When true, indicates that the rule is currently paused.
	Paused pulumi.BoolOutput `pulumi:"paused"`
	// The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
	Priority pulumi.Float64PtrOutput `pulumi:"priority"`
	// The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
	Urls pulumi.StringArrayOutput `pulumi:"urls"`
	// Defines an identifier.
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewZoneLockdown registers a new resource with the given unique name, arguments, and options.
func NewZoneLockdown(ctx *pulumi.Context,
	name string, args *ZoneLockdownArgs, opts ...pulumi.ResourceOption) (*ZoneLockdown, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Configurations == nil {
		return nil, errors.New("invalid value for required argument 'Configurations'")
	}
	if args.Urls == nil {
		return nil, errors.New("invalid value for required argument 'Urls'")
	}
	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ZoneLockdown
	err := ctx.RegisterResource("cloudflare:index/zoneLockdown:ZoneLockdown", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetZoneLockdown gets an existing ZoneLockdown resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetZoneLockdown(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ZoneLockdownState, opts ...pulumi.ResourceOption) (*ZoneLockdown, error) {
	var resource ZoneLockdown
	err := ctx.ReadResource("cloudflare:index/zoneLockdown:ZoneLockdown", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ZoneLockdown resources.
type zoneLockdownState struct {
	// A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
	Configurations []ZoneLockdownConfiguration `pulumi:"configurations"`
	// The timestamp of when the rule was created.
	CreatedOn *string `pulumi:"createdOn"`
	// An informative summary of the rule. This value is sanitized and any tags will be removed.
	Description *string `pulumi:"description"`
	// The timestamp of when the rule was last modified.
	ModifiedOn *string `pulumi:"modifiedOn"`
	// When true, indicates that the rule is currently paused.
	Paused *bool `pulumi:"paused"`
	// The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
	Priority *float64 `pulumi:"priority"`
	// The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
	Urls []string `pulumi:"urls"`
	// Defines an identifier.
	ZoneId *string `pulumi:"zoneId"`
}

type ZoneLockdownState struct {
	// A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
	Configurations ZoneLockdownConfigurationArrayInput
	// The timestamp of when the rule was created.
	CreatedOn pulumi.StringPtrInput
	// An informative summary of the rule. This value is sanitized and any tags will be removed.
	Description pulumi.StringPtrInput
	// The timestamp of when the rule was last modified.
	ModifiedOn pulumi.StringPtrInput
	// When true, indicates that the rule is currently paused.
	Paused pulumi.BoolPtrInput
	// The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
	Priority pulumi.Float64PtrInput
	// The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
	Urls pulumi.StringArrayInput
	// Defines an identifier.
	ZoneId pulumi.StringPtrInput
}

func (ZoneLockdownState) ElementType() reflect.Type {
	return reflect.TypeOf((*zoneLockdownState)(nil)).Elem()
}

type zoneLockdownArgs struct {
	// A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
	Configurations []ZoneLockdownConfiguration `pulumi:"configurations"`
	// An informative summary of the rule. This value is sanitized and any tags will be removed.
	Description *string `pulumi:"description"`
	// When true, indicates that the rule is currently paused.
	Paused *bool `pulumi:"paused"`
	// The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
	Priority *float64 `pulumi:"priority"`
	// The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
	Urls []string `pulumi:"urls"`
	// Defines an identifier.
	ZoneId string `pulumi:"zoneId"`
}

// The set of arguments for constructing a ZoneLockdown resource.
type ZoneLockdownArgs struct {
	// A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
	Configurations ZoneLockdownConfigurationArrayInput
	// An informative summary of the rule. This value is sanitized and any tags will be removed.
	Description pulumi.StringPtrInput
	// When true, indicates that the rule is currently paused.
	Paused pulumi.BoolPtrInput
	// The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
	Priority pulumi.Float64PtrInput
	// The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
	Urls pulumi.StringArrayInput
	// Defines an identifier.
	ZoneId pulumi.StringInput
}

func (ZoneLockdownArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*zoneLockdownArgs)(nil)).Elem()
}

type ZoneLockdownInput interface {
	pulumi.Input

	ToZoneLockdownOutput() ZoneLockdownOutput
	ToZoneLockdownOutputWithContext(ctx context.Context) ZoneLockdownOutput
}

func (*ZoneLockdown) ElementType() reflect.Type {
	return reflect.TypeOf((**ZoneLockdown)(nil)).Elem()
}

func (i *ZoneLockdown) ToZoneLockdownOutput() ZoneLockdownOutput {
	return i.ToZoneLockdownOutputWithContext(context.Background())
}

func (i *ZoneLockdown) ToZoneLockdownOutputWithContext(ctx context.Context) ZoneLockdownOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZoneLockdownOutput)
}

// ZoneLockdownArrayInput is an input type that accepts ZoneLockdownArray and ZoneLockdownArrayOutput values.
// You can construct a concrete instance of `ZoneLockdownArrayInput` via:
//
//	ZoneLockdownArray{ ZoneLockdownArgs{...} }
type ZoneLockdownArrayInput interface {
	pulumi.Input

	ToZoneLockdownArrayOutput() ZoneLockdownArrayOutput
	ToZoneLockdownArrayOutputWithContext(context.Context) ZoneLockdownArrayOutput
}

type ZoneLockdownArray []ZoneLockdownInput

func (ZoneLockdownArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ZoneLockdown)(nil)).Elem()
}

func (i ZoneLockdownArray) ToZoneLockdownArrayOutput() ZoneLockdownArrayOutput {
	return i.ToZoneLockdownArrayOutputWithContext(context.Background())
}

func (i ZoneLockdownArray) ToZoneLockdownArrayOutputWithContext(ctx context.Context) ZoneLockdownArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZoneLockdownArrayOutput)
}

// ZoneLockdownMapInput is an input type that accepts ZoneLockdownMap and ZoneLockdownMapOutput values.
// You can construct a concrete instance of `ZoneLockdownMapInput` via:
//
//	ZoneLockdownMap{ "key": ZoneLockdownArgs{...} }
type ZoneLockdownMapInput interface {
	pulumi.Input

	ToZoneLockdownMapOutput() ZoneLockdownMapOutput
	ToZoneLockdownMapOutputWithContext(context.Context) ZoneLockdownMapOutput
}

type ZoneLockdownMap map[string]ZoneLockdownInput

func (ZoneLockdownMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ZoneLockdown)(nil)).Elem()
}

func (i ZoneLockdownMap) ToZoneLockdownMapOutput() ZoneLockdownMapOutput {
	return i.ToZoneLockdownMapOutputWithContext(context.Background())
}

func (i ZoneLockdownMap) ToZoneLockdownMapOutputWithContext(ctx context.Context) ZoneLockdownMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZoneLockdownMapOutput)
}

type ZoneLockdownOutput struct{ *pulumi.OutputState }

func (ZoneLockdownOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ZoneLockdown)(nil)).Elem()
}

func (o ZoneLockdownOutput) ToZoneLockdownOutput() ZoneLockdownOutput {
	return o
}

func (o ZoneLockdownOutput) ToZoneLockdownOutputWithContext(ctx context.Context) ZoneLockdownOutput {
	return o
}

// A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
func (o ZoneLockdownOutput) Configurations() ZoneLockdownConfigurationArrayOutput {
	return o.ApplyT(func(v *ZoneLockdown) ZoneLockdownConfigurationArrayOutput { return v.Configurations }).(ZoneLockdownConfigurationArrayOutput)
}

// The timestamp of when the rule was created.
func (o ZoneLockdownOutput) CreatedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.StringOutput { return v.CreatedOn }).(pulumi.StringOutput)
}

// An informative summary of the rule. This value is sanitized and any tags will be removed.
func (o ZoneLockdownOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The timestamp of when the rule was last modified.
func (o ZoneLockdownOutput) ModifiedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.StringOutput { return v.ModifiedOn }).(pulumi.StringOutput)
}

// When true, indicates that the rule is currently paused.
func (o ZoneLockdownOutput) Paused() pulumi.BoolOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.BoolOutput { return v.Paused }).(pulumi.BoolOutput)
}

// The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
func (o ZoneLockdownOutput) Priority() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.Float64PtrOutput { return v.Priority }).(pulumi.Float64PtrOutput)
}

// The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
func (o ZoneLockdownOutput) Urls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.StringArrayOutput { return v.Urls }).(pulumi.StringArrayOutput)
}

// Defines an identifier.
func (o ZoneLockdownOutput) ZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *ZoneLockdown) pulumi.StringOutput { return v.ZoneId }).(pulumi.StringOutput)
}

type ZoneLockdownArrayOutput struct{ *pulumi.OutputState }

func (ZoneLockdownArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ZoneLockdown)(nil)).Elem()
}

func (o ZoneLockdownArrayOutput) ToZoneLockdownArrayOutput() ZoneLockdownArrayOutput {
	return o
}

func (o ZoneLockdownArrayOutput) ToZoneLockdownArrayOutputWithContext(ctx context.Context) ZoneLockdownArrayOutput {
	return o
}

func (o ZoneLockdownArrayOutput) Index(i pulumi.IntInput) ZoneLockdownOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ZoneLockdown {
		return vs[0].([]*ZoneLockdown)[vs[1].(int)]
	}).(ZoneLockdownOutput)
}

type ZoneLockdownMapOutput struct{ *pulumi.OutputState }

func (ZoneLockdownMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ZoneLockdown)(nil)).Elem()
}

func (o ZoneLockdownMapOutput) ToZoneLockdownMapOutput() ZoneLockdownMapOutput {
	return o
}

func (o ZoneLockdownMapOutput) ToZoneLockdownMapOutputWithContext(ctx context.Context) ZoneLockdownMapOutput {
	return o
}

func (o ZoneLockdownMapOutput) MapIndex(k pulumi.StringInput) ZoneLockdownOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ZoneLockdown {
		return vs[0].(map[string]*ZoneLockdown)[vs[1].(string)]
	}).(ZoneLockdownOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ZoneLockdownInput)(nil)).Elem(), &ZoneLockdown{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZoneLockdownArrayInput)(nil)).Elem(), ZoneLockdownArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZoneLockdownMapInput)(nil)).Elem(), ZoneLockdownMap{})
	pulumi.RegisterOutputType(ZoneLockdownOutput{})
	pulumi.RegisterOutputType(ZoneLockdownArrayOutput{})
	pulumi.RegisterOutputType(ZoneLockdownMapOutput{})
}
