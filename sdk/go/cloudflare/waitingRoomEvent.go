// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cloudflare.NewWaitingRoomEvent(ctx, "example_waiting_room_event", &cloudflare.WaitingRoomEventArgs{
//				ZoneId:                pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
//				WaitingRoomId:         pulumi.String("699d98642c564d2e855e9661899b7252"),
//				EventEndTime:          pulumi.String("2021-09-28T17:00:00.000Z"),
//				EventStartTime:        pulumi.String("2021-09-28T15:30:00.000Z"),
//				Name:                  pulumi.String("production_webinar_event"),
//				CustomPageHtml:        pulumi.String("{{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Event is prequeueing / Queue all enabled {{/waitTimeKnown}}"),
//				Description:           pulumi.String("Production event - DO NOT MODIFY"),
//				DisableSessionRenewal: pulumi.Bool(true),
//				NewUsersPerMinute:     pulumi.Int(200),
//				PrequeueStartTime:     pulumi.String("2021-09-28T15:00:00.000Z"),
//				QueueingMethod:        pulumi.String("random"),
//				SessionDuration:       pulumi.Int(1),
//				ShuffleAtEventStart:   pulumi.Bool(true),
//				Suspended:             pulumi.Bool(true),
//				TotalActiveUsers:      pulumi.Int(200),
//				TurnstileAction:       pulumi.String("log"),
//				TurnstileMode:         pulumi.String("off"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/waitingRoomEvent:WaitingRoomEvent example '<zone_id>/<waiting_room_id>/<event_id>'
// ```
type WaitingRoomEvent struct {
	pulumi.CustomResourceState

	CreatedOn pulumi.StringOutput `pulumi:"createdOn"`
	// If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
	CustomPageHtml pulumi.StringPtrOutput `pulumi:"customPageHtml"`
	// A note that you can use to add more details about the event.
	Description pulumi.StringOutput `pulumi:"description"`
	// If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
	DisableSessionRenewal pulumi.BoolPtrOutput `pulumi:"disableSessionRenewal"`
	// An ISO 8601 timestamp that marks the end of the event.
	EventEndTime pulumi.StringOutput `pulumi:"eventEndTime"`
	// An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
	EventStartTime pulumi.StringOutput `pulumi:"eventStartTime"`
	ModifiedOn     pulumi.StringOutput `pulumi:"modifiedOn"`
	// A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
	Name pulumi.StringOutput `pulumi:"name"`
	// If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
	NewUsersPerMinute pulumi.IntPtrOutput `pulumi:"newUsersPerMinute"`
	// An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
	PrequeueStartTime pulumi.StringPtrOutput `pulumi:"prequeueStartTime"`
	// If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
	QueueingMethod pulumi.StringPtrOutput `pulumi:"queueingMethod"`
	// If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
	SessionDuration pulumi.IntPtrOutput `pulumi:"sessionDuration"`
	// If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
	ShuffleAtEventStart pulumi.BoolOutput `pulumi:"shuffleAtEventStart"`
	// Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
	Suspended pulumi.BoolOutput `pulumi:"suspended"`
	// If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
	TotalActiveUsers pulumi.IntPtrOutput `pulumi:"totalActiveUsers"`
	// If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
	// Available values: "log", "infiniteQueue".
	TurnstileAction pulumi.StringPtrOutput `pulumi:"turnstileAction"`
	// If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
	// Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
	TurnstileMode pulumi.StringPtrOutput `pulumi:"turnstileMode"`
	WaitingRoomId pulumi.StringOutput    `pulumi:"waitingRoomId"`
	// Identifier
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewWaitingRoomEvent registers a new resource with the given unique name, arguments, and options.
func NewWaitingRoomEvent(ctx *pulumi.Context,
	name string, args *WaitingRoomEventArgs, opts ...pulumi.ResourceOption) (*WaitingRoomEvent, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EventEndTime == nil {
		return nil, errors.New("invalid value for required argument 'EventEndTime'")
	}
	if args.EventStartTime == nil {
		return nil, errors.New("invalid value for required argument 'EventStartTime'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.WaitingRoomId == nil {
		return nil, errors.New("invalid value for required argument 'WaitingRoomId'")
	}
	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource WaitingRoomEvent
	err := ctx.RegisterResource("cloudflare:index/waitingRoomEvent:WaitingRoomEvent", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetWaitingRoomEvent gets an existing WaitingRoomEvent resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetWaitingRoomEvent(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *WaitingRoomEventState, opts ...pulumi.ResourceOption) (*WaitingRoomEvent, error) {
	var resource WaitingRoomEvent
	err := ctx.ReadResource("cloudflare:index/waitingRoomEvent:WaitingRoomEvent", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering WaitingRoomEvent resources.
type waitingRoomEventState struct {
	CreatedOn *string `pulumi:"createdOn"`
	// If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
	CustomPageHtml *string `pulumi:"customPageHtml"`
	// A note that you can use to add more details about the event.
	Description *string `pulumi:"description"`
	// If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
	DisableSessionRenewal *bool `pulumi:"disableSessionRenewal"`
	// An ISO 8601 timestamp that marks the end of the event.
	EventEndTime *string `pulumi:"eventEndTime"`
	// An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
	EventStartTime *string `pulumi:"eventStartTime"`
	ModifiedOn     *string `pulumi:"modifiedOn"`
	// A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
	Name *string `pulumi:"name"`
	// If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
	NewUsersPerMinute *int `pulumi:"newUsersPerMinute"`
	// An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
	PrequeueStartTime *string `pulumi:"prequeueStartTime"`
	// If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
	QueueingMethod *string `pulumi:"queueingMethod"`
	// If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
	SessionDuration *int `pulumi:"sessionDuration"`
	// If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
	ShuffleAtEventStart *bool `pulumi:"shuffleAtEventStart"`
	// Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
	Suspended *bool `pulumi:"suspended"`
	// If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
	TotalActiveUsers *int `pulumi:"totalActiveUsers"`
	// If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
	// Available values: "log", "infiniteQueue".
	TurnstileAction *string `pulumi:"turnstileAction"`
	// If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
	// Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
	TurnstileMode *string `pulumi:"turnstileMode"`
	WaitingRoomId *string `pulumi:"waitingRoomId"`
	// Identifier
	ZoneId *string `pulumi:"zoneId"`
}

type WaitingRoomEventState struct {
	CreatedOn pulumi.StringPtrInput
	// If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
	CustomPageHtml pulumi.StringPtrInput
	// A note that you can use to add more details about the event.
	Description pulumi.StringPtrInput
	// If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
	DisableSessionRenewal pulumi.BoolPtrInput
	// An ISO 8601 timestamp that marks the end of the event.
	EventEndTime pulumi.StringPtrInput
	// An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
	EventStartTime pulumi.StringPtrInput
	ModifiedOn     pulumi.StringPtrInput
	// A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
	Name pulumi.StringPtrInput
	// If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
	NewUsersPerMinute pulumi.IntPtrInput
	// An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
	PrequeueStartTime pulumi.StringPtrInput
	// If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
	QueueingMethod pulumi.StringPtrInput
	// If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
	SessionDuration pulumi.IntPtrInput
	// If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
	ShuffleAtEventStart pulumi.BoolPtrInput
	// Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
	Suspended pulumi.BoolPtrInput
	// If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
	TotalActiveUsers pulumi.IntPtrInput
	// If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
	// Available values: "log", "infiniteQueue".
	TurnstileAction pulumi.StringPtrInput
	// If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
	// Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
	TurnstileMode pulumi.StringPtrInput
	WaitingRoomId pulumi.StringPtrInput
	// Identifier
	ZoneId pulumi.StringPtrInput
}

func (WaitingRoomEventState) ElementType() reflect.Type {
	return reflect.TypeOf((*waitingRoomEventState)(nil)).Elem()
}

type waitingRoomEventArgs struct {
	// If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
	CustomPageHtml *string `pulumi:"customPageHtml"`
	// A note that you can use to add more details about the event.
	Description *string `pulumi:"description"`
	// If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
	DisableSessionRenewal *bool `pulumi:"disableSessionRenewal"`
	// An ISO 8601 timestamp that marks the end of the event.
	EventEndTime string `pulumi:"eventEndTime"`
	// An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
	EventStartTime string `pulumi:"eventStartTime"`
	// A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
	Name string `pulumi:"name"`
	// If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
	NewUsersPerMinute *int `pulumi:"newUsersPerMinute"`
	// An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
	PrequeueStartTime *string `pulumi:"prequeueStartTime"`
	// If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
	QueueingMethod *string `pulumi:"queueingMethod"`
	// If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
	SessionDuration *int `pulumi:"sessionDuration"`
	// If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
	ShuffleAtEventStart *bool `pulumi:"shuffleAtEventStart"`
	// Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
	Suspended *bool `pulumi:"suspended"`
	// If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
	TotalActiveUsers *int `pulumi:"totalActiveUsers"`
	// If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
	// Available values: "log", "infiniteQueue".
	TurnstileAction *string `pulumi:"turnstileAction"`
	// If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
	// Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
	TurnstileMode *string `pulumi:"turnstileMode"`
	WaitingRoomId string  `pulumi:"waitingRoomId"`
	// Identifier
	ZoneId string `pulumi:"zoneId"`
}

// The set of arguments for constructing a WaitingRoomEvent resource.
type WaitingRoomEventArgs struct {
	// If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
	CustomPageHtml pulumi.StringPtrInput
	// A note that you can use to add more details about the event.
	Description pulumi.StringPtrInput
	// If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
	DisableSessionRenewal pulumi.BoolPtrInput
	// An ISO 8601 timestamp that marks the end of the event.
	EventEndTime pulumi.StringInput
	// An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
	EventStartTime pulumi.StringInput
	// A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
	Name pulumi.StringInput
	// If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
	NewUsersPerMinute pulumi.IntPtrInput
	// An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
	PrequeueStartTime pulumi.StringPtrInput
	// If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
	QueueingMethod pulumi.StringPtrInput
	// If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
	SessionDuration pulumi.IntPtrInput
	// If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
	ShuffleAtEventStart pulumi.BoolPtrInput
	// Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
	Suspended pulumi.BoolPtrInput
	// If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
	TotalActiveUsers pulumi.IntPtrInput
	// If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
	// Available values: "log", "infiniteQueue".
	TurnstileAction pulumi.StringPtrInput
	// If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
	// Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
	TurnstileMode pulumi.StringPtrInput
	WaitingRoomId pulumi.StringInput
	// Identifier
	ZoneId pulumi.StringInput
}

func (WaitingRoomEventArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*waitingRoomEventArgs)(nil)).Elem()
}

type WaitingRoomEventInput interface {
	pulumi.Input

	ToWaitingRoomEventOutput() WaitingRoomEventOutput
	ToWaitingRoomEventOutputWithContext(ctx context.Context) WaitingRoomEventOutput
}

func (*WaitingRoomEvent) ElementType() reflect.Type {
	return reflect.TypeOf((**WaitingRoomEvent)(nil)).Elem()
}

func (i *WaitingRoomEvent) ToWaitingRoomEventOutput() WaitingRoomEventOutput {
	return i.ToWaitingRoomEventOutputWithContext(context.Background())
}

func (i *WaitingRoomEvent) ToWaitingRoomEventOutputWithContext(ctx context.Context) WaitingRoomEventOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WaitingRoomEventOutput)
}

// WaitingRoomEventArrayInput is an input type that accepts WaitingRoomEventArray and WaitingRoomEventArrayOutput values.
// You can construct a concrete instance of `WaitingRoomEventArrayInput` via:
//
//	WaitingRoomEventArray{ WaitingRoomEventArgs{...} }
type WaitingRoomEventArrayInput interface {
	pulumi.Input

	ToWaitingRoomEventArrayOutput() WaitingRoomEventArrayOutput
	ToWaitingRoomEventArrayOutputWithContext(context.Context) WaitingRoomEventArrayOutput
}

type WaitingRoomEventArray []WaitingRoomEventInput

func (WaitingRoomEventArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*WaitingRoomEvent)(nil)).Elem()
}

func (i WaitingRoomEventArray) ToWaitingRoomEventArrayOutput() WaitingRoomEventArrayOutput {
	return i.ToWaitingRoomEventArrayOutputWithContext(context.Background())
}

func (i WaitingRoomEventArray) ToWaitingRoomEventArrayOutputWithContext(ctx context.Context) WaitingRoomEventArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WaitingRoomEventArrayOutput)
}

// WaitingRoomEventMapInput is an input type that accepts WaitingRoomEventMap and WaitingRoomEventMapOutput values.
// You can construct a concrete instance of `WaitingRoomEventMapInput` via:
//
//	WaitingRoomEventMap{ "key": WaitingRoomEventArgs{...} }
type WaitingRoomEventMapInput interface {
	pulumi.Input

	ToWaitingRoomEventMapOutput() WaitingRoomEventMapOutput
	ToWaitingRoomEventMapOutputWithContext(context.Context) WaitingRoomEventMapOutput
}

type WaitingRoomEventMap map[string]WaitingRoomEventInput

func (WaitingRoomEventMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*WaitingRoomEvent)(nil)).Elem()
}

func (i WaitingRoomEventMap) ToWaitingRoomEventMapOutput() WaitingRoomEventMapOutput {
	return i.ToWaitingRoomEventMapOutputWithContext(context.Background())
}

func (i WaitingRoomEventMap) ToWaitingRoomEventMapOutputWithContext(ctx context.Context) WaitingRoomEventMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WaitingRoomEventMapOutput)
}

type WaitingRoomEventOutput struct{ *pulumi.OutputState }

func (WaitingRoomEventOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WaitingRoomEvent)(nil)).Elem()
}

func (o WaitingRoomEventOutput) ToWaitingRoomEventOutput() WaitingRoomEventOutput {
	return o
}

func (o WaitingRoomEventOutput) ToWaitingRoomEventOutputWithContext(ctx context.Context) WaitingRoomEventOutput {
	return o
}

func (o WaitingRoomEventOutput) CreatedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.CreatedOn }).(pulumi.StringOutput)
}

// If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
func (o WaitingRoomEventOutput) CustomPageHtml() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringPtrOutput { return v.CustomPageHtml }).(pulumi.StringPtrOutput)
}

// A note that you can use to add more details about the event.
func (o WaitingRoomEventOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
func (o WaitingRoomEventOutput) DisableSessionRenewal() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.BoolPtrOutput { return v.DisableSessionRenewal }).(pulumi.BoolPtrOutput)
}

// An ISO 8601 timestamp that marks the end of the event.
func (o WaitingRoomEventOutput) EventEndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.EventEndTime }).(pulumi.StringOutput)
}

// An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
func (o WaitingRoomEventOutput) EventStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.EventStartTime }).(pulumi.StringOutput)
}

func (o WaitingRoomEventOutput) ModifiedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.ModifiedOn }).(pulumi.StringOutput)
}

// A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
func (o WaitingRoomEventOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
func (o WaitingRoomEventOutput) NewUsersPerMinute() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.IntPtrOutput { return v.NewUsersPerMinute }).(pulumi.IntPtrOutput)
}

// An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
func (o WaitingRoomEventOutput) PrequeueStartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringPtrOutput { return v.PrequeueStartTime }).(pulumi.StringPtrOutput)
}

// If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
func (o WaitingRoomEventOutput) QueueingMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringPtrOutput { return v.QueueingMethod }).(pulumi.StringPtrOutput)
}

// If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
func (o WaitingRoomEventOutput) SessionDuration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.IntPtrOutput { return v.SessionDuration }).(pulumi.IntPtrOutput)
}

// If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
func (o WaitingRoomEventOutput) ShuffleAtEventStart() pulumi.BoolOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.BoolOutput { return v.ShuffleAtEventStart }).(pulumi.BoolOutput)
}

// Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
func (o WaitingRoomEventOutput) Suspended() pulumi.BoolOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.BoolOutput { return v.Suspended }).(pulumi.BoolOutput)
}

// If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
func (o WaitingRoomEventOutput) TotalActiveUsers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.IntPtrOutput { return v.TotalActiveUsers }).(pulumi.IntPtrOutput)
}

// If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
// Available values: "log", "infiniteQueue".
func (o WaitingRoomEventOutput) TurnstileAction() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringPtrOutput { return v.TurnstileAction }).(pulumi.StringPtrOutput)
}

// If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
// Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
func (o WaitingRoomEventOutput) TurnstileMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringPtrOutput { return v.TurnstileMode }).(pulumi.StringPtrOutput)
}

func (o WaitingRoomEventOutput) WaitingRoomId() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.WaitingRoomId }).(pulumi.StringOutput)
}

// Identifier
func (o WaitingRoomEventOutput) ZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *WaitingRoomEvent) pulumi.StringOutput { return v.ZoneId }).(pulumi.StringOutput)
}

type WaitingRoomEventArrayOutput struct{ *pulumi.OutputState }

func (WaitingRoomEventArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*WaitingRoomEvent)(nil)).Elem()
}

func (o WaitingRoomEventArrayOutput) ToWaitingRoomEventArrayOutput() WaitingRoomEventArrayOutput {
	return o
}

func (o WaitingRoomEventArrayOutput) ToWaitingRoomEventArrayOutputWithContext(ctx context.Context) WaitingRoomEventArrayOutput {
	return o
}

func (o WaitingRoomEventArrayOutput) Index(i pulumi.IntInput) WaitingRoomEventOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *WaitingRoomEvent {
		return vs[0].([]*WaitingRoomEvent)[vs[1].(int)]
	}).(WaitingRoomEventOutput)
}

type WaitingRoomEventMapOutput struct{ *pulumi.OutputState }

func (WaitingRoomEventMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*WaitingRoomEvent)(nil)).Elem()
}

func (o WaitingRoomEventMapOutput) ToWaitingRoomEventMapOutput() WaitingRoomEventMapOutput {
	return o
}

func (o WaitingRoomEventMapOutput) ToWaitingRoomEventMapOutputWithContext(ctx context.Context) WaitingRoomEventMapOutput {
	return o
}

func (o WaitingRoomEventMapOutput) MapIndex(k pulumi.StringInput) WaitingRoomEventOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *WaitingRoomEvent {
		return vs[0].(map[string]*WaitingRoomEvent)[vs[1].(string)]
	}).(WaitingRoomEventOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*WaitingRoomEventInput)(nil)).Elem(), &WaitingRoomEvent{})
	pulumi.RegisterInputType(reflect.TypeOf((*WaitingRoomEventArrayInput)(nil)).Elem(), WaitingRoomEventArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WaitingRoomEventMapInput)(nil)).Elem(), WaitingRoomEventMap{})
	pulumi.RegisterOutputType(WaitingRoomEventOutput{})
	pulumi.RegisterOutputType(WaitingRoomEventArrayOutput{})
	pulumi.RegisterOutputType(WaitingRoomEventMapOutput{})
}
