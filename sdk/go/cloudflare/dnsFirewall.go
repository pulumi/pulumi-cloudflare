// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudflare

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-cloudflare/sdk/v6/go/cloudflare/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ## Import
//
// ```sh
// $ pulumi import cloudflare:index/dnsFirewall:DnsFirewall example '<account_id>/<dns_firewall_id>'
// ```
type DnsFirewall struct {
	pulumi.CustomResourceState

	// Identifier.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Attack mitigation settings
	AttackMitigation DnsFirewallAttackMitigationOutput `pulumi:"attackMitigation"`
	// Whether to refuse to answer queries for the ANY type
	DeprecateAnyRequests pulumi.BoolPtrOutput     `pulumi:"deprecateAnyRequests"`
	DnsFirewallIps       pulumi.StringArrayOutput `pulumi:"dnsFirewallIps"`
	// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
	EcsFallback pulumi.BoolPtrOutput `pulumi:"ecsFallback"`
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets an upper bound on this duration. For caching purposes, higher TTLs
	// will be decreased to the maximum value defined by this setting.
	MaximumCacheTtl pulumi.Float64Output `pulumi:"maximumCacheTtl"`
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets a lower bound on this duration. For caching purposes, lower TTLs
	// will be increased to the minimum value defined by this setting.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	//
	// Note that, even with this setting, there is no guarantee that a
	// response will be cached for at least the specified duration. Cached
	// responses may be removed earlier for capacity or other operational
	// reasons.
	MinimumCacheTtl pulumi.Float64Output `pulumi:"minimumCacheTtl"`
	// Last modification of DNS Firewall cluster
	ModifiedOn pulumi.StringOutput `pulumi:"modifiedOn"`
	// DNS Firewall cluster name
	Name pulumi.StringOutput `pulumi:"name"`
	// This setting controls how long DNS Firewall should cache negative
	// responses (e.g., NXDOMAIN) from the upstream servers.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	NegativeCacheTtl pulumi.Float64PtrOutput `pulumi:"negativeCacheTtl"`
	// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
	Ratelimit pulumi.Float64PtrOutput `pulumi:"ratelimit"`
	// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
	Retries     pulumi.Float64Output     `pulumi:"retries"`
	UpstreamIps pulumi.StringArrayOutput `pulumi:"upstreamIps"`
}

// NewDnsFirewall registers a new resource with the given unique name, arguments, and options.
func NewDnsFirewall(ctx *pulumi.Context,
	name string, args *DnsFirewallArgs, opts ...pulumi.ResourceOption) (*DnsFirewall, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.UpstreamIps == nil {
		return nil, errors.New("invalid value for required argument 'UpstreamIps'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DnsFirewall
	err := ctx.RegisterResource("cloudflare:index/dnsFirewall:DnsFirewall", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDnsFirewall gets an existing DnsFirewall resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDnsFirewall(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DnsFirewallState, opts ...pulumi.ResourceOption) (*DnsFirewall, error) {
	var resource DnsFirewall
	err := ctx.ReadResource("cloudflare:index/dnsFirewall:DnsFirewall", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DnsFirewall resources.
type dnsFirewallState struct {
	// Identifier.
	AccountId *string `pulumi:"accountId"`
	// Attack mitigation settings
	AttackMitigation *DnsFirewallAttackMitigation `pulumi:"attackMitigation"`
	// Whether to refuse to answer queries for the ANY type
	DeprecateAnyRequests *bool    `pulumi:"deprecateAnyRequests"`
	DnsFirewallIps       []string `pulumi:"dnsFirewallIps"`
	// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
	EcsFallback *bool `pulumi:"ecsFallback"`
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets an upper bound on this duration. For caching purposes, higher TTLs
	// will be decreased to the maximum value defined by this setting.
	MaximumCacheTtl *float64 `pulumi:"maximumCacheTtl"`
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets a lower bound on this duration. For caching purposes, lower TTLs
	// will be increased to the minimum value defined by this setting.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	//
	// Note that, even with this setting, there is no guarantee that a
	// response will be cached for at least the specified duration. Cached
	// responses may be removed earlier for capacity or other operational
	// reasons.
	MinimumCacheTtl *float64 `pulumi:"minimumCacheTtl"`
	// Last modification of DNS Firewall cluster
	ModifiedOn *string `pulumi:"modifiedOn"`
	// DNS Firewall cluster name
	Name *string `pulumi:"name"`
	// This setting controls how long DNS Firewall should cache negative
	// responses (e.g., NXDOMAIN) from the upstream servers.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	NegativeCacheTtl *float64 `pulumi:"negativeCacheTtl"`
	// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
	Ratelimit *float64 `pulumi:"ratelimit"`
	// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
	Retries     *float64 `pulumi:"retries"`
	UpstreamIps []string `pulumi:"upstreamIps"`
}

type DnsFirewallState struct {
	// Identifier.
	AccountId pulumi.StringPtrInput
	// Attack mitigation settings
	AttackMitigation DnsFirewallAttackMitigationPtrInput
	// Whether to refuse to answer queries for the ANY type
	DeprecateAnyRequests pulumi.BoolPtrInput
	DnsFirewallIps       pulumi.StringArrayInput
	// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
	EcsFallback pulumi.BoolPtrInput
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets an upper bound on this duration. For caching purposes, higher TTLs
	// will be decreased to the maximum value defined by this setting.
	MaximumCacheTtl pulumi.Float64PtrInput
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets a lower bound on this duration. For caching purposes, lower TTLs
	// will be increased to the minimum value defined by this setting.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	//
	// Note that, even with this setting, there is no guarantee that a
	// response will be cached for at least the specified duration. Cached
	// responses may be removed earlier for capacity or other operational
	// reasons.
	MinimumCacheTtl pulumi.Float64PtrInput
	// Last modification of DNS Firewall cluster
	ModifiedOn pulumi.StringPtrInput
	// DNS Firewall cluster name
	Name pulumi.StringPtrInput
	// This setting controls how long DNS Firewall should cache negative
	// responses (e.g., NXDOMAIN) from the upstream servers.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	NegativeCacheTtl pulumi.Float64PtrInput
	// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
	Ratelimit pulumi.Float64PtrInput
	// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
	Retries     pulumi.Float64PtrInput
	UpstreamIps pulumi.StringArrayInput
}

func (DnsFirewallState) ElementType() reflect.Type {
	return reflect.TypeOf((*dnsFirewallState)(nil)).Elem()
}

type dnsFirewallArgs struct {
	// Identifier.
	AccountId string `pulumi:"accountId"`
	// Attack mitigation settings
	AttackMitigation *DnsFirewallAttackMitigation `pulumi:"attackMitigation"`
	// Whether to refuse to answer queries for the ANY type
	DeprecateAnyRequests *bool `pulumi:"deprecateAnyRequests"`
	// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
	EcsFallback *bool `pulumi:"ecsFallback"`
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets an upper bound on this duration. For caching purposes, higher TTLs
	// will be decreased to the maximum value defined by this setting.
	MaximumCacheTtl *float64 `pulumi:"maximumCacheTtl"`
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets a lower bound on this duration. For caching purposes, lower TTLs
	// will be increased to the minimum value defined by this setting.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	//
	// Note that, even with this setting, there is no guarantee that a
	// response will be cached for at least the specified duration. Cached
	// responses may be removed earlier for capacity or other operational
	// reasons.
	MinimumCacheTtl *float64 `pulumi:"minimumCacheTtl"`
	// DNS Firewall cluster name
	Name string `pulumi:"name"`
	// This setting controls how long DNS Firewall should cache negative
	// responses (e.g., NXDOMAIN) from the upstream servers.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	NegativeCacheTtl *float64 `pulumi:"negativeCacheTtl"`
	// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
	Ratelimit *float64 `pulumi:"ratelimit"`
	// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
	Retries     *float64 `pulumi:"retries"`
	UpstreamIps []string `pulumi:"upstreamIps"`
}

// The set of arguments for constructing a DnsFirewall resource.
type DnsFirewallArgs struct {
	// Identifier.
	AccountId pulumi.StringInput
	// Attack mitigation settings
	AttackMitigation DnsFirewallAttackMitigationPtrInput
	// Whether to refuse to answer queries for the ANY type
	DeprecateAnyRequests pulumi.BoolPtrInput
	// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
	EcsFallback pulumi.BoolPtrInput
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets an upper bound on this duration. For caching purposes, higher TTLs
	// will be decreased to the maximum value defined by this setting.
	MaximumCacheTtl pulumi.Float64PtrInput
	// By default, Cloudflare attempts to cache responses for as long as
	// indicated by the TTL received from upstream nameservers. This setting
	// sets a lower bound on this duration. For caching purposes, lower TTLs
	// will be increased to the minimum value defined by this setting.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	//
	// Note that, even with this setting, there is no guarantee that a
	// response will be cached for at least the specified duration. Cached
	// responses may be removed earlier for capacity or other operational
	// reasons.
	MinimumCacheTtl pulumi.Float64PtrInput
	// DNS Firewall cluster name
	Name pulumi.StringInput
	// This setting controls how long DNS Firewall should cache negative
	// responses (e.g., NXDOMAIN) from the upstream servers.
	//
	// This setting does not affect the TTL value in the DNS response
	// Cloudflare returns to clients. Cloudflare will always forward the TTL
	// value received from upstream nameservers.
	NegativeCacheTtl pulumi.Float64PtrInput
	// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
	Ratelimit pulumi.Float64PtrInput
	// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
	Retries     pulumi.Float64PtrInput
	UpstreamIps pulumi.StringArrayInput
}

func (DnsFirewallArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dnsFirewallArgs)(nil)).Elem()
}

type DnsFirewallInput interface {
	pulumi.Input

	ToDnsFirewallOutput() DnsFirewallOutput
	ToDnsFirewallOutputWithContext(ctx context.Context) DnsFirewallOutput
}

func (*DnsFirewall) ElementType() reflect.Type {
	return reflect.TypeOf((**DnsFirewall)(nil)).Elem()
}

func (i *DnsFirewall) ToDnsFirewallOutput() DnsFirewallOutput {
	return i.ToDnsFirewallOutputWithContext(context.Background())
}

func (i *DnsFirewall) ToDnsFirewallOutputWithContext(ctx context.Context) DnsFirewallOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsFirewallOutput)
}

// DnsFirewallArrayInput is an input type that accepts DnsFirewallArray and DnsFirewallArrayOutput values.
// You can construct a concrete instance of `DnsFirewallArrayInput` via:
//
//	DnsFirewallArray{ DnsFirewallArgs{...} }
type DnsFirewallArrayInput interface {
	pulumi.Input

	ToDnsFirewallArrayOutput() DnsFirewallArrayOutput
	ToDnsFirewallArrayOutputWithContext(context.Context) DnsFirewallArrayOutput
}

type DnsFirewallArray []DnsFirewallInput

func (DnsFirewallArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DnsFirewall)(nil)).Elem()
}

func (i DnsFirewallArray) ToDnsFirewallArrayOutput() DnsFirewallArrayOutput {
	return i.ToDnsFirewallArrayOutputWithContext(context.Background())
}

func (i DnsFirewallArray) ToDnsFirewallArrayOutputWithContext(ctx context.Context) DnsFirewallArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsFirewallArrayOutput)
}

// DnsFirewallMapInput is an input type that accepts DnsFirewallMap and DnsFirewallMapOutput values.
// You can construct a concrete instance of `DnsFirewallMapInput` via:
//
//	DnsFirewallMap{ "key": DnsFirewallArgs{...} }
type DnsFirewallMapInput interface {
	pulumi.Input

	ToDnsFirewallMapOutput() DnsFirewallMapOutput
	ToDnsFirewallMapOutputWithContext(context.Context) DnsFirewallMapOutput
}

type DnsFirewallMap map[string]DnsFirewallInput

func (DnsFirewallMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DnsFirewall)(nil)).Elem()
}

func (i DnsFirewallMap) ToDnsFirewallMapOutput() DnsFirewallMapOutput {
	return i.ToDnsFirewallMapOutputWithContext(context.Background())
}

func (i DnsFirewallMap) ToDnsFirewallMapOutputWithContext(ctx context.Context) DnsFirewallMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DnsFirewallMapOutput)
}

type DnsFirewallOutput struct{ *pulumi.OutputState }

func (DnsFirewallOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DnsFirewall)(nil)).Elem()
}

func (o DnsFirewallOutput) ToDnsFirewallOutput() DnsFirewallOutput {
	return o
}

func (o DnsFirewallOutput) ToDnsFirewallOutputWithContext(ctx context.Context) DnsFirewallOutput {
	return o
}

// Identifier.
func (o DnsFirewallOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Attack mitigation settings
func (o DnsFirewallOutput) AttackMitigation() DnsFirewallAttackMitigationOutput {
	return o.ApplyT(func(v *DnsFirewall) DnsFirewallAttackMitigationOutput { return v.AttackMitigation }).(DnsFirewallAttackMitigationOutput)
}

// Whether to refuse to answer queries for the ANY type
func (o DnsFirewallOutput) DeprecateAnyRequests() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.BoolPtrOutput { return v.DeprecateAnyRequests }).(pulumi.BoolPtrOutput)
}

func (o DnsFirewallOutput) DnsFirewallIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.StringArrayOutput { return v.DnsFirewallIps }).(pulumi.StringArrayOutput)
}

// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
func (o DnsFirewallOutput) EcsFallback() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.BoolPtrOutput { return v.EcsFallback }).(pulumi.BoolPtrOutput)
}

// By default, Cloudflare attempts to cache responses for as long as
// indicated by the TTL received from upstream nameservers. This setting
// sets an upper bound on this duration. For caching purposes, higher TTLs
// will be decreased to the maximum value defined by this setting.
func (o DnsFirewallOutput) MaximumCacheTtl() pulumi.Float64Output {
	return o.ApplyT(func(v *DnsFirewall) pulumi.Float64Output { return v.MaximumCacheTtl }).(pulumi.Float64Output)
}

// By default, Cloudflare attempts to cache responses for as long as
// indicated by the TTL received from upstream nameservers. This setting
// sets a lower bound on this duration. For caching purposes, lower TTLs
// will be increased to the minimum value defined by this setting.
//
// This setting does not affect the TTL value in the DNS response
// Cloudflare returns to clients. Cloudflare will always forward the TTL
// value received from upstream nameservers.
//
// Note that, even with this setting, there is no guarantee that a
// response will be cached for at least the specified duration. Cached
// responses may be removed earlier for capacity or other operational
// reasons.
func (o DnsFirewallOutput) MinimumCacheTtl() pulumi.Float64Output {
	return o.ApplyT(func(v *DnsFirewall) pulumi.Float64Output { return v.MinimumCacheTtl }).(pulumi.Float64Output)
}

// Last modification of DNS Firewall cluster
func (o DnsFirewallOutput) ModifiedOn() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.StringOutput { return v.ModifiedOn }).(pulumi.StringOutput)
}

// DNS Firewall cluster name
func (o DnsFirewallOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// This setting controls how long DNS Firewall should cache negative
// responses (e.g., NXDOMAIN) from the upstream servers.
//
// This setting does not affect the TTL value in the DNS response
// Cloudflare returns to clients. Cloudflare will always forward the TTL
// value received from upstream nameservers.
func (o DnsFirewallOutput) NegativeCacheTtl() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.Float64PtrOutput { return v.NegativeCacheTtl }).(pulumi.Float64PtrOutput)
}

// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
func (o DnsFirewallOutput) Ratelimit() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.Float64PtrOutput { return v.Ratelimit }).(pulumi.Float64PtrOutput)
}

// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
func (o DnsFirewallOutput) Retries() pulumi.Float64Output {
	return o.ApplyT(func(v *DnsFirewall) pulumi.Float64Output { return v.Retries }).(pulumi.Float64Output)
}

func (o DnsFirewallOutput) UpstreamIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DnsFirewall) pulumi.StringArrayOutput { return v.UpstreamIps }).(pulumi.StringArrayOutput)
}

type DnsFirewallArrayOutput struct{ *pulumi.OutputState }

func (DnsFirewallArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DnsFirewall)(nil)).Elem()
}

func (o DnsFirewallArrayOutput) ToDnsFirewallArrayOutput() DnsFirewallArrayOutput {
	return o
}

func (o DnsFirewallArrayOutput) ToDnsFirewallArrayOutputWithContext(ctx context.Context) DnsFirewallArrayOutput {
	return o
}

func (o DnsFirewallArrayOutput) Index(i pulumi.IntInput) DnsFirewallOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DnsFirewall {
		return vs[0].([]*DnsFirewall)[vs[1].(int)]
	}).(DnsFirewallOutput)
}

type DnsFirewallMapOutput struct{ *pulumi.OutputState }

func (DnsFirewallMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DnsFirewall)(nil)).Elem()
}

func (o DnsFirewallMapOutput) ToDnsFirewallMapOutput() DnsFirewallMapOutput {
	return o
}

func (o DnsFirewallMapOutput) ToDnsFirewallMapOutputWithContext(ctx context.Context) DnsFirewallMapOutput {
	return o
}

func (o DnsFirewallMapOutput) MapIndex(k pulumi.StringInput) DnsFirewallOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DnsFirewall {
		return vs[0].(map[string]*DnsFirewall)[vs[1].(string)]
	}).(DnsFirewallOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DnsFirewallInput)(nil)).Elem(), &DnsFirewall{})
	pulumi.RegisterInputType(reflect.TypeOf((*DnsFirewallArrayInput)(nil)).Elem(), DnsFirewallArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DnsFirewallMapInput)(nil)).Elem(), DnsFirewallMap{})
	pulumi.RegisterOutputType(DnsFirewallOutput{})
	pulumi.RegisterOutputType(DnsFirewallArrayOutput{})
	pulumi.RegisterOutputType(DnsFirewallMapOutput{})
}
