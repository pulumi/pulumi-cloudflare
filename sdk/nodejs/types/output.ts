// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface AccessApplicationCorsHeader {
    /**
     * Value to determine whether all HTTP headers are exposed.
     */
    allowAllHeaders?: boolean;
    /**
     * Value to determine whether all methods are exposed.
     */
    allowAllMethods?: boolean;
    /**
     * Value to determine whether all origins are permitted to make CORS requests.
     */
    allowAllOrigins?: boolean;
    /**
     * Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
     */
    allowCredentials?: boolean;
    /**
     * List of HTTP headers to expose via CORS.
     */
    allowedHeaders?: string[];
    /**
     * List of methods to expose via CORS.
     */
    allowedMethods?: string[];
    /**
     * List of origins permitted to make CORS requests.
     */
    allowedOrigins?: string[];
    /**
     * The maximum time a preflight request will be cached.
     */
    maxAge?: number;
}

export interface AccessApplicationSaasApp {
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: string;
    /**
     * The format of the name identifier sent to the SaaS application. Defaults to `email`.
     */
    nameIdFormat?: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: string;
}

export interface AccessGroupExclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessGroupExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupExcludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupExcludeGsuite[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupExcludeOkta[];
    samls?: outputs.AccessGroupExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupExcludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessGroupExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupInclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessGroupIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupIncludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupIncludeGsuite[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupIncludeOkta[];
    samls?: outputs.AccessGroupIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupIncludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessGroupIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupRequire {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessGroupRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupRequireExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupRequireGsuite[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupRequireOkta[];
    samls?: outputs.AccessGroupRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupRequireAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessGroupRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessIdentityProviderConfig {
    apiToken?: string;
    appsDomain?: string;
    attributes?: string[];
    authUrl?: string;
    centrifyAccount?: string;
    centrifyAppId?: string;
    certsUrl?: string;
    clientId?: string;
    clientSecret?: string;
    directoryId?: string;
    emailAttributeName?: string;
    idpPublicCert?: string;
    issuerUrl?: string;
    oktaAccount?: string;
    oneloginAccount?: string;
    pkceEnabled?: boolean;
    redirectUrl: string;
    signRequest?: boolean;
    ssoTargetUrl?: string;
    supportGroups?: boolean;
    tokenUrl?: string;
}

export interface AccessPolicyApprovalGroup {
    /**
     * Number of approvals needed.
     */
    approvalsNeeded: number;
    /**
     * List of emails to request approval from.
     */
    emailAddresses?: string[];
    emailListUuid?: string;
}

export interface AccessPolicyExclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessPolicyExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyExcludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyExcludeGsuite[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyExcludeOkta[];
    samls?: outputs.AccessPolicyExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyExcludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessPolicyExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyExcludeGithub {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    name?: string;
    teams?: string[];
}

export interface AccessPolicyExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyExcludeOkta {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    names?: string[];
}

export interface AccessPolicyExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyInclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessPolicyIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyIncludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyIncludeGsuite[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyIncludeOkta[];
    samls?: outputs.AccessPolicyIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyIncludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessPolicyIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyIncludeGithub {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    name?: string;
    teams?: string[];
}

export interface AccessPolicyIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyIncludeOkta {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    names?: string[];
}

export interface AccessPolicyIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyRequire {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessPolicyRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyRequireExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyRequireGsuite[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyRequireOkta[];
    samls?: outputs.AccessPolicyRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyRequireAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessPolicyRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyRequireGithub {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    name?: string;
    teams?: string[];
}

export interface AccessPolicyRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyRequireOkta {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    names?: string[];
}

export interface AccessPolicyRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessRuleConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ip6`, `ipRange`, `asn`, `country`.
     */
    target: string;
    /**
     * The value to target. Depends on target's type.
     */
    value: string;
}

export interface ApiTokenCondition {
    /**
     * Request IP related conditions.
     */
    requestIp?: outputs.ApiTokenConditionRequestIp;
}

export interface ApiTokenConditionRequestIp {
    ins?: string[];
    notIns?: string[];
}

export interface ApiTokenPolicy {
    /**
     * Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
     */
    effect?: string;
    /**
     * List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
     */
    permissionGroups: string[];
    /**
     * Describes what operations against which resources are allowed or denied.
     */
    resources: {[key: string]: string};
}

export interface CertificatePackValidationError {
    message: string;
}

export interface CertificatePackValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomHostnameSsl {
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate?: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: string;
    /**
     * Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     */
    method?: string;
    /**
     * SSL/TLS settings for the certificate.
     */
    settings: outputs.CustomHostnameSslSetting[];
    /**
     * Status of the certificate.
     */
    status: string;
    /**
     * Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     */
    type?: string;
    validationErrors: outputs.CustomHostnameSslValidationError[];
    validationRecords: outputs.CustomHostnameSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: boolean;
}

export interface CustomHostnameSslSetting {
    ciphers?: string[];
    earlyHints?: string;
    http2?: string;
    minTlsVersion?: string;
    tls13?: string;
}

export interface CustomHostnameSslValidationError {
    message: string;
}

export interface CustomHostnameSslValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomSslCustomSslOptions {
    /**
     * Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
     */
    bundleMethod?: string;
    /**
     * Certificate certificate and the intermediate(s)
     */
    certificate?: string;
    /**
     * Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highestSecurity`.
     */
    geoRestrictions?: string;
    /**
     * Certificate's private key
     */
    privateKey?: string;
    /**
     * Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacyCustom` (default), `sniCustom`.
     */
    type?: string;
}

export interface CustomSslCustomSslPriority {
    id?: string;
    priority?: number;
}

export interface DevicePostureIntegrationConfig {
    /**
     * The third-party API's URL.
     */
    apiUrl?: string;
    /**
     * The third-party authorization API URL.
     */
    authUrl?: string;
    /**
     * The client identifier for authenticating API calls.
     */
    clientId?: string;
    /**
     * The client key for authenticating API calls.
     */
    clientKey?: string;
    /**
     * The client secret for authenticating API calls.
     */
    clientSecret?: string;
    /**
     * The customer identifier for authenticating API calls.
     */
    customerId?: string;
}

export interface DevicePostureRuleInput {
    complianceStatus?: string;
    connectionId?: string;
    /**
     * = (Required) The domain that the client must join.
     */
    domain?: string;
    /**
     * = (Required) True if the firewall must be enabled.
     */
    enabled: boolean;
    /**
     * Checks if the file should exist.
     */
    exists: boolean;
    /**
     * The Teams List id.
     */
    id?: string;
    /**
     * = (Required) The version comparison operator in (>,>=,<,<=,==)
     */
    operator?: string;
    /**
     * The path to the application.
     */
    path?: string;
    /**
     * = (Required) True if all drives must be encrypted.
     */
    requireAll: boolean;
    /**
     * Checks if the application should be running.
     */
    running: boolean;
    /**
     * The sha256 hash of the file.
     */
    sha256?: string;
    /**
     * The thumbprint of the application certificate.
     */
    thumbprint?: string;
    /**
     * = (Required) The operating system semantic version.
     */
    version?: string;
}

export interface DevicePostureRuleMatch {
    /**
     * The platform of the device. Valid values are `windows`, `mac`, `linux`, `android`, and `ios`.
     */
    platform?: string;
}

export interface FallbackDomainDomain {
    /**
     * The description of the domain.
     */
    description?: string;
    /**
     * The DNS servers to receive the redirected request.
     */
    dnsServers?: string[];
    /**
     * The domain to ignore DNS requests.
     */
    suffix?: string;
}

export interface GetAccountRolesRole {
    description?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    name?: string;
}

export interface GetAccountsAccount {
    enforceTwofactor?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
    /**
     * The account name to target for the resource.
     */
    name?: string;
    type?: string;
}

export interface GetDevicesDevice {
    created?: string;
    deviceType?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    ip?: string;
    key?: string;
    lastSeen?: string;
    model?: string;
    name?: string;
    osVersion?: string;
    updated?: string;
    userEmail?: string;
    userId?: string;
    userName?: string;
    version?: string;
}

export interface GetWafGroupsFilter {
    mode?: string;
    name?: string;
}

export interface GetWafGroupsGroup {
    description?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    mode?: string;
    modifiedRulesCount?: number;
    name?: string;
    packageId?: string;
    rulesCount?: number;
}

export interface GetWafPackagesFilter {
    actionMode?: string;
    detectionMode?: string;
    name?: string;
    sensitivity?: string;
}

export interface GetWafPackagesPackage {
    actionMode?: string;
    description?: string;
    detectionMode?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    name?: string;
    sensitivity?: string;
}

export interface GetWafRulesFilter {
    description?: string;
    groupId?: string;
    mode?: string;
}

export interface GetWafRulesRule {
    allowedModes?: string[];
    defaultMode?: string;
    description?: string;
    groupId?: string;
    groupName?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    mode?: string;
    packageId?: string;
    priority?: string;
}

export interface GetZonesFilter {
    /**
     * The account identifier to target for the resource.
     */
    accountId?: string;
    /**
     * Defaults to `exact`.
     */
    lookupType?: string;
    match?: string;
    name?: string;
    /**
     * Defaults to `false`.
     */
    paused?: boolean;
    status?: string;
}

export interface GetZonesZone {
    /**
     * The ID of this resource.
     */
    id?: string;
    name?: string;
}

export interface HealthcheckHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of string values for the header.
     */
    values: string[];
}

export interface IpListItem {
    /**
     * A note that can be used to annotate the item.
     */
    comment?: string;
    /**
     * The IPv4 address, IPv4 CIDR or IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.
     */
    value: string;
}

export interface ListItem {
    /**
     * An optional comment for the item.
     */
    comment?: string;
    value: outputs.ListItemValue;
}

export interface ListItemValue {
    ip?: string;
    redirects?: outputs.ListItemValueRedirect[];
}

export interface ListItemValueRedirect {
    includeSubdomains?: string;
    preservePathSuffix?: string;
    preserveQueryString?: string;
    sourceUrl: string;
    statusCode?: number;
    subpathMatching?: string;
    targetUrl: string;
}

export interface LoadBalancerCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
}

export interface LoadBalancerMonitorHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of string values for the header.
     */
    values: string[];
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * Percent of traffic to shed 0 - 100.
     */
    defaultPercent?: number;
    /**
     * Method of shedding traffic "", "hash" or "random".
     */
    defaultPolicy?: string;
    /**
     * Percent of session traffic to shed 0 - 100.
     */
    sessionPercent?: number;
    /**
     * Method of shedding session traffic "" or "hash".
     */
    sessionPolicy?: string;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare.
     */
    address: string;
    /**
     * Whether to enable (the default) this origin within the Pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled?: boolean;
    /**
     * The header name.
     */
    headers?: outputs.LoadBalancerPoolOriginHeader[];
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Default: 1.
     */
    weight?: number;
}

export interface LoadBalancerPoolOriginHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of string values for the header.
     */
    values: string[];
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * Either "random" (default) or "hash".
     */
    policy?: string;
}

export interface LoadBalancerPopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRegionPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRule {
    /**
     * The statement to evaluate to determine if this rules effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
     */
    condition?: string;
    /**
     * A disabled rule will be be executed.
     */
    disabled?: boolean;
    /**
     * Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: overrides or fixedResponse must be set. See the field documentation below.
     */
    fixedResponse?: outputs.LoadBalancerRuleFixedResponse;
    /**
     * Human readable name for this rule.
     */
    name: string;
    /**
     * The Load Balancer settings to alter if this rules condition is true. Note: overrides or fixedResponse must be set. See the field documentation below.
     */
    overrides?: outputs.LoadBalancerRuleOverride[];
    /**
     * Priority used when determining the order of rule execution. Lower values are executed first. If not provided list order will be used.
     */
    priority: number;
    /**
     * Terminates indicates that if this rule is true no further rules should be executed. Note: setting a fixedResponse forces this field to true.
     */
    terminates: boolean;
}

export interface LoadBalancerRuleFixedResponse {
    /**
     * The value of the HTTP context-type header for this fixed response.
     */
    contentType?: string;
    /**
     * The value of the HTTP location header for this fixed response.
     */
    location?: string;
    /**
     * The text used as the html body for this fixed response.
     */
    messageBody?: string;
    /**
     * The HTTP status code used for this fixed response.
     */
    statusCode?: number;
}

export interface LoadBalancerRuleOverride {
    /**
     * See countryPools above.
     */
    countryPools?: outputs.LoadBalancerRuleOverrideCountryPool[];
    /**
     * See defaultPoolIds above.
     */
    defaultPools?: string[];
    /**
     * See fallbackPoolId above.
     */
    fallbackPool?: string;
    /**
     * See popPools above.
     */
    popPools?: outputs.LoadBalancerRuleOverridePopPool[];
    /**
     * See regionPools above.
     */
    regionPools?: outputs.LoadBalancerRuleOverrideRegionPool[];
    /**
     * See field above.
     */
    sessionAffinity?: string;
    /**
     * See field above.
     */
    sessionAffinityAttributes?: {[key: string]: string};
    /**
     * See field above.
     */
    sessionAffinityTtl?: number;
    /**
     * See field above.
     */
    steeringPolicy?: string;
    /**
     * See field above.
     */
    ttl?: number;
}

export interface LoadBalancerRuleOverrideCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
}

export interface LoadBalancerRuleOverridePopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRuleOverrideRegionPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface ManagedHeadersManagedRequestHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface ManagedHeadersManagedResponseHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface NotificationPolicyEmailIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the notification policy.
     */
    name?: string;
}

export interface NotificationPolicyFilters {
    /**
     * State of the pool to alert on.
     */
    enableds?: string[];
    /**
     * Source configuration to alert on for pool or origin.
     */
    eventSources?: string[];
    /**
     * Stream event type to alert on.
     */
    eventTypes?: string[];
    /**
     * Identifier health check. Required when using `filters.0.status`.
     */
    healthCheckIds?: string[];
    /**
     * Stream input id to alert on.
     */
    inputIds?: string[];
    /**
     * A numerical limit. Example: `100`.
     */
    limits?: string[];
    /**
     * Health status to alert on for pool or origin.
     */
    newHealths?: string[];
    /**
     * Packets per second threshold for dos alert.
     */
    packetsPerSeconds?: string[];
    /**
     * Load balancer pool identifier.
     */
    poolIds?: string[];
    /**
     * Product name. Available values: `workerRequests`, `workerDurableObjectsRequests`, `workerDurableObjectsDuration`, `workerDurableObjectsDataTransfer`, `workerDurableObjectsStoredData`, `workerDurableObjectsStorageDeletes`, `workerDurableObjectsStorageWrites`, `workerDurableObjectsStorageReads`.
     */
    products?: string[];
    /**
     * Protocol to alert on for dos.
     */
    protocols?: string[];
    /**
     * Requests per second threshold for dos alert.
     */
    requestsPerSeconds?: string[];
    services?: string[];
    /**
     * A numerical limit. Example: `99.9`.
     */
    slos?: string[];
    /**
     * Status to alert on.
     */
    statuses?: string[];
    /**
     * Target host to alert on for dos.
     */
    targetHosts?: string[];
    /**
     * Target domain to alert on.
     */
    targetZoneNames?: string[];
    /**
     * A list of zone identifiers.
     */
    zones?: string[];
}

export interface NotificationPolicyPagerdutyIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the notification policy.
     */
    name?: string;
}

export interface NotificationPolicyWebhooksIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the notification policy.
     */
    name?: string;
}

export interface PageRuleActions {
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    alwaysUseHttps?: boolean;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    automaticHttpsRewrites?: string;
    /**
     * The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
     */
    browserCacheTtl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    browserCheck?: string;
    /**
     * String value of cookie name to conditionally bypass cache the page.
     */
    bypassCacheOnCookie?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheByDeviceType?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheDeceptionArmor?: string;
    /**
     * Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
     */
    cacheKeyFields?: outputs.PageRuleActionsCacheKeyFields;
    /**
     * Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cacheEverything"`.
     */
    cacheLevel?: string;
    /**
     * String value of cookie name to conditionally cache the page.
     */
    cacheOnCookie?: string;
    /**
     * Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
     */
    cacheTtlByStatuses?: outputs.PageRuleActionsCacheTtlByStatus[];
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableApps?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disablePerformance?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableRailgun?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableSecurity?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableZaraz?: boolean;
    /**
     * The Time To Live for the edge cache.
     */
    edgeCacheTtl?: number;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    emailObfuscation?: string;
    /**
     * Whether origin Cache-Control action is `"on"` or `"off"`.
     */
    explicitCacheControl?: string;
    /**
     * The URL to forward to, and with what status. See below.
     */
    forwardingUrl?: outputs.PageRuleActionsForwardingUrl;
    /**
     * Value of the Host header to send.
     */
    hostHeaderOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    ipGeolocation?: string;
    /**
     * The configuration for HTML, CSS and JS minification. See below for full list of options.
     */
    minifies?: outputs.PageRuleActionsMinify[];
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    mirage?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    opportunisticEncryption?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    originErrorPagePassThru?: string;
    /**
     * Whether this action is `"off"`, `"lossless"` or `"lossy"`.
     */
    polish?: string;
    /**
     * Overridden origin server name.
     */
    resolveOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    respectStrongEtag?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    responseBuffering?: string;
    /**
     * Whether to set the rocket loader to `"on"`, `"off"`.
     */
    rocketLoader?: string;
    /**
     * Whether to set the security level to `"off"`, `"essentiallyOff"`, `"low"`, `"medium"`, `"high"`, or `"underAttack"`.
     */
    securityLevel?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    serverSideExclude?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    sortQueryStringForCache?: string;
    /**
     * Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"originPull"`.
     */
    ssl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    trueClientIpHeader?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    waf?: string;
}

export interface PageRuleActionsCacheKeyFields {
    /**
     * Controls what cookies go into Cache Key:
     */
    cookie: outputs.PageRuleActionsCacheKeyFieldsCookie;
    /**
     * Controls what HTTP headers go into Cache Key:
     */
    header: outputs.PageRuleActionsCacheKeyFieldsHeader;
    /**
     * Controls which Host header goes into Cache Key:
     */
    host: outputs.PageRuleActionsCacheKeyFieldsHost;
    /**
     * Controls which URL query string parameters go into the Cache Key.
     */
    queryString: outputs.PageRuleActionsCacheKeyFieldsQueryString;
    /**
     * Controls which end user-related features go into the Cache Key.
     */
    user: outputs.PageRuleActionsCacheKeyFieldsUser;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    /**
     * Check for presence of specified HTTP headers, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    /**
     * Check for presence of specified HTTP headers, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Exclude these query string parameters from Cache Key.
     */
    excludes: string[];
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHost {
    /**
     * `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
     */
    resolved?: boolean;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    /**
     * Exclude these query string parameters from Cache Key.
     */
    excludes: string[];
    /**
     * `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
     */
    ignore: boolean;
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsUser {
    /**
     * `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
     */
    deviceType: boolean;
    /**
     * `true` - includes the client’s country, derived from the IP address; defaults to `false`.
     */
    geo: boolean;
    /**
     * `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
     */
    lang: boolean;
}

export interface PageRuleActionsCacheTtlByStatus {
    /**
     * A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
     */
    codes: string;
    /**
     * Duration a resource lives in the Cloudflare cache.
     * - positive number - cache for specified duration in seconds
     */
    ttl: number;
}

export interface PageRuleActionsForwardingUrl {
    /**
     * The status code to use for the redirection.
     */
    statusCode: number;
    /**
     * The URL to which the page rule should forward.
     */
    url: string;
}

export interface PageRuleActionsMinify {
    /**
     * Whether CSS should be minified. Valid values are `"on"` or `"off"`.
     */
    css: string;
    /**
     * Whether HTML should be minified. Valid values are `"on"` or `"off"`.
     */
    html: string;
    /**
     * Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
     */
    js: string;
}

export interface RateLimitAction {
    /**
     * The type of action to perform. Allowable values are 'simulate', 'ban', 'challenge', 'js_challenge' and 'managed_challenge'.
     */
    mode: string;
    /**
     * Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.
     */
    response?: outputs.RateLimitActionResponse;
    /**
     * The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period (min: 1, max: 86400).
     */
    timeout?: number;
}

export interface RateLimitActionResponse {
    /**
     * The body to return, the content here should conform to the content_type.
     */
    body: string;
    /**
     * The content-type of the body, must be one of: 'text/plain', 'text/xml', 'application/json'.
     */
    contentType: string;
}

export interface RateLimitCorrelate {
    /**
     * If set to 'nat', NAT support will be enabled for rate limiting.
     */
    by?: string;
}

export interface RateLimitMatch {
    /**
     * Matches HTTP requests (from the client to Cloudflare). See definition below.
     */
    request: outputs.RateLimitMatchRequest;
    /**
     * Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page. Definition below.
     */
    response: outputs.RateLimitMatchResponse;
}

export interface RateLimitMatchRequest {
    /**
     * HTTP Methods, can be a subset ['POST','PUT'] or all ['\_ALL\_']. Default: ['\_ALL\_'].
     */
    methods: string[];
    /**
     * HTTP Schemes, can be one ['HTTPS'], both ['HTTP','HTTPS'] or all ['\_ALL\_']. Default: ['\_ALL\_'].
     */
    schemes: string[];
    /**
     * The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone. Default: '_'.
     */
    urlPattern: string;
}

export interface RateLimitMatchResponse {
    /**
     * block is a list of maps with the following attributes:
     */
    headers?: {[key: string]: string}[];
    /**
     * Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting. Default: `true`.
     */
    originTraffic: boolean;
    /**
     * HTTP Status codes, can be one [403], many [401,403] or indicate all by not providing this value.
     */
    statuses: number[];
}

export interface RecordData {
    algorithm?: number;
    altitude?: number;
    certificate?: string;
    content?: string;
    digest?: string;
    digestType?: number;
    fingerprint?: string;
    flags?: string;
    keyTag?: number;
    latDegrees?: number;
    latDirection?: string;
    latMinutes?: number;
    latSeconds?: number;
    longDegrees?: number;
    longDirection?: string;
    longMinutes?: number;
    longSeconds?: number;
    matchingType?: number;
    /**
     * The name of the record
     */
    name?: string;
    order?: number;
    port?: number;
    precisionHorz?: number;
    precisionVert?: number;
    preference?: number;
    /**
     * The priority of the record
     */
    priority?: number;
    proto?: string;
    protocol?: number;
    publicKey?: string;
    regex?: string;
    replacement?: string;
    selector?: number;
    service?: string;
    size?: number;
    tag?: string;
    target?: string;
    /**
     * The type of the record
     */
    type?: number;
    usage?: number;
    /**
     * The (string) value of the record. Either this or `data` must be specified
     */
    value?: string;
    weight?: number;
}

export interface RulesetRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `ddosDynamic`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `setCacheSettings`, `setConfig`, `serveError`, `skip`.
     */
    action?: string;
    /**
     * List of parameters that configure the behavior of the ruleset rule action.
     */
    actionParameters?: outputs.RulesetRuleActionParameters;
    /**
     * Brief summary of the ruleset rule and its intended use.
     */
    description?: string;
    /**
     * Whether the rule is active.
     */
    enabled?: boolean;
    /**
     * List of parameters that configure exposed credential checks.
     */
    exposedCredentialCheck?: outputs.RulesetRuleExposedCredentialCheck;
    /**
     * Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * List parameters to configure how the rule generates logs.
     */
    logging?: outputs.RulesetRuleLogging;
    /**
     * List of parameters that configure HTTP rate limiting behaviour.
     */
    ratelimit?: outputs.RulesetRuleRatelimit;
    /**
     * Rule reference.
     */
    ref: string;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface RulesetRuleActionParameters {
    automaticHttpsRewrites?: boolean;
    autominifies?: outputs.RulesetRuleActionParametersAutominify[];
    bic?: boolean;
    browserTtl?: outputs.RulesetRuleActionParametersBrowserTtl;
    cache?: boolean;
    cacheKey?: outputs.RulesetRuleActionParametersCacheKey;
    content?: string;
    contentType?: string;
    cookieFields?: string[];
    disableApps?: boolean;
    disableRailgun?: boolean;
    disableZaraz?: boolean;
    edgeTtl?: outputs.RulesetRuleActionParametersEdgeTtl;
    emailObfuscation?: boolean;
    fromList?: outputs.RulesetRuleActionParametersFromList;
    fromValue?: outputs.RulesetRuleActionParametersFromValue;
    headers?: outputs.RulesetRuleActionParametersHeader[];
    hostHeader?: string;
    hotlinkProtection?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
    increment?: number;
    matchedData?: outputs.RulesetRuleActionParametersMatchedData;
    mirage?: boolean;
    opportunisticEncryption?: boolean;
    origin?: outputs.RulesetRuleActionParametersOrigin;
    originErrorPagePassthru?: boolean;
    overrides?: outputs.RulesetRuleActionParametersOverrides;
    phases?: string[];
    polish?: string;
    products?: string[];
    requestFields?: string[];
    respectStrongEtags?: boolean;
    responseFields?: string[];
    responses?: outputs.RulesetRuleActionParametersResponse[];
    rocketLoader?: boolean;
    /**
     * List of rules to apply to the ruleset.
     */
    rules?: {[key: string]: string};
    ruleset?: string;
    rulesets?: string[];
    securityLevel?: string;
    serveStale?: outputs.RulesetRuleActionParametersServeStale;
    serverSideExcludes?: boolean;
    sni?: outputs.RulesetRuleActionParametersSni;
    ssl?: string;
    statusCode?: number;
    sxg?: boolean;
    uri?: outputs.RulesetRuleActionParametersUri;
    version: string;
}

export interface RulesetRuleActionParametersAutominify {
    css?: boolean;
    html?: boolean;
    js?: boolean;
}

export interface RulesetRuleActionParametersBrowserTtl {
    default?: number;
    mode: string;
}

export interface RulesetRuleActionParametersCacheKey {
    cacheByDeviceType?: boolean;
    cacheDeceptionArmor?: boolean;
    customKey?: outputs.RulesetRuleActionParametersCacheKeyCustomKey;
    ignoreQueryStringsOrder?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKey {
    cookie?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie;
    header?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader;
    host?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost;
    queryString?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    user?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyCookie {
    checkPresences?: string[];
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHeader {
    checkPresences?: string[];
    excludeOrigin?: boolean;
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHost {
    resolved?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    excludes?: string[];
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyUser {
    deviceType?: boolean;
    geo?: boolean;
    lang?: boolean;
}

export interface RulesetRuleActionParametersEdgeTtl {
    default: number;
    mode: string;
    statusCodeTtls?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    statusCode?: number;
    statusCodeRanges?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange[];
    value: number;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    from?: number;
    to?: number;
}

export interface RulesetRuleActionParametersFromList {
    key: string;
    /**
     * Name of the ruleset.
     */
    name: string;
}

export interface RulesetRuleActionParametersFromValue {
    preserveQueryString?: boolean;
    statusCode?: number;
    targetUrl?: outputs.RulesetRuleActionParametersFromValueTargetUrl;
}

export interface RulesetRuleActionParametersFromValueTargetUrl {
    expression?: string;
    value?: string;
}

export interface RulesetRuleActionParametersHeader {
    expression?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
    operation?: string;
    value?: string;
}

export interface RulesetRuleActionParametersMatchedData {
    publicKey?: string;
}

export interface RulesetRuleActionParametersOrigin {
    host?: string;
    port?: number;
}

export interface RulesetRuleActionParametersOverrides {
    action?: string;
    categories?: outputs.RulesetRuleActionParametersOverridesCategory[];
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * List of rules to apply to the ruleset.
     */
    rules?: outputs.RulesetRuleActionParametersOverridesRule[];
    status?: string;
}

export interface RulesetRuleActionParametersOverridesCategory {
    action?: string;
    category?: string;
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    status?: string;
}

export interface RulesetRuleActionParametersOverridesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `ddosDynamic`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `setCacheSettings`, `setConfig`, `serveError`, `skip`.
     */
    action?: string;
    /**
     * Whether the rule is active.
     *
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * Unique rule identifier.
     */
    id?: string;
    scoreThreshold?: number;
    sensitivityLevel?: string;
    status?: string;
}

export interface RulesetRuleActionParametersResponse {
    content?: string;
    contentType?: string;
    statusCode?: number;
}

export interface RulesetRuleActionParametersServeStale {
    disableStaleWhileUpdating?: boolean;
}

export interface RulesetRuleActionParametersSni {
    value?: string;
}

export interface RulesetRuleActionParametersUri {
    origin?: boolean;
    path?: outputs.RulesetRuleActionParametersUriPath;
    query?: outputs.RulesetRuleActionParametersUriQuery;
}

export interface RulesetRuleActionParametersUriPath {
    expression?: string;
    value?: string;
}

export interface RulesetRuleActionParametersUriQuery {
    expression?: string;
    value?: string;
}

export interface RulesetRuleExposedCredentialCheck {
    passwordExpression?: string;
    usernameExpression?: string;
}

export interface RulesetRuleLogging {
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    status?: string;
}

export interface RulesetRuleRatelimit {
    characteristics?: string[];
    countingExpression?: string;
    mitigationTimeout?: number;
    period?: number;
    requestsPerPeriod?: number;
    requestsToOrigin?: boolean;
}

export interface SpectrumApplicationDns {
    /**
     * Fully qualified domain name of the origin e.g. origin-ssh.example.com.
     */
    name: string;
    /**
     * The type of DNS record associated with the application. Valid values: `CNAME`.
     */
    type: string;
}

export interface SpectrumApplicationOriginDns {
    /**
     * Fully qualified domain name of the origin e.g. origin-ssh.example.com.
     */
    name: string;
}

export interface SpectrumApplicationOriginPortRange {
    /**
     * Upper bound of the origin port range, e.g. `2000`
     */
    end: number;
    /**
     * Lower bound of the origin port range, e.g. `1000`
     */
    start: number;
}

export interface SplitTunnelTunnel {
    /**
     * The address in CIDR format to include in the tunnel configuration. Conflicts with `"host"`.
     */
    address?: string;
    /**
     * The description of the tunnel.
     */
    description?: string;
    /**
     * The domain name to include in the tunnel configuration. Conflicts with `"address"`.
     */
    host?: string;
}

export interface TeamsAccountAntivirus {
    /**
     * Scan on file download.
     */
    enabledDownloadPhase: boolean;
    /**
     * Scan on file upload.
     */
    enabledUploadPhase: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: boolean;
}

export interface TeamsAccountBlockPage {
    /**
     * Hex code of block page background color.
     */
    backgroundColor?: string;
    /**
     * Indicator of enablement.
     */
    enabled?: boolean;
    /**
     * Block page header text.
     */
    footerText?: string;
    /**
     * Block page footer text.
     */
    headerText?: string;
    /**
     * URL of block page logo.
     */
    logoPath?: string;
    /**
     * Name of block page configuration.
     */
    name?: string;
}

export interface TeamsAccountFips {
    /**
     * Only allow FIPS-compliant TLS configuration.
     */
    tls?: boolean;
}

export interface TeamsAccountLogging {
    /**
     * Redact personally identifiable information from activity logging (PII fields are: source IP,
     * user email, user ID, device ID, URL, referrer, user agent).
     */
    redactPii: boolean;
    /**
     * Represents whether all requests are logged or only the blocked requests are
     * logged in DNS, HTTP and L4 filters.
     */
    settingsByRuleType: outputs.TeamsAccountLoggingSettingsByRuleType;
}

export interface TeamsAccountLoggingSettingsByRuleType {
    dns: outputs.TeamsAccountLoggingSettingsByRuleTypeDns;
    http: outputs.TeamsAccountLoggingSettingsByRuleTypeHttp;
    l4: outputs.TeamsAccountLoggingSettingsByRuleTypeL4;
}

export interface TeamsAccountLoggingSettingsByRuleTypeDns {
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeHttp {
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeL4 {
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountProxy {
    /**
     * Whether gateway proxy is enabled on gateway devices for tcp traffic.
     */
    tcp: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for udp traffic.
     */
    udp: boolean;
}

export interface TeamsLocationNetwork {
    /**
     * ID of the teams location.
     */
    id: string;
    network: string;
}

export interface TeamsRuleRuleSettings {
    /**
     * Add custom headers to allowed requests in the form of key-value pairs.
     */
    addHeaders?: {[key: string]: string};
    /**
     * Configure how browser isolation behaves (refer to the nested schema).
     */
    bisoAdminControls?: outputs.TeamsRuleRuleSettingsBisoAdminControls;
    /**
     * Indicator of block page enablement.
     */
    blockPageEnabled?: boolean;
    /**
     * The displayed reason for a user being blocked.
     */
    blockPageReason?: string;
    /**
     * Configure how session check behaves (refer to the nested schema).
     */
    checkSession?: outputs.TeamsRuleRuleSettingsCheckSession;
    /**
     * Disable DNSSEC validation (must be Allow rule)
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Settings to forward layer 4 traffic (refer to the nested schema).
     */
    l4override?: outputs.TeamsRuleRuleSettingsL4override;
    /**
     * The host to override matching DNS queries with.
     */
    overrideHost?: string;
    /**
     * The IPs to override matching DNS queries with.
     */
    overrideIps?: string[];
}

export interface TeamsRuleRuleSettingsBisoAdminControls {
    /**
     * Disable copy-paste.
     */
    disableCopyPaste?: boolean;
    /**
     * Disable download.
     */
    disableDownload?: boolean;
    /**
     * Disable keyboard usage.
     */
    disableKeyboard?: boolean;
    /**
     * Disable printing.
     */
    disablePrinting?: boolean;
    /**
     * Disable upload.
     */
    disableUpload?: boolean;
}

export interface TeamsRuleRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: string;
    /**
     * Enable session enforcement for this rule.
     */
    enforce: boolean;
}

export interface TeamsRuleRuleSettingsL4override {
    /**
     * Override IP to forward traffic to.
     */
    ip: string;
    /**
     * Override Port to forward traffic to.
     */
    port: number;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
     */
    value: string;
}

export interface WorkerScriptKvNamespaceBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * ID of the KV namespace you want to use.
     */
    namespaceId: string;
}

export interface WorkerScriptPlainTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The plain text you want to store.
     */
    text: string;
}

export interface WorkerScriptR2BucketBinding {
    /**
     * The name of the Bucket to bind to.
     */
    bucketName: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptSecretTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The secret text you want to store.
     */
    text: string;
}

export interface WorkerScriptServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface WorkerScriptWebassemblyBinding {
    /**
     * The base64 encoded wasm module you want to store.
     */
    module: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface ZoneLockdownConfiguration {
    /**
     * The request property to target. Allowed values: "ip", "ipRange"
     */
    target: string;
    /**
     * The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `198.51.100.4` or `2001:db8::/32` and IP ranges in CIDR format i.e. `198.51.0.0/16`.
     */
    value: string;
}

export interface ZoneSettingsOverrideInitialSetting {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    /**
     * Allowed values: "aggressive" (default) - delivers a different resource each time the query string changes, "basic" - delivers resources from cache when there is no query string, "simplified" - delivers the same resource to everyone independent of the query string.
     */
    cacheLevel: string;
    challengeTtl: number;
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers: string[];
    /**
     * Allowed values: "flattenAtRoot" (default), "flattenAll", "flattenNone".
     */
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    /**
     * Allowed values: "on", "off" (default), "custom".
     */
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    /**
     * Allowed values: "on", "off" (default), "open".
     */
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    /**
     * Allowed values: "1.0" (default), "1.1", "1.2", "1.3".
     */
    minTlsVersion: string;
    minify: outputs.ZoneSettingsOverrideInitialSettingMinify;
    mirage: string;
    mobileRedirect: outputs.ZoneSettingsOverrideInitialSettingMobileRedirect;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    /**
     * Allowed values: "1" (default on Enterprise), "2" (default)
     */
    originMaxHttpVersion: string;
    /**
     * Allowed values: "off" (default), "lossless", "lossy".
     */
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    /**
     * Allowed values: "off" (default), "addHeader", "overwriteHeader".
     */
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader: outputs.ZoneSettingsOverrideInitialSettingSecurityHeader;
    /**
     * Allowed values: "off" (Enterprise only), "essentiallyOff", "low", "medium" (default), "high", "underAttack".
     */
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    /**
     * Allowed values: "off" (default), "flexible", "full", "strict", "originPull".
     */
    ssl: string;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `min_tls_version = "1.2"` instead.
     */
    tls12Only: string;
    /**
     * Allowed values: "off" (default), "on", "zrt".
     */
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    /**
     * . Note that the value specified will be ignored unless `polish` is turned on (i.e. is "lossless" or "lossy")
     */
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideInitialSettingMinify {
    /**
     * "on"/"off"
     */
    css: string;
    /**
     * "on"/"off"
     */
    html: string;
    /**
     * "on"/"off"
     */
    js: string;
}

export interface ZoneSettingsOverrideInitialSettingMobileRedirect {
    /**
     * String value
     */
    mobileSubdomain: string;
    /**
     * "on"/"off"
     */
    status: string;
    /**
     * true/false
     */
    stripUri: boolean;
}

export interface ZoneSettingsOverrideInitialSettingSecurityHeader {
    /**
     * true/false
     */
    enabled: boolean;
    /**
     * true/false
     */
    includeSubdomains: boolean;
    /**
     * Integer
     */
    maxAge: number;
    /**
     * true/false
     */
    nosniff: boolean;
    /**
     * true/false
     */
    preload: boolean;
}

export interface ZoneSettingsOverrideSettings {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    /**
     * Allowed values: "aggressive" (default) - delivers a different resource each time the query string changes, "basic" - delivers resources from cache when there is no query string, "simplified" - delivers the same resource to everyone independent of the query string.
     */
    cacheLevel: string;
    challengeTtl: number;
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers: string[];
    /**
     * Allowed values: "flattenAtRoot" (default), "flattenAll", "flattenNone".
     */
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    /**
     * Allowed values: "on", "off" (default), "custom".
     */
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    /**
     * Allowed values: "on", "off" (default), "open".
     */
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    /**
     * Allowed values: "1.0" (default), "1.1", "1.2", "1.3".
     */
    minTlsVersion: string;
    minify: outputs.ZoneSettingsOverrideSettingsMinify;
    mirage: string;
    mobileRedirect: outputs.ZoneSettingsOverrideSettingsMobileRedirect;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    /**
     * Allowed values: "1" (default on Enterprise), "2" (default)
     */
    originMaxHttpVersion: string;
    /**
     * Allowed values: "off" (default), "lossless", "lossy".
     */
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    /**
     * Allowed values: "off" (default), "addHeader", "overwriteHeader".
     */
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader: outputs.ZoneSettingsOverrideSettingsSecurityHeader;
    /**
     * Allowed values: "off" (Enterprise only), "essentiallyOff", "low", "medium" (default), "high", "underAttack".
     */
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    /**
     * Allowed values: "off" (default), "flexible", "full", "strict", "originPull".
     */
    ssl: string;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `min_tls_version = "1.2"` instead.
     */
    tls12Only: string;
    /**
     * Allowed values: "off" (default), "on", "zrt".
     */
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    /**
     * . Note that the value specified will be ignored unless `polish` is turned on (i.e. is "lossless" or "lossy")
     */
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideSettingsMinify {
    /**
     * "on"/"off"
     */
    css: string;
    /**
     * "on"/"off"
     */
    html: string;
    /**
     * "on"/"off"
     */
    js: string;
}

export interface ZoneSettingsOverrideSettingsMobileRedirect {
    /**
     * String value
     */
    mobileSubdomain: string;
    /**
     * "on"/"off"
     */
    status: string;
    /**
     * true/false
     */
    stripUri: boolean;
}

export interface ZoneSettingsOverrideSettingsSecurityHeader {
    /**
     * true/false
     */
    enabled: boolean;
    /**
     * true/false
     */
    includeSubdomains: boolean;
    /**
     * Integer
     */
    maxAge: number;
    /**
     * true/false
     */
    nosniff: boolean;
    /**
     * true/false
     */
    preload: boolean;
}

