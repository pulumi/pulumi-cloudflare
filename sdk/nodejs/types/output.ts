// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApplicationCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders?: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods?: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins?: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials?: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders?: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods?: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins?: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge?: number;
}

export interface AccessApplicationDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr?: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname?: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     * Available values: "tcp", "udp".
     */
    l4Protocol?: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange?: string;
    /**
     * Available values: "public", "private".
     */
    type: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri?: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId?: string;
}

export interface AccessApplicationFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface AccessApplicationLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor?: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor?: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl?: string;
    /**
     * The message shown on the landing page.
     */
    message?: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface AccessApplicationPolicy {
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules?: outputs.AccessApplicationPolicyConnectionRules;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     * Available values: "allow", "deny", "nonIdentity", "bypass".
     */
    decision?: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes?: outputs.AccessApplicationPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id?: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes?: outputs.AccessApplicationPolicyInclude[];
    /**
     * The name of the Access policy.
     */
    name?: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence: number;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires?: outputs.AccessApplicationPolicyRequire[];
}

export interface AccessApplicationPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh?: outputs.AccessApplicationPolicyConnectionRulesSsh;
}

export interface AccessApplicationPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias?: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface AccessApplicationPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessApplicationPolicyExcludeAnyValidServiceToken;
    authContext?: outputs.AccessApplicationPolicyExcludeAuthContext;
    authMethod?: outputs.AccessApplicationPolicyExcludeAuthMethod;
    azureAd?: outputs.AccessApplicationPolicyExcludeAzureAd;
    certificate?: outputs.AccessApplicationPolicyExcludeCertificate;
    commonName?: outputs.AccessApplicationPolicyExcludeCommonName;
    devicePosture?: outputs.AccessApplicationPolicyExcludeDevicePosture;
    email?: outputs.AccessApplicationPolicyExcludeEmail;
    emailDomain?: outputs.AccessApplicationPolicyExcludeEmailDomain;
    emailList?: outputs.AccessApplicationPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessApplicationPolicyExcludeEveryone;
    externalEvaluation?: outputs.AccessApplicationPolicyExcludeExternalEvaluation;
    geo?: outputs.AccessApplicationPolicyExcludeGeo;
    githubOrganization?: outputs.AccessApplicationPolicyExcludeGithubOrganization;
    group?: outputs.AccessApplicationPolicyExcludeGroup;
    gsuite?: outputs.AccessApplicationPolicyExcludeGsuite;
    ip?: outputs.AccessApplicationPolicyExcludeIp;
    ipList?: outputs.AccessApplicationPolicyExcludeIpList;
    linkedAppToken?: outputs.AccessApplicationPolicyExcludeLinkedAppToken;
    loginMethod?: outputs.AccessApplicationPolicyExcludeLoginMethod;
    oidc?: outputs.AccessApplicationPolicyExcludeOidc;
    okta?: outputs.AccessApplicationPolicyExcludeOkta;
    saml?: outputs.AccessApplicationPolicyExcludeSaml;
    serviceToken?: outputs.AccessApplicationPolicyExcludeServiceToken;
}

export interface AccessApplicationPolicyExcludeAnyValidServiceToken {
}

export interface AccessApplicationPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessApplicationPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyExcludeCertificate {
}

export interface AccessApplicationPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessApplicationPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessApplicationPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessApplicationPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessApplicationPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessApplicationPolicyExcludeEveryone {
}

export interface AccessApplicationPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessApplicationPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessApplicationPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessApplicationPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessApplicationPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessApplicationPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessApplicationPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessApplicationPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessApplicationPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessApplicationPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessApplicationPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessApplicationPolicyIncludeAnyValidServiceToken;
    authContext?: outputs.AccessApplicationPolicyIncludeAuthContext;
    authMethod?: outputs.AccessApplicationPolicyIncludeAuthMethod;
    azureAd?: outputs.AccessApplicationPolicyIncludeAzureAd;
    certificate?: outputs.AccessApplicationPolicyIncludeCertificate;
    commonName?: outputs.AccessApplicationPolicyIncludeCommonName;
    devicePosture?: outputs.AccessApplicationPolicyIncludeDevicePosture;
    email?: outputs.AccessApplicationPolicyIncludeEmail;
    emailDomain?: outputs.AccessApplicationPolicyIncludeEmailDomain;
    emailList?: outputs.AccessApplicationPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessApplicationPolicyIncludeEveryone;
    externalEvaluation?: outputs.AccessApplicationPolicyIncludeExternalEvaluation;
    geo?: outputs.AccessApplicationPolicyIncludeGeo;
    githubOrganization?: outputs.AccessApplicationPolicyIncludeGithubOrganization;
    group?: outputs.AccessApplicationPolicyIncludeGroup;
    gsuite?: outputs.AccessApplicationPolicyIncludeGsuite;
    ip?: outputs.AccessApplicationPolicyIncludeIp;
    ipList?: outputs.AccessApplicationPolicyIncludeIpList;
    linkedAppToken?: outputs.AccessApplicationPolicyIncludeLinkedAppToken;
    loginMethod?: outputs.AccessApplicationPolicyIncludeLoginMethod;
    oidc?: outputs.AccessApplicationPolicyIncludeOidc;
    okta?: outputs.AccessApplicationPolicyIncludeOkta;
    saml?: outputs.AccessApplicationPolicyIncludeSaml;
    serviceToken?: outputs.AccessApplicationPolicyIncludeServiceToken;
}

export interface AccessApplicationPolicyIncludeAnyValidServiceToken {
}

export interface AccessApplicationPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessApplicationPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyIncludeCertificate {
}

export interface AccessApplicationPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessApplicationPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessApplicationPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessApplicationPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessApplicationPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessApplicationPolicyIncludeEveryone {
}

export interface AccessApplicationPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessApplicationPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessApplicationPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessApplicationPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessApplicationPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessApplicationPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessApplicationPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessApplicationPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessApplicationPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessApplicationPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessApplicationPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessApplicationPolicyRequireAnyValidServiceToken;
    authContext?: outputs.AccessApplicationPolicyRequireAuthContext;
    authMethod?: outputs.AccessApplicationPolicyRequireAuthMethod;
    azureAd?: outputs.AccessApplicationPolicyRequireAzureAd;
    certificate?: outputs.AccessApplicationPolicyRequireCertificate;
    commonName?: outputs.AccessApplicationPolicyRequireCommonName;
    devicePosture?: outputs.AccessApplicationPolicyRequireDevicePosture;
    email?: outputs.AccessApplicationPolicyRequireEmail;
    emailDomain?: outputs.AccessApplicationPolicyRequireEmailDomain;
    emailList?: outputs.AccessApplicationPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessApplicationPolicyRequireEveryone;
    externalEvaluation?: outputs.AccessApplicationPolicyRequireExternalEvaluation;
    geo?: outputs.AccessApplicationPolicyRequireGeo;
    githubOrganization?: outputs.AccessApplicationPolicyRequireGithubOrganization;
    group?: outputs.AccessApplicationPolicyRequireGroup;
    gsuite?: outputs.AccessApplicationPolicyRequireGsuite;
    ip?: outputs.AccessApplicationPolicyRequireIp;
    ipList?: outputs.AccessApplicationPolicyRequireIpList;
    linkedAppToken?: outputs.AccessApplicationPolicyRequireLinkedAppToken;
    loginMethod?: outputs.AccessApplicationPolicyRequireLoginMethod;
    oidc?: outputs.AccessApplicationPolicyRequireOidc;
    okta?: outputs.AccessApplicationPolicyRequireOkta;
    saml?: outputs.AccessApplicationPolicyRequireSaml;
    serviceToken?: outputs.AccessApplicationPolicyRequireServiceToken;
}

export interface AccessApplicationPolicyRequireAnyValidServiceToken {
}

export interface AccessApplicationPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessApplicationPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyRequireCertificate {
}

export interface AccessApplicationPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessApplicationPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessApplicationPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessApplicationPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessApplicationPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessApplicationPolicyRequireEveryone {
}

export interface AccessApplicationPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessApplicationPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessApplicationPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessApplicationPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessApplicationPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessApplicationPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessApplicationPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessApplicationPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessApplicationPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessApplicationPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessApplicationPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessApplicationSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret?: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl?: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     * Available values: "saml", "oidc".
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl?: string;
    customAttributes?: outputs.AccessApplicationSaasAppCustomAttribute[];
    customClaims?: outputs.AccessApplicationSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState?: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes?: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex?: string;
    hybridAndImplicitOptions?: outputs.AccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     * Available values: "id", "email".
     */
    nameIdFormat: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata?: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris?: string[];
    refreshTokenOptions?: outputs.AccessApplicationSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata?: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes?: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId?: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface AccessApplicationSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName?: string;
    /**
     * The name of the attribute.
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     * Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
     */
    nameFormat?: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required?: boolean;
    source?: outputs.AccessApplicationSaasAppCustomAttributeSource;
}

export interface AccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name?: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
    nameByIdps?: outputs.AccessApplicationSaasAppCustomAttributeSourceNameByIdp[];
}

export interface AccessApplicationSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId?: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName?: string;
}

export interface AccessApplicationSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name?: string;
    /**
     * If the claim is required when building an OIDC token.
     */
    required?: boolean;
    /**
     * The scope of the claim.
     * Available values: "groups", "profile", "email", "openid".
     */
    scope?: string;
    source?: outputs.AccessApplicationSaasAppCustomClaimSource;
}

export interface AccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name?: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface AccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint?: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint?: boolean;
}

export interface AccessApplicationSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime?: string;
}

export interface AccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication?: outputs.AccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete?: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled?: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings?: outputs.AccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface AccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl?: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId?: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret?: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password?: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     * Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes?: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token?: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl?: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user?: string;
}

export interface AccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled?: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter?: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations?: outputs.AccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     * Available values: "strict", "passthrough".
     */
    strictness?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata?: string;
}

export interface AccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
}

export interface AccessApplicationTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     * Available values: "SSH", "RDP".
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface AccessGroupExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessGroupExcludeAnyValidServiceToken;
    authContext?: outputs.AccessGroupExcludeAuthContext;
    authMethod?: outputs.AccessGroupExcludeAuthMethod;
    azureAd?: outputs.AccessGroupExcludeAzureAd;
    certificate?: outputs.AccessGroupExcludeCertificate;
    commonName?: outputs.AccessGroupExcludeCommonName;
    devicePosture?: outputs.AccessGroupExcludeDevicePosture;
    email?: outputs.AccessGroupExcludeEmail;
    emailDomain?: outputs.AccessGroupExcludeEmailDomain;
    emailList?: outputs.AccessGroupExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessGroupExcludeEveryone;
    externalEvaluation?: outputs.AccessGroupExcludeExternalEvaluation;
    geo?: outputs.AccessGroupExcludeGeo;
    githubOrganization?: outputs.AccessGroupExcludeGithubOrganization;
    group?: outputs.AccessGroupExcludeGroup;
    gsuite?: outputs.AccessGroupExcludeGsuite;
    ip?: outputs.AccessGroupExcludeIp;
    ipList?: outputs.AccessGroupExcludeIpList;
    linkedAppToken?: outputs.AccessGroupExcludeLinkedAppToken;
    loginMethod?: outputs.AccessGroupExcludeLoginMethod;
    oidc?: outputs.AccessGroupExcludeOidc;
    okta?: outputs.AccessGroupExcludeOkta;
    saml?: outputs.AccessGroupExcludeSaml;
    serviceToken?: outputs.AccessGroupExcludeServiceToken;
}

export interface AccessGroupExcludeAnyValidServiceToken {
}

export interface AccessGroupExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessGroupExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeCertificate {
}

export interface AccessGroupExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessGroupExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessGroupExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessGroupExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessGroupExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessGroupExcludeEveryone {
}

export interface AccessGroupExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessGroupExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessGroupExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessGroupExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessGroupExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessGroupExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessGroupExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessGroupExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessGroupExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessGroupExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessGroupInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessGroupIncludeAnyValidServiceToken;
    authContext?: outputs.AccessGroupIncludeAuthContext;
    authMethod?: outputs.AccessGroupIncludeAuthMethod;
    azureAd?: outputs.AccessGroupIncludeAzureAd;
    certificate?: outputs.AccessGroupIncludeCertificate;
    commonName?: outputs.AccessGroupIncludeCommonName;
    devicePosture?: outputs.AccessGroupIncludeDevicePosture;
    email?: outputs.AccessGroupIncludeEmail;
    emailDomain?: outputs.AccessGroupIncludeEmailDomain;
    emailList?: outputs.AccessGroupIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessGroupIncludeEveryone;
    externalEvaluation?: outputs.AccessGroupIncludeExternalEvaluation;
    geo?: outputs.AccessGroupIncludeGeo;
    githubOrganization?: outputs.AccessGroupIncludeGithubOrganization;
    group?: outputs.AccessGroupIncludeGroup;
    gsuite?: outputs.AccessGroupIncludeGsuite;
    ip?: outputs.AccessGroupIncludeIp;
    ipList?: outputs.AccessGroupIncludeIpList;
    linkedAppToken?: outputs.AccessGroupIncludeLinkedAppToken;
    loginMethod?: outputs.AccessGroupIncludeLoginMethod;
    oidc?: outputs.AccessGroupIncludeOidc;
    okta?: outputs.AccessGroupIncludeOkta;
    saml?: outputs.AccessGroupIncludeSaml;
    serviceToken?: outputs.AccessGroupIncludeServiceToken;
}

export interface AccessGroupIncludeAnyValidServiceToken {
}

export interface AccessGroupIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessGroupIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeCertificate {
}

export interface AccessGroupIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessGroupIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessGroupIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessGroupIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessGroupIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessGroupIncludeEveryone {
}

export interface AccessGroupIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessGroupIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessGroupIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessGroupIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessGroupIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessGroupIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessGroupIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessGroupIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessGroupIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessGroupIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessGroupRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessGroupRequireAnyValidServiceToken;
    authContext?: outputs.AccessGroupRequireAuthContext;
    authMethod?: outputs.AccessGroupRequireAuthMethod;
    azureAd?: outputs.AccessGroupRequireAzureAd;
    certificate?: outputs.AccessGroupRequireCertificate;
    commonName?: outputs.AccessGroupRequireCommonName;
    devicePosture?: outputs.AccessGroupRequireDevicePosture;
    email?: outputs.AccessGroupRequireEmail;
    emailDomain?: outputs.AccessGroupRequireEmailDomain;
    emailList?: outputs.AccessGroupRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessGroupRequireEveryone;
    externalEvaluation?: outputs.AccessGroupRequireExternalEvaluation;
    geo?: outputs.AccessGroupRequireGeo;
    githubOrganization?: outputs.AccessGroupRequireGithubOrganization;
    group?: outputs.AccessGroupRequireGroup;
    gsuite?: outputs.AccessGroupRequireGsuite;
    ip?: outputs.AccessGroupRequireIp;
    ipList?: outputs.AccessGroupRequireIpList;
    linkedAppToken?: outputs.AccessGroupRequireLinkedAppToken;
    loginMethod?: outputs.AccessGroupRequireLoginMethod;
    oidc?: outputs.AccessGroupRequireOidc;
    okta?: outputs.AccessGroupRequireOkta;
    saml?: outputs.AccessGroupRequireSaml;
    serviceToken?: outputs.AccessGroupRequireServiceToken;
}

export interface AccessGroupRequireAnyValidServiceToken {
}

export interface AccessGroupRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessGroupRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireCertificate {
}

export interface AccessGroupRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessGroupRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessGroupRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessGroupRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessGroupRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessGroupRequireEveryone {
}

export interface AccessGroupRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessGroupRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessGroupRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessGroupRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessGroupRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessGroupRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessGroupRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessGroupRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessGroupRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessGroupRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessIdentityProviderConfig {
    /**
     * Your companies TLD
     */
    appsDomain?: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes?: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl?: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId?: string;
    /**
     * Your centrify account url
     */
    centrifyAccount?: string;
    /**
     * Your centrify app id
     */
    centrifyAppId?: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl?: string;
    /**
     * Custom claims
     */
    claims?: string[];
    /**
     * Your OAuth Client ID
     */
    clientId?: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret?: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled?: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId?: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName?: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName?: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes?: outputs.AccessIdentityProviderConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts?: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl?: string;
    /**
     * Your okta account url
     */
    oktaAccount?: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount?: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId?: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled?: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     * Available values: "login", "selectAccount", "none".
     */
    prompt?: string;
    redirectUrl: string;
    /**
     * OAuth scopes
     */
    scopes?: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest?: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl?: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups?: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl?: string;
}

export interface AccessIdentityProviderConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName?: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName?: string;
}

export interface AccessIdentityProviderScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     * Available values: "automatic", "reauth", "no*action".
     */
    identityUpdateBehavior: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision: boolean;
}

export interface AccessMutualTlsHostnameSettingsSetting {
    /**
     * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
     */
    chinaNetwork: boolean;
    /**
     * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
     */
    clientCertificateForwarding: boolean;
    /**
     * The hostname that these settings apply to.
     */
    hostname: string;
}

export interface AccessOrganizationCustomPages {
    /**
     * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
     */
    forbidden?: string;
    /**
     * The uid of the custom page to use when a user is denied access.
     */
    identityDenied?: string;
}

export interface AccessOrganizationLoginDesign {
    /**
     * The background color on your login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of your login page.
     */
    footerText?: string;
    /**
     * The text at the top of your login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on your login page.
     */
    logoPath?: string;
    /**
     * The text color on your login page.
     */
    textColor?: string;
}

export interface AccessPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses?: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid?: string;
}

export interface AccessPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessPolicyExcludeAnyValidServiceToken;
    authContext?: outputs.AccessPolicyExcludeAuthContext;
    authMethod?: outputs.AccessPolicyExcludeAuthMethod;
    azureAd?: outputs.AccessPolicyExcludeAzureAd;
    certificate?: outputs.AccessPolicyExcludeCertificate;
    commonName?: outputs.AccessPolicyExcludeCommonName;
    devicePosture?: outputs.AccessPolicyExcludeDevicePosture;
    email?: outputs.AccessPolicyExcludeEmail;
    emailDomain?: outputs.AccessPolicyExcludeEmailDomain;
    emailList?: outputs.AccessPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessPolicyExcludeEveryone;
    externalEvaluation?: outputs.AccessPolicyExcludeExternalEvaluation;
    geo?: outputs.AccessPolicyExcludeGeo;
    githubOrganization?: outputs.AccessPolicyExcludeGithubOrganization;
    group?: outputs.AccessPolicyExcludeGroup;
    gsuite?: outputs.AccessPolicyExcludeGsuite;
    ip?: outputs.AccessPolicyExcludeIp;
    ipList?: outputs.AccessPolicyExcludeIpList;
    linkedAppToken?: outputs.AccessPolicyExcludeLinkedAppToken;
    loginMethod?: outputs.AccessPolicyExcludeLoginMethod;
    oidc?: outputs.AccessPolicyExcludeOidc;
    okta?: outputs.AccessPolicyExcludeOkta;
    saml?: outputs.AccessPolicyExcludeSaml;
    serviceToken?: outputs.AccessPolicyExcludeServiceToken;
}

export interface AccessPolicyExcludeAnyValidServiceToken {
}

export interface AccessPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeCertificate {
}

export interface AccessPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessPolicyExcludeEveryone {
}

export interface AccessPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessPolicyIncludeAnyValidServiceToken;
    authContext?: outputs.AccessPolicyIncludeAuthContext;
    authMethod?: outputs.AccessPolicyIncludeAuthMethod;
    azureAd?: outputs.AccessPolicyIncludeAzureAd;
    certificate?: outputs.AccessPolicyIncludeCertificate;
    commonName?: outputs.AccessPolicyIncludeCommonName;
    devicePosture?: outputs.AccessPolicyIncludeDevicePosture;
    email?: outputs.AccessPolicyIncludeEmail;
    emailDomain?: outputs.AccessPolicyIncludeEmailDomain;
    emailList?: outputs.AccessPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessPolicyIncludeEveryone;
    externalEvaluation?: outputs.AccessPolicyIncludeExternalEvaluation;
    geo?: outputs.AccessPolicyIncludeGeo;
    githubOrganization?: outputs.AccessPolicyIncludeGithubOrganization;
    group?: outputs.AccessPolicyIncludeGroup;
    gsuite?: outputs.AccessPolicyIncludeGsuite;
    ip?: outputs.AccessPolicyIncludeIp;
    ipList?: outputs.AccessPolicyIncludeIpList;
    linkedAppToken?: outputs.AccessPolicyIncludeLinkedAppToken;
    loginMethod?: outputs.AccessPolicyIncludeLoginMethod;
    oidc?: outputs.AccessPolicyIncludeOidc;
    okta?: outputs.AccessPolicyIncludeOkta;
    saml?: outputs.AccessPolicyIncludeSaml;
    serviceToken?: outputs.AccessPolicyIncludeServiceToken;
}

export interface AccessPolicyIncludeAnyValidServiceToken {
}

export interface AccessPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeCertificate {
}

export interface AccessPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessPolicyIncludeEveryone {
}

export interface AccessPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.AccessPolicyRequireAnyValidServiceToken;
    authContext?: outputs.AccessPolicyRequireAuthContext;
    authMethod?: outputs.AccessPolicyRequireAuthMethod;
    azureAd?: outputs.AccessPolicyRequireAzureAd;
    certificate?: outputs.AccessPolicyRequireCertificate;
    commonName?: outputs.AccessPolicyRequireCommonName;
    devicePosture?: outputs.AccessPolicyRequireDevicePosture;
    email?: outputs.AccessPolicyRequireEmail;
    emailDomain?: outputs.AccessPolicyRequireEmailDomain;
    emailList?: outputs.AccessPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.AccessPolicyRequireEveryone;
    externalEvaluation?: outputs.AccessPolicyRequireExternalEvaluation;
    geo?: outputs.AccessPolicyRequireGeo;
    githubOrganization?: outputs.AccessPolicyRequireGithubOrganization;
    group?: outputs.AccessPolicyRequireGroup;
    gsuite?: outputs.AccessPolicyRequireGsuite;
    ip?: outputs.AccessPolicyRequireIp;
    ipList?: outputs.AccessPolicyRequireIpList;
    linkedAppToken?: outputs.AccessPolicyRequireLinkedAppToken;
    loginMethod?: outputs.AccessPolicyRequireLoginMethod;
    oidc?: outputs.AccessPolicyRequireOidc;
    okta?: outputs.AccessPolicyRequireOkta;
    saml?: outputs.AccessPolicyRequireSaml;
    serviceToken?: outputs.AccessPolicyRequireServiceToken;
}

export interface AccessPolicyRequireAnyValidServiceToken {
}

export interface AccessPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface AccessPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireCertificate {
}

export interface AccessPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface AccessPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface AccessPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface AccessPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface AccessPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface AccessPolicyRequireEveryone {
}

export interface AccessPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface AccessPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface AccessPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface AccessPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface AccessPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface AccessPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface AccessPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface AccessPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface AccessPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface AccessPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface AccessRuleConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     * Available values: "ip", "ip6", "ipRange", "asn", "country".
     */
    target?: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value?: string;
}

export interface AccessRuleScope {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Defines an identifier.
     */
    id: string;
    /**
     * Defines the scope of the rule.
     * Available values: "user", "organization".
     */
    type: string;
}

export interface AccountDnsSettingsZoneDefaults {
    /**
     * Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
     */
    flattenAllCnames?: boolean;
    /**
     * Whether to enable Foundation DNS Advanced Nameservers on the zone.
     */
    foundationDns?: boolean;
    /**
     * Settings for this internal zone.
     */
    internalDns?: outputs.AccountDnsSettingsZoneDefaultsInternalDns;
    /**
     * Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
     */
    multiProvider?: boolean;
    /**
     * Settings determining the nameservers through which the zone should be available.
     */
    nameservers?: outputs.AccountDnsSettingsZoneDefaultsNameservers;
    /**
     * The time to live (TTL) of the zone's nameserver (NS) records.
     */
    nsTtl?: number;
    /**
     * Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
     */
    secondaryOverrides?: boolean;
    /**
     * Components of the zone's SOA record.
     */
    soa?: outputs.AccountDnsSettingsZoneDefaultsSoa;
    /**
     * Whether the zone mode is a regular or CDN/DNS only zone.
     * Available values: "standard", "cdn*only", "dns*only".
     */
    zoneMode?: string;
}

export interface AccountDnsSettingsZoneDefaultsInternalDns {
    /**
     * The ID of the zone to fallback to.
     */
    referenceZoneId?: string;
}

export interface AccountDnsSettingsZoneDefaultsNameservers {
    /**
     * Nameserver type
     * Available values: "cloudflare.standard", "cloudflare.standard.random", "custom.account", "custom.tenant".
     */
    type?: string;
}

export interface AccountDnsSettingsZoneDefaultsSoa {
    /**
     * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
     */
    expire?: number;
    /**
     * The time to live (TTL) for negative caching of records within the zone.
     */
    minTtl?: number;
    /**
     * The primary nameserver, which may be used for outbound zone transfers. If null, a Cloudflare-assigned value will be used.
     */
    mname?: string;
    /**
     * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
     */
    refresh?: number;
    /**
     * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
     */
    retry?: number;
    /**
     * The email address of the zone administrator, with the first label representing the local part of the email address.
     */
    rname?: string;
    /**
     * The time to live (TTL) of the SOA record itself.
     */
    ttl?: number;
}

export interface AccountMemberPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    access: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.AccountMemberPolicyPermissionGroup[];
    /**
     * A list of resource groups that the policy applies to.
     */
    resourceGroups: outputs.AccountMemberPolicyResourceGroup[];
}

export interface AccountMemberPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
}

export interface AccountMemberPolicyResourceGroup {
    /**
     * Identifier of the group.
     */
    id: string;
}

export interface AccountMemberUser {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
     */
    twoFactorAuthenticationEnabled: boolean;
}

export interface AccountSettings {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     */
    abuseContactEmail?: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     */
    enforceTwofactor: boolean;
}

export interface AccountSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency?: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged?: boolean;
    /**
     * The ID of the rate plan.
     * Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partnersEnterprise".
     */
    id?: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract?: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName?: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope?: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets?: string[];
}

export interface AccountTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp?: outputs.AccountTokenConditionRequestIp;
}

export interface AccountTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins?: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns?: string[];
}

export interface AccountTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.AccountTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface AccountTokenPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.AccountTokenPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface AccountTokenPolicyPermissionGroupMeta {
    key?: string;
    value?: string;
}

export interface AccountUnit {
    /**
     * Tenant unit ID
     */
    id?: string;
}

export interface AddressMapMembership {
    /**
     * The identifier for the membership (eg. a zone or account tag).
     */
    identifier?: string;
    /**
     * The type of the membership.
     * Available values: "zone", "account".
     */
    kind?: string;
}

export interface ApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic field, i.e., the header or cookie name.
     */
    name: string;
    /**
     * The type of characteristic.
     * Available values: "header", "cookie", "jwt".
     */
    type: string;
}

export interface ApiShieldError {
    code: number;
    documentationUrl: string;
    message: string;
    source: outputs.ApiShieldErrorSource;
}

export interface ApiShieldErrorSource {
    pointer: string;
}

export interface ApiShieldMessage {
    code: number;
    documentationUrl: string;
    message: string;
    source: outputs.ApiShieldMessageSource;
}

export interface ApiShieldMessageSource {
    pointer: string;
}

export interface ApiShieldOperationFeatures {
    /**
     * API Routing settings on endpoint.
     */
    apiRouting: outputs.ApiShieldOperationFeaturesApiRouting;
    confidenceIntervals: outputs.ApiShieldOperationFeaturesConfidenceIntervals;
    parameterSchemas: outputs.ApiShieldOperationFeaturesParameterSchemas;
    schemaInfo: outputs.ApiShieldOperationFeaturesSchemaInfo;
    thresholds: outputs.ApiShieldOperationFeaturesThresholds;
}

export interface ApiShieldOperationFeaturesApiRouting {
    lastUpdated: string;
    /**
     * Target route.
     */
    route: string;
}

export interface ApiShieldOperationFeaturesConfidenceIntervals {
    lastUpdated: string;
    suggestedThreshold: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold {
    confidenceIntervals: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals;
    /**
     * Suggested threshold.
     */
    mean: number;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals {
    /**
     * Upper and lower bound for percentile estimate
     */
    p90: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90;
    /**
     * Upper and lower bound for percentile estimate
     */
    p95: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95;
    /**
     * Upper and lower bound for percentile estimate
     */
    p99: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface ApiShieldOperationFeaturesParameterSchemas {
    lastUpdated: string;
    /**
     * An operation schema object containing a response.
     */
    parameterSchemas: outputs.ApiShieldOperationFeaturesParameterSchemasParameterSchemas;
}

export interface ApiShieldOperationFeaturesParameterSchemasParameterSchemas {
    /**
     * An array containing the learned parameter schemas.
     */
    parameters: string[];
    /**
     * An empty response object. This field is required to yield a valid operation schema.
     */
    responses: string;
}

export interface ApiShieldOperationFeaturesSchemaInfo {
    /**
     * Schema active on endpoint.
     */
    activeSchema: outputs.ApiShieldOperationFeaturesSchemaInfoActiveSchema;
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     */
    learnedAvailable: boolean;
    /**
     * Action taken on requests failing validation.
     * Available values: "none", "log", "block".
     */
    mitigationAction: string;
}

export interface ApiShieldOperationFeaturesSchemaInfoActiveSchema {
    createdAt: string;
    /**
     * UUID.
     */
    id: string;
    /**
     * True if schema is Cloudflare-provided.
     */
    isLearned: boolean;
    /**
     * Schema file name.
     */
    name: string;
}

export interface ApiShieldOperationFeaturesThresholds {
    /**
     * The total number of auth-ids seen across this calculation.
     */
    authIdTokens: number;
    /**
     * The number of data points used for the threshold suggestion calculation.
     */
    dataPoints: number;
    lastUpdated: string;
    /**
     * The p50 quantile of requests (in period_seconds).
     */
    p50: number;
    /**
     * The p90 quantile of requests (in period_seconds).
     */
    p90: number;
    /**
     * The p99 quantile of requests (in period_seconds).
     */
    p99: number;
    /**
     * The period over which this threshold is suggested.
     */
    periodSeconds: number;
    /**
     * The estimated number of requests covered by these calculations.
     */
    requests: number;
    /**
     * The suggested threshold in requests done by the same auth*id or period*seconds.
     */
    suggestedThreshold: number;
}

export interface ApiShieldSchemaSchema {
    createdAt: string;
    /**
     * Kind of schema
     * Available values: "openapiV3".
     */
    kind: string;
    /**
     * Name of the schema
     */
    name: string;
    /**
     * UUID.
     */
    schemaId: string;
    /**
     * Source of the schema
     */
    source: string;
    /**
     * Flag whether schema is enabled for validation.
     */
    validationEnabled: boolean;
}

export interface ApiShieldSchemaUploadDetails {
    /**
     * Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
     */
    warnings: outputs.ApiShieldSchemaUploadDetailsWarning[];
}

export interface ApiShieldSchemaUploadDetailsWarning {
    /**
     * Code that identifies the event that occurred.
     */
    code: number;
    /**
     * JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
     */
    locations: string[];
    /**
     * Diagnostic message that describes the event.
     */
    message: string;
}

export interface ApiTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp?: outputs.ApiTokenConditionRequestIp;
}

export interface ApiTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins?: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns?: string[];
}

export interface ApiTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.ApiTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface ApiTokenPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta?: outputs.ApiTokenPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface ApiTokenPolicyPermissionGroupMeta {
    key?: string;
    value?: string;
}

export interface AuthenticatedOriginPullsConfig {
    /**
     * Certificate identifier tag.
     */
    certId?: string;
    /**
     * Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
     */
    enabled?: boolean;
    /**
     * The hostname on the origin for which the client certificate uploaded will be used.
     */
    hostname?: string;
}

export interface BotManagementStaleZoneConfiguration {
    /**
     * Indicates that the zone's Bot Fight Mode is turned on.
     */
    fightMode: boolean;
    /**
     * Indicates that the zone's wordpress optimization for SBFM is turned on.
     */
    optimizeWordpress: boolean;
    /**
     * Indicates that the zone's definitely automated requests are being blocked or challenged.
     */
    sbfmDefinitelyAutomated: string;
    /**
     * Indicates that the zone's likely automated requests are being blocked or challenged.
     */
    sbfmLikelyAutomated: string;
    /**
     * Indicates that the zone's static resource protection is turned on.
     */
    sbfmStaticResourceProtection: string;
    /**
     * Indicates that the zone's verified bot requests are being blocked.
     */
    sbfmVerifiedBots: string;
    /**
     * Indicates that the zone's session score tracking is disabled.
     */
    suppressSessionScore: boolean;
}

export interface CertificatePackValidationError {
    /**
     * A domain validation error.
     */
    message: string;
}

export interface CertificatePackValidationRecord {
    /**
     * The set of email addresses that the certificate authority (CA) will use to complete domain validation.
     */
    emails: string[];
    /**
     * The content that the certificate authority (CA) will expect to find at the httpUrl during the domain validation.
     */
    httpBody: string;
    /**
     * The url that will be checked during domain validation.
     */
    httpUrl: string;
    /**
     * The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
     */
    txtName: string;
    /**
     * The TXT record that the certificate authority (CA) will check during domain validation.
     */
    txtValue: string;
}

export interface CloudConnectorRulesRule {
    description?: string;
    enabled?: boolean;
    expression?: string;
    id: string;
    /**
     * Parameters of Cloud Connector Rule
     */
    parameters?: outputs.CloudConnectorRulesRuleParameters;
    /**
     * Cloud Provider type
     * Available values: "aws*s3", "cloudflare*r2", "gcp*storage", "azure*storage".
     */
    provider?: string;
}

export interface CloudConnectorRulesRuleParameters {
    /**
     * Host to perform Cloud Connection to
     */
    host?: string;
}

export interface ContentScanningExpressionBody {
    /**
     * Defines the ruleset expression to use in matching content objects.
     */
    payload: string;
}

export interface CustomHostnameOwnershipVerification {
    /**
     * DNS Name for record.
     */
    name: string;
    /**
     * DNS Record type.
     * Available values: "txt".
     */
    type: string;
    /**
     * Content for the record.
     */
    value: string;
}

export interface CustomHostnameOwnershipVerificationHttp {
    /**
     * Token to be served.
     */
    httpBody: string;
    /**
     * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
     */
    httpUrl: string;
}

export interface CustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: "ubiquitous", "optimal", "force".
     */
    bundleMethod: string;
    /**
     * The Certificate Authority that will issue the certificate
     * Available values: "digicert", "google", "lets*encrypt", "ssl*com".
     */
    certificateAuthority: string;
    /**
     * Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
     */
    cloudflareBranding?: boolean;
    /**
     * Array of custom certificate and key pairs (1 or 2 pairs allowed)
     */
    customCertBundles?: outputs.CustomHostnameSslCustomCertBundle[];
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate?: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: string;
    /**
     * Domain control validation (DCV) method used for this hostname.
     * Available values: "http", "txt", "email".
     */
    method?: string;
    /**
     * SSL specific settings.
     */
    settings?: outputs.CustomHostnameSslSettings;
    /**
     * Level of validation to be used for this hostname. Domain validation (dv) must be used.
     * Available values: "dv".
     */
    type?: string;
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: boolean;
}

export interface CustomHostnameSslCustomCertBundle {
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey: string;
}

export interface CustomHostnameSslSettings {
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers?: string[];
    /**
     * Whether or not Early Hints is enabled.
     * Available values: "on", "off".
     */
    earlyHints?: string;
    /**
     * Whether or not HTTP2 is enabled.
     * Available values: "on", "off".
     */
    http2?: string;
    /**
     * The minimum TLS version supported.
     * Available values: "1.0", "1.1", "1.2", "1.3".
     */
    minTlsVersion?: string;
    /**
     * Whether or not TLS 1.3 is enabled.
     * Available values: "on", "off".
     */
    tls13?: string;
}

export interface CustomSslGeoRestrictions {
    /**
     * Available values: "us", "eu", "highestSecurity".
     */
    label?: string;
}

export interface CustomSslKeylessServer {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     * Available values: "active", "deleted".
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.CustomSslKeylessServerTunnel;
}

export interface CustomSslKeylessServerTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface D1DatabaseReadReplication {
    /**
     * The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
     * Available values: "auto", "disabled".
     */
    mode: string;
}

export interface DeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256?: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface DevicePostureIntegrationConfig {
    /**
     * If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `apiUrl`.
     */
    accessClientId?: string;
    /**
     * If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `apiUrl`.
     */
    accessClientSecret?: string;
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl?: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl?: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId?: string;
    /**
     * The Uptycs client secret.
     */
    clientKey?: string;
    /**
     * The Workspace One client secret provided in the Workspace One Admin Dashboard.
     */
    clientSecret?: string;
    /**
     * The Crowdstrike customer ID.
     */
    customerId?: string;
}

export interface DevicePostureRuleInput {
    /**
     * The Number of active threats.
     */
    activeThreats?: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks?: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey?: boolean;
    /**
     * Common Name that is protected by the certificate.
     */
    cn?: string;
    /**
     * Compliance Status.
     * Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
     */
    complianceStatus?: string;
    /**
     * Posture Integration ID.
     */
    connectionId?: string;
    /**
     * Count Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    countOperator?: string;
    /**
     * Domain.
     */
    domain?: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen?: string;
    /**
     * Enabled.
     */
    enabled?: boolean;
    /**
     * Whether or not file exists.
     */
    exists?: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used.
     */
    extendedKeyUsages?: string[];
    /**
     * List ID.
     */
    id?: string;
    /**
     * Whether device is infected.
     */
    infected?: boolean;
    /**
     * Whether device is active.
     */
    isActive?: boolean;
    /**
     * The Number of Issues.
     */
    issueCount?: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen?: string;
    locations?: outputs.DevicePostureRuleInputLocations;
    /**
     * Network status of device.
     * Available values: "connected", "disconnected", "disconnecting", "connecting".
     */
    networkStatus?: string;
    /**
     * Operating system.
     * Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
     */
    operatingSystem?: string;
    /**
     * Agent operational state.
     * Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
     */
    operationalState?: string;
    /**
     * Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    operator?: string;
    /**
     * Os Version.
     */
    os?: string;
    /**
     * Operating System Distribution Name (linux only).
     */
    osDistroName?: string;
    /**
     * Version of OS Distribution (linux only).
     */
    osDistroRevision?: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
     */
    osVersionExtra?: string;
    /**
     * Overall.
     */
    overall?: string;
    /**
     * File path.
     */
    path?: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll?: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     * Available values: "low", "medium", "high", "critical".
     */
    riskLevel?: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score?: number;
    /**
     * Score Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    scoreOperator?: string;
    /**
     * SensorConfig.
     */
    sensorConfig?: string;
    /**
     * SHA-256.
     */
    sha256?: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     * Available values: "online", "offline", "unknown".
     */
    state?: string;
    /**
     * List of certificate Subject Alternative Names.
     */
    subjectAlternativeNames?: string[];
    /**
     * Signing certificate thumbprint.
     */
    thumbprint?: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore?: number;
    /**
     * Version of OS.
     */
    version?: string;
    /**
     * Version Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    versionOperator?: string;
}

export interface DevicePostureRuleInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths?: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores?: string[];
}

export interface DevicePostureRuleMatch {
    /**
     * Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
     */
    platform?: string;
}

export interface DlpCustomProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.DlpCustomProfileContextAwarenessSkip;
}

export interface DlpCustomProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface DlpCustomProfileEntry {
    enabled: boolean;
    entryId?: string;
    name: string;
    pattern: outputs.DlpCustomProfileEntryPattern;
}

export interface DlpCustomProfileEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation?: string;
}

export interface DlpCustomProfileSharedEntry {
    enabled: boolean;
    entryId: string;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
     */
    entryType: string;
}

export interface DlpPredefinedProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.DlpPredefinedProfileContextAwarenessSkip;
}

export interface DlpPredefinedProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface DlpPredefinedProfileEntry {
    enabled: boolean;
    id: string;
}

export interface DnsFirewallAttackMitigation {
    /**
     * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
     */
    enabled?: boolean;
    /**
     * Only mitigate attacks when upstream servers seem unhealthy
     */
    onlyWhenUpstreamUnhealthy: boolean;
}

export interface DnsRecordData {
    /**
     * Algorithm.
     */
    algorithm?: number;
    /**
     * Altitude of location in meters.
     */
    altitude?: number;
    /**
     * Certificate.
     */
    certificate?: string;
    /**
     * Digest.
     */
    digest?: string;
    /**
     * Digest Type.
     */
    digestType?: number;
    /**
     * Fingerprint.
     */
    fingerprint?: string;
    /**
     * Flags for the CAA record.
     */
    flags?: any;
    /**
     * Key Tag.
     */
    keyTag?: number;
    /**
     * Degrees of latitude.
     */
    latDegrees?: number;
    /**
     * Latitude direction.
     * Available values: "N", "S".
     */
    latDirection?: string;
    /**
     * Minutes of latitude.
     */
    latMinutes?: number;
    /**
     * Seconds of latitude.
     */
    latSeconds?: number;
    /**
     * Degrees of longitude.
     */
    longDegrees?: number;
    /**
     * Longitude direction.
     * Available values: "E", "W".
     */
    longDirection?: string;
    /**
     * Minutes of longitude.
     */
    longMinutes?: number;
    /**
     * Seconds of longitude.
     */
    longSeconds?: number;
    /**
     * Matching Type.
     */
    matchingType?: number;
    /**
     * Order.
     */
    order?: number;
    /**
     * The port of the service.
     */
    port?: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz?: number;
    /**
     * Vertical precision of location.
     */
    precisionVert?: number;
    /**
     * Preference.
     */
    preference?: number;
    /**
     * Priority.
     */
    priority?: number;
    /**
     * Protocol.
     */
    protocol?: number;
    /**
     * Public Key.
     */
    publicKey?: string;
    /**
     * Regex.
     */
    regex?: string;
    /**
     * Replacement.
     */
    replacement?: string;
    /**
     * Selector.
     */
    selector?: number;
    /**
     * Service.
     */
    service?: string;
    /**
     * Size of location in meters.
     */
    size?: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag?: string;
    /**
     * Target.
     */
    target?: string;
    /**
     * Type.
     */
    type?: number;
    /**
     * Usage.
     */
    usage?: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value?: string;
    /**
     * The record weight.
     */
    weight?: number;
}

export interface DnsRecordSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface EmailRoutingCatchAllAction {
    /**
     * Type of action for catch-all rule.
     * Available values: "drop", "forward", "worker".
     */
    type: string;
    values?: string[];
}

export interface EmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Default is 'all'.
     * Available values: "all".
     */
    type: string;
}

export interface EmailRoutingDnsError {
    code: number;
    documentationUrl: string;
    message: string;
    source: outputs.EmailRoutingDnsErrorSource;
}

export interface EmailRoutingDnsErrorSource {
    pointer: string;
}

export interface EmailRoutingDnsMessage {
    code: number;
    documentationUrl: string;
    message: string;
    source: outputs.EmailRoutingDnsMessageSource;
}

export interface EmailRoutingDnsMessageSource {
    pointer: string;
}

export interface EmailRoutingDnsResult {
    /**
     * DNS record content.
     */
    content: string;
    errors: outputs.EmailRoutingDnsResultError[];
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    records: outputs.EmailRoutingDnsResultRecord[];
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     * Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface EmailRoutingDnsResultError {
    code: string;
    /**
     * List of records needed to enable an Email Routing zone.
     */
    missing: outputs.EmailRoutingDnsResultErrorMissing;
}

export interface EmailRoutingDnsResultErrorMissing {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     * Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface EmailRoutingDnsResultInfo {
    /**
     * Total number of results for the requested service.
     */
    count: number;
    /**
     * Current page within paginated list of results.
     */
    page: number;
    /**
     * Number of results per page of results.
     */
    perPage: number;
    /**
     * Total results available without any search parameters.
     */
    totalCount: number;
}

export interface EmailRoutingDnsResultRecord {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     * Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface EmailRoutingRuleAction {
    /**
     * Type of supported action.
     * Available values: "drop", "forward", "worker".
     */
    type: string;
    values?: string[];
}

export interface EmailRoutingRuleMatcher {
    /**
     * Field for type matcher.
     * Available values: "to".
     */
    field?: string;
    /**
     * Type of matcher.
     * Available values: "all", "literal".
     */
    type: string;
    /**
     * Value for matcher.
     */
    value?: string;
}

export interface EmailSecurityTrustedDomainsBody {
    comments?: string;
    /**
     * Select to prevent recently registered domains from triggering a
     * Suspicious or Malicious disposition.
     */
    isRecent: boolean;
    isRegex: boolean;
    /**
     * Select for partner or other approved domains that have similar
     * spelling to your connected domains. Prevents listed domains from
     * triggering a Spoof disposition.
     */
    isSimilarity: boolean;
    pattern: string;
}

export interface FilterBody {
    /**
     * An informative summary of the filter.
     */
    description?: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression?: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused?: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref?: string;
}

export interface FirewallRuleAction {
    /**
     * The action to perform.
     * Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
     */
    mode?: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response?: outputs.FirewallRuleActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout?: number;
}

export interface FirewallRuleActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body?: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType?: string;
}

export interface FirewallRuleFilter {
    /**
     * An informative summary of the filter.
     */
    description?: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression?: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused?: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref?: string;
}

export interface GetAccessRuleConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     * Available values: "ip", "ip6", "ipRange", "asn", "country".
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetAccessRuleFilter {
    configuration?: outputs.GetAccessRuleFilterConfiguration;
    /**
     * Defines the direction used to sort returned rules.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Defines the search requirements. When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
     * Available values: "any", "all".
     */
    match: string;
    /**
     * The action to apply to a matched request.
     * Available values: "block", "challenge", "whitelist", "js*challenge", "managed*challenge".
     */
    mode?: string;
    /**
     * Defines the string to search for in the notes of existing IP Access rules.
     * Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
     */
    notes?: string;
    /**
     * Defines the field used to sort returned rules.
     * Available values: "configuration.target", "configuration.value", "mode".
     */
    order?: string;
}

export interface GetAccessRuleFilterConfiguration {
    /**
     * Defines the target to search in existing rules.
     * Available values: "ip", "ipRange", "asn", "country".
     */
    target?: string;
    /**
     * Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
     * Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
     */
    value?: string;
}

export interface GetAccessRuleScope {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Defines an identifier.
     */
    id: string;
    /**
     * Defines the scope of the rule.
     * Available values: "user", "organization".
     */
    type: string;
}

export interface GetAccessRulesConfiguration {
    /**
     * Defines the target to search in existing rules.
     * Available values: "ip", "ipRange", "asn", "country".
     */
    target?: string;
    /**
     * Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
     * Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
     */
    value?: string;
}

export interface GetAccessRulesResult {
    /**
     * The available actions that a rule can apply to a matched request.
     */
    allowedModes: string[];
    /**
     * The rule configuration.
     */
    configuration: outputs.GetAccessRulesResultConfiguration;
    /**
     * The timestamp of when the rule was created.
     */
    createdOn: string;
    /**
     * The unique identifier of the IP Access rule.
     */
    id: string;
    /**
     * The action to apply to a matched request.
     * Available values: "block", "challenge", "whitelist", "js*challenge", "managed*challenge".
     */
    mode: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    modifiedOn: string;
    /**
     * An informative summary of the rule, typically used as a reminder or explanation.
     */
    notes: string;
    /**
     * All zones owned by the user will have the rule applied.
     */
    scope: outputs.GetAccessRulesResultScope;
}

export interface GetAccessRulesResultConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     * Available values: "ip", "ip6", "ipRange", "asn", "country".
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetAccessRulesResultScope {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Defines an identifier.
     */
    id: string;
    /**
     * Defines the scope of the rule.
     * Available values: "user", "organization".
     */
    type: string;
}

export interface GetAccountApiTokenPermissionGroupsListResult {
    /**
     * Public ID.
     */
    id: string;
    /**
     * Permission Group Name
     */
    name: string;
    /**
     * Resources to which the Permission Group is scoped
     */
    scopes: string[];
}

export interface GetAccountDnsSettingsInternalViewFilter {
    /**
     * Direction to order DNS views in.
     * Available values: "asc", "desc".
     */
    direction: string;
    /**
     * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
     * Available values: "any", "all".
     */
    match: string;
    name?: outputs.GetAccountDnsSettingsInternalViewFilterName;
    /**
     * Field to order DNS views by.
     * Available values: "name", "created*on", "modified*on".
     */
    order?: string;
    /**
     * A zone ID that exists in the zones list for the view.
     */
    zoneId?: string;
    /**
     * A zone name that exists in the zones list for the view.
     */
    zoneName?: string;
}

export interface GetAccountDnsSettingsInternalViewFilterName {
    /**
     * Substring of the DNS view name.
     */
    contains?: string;
    /**
     * Suffix of the DNS view name.
     */
    endswith?: string;
    /**
     * Exact value of the DNS view name.
     */
    exact?: string;
    /**
     * Prefix of the DNS view name.
     */
    startswith?: string;
}

export interface GetAccountDnsSettingsInternalViewsName {
    /**
     * Substring of the DNS view name.
     */
    contains?: string;
    /**
     * Suffix of the DNS view name.
     */
    endswith?: string;
    /**
     * Exact value of the DNS view name.
     */
    exact?: string;
    /**
     * Prefix of the DNS view name.
     */
    startswith?: string;
}

export interface GetAccountDnsSettingsInternalViewsResult {
    /**
     * When the view was created.
     */
    createdTime: string;
    /**
     * Identifier.
     */
    id: string;
    /**
     * When the view was last modified.
     */
    modifiedTime: string;
    /**
     * The name of the view.
     */
    name: string;
    /**
     * The list of zones linked to this view.
     */
    zones: string[];
}

export interface GetAccountDnsSettingsZoneDefaults {
    /**
     * Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
     */
    flattenAllCnames: boolean;
    /**
     * Whether to enable Foundation DNS Advanced Nameservers on the zone.
     */
    foundationDns: boolean;
    /**
     * Settings for this internal zone.
     */
    internalDns: outputs.GetAccountDnsSettingsZoneDefaultsInternalDns;
    /**
     * Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
     */
    multiProvider: boolean;
    /**
     * Settings determining the nameservers through which the zone should be available.
     */
    nameservers: outputs.GetAccountDnsSettingsZoneDefaultsNameservers;
    /**
     * The time to live (TTL) of the zone's nameserver (NS) records.
     */
    nsTtl: number;
    /**
     * Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
     */
    secondaryOverrides: boolean;
    /**
     * Components of the zone's SOA record.
     */
    soa: outputs.GetAccountDnsSettingsZoneDefaultsSoa;
    /**
     * Whether the zone mode is a regular or CDN/DNS only zone.
     * Available values: "standard", "cdn*only", "dns*only".
     */
    zoneMode: string;
}

export interface GetAccountDnsSettingsZoneDefaultsInternalDns {
    /**
     * The ID of the zone to fallback to.
     */
    referenceZoneId: string;
}

export interface GetAccountDnsSettingsZoneDefaultsNameservers {
    /**
     * Nameserver type
     * Available values: "cloudflare.standard", "cloudflare.standard.random", "custom.account", "custom.tenant".
     */
    type: string;
}

export interface GetAccountDnsSettingsZoneDefaultsSoa {
    /**
     * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
     */
    expire: number;
    /**
     * The time to live (TTL) for negative caching of records within the zone.
     */
    minTtl: number;
    /**
     * The primary nameserver, which may be used for outbound zone transfers. If null, a Cloudflare-assigned value will be used.
     */
    mname: string;
    /**
     * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
     */
    refresh: number;
    /**
     * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
     */
    retry: number;
    /**
     * The email address of the zone administrator, with the first label representing the local part of the email address.
     */
    rname: string;
    /**
     * The time to live (TTL) of the SOA record itself.
     */
    ttl: number;
}

export interface GetAccountFilter {
    /**
     * Direction to order results.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Name of the account.
     */
    name?: string;
}

export interface GetAccountMemberFilter {
    /**
     * Direction to order results.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Field to order results by.
     * Available values: "user.first*name", "user.last*name", "user.email", "status".
     */
    order?: string;
    /**
     * A member's status in the account.
     * Available values: "accepted", "pending", "rejected".
     */
    status?: string;
}

export interface GetAccountMemberPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    access: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountMemberPolicyPermissionGroup[];
    /**
     * A list of resource groups that the policy applies to.
     */
    resourceGroups: outputs.GetAccountMemberPolicyResourceGroup[];
}

export interface GetAccountMemberPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountMemberPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetAccountMemberPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMemberPolicyResourceGroup {
    /**
     * Identifier of the resource group.
     */
    id: string;
    /**
     * Attributes associated to the resource group.
     */
    meta: outputs.GetAccountMemberPolicyResourceGroupMeta;
    /**
     * Name of the resource group.
     */
    name: string;
    /**
     * The scope associated to the resource group
     */
    scopes: outputs.GetAccountMemberPolicyResourceGroupScope[];
}

export interface GetAccountMemberPolicyResourceGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMemberPolicyResourceGroupScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetAccountMemberPolicyResourceGroupScopeObject[];
}

export interface GetAccountMemberPolicyResourceGroupScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetAccountMemberRole {
    /**
     * Description of role's permissions.
     */
    description: string;
    /**
     * Role identifier tag.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
    permissions: outputs.GetAccountMemberRolePermissions;
}

export interface GetAccountMemberRolePermissions {
    analytics: outputs.GetAccountMemberRolePermissionsAnalytics;
    billing: outputs.GetAccountMemberRolePermissionsBilling;
    cachePurge: outputs.GetAccountMemberRolePermissionsCachePurge;
    dns: outputs.GetAccountMemberRolePermissionsDns;
    dnsRecords: outputs.GetAccountMemberRolePermissionsDnsRecords;
    lb: outputs.GetAccountMemberRolePermissionsLb;
    logs: outputs.GetAccountMemberRolePermissionsLogs;
    organization: outputs.GetAccountMemberRolePermissionsOrganization;
    ssl: outputs.GetAccountMemberRolePermissionsSsl;
    waf: outputs.GetAccountMemberRolePermissionsWaf;
    zoneSettings: outputs.GetAccountMemberRolePermissionsZoneSettings;
    zones: outputs.GetAccountMemberRolePermissionsZones;
}

export interface GetAccountMemberRolePermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberUser {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
     */
    twoFactorAuthenticationEnabled: boolean;
}

export interface GetAccountMembersResult {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Membership identifier tag.
     */
    id: string;
    /**
     * Access policy for the membership
     */
    policies: outputs.GetAccountMembersResultPolicy[];
    /**
     * Roles assigned to this Member.
     */
    roles: outputs.GetAccountMembersResultRole[];
    /**
     * A member's status in the account.
     * Available values: "accepted", "pending".
     */
    status: string;
    /**
     * Details of the user associated to the membership.
     */
    user: outputs.GetAccountMembersResultUser;
}

export interface GetAccountMembersResultPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    access: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountMembersResultPolicyPermissionGroup[];
    /**
     * A list of resource groups that the policy applies to.
     */
    resourceGroups: outputs.GetAccountMembersResultPolicyResourceGroup[];
}

export interface GetAccountMembersResultPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountMembersResultPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetAccountMembersResultPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMembersResultPolicyResourceGroup {
    /**
     * Identifier of the resource group.
     */
    id: string;
    /**
     * Attributes associated to the resource group.
     */
    meta: outputs.GetAccountMembersResultPolicyResourceGroupMeta;
    /**
     * Name of the resource group.
     */
    name: string;
    /**
     * The scope associated to the resource group
     */
    scopes: outputs.GetAccountMembersResultPolicyResourceGroupScope[];
}

export interface GetAccountMembersResultPolicyResourceGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMembersResultPolicyResourceGroupScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetAccountMembersResultPolicyResourceGroupScopeObject[];
}

export interface GetAccountMembersResultPolicyResourceGroupScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetAccountMembersResultRole {
    /**
     * Description of role's permissions.
     */
    description: string;
    /**
     * Role identifier tag.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
    permissions: outputs.GetAccountMembersResultRolePermissions;
}

export interface GetAccountMembersResultRolePermissions {
    analytics: outputs.GetAccountMembersResultRolePermissionsAnalytics;
    billing: outputs.GetAccountMembersResultRolePermissionsBilling;
    cachePurge: outputs.GetAccountMembersResultRolePermissionsCachePurge;
    dns: outputs.GetAccountMembersResultRolePermissionsDns;
    dnsRecords: outputs.GetAccountMembersResultRolePermissionsDnsRecords;
    lb: outputs.GetAccountMembersResultRolePermissionsLb;
    logs: outputs.GetAccountMembersResultRolePermissionsLogs;
    organization: outputs.GetAccountMembersResultRolePermissionsOrganization;
    ssl: outputs.GetAccountMembersResultRolePermissionsSsl;
    waf: outputs.GetAccountMembersResultRolePermissionsWaf;
    zoneSettings: outputs.GetAccountMembersResultRolePermissionsZoneSettings;
    zones: outputs.GetAccountMembersResultRolePermissionsZones;
}

export interface GetAccountMembersResultRolePermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultUser {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
     */
    twoFactorAuthenticationEnabled: boolean;
}

export interface GetAccountPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountPermissionGroupsResult {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountPermissionGroupsResultMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetAccountPermissionGroupsResultMeta {
    key: string;
    value: string;
}

export interface GetAccountRolePermissions {
    analytics: outputs.GetAccountRolePermissionsAnalytics;
    billing: outputs.GetAccountRolePermissionsBilling;
    cachePurge: outputs.GetAccountRolePermissionsCachePurge;
    dns: outputs.GetAccountRolePermissionsDns;
    dnsRecords: outputs.GetAccountRolePermissionsDnsRecords;
    lb: outputs.GetAccountRolePermissionsLb;
    logs: outputs.GetAccountRolePermissionsLogs;
    organization: outputs.GetAccountRolePermissionsOrganization;
    ssl: outputs.GetAccountRolePermissionsSsl;
    waf: outputs.GetAccountRolePermissionsWaf;
    zoneSettings: outputs.GetAccountRolePermissionsZoneSettings;
    zones: outputs.GetAccountRolePermissionsZones;
}

export interface GetAccountRolePermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResult {
    /**
     * Description of role's permissions.
     */
    description: string;
    /**
     * Role identifier tag.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
    permissions: outputs.GetAccountRolesResultPermissions;
}

export interface GetAccountRolesResultPermissions {
    analytics: outputs.GetAccountRolesResultPermissionsAnalytics;
    billing: outputs.GetAccountRolesResultPermissionsBilling;
    cachePurge: outputs.GetAccountRolesResultPermissionsCachePurge;
    dns: outputs.GetAccountRolesResultPermissionsDns;
    dnsRecords: outputs.GetAccountRolesResultPermissionsDnsRecords;
    lb: outputs.GetAccountRolesResultPermissionsLb;
    logs: outputs.GetAccountRolesResultPermissionsLogs;
    organization: outputs.GetAccountRolesResultPermissionsOrganization;
    ssl: outputs.GetAccountRolesResultPermissionsSsl;
    waf: outputs.GetAccountRolesResultPermissionsWaf;
    zoneSettings: outputs.GetAccountRolesResultPermissionsZoneSettings;
    zones: outputs.GetAccountRolesResultPermissionsZones;
}

export interface GetAccountRolesResultPermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountSettings {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     */
    abuseContactEmail: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     */
    enforceTwofactor: boolean;
}

export interface GetAccountSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged: boolean;
    /**
     * The ID of the rate plan.
     * Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partnersEnterprise".
     */
    id: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets: string[];
}

export interface GetAccountTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetAccountTokenConditionRequestIp;
}

export interface GetAccountTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetAccountTokenFilter {
    /**
     * Direction to order results.
     * Available values: "asc", "desc".
     */
    direction?: string;
}

export interface GetAccountTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetAccountTokenPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountTokenPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetAccountTokenPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountTokensResult {
    condition: outputs.GetAccountTokensResultCondition;
    /**
     * The expiration time on or after which the JWT MUST NOT be accepted for processing.
     */
    expiresOn: string;
    /**
     * Token identifier tag.
     */
    id: string;
    /**
     * The time on which the token was created.
     */
    issuedOn: string;
    /**
     * Last time the token was used.
     */
    lastUsedOn: string;
    /**
     * Last time the token was modified.
     */
    modifiedOn: string;
    /**
     * Token name.
     */
    name: string;
    /**
     * The time before which the token MUST NOT be accepted for processing.
     */
    notBefore: string;
    /**
     * List of access policies assigned to the token.
     */
    policies: outputs.GetAccountTokensResultPolicy[];
    /**
     * Status of the token.
     * Available values: "active", "disabled", "expired".
     */
    status: string;
}

export interface GetAccountTokensResultCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetAccountTokensResultConditionRequestIp;
}

export interface GetAccountTokensResultConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetAccountTokensResultPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountTokensResultPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetAccountTokensResultPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountTokensResultPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetAccountTokensResultPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountsResult {
    /**
     * Timestamp for the creation of the account
     */
    createdOn: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * Account name
     */
    name: string;
    /**
     * Account settings
     */
    settings: outputs.GetAccountsResultSettings;
    /**
     * Available values: "standard", "enterprise".
     */
    type: string;
}

export interface GetAccountsResultSettings {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     */
    abuseContactEmail: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     */
    enforceTwofactor: boolean;
}

export interface GetAddressMapIp {
    createdAt: string;
    /**
     * An IPv4 or IPv6 address.
     */
    ip: string;
}

export interface GetAddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete: boolean;
    createdAt: string;
    /**
     * The identifier for the membership (eg. a zone or account tag).
     */
    identifier: string;
    /**
     * The type of the membership.
     * Available values: "zone", "account".
     */
    kind: string;
}

export interface GetAddressMapsResult {
    /**
     * If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
     */
    canDelete: boolean;
    /**
     * If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
     */
    canModifyIps: boolean;
    createdAt: string;
    /**
     * If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
     */
    defaultSni: string;
    /**
     * An optional description field which may be used to describe the types of IPs or zones on the map.
     */
    description: string;
    /**
     * Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
     */
    enabled: boolean;
    /**
     * Identifier of an Address Map.
     */
    id: string;
    modifiedAt: string;
}

export interface GetApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic field, i.e., the header or cookie name.
     */
    name: string;
    /**
     * The type of characteristic.
     * Available values: "header", "cookie", "jwt".
     */
    type: string;
}

export interface GetApiShieldDiscoveryOperationsResult {
    /**
     * The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
     */
    endpoint: string;
    features: outputs.GetApiShieldDiscoveryOperationsResultFeatures;
    /**
     * RFC3986-compliant host.
     */
    host: string;
    /**
     * UUID.
     */
    id: string;
    lastUpdated: string;
    /**
     * The HTTP method used to access the endpoint.
     * Available values: "GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE".
     */
    method: string;
    /**
     * API discovery engine(s) that discovered this operation
     */
    origins: string[];
    /**
     * State of operation in API Discovery
     *   * `review` - Operation is not saved into API Shield Endpoint Management
     *   * `saved` - Operation is saved into API Shield Endpoint Management
     *   * `ignored` - Operation is marked as ignored
     * Available values: "review", "saved", "ignored".
     */
    state: string;
}

export interface GetApiShieldDiscoveryOperationsResultFeatures {
    trafficStats: outputs.GetApiShieldDiscoveryOperationsResultFeaturesTrafficStats;
}

export interface GetApiShieldDiscoveryOperationsResultFeaturesTrafficStats {
    lastUpdated: string;
    /**
     * The period in seconds these statistics were computed over
     */
    periodSeconds: number;
    /**
     * The average number of requests seen during this period
     */
    requests: number;
}

export interface GetApiShieldOperationFeatures {
    /**
     * API Routing settings on endpoint.
     */
    apiRouting: outputs.GetApiShieldOperationFeaturesApiRouting;
    confidenceIntervals: outputs.GetApiShieldOperationFeaturesConfidenceIntervals;
    parameterSchemas: outputs.GetApiShieldOperationFeaturesParameterSchemas;
    schemaInfo: outputs.GetApiShieldOperationFeaturesSchemaInfo;
    thresholds: outputs.GetApiShieldOperationFeaturesThresholds;
}

export interface GetApiShieldOperationFeaturesApiRouting {
    lastUpdated: string;
    /**
     * Target route.
     */
    route: string;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervals {
    lastUpdated: string;
    suggestedThreshold: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold {
    confidenceIntervals: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals;
    /**
     * Suggested threshold.
     */
    mean: number;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals {
    /**
     * Upper and lower bound for percentile estimate
     */
    p90: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90;
    /**
     * Upper and lower bound for percentile estimate
     */
    p95: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95;
    /**
     * Upper and lower bound for percentile estimate
     */
    p99: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationFeaturesParameterSchemas {
    lastUpdated: string;
    /**
     * An operation schema object containing a response.
     */
    parameterSchemas: outputs.GetApiShieldOperationFeaturesParameterSchemasParameterSchemas;
}

export interface GetApiShieldOperationFeaturesParameterSchemasParameterSchemas {
    /**
     * An array containing the learned parameter schemas.
     */
    parameters: string[];
    /**
     * An empty response object. This field is required to yield a valid operation schema.
     */
    responses: string;
}

export interface GetApiShieldOperationFeaturesSchemaInfo {
    /**
     * Schema active on endpoint.
     */
    activeSchema: outputs.GetApiShieldOperationFeaturesSchemaInfoActiveSchema;
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     */
    learnedAvailable: boolean;
    /**
     * Action taken on requests failing validation.
     * Available values: "none", "log", "block".
     */
    mitigationAction: string;
}

export interface GetApiShieldOperationFeaturesSchemaInfoActiveSchema {
    createdAt: string;
    /**
     * UUID.
     */
    id: string;
    /**
     * True if schema is Cloudflare-provided.
     */
    isLearned: boolean;
    /**
     * Schema file name.
     */
    name: string;
}

export interface GetApiShieldOperationFeaturesThresholds {
    /**
     * The total number of auth-ids seen across this calculation.
     */
    authIdTokens: number;
    /**
     * The number of data points used for the threshold suggestion calculation.
     */
    dataPoints: number;
    lastUpdated: string;
    /**
     * The p50 quantile of requests (in period_seconds).
     */
    p50: number;
    /**
     * The p90 quantile of requests (in period_seconds).
     */
    p90: number;
    /**
     * The p99 quantile of requests (in period_seconds).
     */
    p99: number;
    /**
     * The period over which this threshold is suggested.
     */
    periodSeconds: number;
    /**
     * The estimated number of requests covered by these calculations.
     */
    requests: number;
    /**
     * The suggested threshold in requests done by the same auth*id or period*seconds.
     */
    suggestedThreshold: number;
}

export interface GetApiShieldOperationFilter {
    /**
     * Direction to order results.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Filter results to only include endpoints containing this pattern.
     */
    endpoint?: string;
    /**
     * Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
     */
    features?: string[];
    /**
     * Filter results to only include the specified hosts.
     */
    hosts?: string[];
    /**
     * Filter results to only include the specified HTTP methods.
     */
    methods?: string[];
    /**
     * Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
     * Available values: "method", "host", "endpoint", "thresholds.$key".
     */
    order?: string;
}

export interface GetApiShieldOperationsResult {
    /**
     * The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
     */
    endpoint: string;
    features: outputs.GetApiShieldOperationsResultFeatures;
    /**
     * RFC3986-compliant host.
     */
    host: string;
    lastUpdated: string;
    /**
     * The HTTP method used to access the endpoint.
     * Available values: "GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE".
     */
    method: string;
    /**
     * UUID.
     */
    operationId: string;
}

export interface GetApiShieldOperationsResultFeatures {
    /**
     * API Routing settings on endpoint.
     */
    apiRouting: outputs.GetApiShieldOperationsResultFeaturesApiRouting;
    confidenceIntervals: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervals;
    parameterSchemas: outputs.GetApiShieldOperationsResultFeaturesParameterSchemas;
    schemaInfo: outputs.GetApiShieldOperationsResultFeaturesSchemaInfo;
    thresholds: outputs.GetApiShieldOperationsResultFeaturesThresholds;
}

export interface GetApiShieldOperationsResultFeaturesApiRouting {
    lastUpdated: string;
    /**
     * Target route.
     */
    route: string;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervals {
    lastUpdated: string;
    suggestedThreshold: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThreshold;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThreshold {
    confidenceIntervals: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals;
    /**
     * Suggested threshold.
     */
    mean: number;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals {
    /**
     * Upper and lower bound for percentile estimate
     */
    p90: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90;
    /**
     * Upper and lower bound for percentile estimate
     */
    p95: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95;
    /**
     * Upper and lower bound for percentile estimate
     */
    p99: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationsResultFeaturesParameterSchemas {
    lastUpdated: string;
    /**
     * An operation schema object containing a response.
     */
    parameterSchemas: outputs.GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemas;
}

export interface GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemas {
    /**
     * An array containing the learned parameter schemas.
     */
    parameters: string[];
    /**
     * An empty response object. This field is required to yield a valid operation schema.
     */
    responses: string;
}

export interface GetApiShieldOperationsResultFeaturesSchemaInfo {
    /**
     * Schema active on endpoint.
     */
    activeSchema: outputs.GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchema;
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     */
    learnedAvailable: boolean;
    /**
     * Action taken on requests failing validation.
     * Available values: "none", "log", "block".
     */
    mitigationAction: string;
}

export interface GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchema {
    createdAt: string;
    /**
     * UUID.
     */
    id: string;
    /**
     * True if schema is Cloudflare-provided.
     */
    isLearned: boolean;
    /**
     * Schema file name.
     */
    name: string;
}

export interface GetApiShieldOperationsResultFeaturesThresholds {
    /**
     * The total number of auth-ids seen across this calculation.
     */
    authIdTokens: number;
    /**
     * The number of data points used for the threshold suggestion calculation.
     */
    dataPoints: number;
    lastUpdated: string;
    /**
     * The p50 quantile of requests (in period_seconds).
     */
    p50: number;
    /**
     * The p90 quantile of requests (in period_seconds).
     */
    p90: number;
    /**
     * The p99 quantile of requests (in period_seconds).
     */
    p99: number;
    /**
     * The period over which this threshold is suggested.
     */
    periodSeconds: number;
    /**
     * The estimated number of requests covered by these calculations.
     */
    requests: number;
    /**
     * The suggested threshold in requests done by the same auth*id or period*seconds.
     */
    suggestedThreshold: number;
}

export interface GetApiShieldSchemasResult {
    createdAt: string;
    /**
     * Kind of schema
     * Available values: "openapiV3".
     */
    kind: string;
    /**
     * Name of the schema
     */
    name: string;
    /**
     * UUID.
     */
    schemaId: string;
    /**
     * Source of the schema
     */
    source: string;
    /**
     * Flag whether schema is enabled for validation.
     */
    validationEnabled: boolean;
}

export interface GetApiTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetApiTokenConditionRequestIp;
}

export interface GetApiTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetApiTokenFilter {
    /**
     * Direction to order results.
     * Available values: "asc", "desc".
     */
    direction?: string;
}

export interface GetApiTokenPermissionGroupsListResult {
    /**
     * Public ID.
     */
    id: string;
    /**
     * Permission Group Name
     */
    name: string;
    /**
     * Resources to which the Permission Group is scoped
     */
    scopes: string[];
}

export interface GetApiTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetApiTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetApiTokenPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetApiTokenPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetApiTokenPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetApiTokensResult {
    condition: outputs.GetApiTokensResultCondition;
    /**
     * The expiration time on or after which the JWT MUST NOT be accepted for processing.
     */
    expiresOn: string;
    /**
     * Token identifier tag.
     */
    id: string;
    /**
     * The time on which the token was created.
     */
    issuedOn: string;
    /**
     * Last time the token was used.
     */
    lastUsedOn: string;
    /**
     * Last time the token was modified.
     */
    modifiedOn: string;
    /**
     * Token name.
     */
    name: string;
    /**
     * The time before which the token MUST NOT be accepted for processing.
     */
    notBefore: string;
    /**
     * List of access policies assigned to the token.
     */
    policies: outputs.GetApiTokensResultPolicy[];
    /**
     * Status of the token.
     * Available values: "active", "disabled", "expired".
     */
    status: string;
}

export interface GetApiTokensResultCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetApiTokensResultConditionRequestIp;
}

export interface GetApiTokensResultConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetApiTokensResultPolicy {
    /**
     * Allow or deny operations against the resources.
     * Available values: "allow", "deny".
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetApiTokensResultPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetApiTokensResultPolicyPermissionGroup {
    /**
     * Identifier of the permission group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetApiTokensResultPolicyPermissionGroupMeta;
    /**
     * Name of the permission group.
     */
    name: string;
}

export interface GetApiTokensResultPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAuthenticatedOriginPullsCertificatesResult {
    /**
     * The zone's leaf certificate.
     */
    certificate: string;
    /**
     * Indicates whether zone-level authenticated origin pulls is enabled.
     */
    enabled: boolean;
    /**
     * When the certificate from the authority expires.
     */
    expiresOn: string;
    /**
     * Identifier.
     */
    id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    issuer: string;
    /**
     * The zone's private key.
     */
    privateKey: string;
    /**
     * The type of hash used for the certificate.
     */
    signature: string;
    /**
     * Status of the certificate activation.
     * Available values: "initializing", "pending*deployment", "pending*deletion", "active", "deleted", "deployment*timed*out", "deletion*timed*out".
     */
    status: string;
    /**
     * This is the time the certificate was uploaded.
     */
    uploadedOn: string;
}

export interface GetBotManagementStaleZoneConfiguration {
    /**
     * Indicates that the zone's Bot Fight Mode is turned on.
     */
    fightMode: boolean;
    /**
     * Indicates that the zone's wordpress optimization for SBFM is turned on.
     */
    optimizeWordpress: boolean;
    /**
     * Indicates that the zone's definitely automated requests are being blocked or challenged.
     */
    sbfmDefinitelyAutomated: string;
    /**
     * Indicates that the zone's likely automated requests are being blocked or challenged.
     */
    sbfmLikelyAutomated: string;
    /**
     * Indicates that the zone's static resource protection is turned on.
     */
    sbfmStaticResourceProtection: string;
    /**
     * Indicates that the zone's verified bot requests are being blocked.
     */
    sbfmVerifiedBots: string;
    /**
     * Indicates that the zone's session score tracking is disabled.
     */
    suppressSessionScore: boolean;
}

export interface GetByoIpPrefixesResult {
    /**
     * Identifier of a Cloudflare account.
     */
    accountId: string;
    /**
     * Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled.
     *
     * @deprecated Prefer the [BGP Prefixes API](https://developers.cloudflare.com/api/resources/addressing/subresources/prefixes/subresources/bgp_prefixes/) instead, which allows for advertising multiple BGP routes within a single IP Prefix.
     */
    advertised: boolean;
    /**
     * Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled.
     *
     * @deprecated Prefer the [BGP Prefixes API](https://developers.cloudflare.com/api/resources/addressing/subresources/prefixes/subresources/bgp_prefixes/) instead, which allows for advertising multiple BGP routes within a single IP Prefix.
     */
    advertisedModifiedAt: string;
    /**
     * Approval state of the prefix (P = pending, V = active).
     */
    approved: string;
    /**
     * Autonomous System Number (ASN) the prefix will be advertised under.
     */
    asn: number;
    /**
     * IP Prefix in Classless Inter-Domain Routing format.
     */
    cidr: string;
    createdAt: string;
    /**
     * Description of the prefix.
     */
    description: string;
    /**
     * Identifier of an IP Prefix.
     */
    id: string;
    /**
     * Identifier for the uploaded LOA document.
     */
    loaDocumentId: string;
    modifiedAt: string;
    /**
     * Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled.
     *
     * @deprecated Prefer the [BGP Prefixes API](https://developers.cloudflare.com/api/resources/addressing/subresources/prefixes/subresources/bgp_prefixes/) instead, which allows for advertising multiple BGP routes within a single IP Prefix.
     */
    onDemandEnabled: boolean;
    /**
     * Whether advertisement status of the prefix is locked, meaning it cannot be changed.
     *
     * @deprecated Prefer the [BGP Prefixes API](https://developers.cloudflare.com/api/resources/addressing/subresources/prefixes/subresources/bgp_prefixes/) instead, which allows for advertising multiple BGP routes within a single IP Prefix.
     */
    onDemandLocked: boolean;
}

export interface GetCallsSfuAppsResult {
    /**
     * The date and time the item was created.
     */
    created: string;
    /**
     * The date and time the item was last modified.
     */
    modified: string;
    /**
     * A short description of Calls app, not shown to end users.
     */
    name: string;
    /**
     * A Cloudflare-generated unique identifier for a item.
     */
    uid: string;
}

export interface GetCallsTurnAppsResult {
    /**
     * The date and time the item was created.
     */
    created: string;
    /**
     * The date and time the item was last modified.
     */
    modified: string;
    /**
     * A short description of Calls app, not shown to end users.
     */
    name: string;
    /**
     * A Cloudflare-generated unique identifier for a item.
     */
    uid: string;
}

export interface GetCertificatePacksResult {
}

export interface GetCloudConnectorRulesRule {
    description: string;
    enabled: boolean;
    expression: string;
    id: string;
    /**
     * Parameters of Cloud Connector Rule
     */
    parameters: outputs.GetCloudConnectorRulesRuleParameters;
    /**
     * Cloud Provider type
     * Available values: "aws*s3", "cloudflare*r2", "gcp*storage", "azure*storage".
     */
    provider: string;
}

export interface GetCloudConnectorRulesRuleParameters {
    /**
     * Host to perform Cloud Connection to
     */
    host: string;
}

export interface GetCloudforceOneRequestFilter {
    /**
     * Retrieve requests completed after this time.
     */
    completedAfter?: string;
    /**
     * Retrieve requests completed before this time.
     */
    completedBefore?: string;
    /**
     * Retrieve requests created after this time.
     */
    createdAfter?: string;
    /**
     * Retrieve requests created before this time.
     */
    createdBefore?: string;
    /**
     * Page number of results.
     */
    page: number;
    /**
     * Number of results per page.
     */
    perPage: number;
    /**
     * Requested information from request.
     */
    requestType?: string;
    /**
     * Field to sort results by.
     */
    sortBy?: string;
    /**
     * Sort order (asc or desc).
     * Available values: "asc", "desc".
     */
    sortOrder?: string;
    /**
     * Request Status.
     * Available values: "open", "accepted", "reported", "approved", "completed", "declined".
     */
    status?: string;
}

export interface GetCloudforceOneRequestsResult {
    /**
     * Request completion time.
     */
    completed: string;
    /**
     * Request creation time.
     */
    created: string;
    /**
     * UUID.
     */
    id: string;
    /**
     * Tokens for the request messages.
     */
    messageTokens: number;
    /**
     * Available values: "routine", "high", "urgent".
     */
    priority: string;
    /**
     * Readable Request ID.
     */
    readableId: string;
    /**
     * Requested information from request.
     */
    request: string;
    /**
     * Request Status.
     * Available values: "open", "accepted", "reported", "approved", "completed", "declined".
     */
    status: string;
    /**
     * Brief description of the request.
     */
    summary: string;
    /**
     * The CISA defined Traffic Light Protocol (TLP).
     * Available values: "clear", "amber", "amber-strict", "green", "red".
     */
    tlp: string;
    /**
     * Tokens for the request.
     */
    tokens: number;
    /**
     * Request last updated time.
     */
    updated: string;
}

export interface GetContentScanningExpressionsResult {
    /**
     * defines the unique ID for this custom scan expression.
     */
    id: string;
    /**
     * Defines the ruleset expression to use in matching content objects.
     */
    payload: string;
}

export interface GetCustomHostnameFilter {
    /**
     * Direction to order hostnames.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
     */
    hostname?: string;
    /**
     * Hostname ID to match against. This ID was generated and returned during the initial customHostname creation. This parameter cannot be used with the 'hostname' parameter.
     */
    id?: string;
    /**
     * Field to order hostnames by.
     * Available values: "ssl", "sslStatus".
     */
    order: string;
    /**
     * Whether to filter hostnames based on if they have SSL enabled.
     * Available values: 0, 1.
     */
    ssl?: number;
}

export interface GetCustomHostnameOwnershipVerification {
    /**
     * DNS Name for record.
     */
    name: string;
    /**
     * DNS Record type.
     * Available values: "txt".
     */
    type: string;
    /**
     * Content for the record.
     */
    value: string;
}

export interface GetCustomHostnameOwnershipVerificationHttp {
    /**
     * Token to be served.
     */
    httpBody: string;
    /**
     * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
     */
    httpUrl: string;
}

export interface GetCustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: "ubiquitous", "optimal", "force".
     */
    bundleMethod: string;
    /**
     * The Certificate Authority that will issue the certificate
     * Available values: "digicert", "google", "lets*encrypt", "ssl*com".
     */
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate: string;
    /**
     * The identifier for the Custom CSR that was used.
     */
    customCsrId: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey: string;
    /**
     * The time the custom certificate expires on.
     */
    expiresOn: string;
    /**
     * A list of Hostnames on a custom uploaded certificate.
     */
    hosts: string[];
    /**
     * Custom hostname SSL identifier tag.
     */
    id: string;
    /**
     * The issuer on a custom uploaded certificate.
     */
    issuer: string;
    /**
     * Domain control validation (DCV) method used for this hostname.
     * Available values: "http", "txt", "email".
     */
    method: string;
    /**
     * The serial number on a custom uploaded certificate.
     */
    serialNumber: string;
    settings: outputs.GetCustomHostnameSslSettings;
    /**
     * The signature on a custom uploaded certificate.
     */
    signature: string;
    /**
     * Status of the hostname's SSL certificates.
     * Available values: "initializing", "pending*validation", "deleted", "pending*issuance", "pending*deployment", "pending*deletion", "pending*expiration", "expired", "active", "initializing*timed*out", "validation*timed*out", "issuance*timed*out", "deployment*timed*out", "deletion*timed*out", "pending*cleanup", "staging*deployment", "staging*active", "deactivating", "inactive", "backup*issued", "holding*deployment".
     */
    status: string;
    /**
     * Level of validation to be used for this hostname. Domain validation (dv) must be used.
     * Available values: "dv".
     */
    type: string;
    /**
     * The time the custom certificate was uploaded.
     */
    uploadedOn: string;
    /**
     * Domain validation errors that have been received by the certificate authority (CA).
     */
    validationErrors: outputs.GetCustomHostnameSslValidationError[];
    validationRecords: outputs.GetCustomHostnameSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard: boolean;
}

export interface GetCustomHostnameSslSettings {
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers: string[];
    /**
     * Whether or not Early Hints is enabled.
     * Available values: "on", "off".
     */
    earlyHints: string;
    /**
     * Whether or not HTTP2 is enabled.
     * Available values: "on", "off".
     */
    http2: string;
    /**
     * The minimum TLS version supported.
     * Available values: "1.0", "1.1", "1.2", "1.3".
     */
    minTlsVersion: string;
    /**
     * Whether or not TLS 1.3 is enabled.
     * Available values: "on", "off".
     */
    tls13: string;
}

export interface GetCustomHostnameSslValidationError {
    /**
     * A domain validation error.
     */
    message: string;
}

export interface GetCustomHostnameSslValidationRecord {
    /**
     * The set of email addresses that the certificate authority (CA) will use to complete domain validation.
     */
    emails: string[];
    /**
     * The content that the certificate authority (CA) will expect to find at the httpUrl during the domain validation.
     */
    httpBody: string;
    /**
     * The url that will be checked during domain validation.
     */
    httpUrl: string;
    /**
     * The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
     */
    txtName: string;
    /**
     * The TXT record that the certificate authority (CA) will check during domain validation.
     */
    txtValue: string;
}

export interface GetCustomHostnamesResult {
    /**
     * This is the time the hostname was created.
     */
    createdAt: string;
    /**
     * Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
     */
    customMetadata: {[key: string]: string};
    /**
     * a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
     */
    customOriginServer: string;
    /**
     * A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request*host*header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
     */
    customOriginSni: string;
    /**
     * The custom hostname that will point to your hostname via CNAME.
     */
    hostname: string;
    /**
     * Identifier.
     */
    id: string;
    /**
     * This is a record which can be placed to activate a hostname.
     */
    ownershipVerification: outputs.GetCustomHostnamesResultOwnershipVerification;
    /**
     * This presents the token to be served by the given http url to activate a hostname.
     */
    ownershipVerificationHttp: outputs.GetCustomHostnamesResultOwnershipVerificationHttp;
    ssl: outputs.GetCustomHostnamesResultSsl;
    /**
     * Status of the hostname's activation.
     * Available values: "active", "pending", "active*redeploying", "moved", "pending*deletion", "deleted", "pending*blocked", "pending*migration", "pending*provisioned", "test*pending", "test*active", "test*active*apex", "test*blocked", "testFailed", "provisioned", "blocked".
     */
    status: string;
    /**
     * These are errors that were encountered while trying to activate a hostname.
     */
    verificationErrors: string[];
}

export interface GetCustomHostnamesResultOwnershipVerification {
    /**
     * DNS Name for record.
     */
    name: string;
    /**
     * DNS Record type.
     * Available values: "txt".
     */
    type: string;
    /**
     * Content for the record.
     */
    value: string;
}

export interface GetCustomHostnamesResultOwnershipVerificationHttp {
    /**
     * Token to be served.
     */
    httpBody: string;
    /**
     * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
     */
    httpUrl: string;
}

export interface GetCustomHostnamesResultSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: "ubiquitous", "optimal", "force".
     */
    bundleMethod: string;
    /**
     * The Certificate Authority that will issue the certificate
     * Available values: "digicert", "google", "lets*encrypt", "ssl*com".
     */
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate: string;
    /**
     * The identifier for the Custom CSR that was used.
     */
    customCsrId: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey: string;
    /**
     * The time the custom certificate expires on.
     */
    expiresOn: string;
    /**
     * A list of Hostnames on a custom uploaded certificate.
     */
    hosts: string[];
    /**
     * Custom hostname SSL identifier tag.
     */
    id: string;
    /**
     * The issuer on a custom uploaded certificate.
     */
    issuer: string;
    /**
     * Domain control validation (DCV) method used for this hostname.
     * Available values: "http", "txt", "email".
     */
    method: string;
    /**
     * The serial number on a custom uploaded certificate.
     */
    serialNumber: string;
    settings: outputs.GetCustomHostnamesResultSslSettings;
    /**
     * The signature on a custom uploaded certificate.
     */
    signature: string;
    /**
     * Status of the hostname's SSL certificates.
     * Available values: "initializing", "pending*validation", "deleted", "pending*issuance", "pending*deployment", "pending*deletion", "pending*expiration", "expired", "active", "initializing*timed*out", "validation*timed*out", "issuance*timed*out", "deployment*timed*out", "deletion*timed*out", "pending*cleanup", "staging*deployment", "staging*active", "deactivating", "inactive", "backup*issued", "holding*deployment".
     */
    status: string;
    /**
     * Level of validation to be used for this hostname. Domain validation (dv) must be used.
     * Available values: "dv".
     */
    type: string;
    /**
     * The time the custom certificate was uploaded.
     */
    uploadedOn: string;
    /**
     * Domain validation errors that have been received by the certificate authority (CA).
     */
    validationErrors: outputs.GetCustomHostnamesResultSslValidationError[];
    validationRecords: outputs.GetCustomHostnamesResultSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard: boolean;
}

export interface GetCustomHostnamesResultSslSettings {
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers: string[];
    /**
     * Whether or not Early Hints is enabled.
     * Available values: "on", "off".
     */
    earlyHints: string;
    /**
     * Whether or not HTTP2 is enabled.
     * Available values: "on", "off".
     */
    http2: string;
    /**
     * The minimum TLS version supported.
     * Available values: "1.0", "1.1", "1.2", "1.3".
     */
    minTlsVersion: string;
    /**
     * Whether or not TLS 1.3 is enabled.
     * Available values: "on", "off".
     */
    tls13: string;
}

export interface GetCustomHostnamesResultSslValidationError {
    /**
     * A domain validation error.
     */
    message: string;
}

export interface GetCustomHostnamesResultSslValidationRecord {
    /**
     * The set of email addresses that the certificate authority (CA) will use to complete domain validation.
     */
    emails: string[];
    /**
     * The content that the certificate authority (CA) will expect to find at the httpUrl during the domain validation.
     */
    httpBody: string;
    /**
     * The url that will be checked during domain validation.
     */
    httpUrl: string;
    /**
     * The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
     */
    txtName: string;
    /**
     * The TXT record that the certificate authority (CA) will check during domain validation.
     */
    txtValue: string;
}

export interface GetCustomPagesListResult {
    createdOn: string;
    description: string;
    id: string;
    modifiedOn: string;
    previewTarget: string;
    requiredTokens: string[];
    /**
     * The custom page state.
     * Available values: "default", "customized".
     */
    state: string;
    /**
     * The URL associated with the custom page.
     */
    url: string;
}

export interface GetCustomSslFilter {
    /**
     * Whether to match all search requirements or at least one (any).
     * Available values: "any", "all".
     */
    match: string;
    /**
     * Status of the zone's custom SSL.
     * Available values: "active", "expired", "deleted", "pending", "initializing".
     */
    status?: string;
}

export interface GetCustomSslGeoRestrictions {
    /**
     * Available values: "us", "eu", "highestSecurity".
     */
    label: string;
}

export interface GetCustomSslKeylessServer {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     * Available values: "active", "deleted".
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.GetCustomSslKeylessServerTunnel;
}

export interface GetCustomSslKeylessServerTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetCustomSslsResult {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: "ubiquitous", "optimal", "force".
     */
    bundleMethod: string;
    /**
     * When the certificate from the authority expires.
     */
    expiresOn: string;
    /**
     * Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
     */
    geoRestrictions: outputs.GetCustomSslsResultGeoRestrictions;
    hosts: string[];
    /**
     * Identifier.
     */
    id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    issuer: string;
    keylessServer: outputs.GetCustomSslsResultKeylessServer;
    /**
     * When the certificate was last modified.
     */
    modifiedOn: string;
    /**
     * Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
     */
    policy: string;
    /**
     * The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy*custom' certificates, but 'legacy*custom' certificates will always supercede 'sni_custom' certificates.
     */
    priority: number;
    /**
     * The type of hash used for the certificate.
     */
    signature: string;
    /**
     * Status of the zone's custom SSL.
     * Available values: "active", "expired", "deleted", "pending", "initializing".
     */
    status: string;
    /**
     * When the certificate was uploaded to Cloudflare.
     */
    uploadedOn: string;
    /**
     * Identifier.
     */
    zoneId: string;
}

export interface GetCustomSslsResultGeoRestrictions {
    /**
     * Available values: "us", "eu", "highestSecurity".
     */
    label: string;
}

export interface GetCustomSslsResultKeylessServer {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     * Available values: "active", "deleted".
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.GetCustomSslsResultKeylessServerTunnel;
}

export interface GetCustomSslsResultKeylessServerTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetD1DatabaseFilter {
    /**
     * a database name to search for.
     */
    name?: string;
}

export interface GetD1DatabaseReadReplication {
    /**
     * The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
     * Available values: "auto", "disabled".
     */
    mode: string;
}

export interface GetD1DatabasesResult {
    /**
     * Specifies the timestamp the resource was created as an ISO8601 string.
     */
    createdAt: string;
    /**
     * D1 database name.
     */
    name: string;
    /**
     * D1 database identifier (UUID).
     */
    uuid: string;
    version: string;
}

export interface GetDnsFirewallAttackMitigation {
    /**
     * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
     */
    enabled: boolean;
    /**
     * Only mitigate attacks when upstream servers seem unhealthy
     */
    onlyWhenUpstreamUnhealthy: boolean;
}

export interface GetDnsFirewallsResult {
    /**
     * Attack mitigation settings
     */
    attackMitigation: outputs.GetDnsFirewallsResultAttackMitigation;
    /**
     * Whether to refuse to answer queries for the ANY type
     */
    deprecateAnyRequests: boolean;
    dnsFirewallIps: string[];
    /**
     * Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     */
    ecsFallback: boolean;
    /**
     * Identifier.
     */
    id: string;
    /**
     * By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets an upper bound on this duration. For caching purposes, higher TTLs
     * will be decreased to the maximum value defined by this setting.
     */
    maximumCacheTtl: number;
    /**
     * By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets a lower bound on this duration. For caching purposes, lower TTLs
     * will be increased to the minimum value defined by this setting.
     *
     * This setting does not affect the TTL value in the DNS response
     * Cloudflare returns to clients. Cloudflare will always forward the TTL
     * value received from upstream nameservers.
     *
     * Note that, even with this setting, there is no guarantee that a
     * response will be cached for at least the specified duration. Cached
     * responses may be removed earlier for capacity or other operational
     * reasons.
     */
    minimumCacheTtl: number;
    /**
     * Last modification of DNS Firewall cluster
     */
    modifiedOn: string;
    /**
     * DNS Firewall cluster name
     */
    name: string;
    /**
     * This setting controls how long DNS Firewall should cache negative
     * responses (e.g., NXDOMAIN) from the upstream servers.
     *
     * This setting does not affect the TTL value in the DNS response
     * Cloudflare returns to clients. Cloudflare will always forward the TTL
     * value received from upstream nameservers.
     */
    negativeCacheTtl: number;
    /**
     * Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     */
    ratelimit: number;
    /**
     * Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     */
    retries: number;
    upstreamIps: string[];
}

export interface GetDnsFirewallsResultAttackMitigation {
    /**
     * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
     */
    enabled: boolean;
    /**
     * Only mitigate attacks when upstream servers seem unhealthy
     */
    onlyWhenUpstreamUnhealthy: boolean;
}

export interface GetDnsRecordData {
    /**
     * Algorithm.
     */
    algorithm: number;
    /**
     * Altitude of location in meters.
     */
    altitude: number;
    /**
     * Certificate.
     */
    certificate: string;
    /**
     * Digest.
     */
    digest: string;
    /**
     * Digest Type.
     */
    digestType: number;
    /**
     * Fingerprint.
     */
    fingerprint: string;
    /**
     * Flags for the CAA record.
     */
    flags: any;
    /**
     * Key Tag.
     */
    keyTag: number;
    /**
     * Degrees of latitude.
     */
    latDegrees: number;
    /**
     * Latitude direction.
     * Available values: "N", "S".
     */
    latDirection: string;
    /**
     * Minutes of latitude.
     */
    latMinutes: number;
    /**
     * Seconds of latitude.
     */
    latSeconds: number;
    /**
     * Degrees of longitude.
     */
    longDegrees: number;
    /**
     * Longitude direction.
     * Available values: "E", "W".
     */
    longDirection: string;
    /**
     * Minutes of longitude.
     */
    longMinutes: number;
    /**
     * Seconds of longitude.
     */
    longSeconds: number;
    /**
     * Matching Type.
     */
    matchingType: number;
    /**
     * Order.
     */
    order: number;
    /**
     * The port of the service.
     */
    port: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz: number;
    /**
     * Vertical precision of location.
     */
    precisionVert: number;
    /**
     * Preference.
     */
    preference: number;
    /**
     * Priority.
     */
    priority: number;
    /**
     * Protocol.
     */
    protocol: number;
    /**
     * Public Key.
     */
    publicKey: string;
    /**
     * Regex.
     */
    regex: string;
    /**
     * Replacement.
     */
    replacement: string;
    /**
     * Selector.
     */
    selector: number;
    /**
     * Service.
     */
    service: string;
    /**
     * Size of location in meters.
     */
    size: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag: string;
    /**
     * Target.
     */
    target: string;
    /**
     * Type.
     */
    type: number;
    /**
     * Usage.
     */
    usage: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value: string;
    /**
     * The record weight.
     */
    weight: number;
}

export interface GetDnsRecordFilter {
    comment?: outputs.GetDnsRecordFilterComment;
    content?: outputs.GetDnsRecordFilterContent;
    /**
     * Direction to order DNS records in.
     * Available values: "asc", "desc".
     */
    direction: string;
    /**
     * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     * Available values: "any", "all".
     */
    match: string;
    name?: outputs.GetDnsRecordFilterName;
    /**
     * Field to order DNS records by.
     * Available values: "type", "name", "content", "ttl", "proxied".
     */
    order: string;
    /**
     * Whether the record is receiving the performance and security benefits of Cloudflare.
     */
    proxied: boolean;
    /**
     * Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     */
    search?: string;
    tag?: outputs.GetDnsRecordFilterTag;
    /**
     * Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
     * Available values: "any", "all".
     */
    tagMatch: string;
    /**
     * Record type.
     * Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
     */
    type?: string;
}

export interface GetDnsRecordFilterComment {
    /**
     * If this parameter is present, only records *without* a comment are returned.
     */
    absent?: string;
    /**
     * Substring of the DNS record comment. Comment filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record comment. Comment filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record comment. Comment filters are case-insensitive.
     */
    exact?: string;
    /**
     * If this parameter is present, only records *with* a comment are returned.
     */
    present?: string;
    /**
     * Prefix of the DNS record comment. Comment filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordFilterContent {
    /**
     * Substring of the DNS record content. Content filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record content. Content filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record content. Content filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record content. Content filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordFilterName {
    /**
     * Substring of the DNS record name. Name filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record name. Name filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record name. Name filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record name. Name filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordFilterTag {
    /**
     * Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
     */
    absent?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
     */
    contains?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
     */
    endswith?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
     */
    exact?: string;
    /**
     * Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
     */
    present?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface GetDnsRecordsComment {
    /**
     * If this parameter is present, only records *without* a comment are returned.
     */
    absent?: string;
    /**
     * Substring of the DNS record comment. Comment filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record comment. Comment filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record comment. Comment filters are case-insensitive.
     */
    exact?: string;
    /**
     * If this parameter is present, only records *with* a comment are returned.
     */
    present?: string;
    /**
     * Prefix of the DNS record comment. Comment filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordsContent {
    /**
     * Substring of the DNS record content. Content filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record content. Content filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record content. Content filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record content. Content filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordsName {
    /**
     * Substring of the DNS record name. Name filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record name. Name filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record name. Name filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record name. Name filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordsResult {
    /**
     * Comments or notes about the DNS record. This field has no effect on DNS responses.
     */
    comment: string;
    /**
     * When the record comment was last modified. Omitted if there is no comment.
     */
    commentModifiedOn: string;
    /**
     * A valid IPv4 address.
     */
    content: string;
    /**
     * When the record was created.
     */
    createdOn: string;
    /**
     * Components of a CAA record.
     */
    data: outputs.GetDnsRecordsResultData;
    /**
     * Identifier.
     */
    id: string;
    /**
     * Extra Cloudflare-specific information about the record.
     */
    meta: string;
    /**
     * When the record was last modified.
     */
    modifiedOn: string;
    /**
     * Complete DNS record name, including the zone name, in Punycode.
     */
    name: string;
    /**
     * Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Whether the record can be proxied by Cloudflare or not.
     */
    proxiable: boolean;
    /**
     * Whether the record is receiving the performance and security benefits of Cloudflare.
     */
    proxied: boolean;
    /**
     * Settings for the DNS record.
     */
    settings: outputs.GetDnsRecordsResultSettings;
    /**
     * Custom tags for the DNS record. This field has no effect on DNS responses.
     */
    tags: string[];
    /**
     * When the record tags were last modified. Omitted if there are no tags.
     */
    tagsModifiedOn: string;
    /**
     * Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
     */
    ttl: number;
    /**
     * Record type.
     * Available values: "A", "AAAA", "CNAME", "MX", "NS", "OPENPGPKEY", "PTR", "TXT", "CAA", "CERT", "DNSKEY", "DS", "HTTPS", "LOC", "NAPTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface GetDnsRecordsResultData {
    /**
     * Algorithm.
     */
    algorithm: number;
    /**
     * Altitude of location in meters.
     */
    altitude: number;
    /**
     * Certificate.
     */
    certificate: string;
    /**
     * Digest.
     */
    digest: string;
    /**
     * Digest Type.
     */
    digestType: number;
    /**
     * Fingerprint.
     */
    fingerprint: string;
    /**
     * Flags for the CAA record.
     */
    flags: any;
    /**
     * Key Tag.
     */
    keyTag: number;
    /**
     * Degrees of latitude.
     */
    latDegrees: number;
    /**
     * Latitude direction.
     * Available values: "N", "S".
     */
    latDirection: string;
    /**
     * Minutes of latitude.
     */
    latMinutes: number;
    /**
     * Seconds of latitude.
     */
    latSeconds: number;
    /**
     * Degrees of longitude.
     */
    longDegrees: number;
    /**
     * Longitude direction.
     * Available values: "E", "W".
     */
    longDirection: string;
    /**
     * Minutes of longitude.
     */
    longMinutes: number;
    /**
     * Seconds of longitude.
     */
    longSeconds: number;
    /**
     * Matching Type.
     */
    matchingType: number;
    /**
     * Order.
     */
    order: number;
    /**
     * The port of the service.
     */
    port: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz: number;
    /**
     * Vertical precision of location.
     */
    precisionVert: number;
    /**
     * Preference.
     */
    preference: number;
    /**
     * Priority.
     */
    priority: number;
    /**
     * Protocol.
     */
    protocol: number;
    /**
     * Public Key.
     */
    publicKey: string;
    /**
     * Regex.
     */
    regex: string;
    /**
     * Replacement.
     */
    replacement: string;
    /**
     * Selector.
     */
    selector: number;
    /**
     * Service.
     */
    service: string;
    /**
     * Size of location in meters.
     */
    size: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag: string;
    /**
     * Target.
     */
    target: string;
    /**
     * Type.
     */
    type: number;
    /**
     * Usage.
     */
    usage: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value: string;
    /**
     * The record weight.
     */
    weight: number;
}

export interface GetDnsRecordsResultSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface GetDnsRecordsTag {
    /**
     * Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
     */
    absent?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
     */
    contains?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
     */
    endswith?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
     */
    exact?: string;
    /**
     * Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
     */
    present?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsZoneTransfersAclsResult {
    id: string;
    /**
     * Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
     */
    ipRange: string;
    /**
     * The name of the acl.
     */
    name: string;
}

export interface GetDnsZoneTransfersPeersResult {
    id: string;
    /**
     * IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to.
     */
    ip: string;
    /**
     * Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones.
     */
    ixfrEnable: boolean;
    /**
     * The name of the peer.
     */
    name: string;
    /**
     * DNS port of primary or secondary nameserver, depending on what zone this peer is linked to.
     */
    port: number;
    /**
     * TSIG authentication will be used for zone transfer if configured.
     */
    tsigId: string;
}

export interface GetDnsZoneTransfersTsigsResult {
    /**
     * TSIG algorithm.
     */
    algo: string;
    id: string;
    /**
     * TSIG key name.
     */
    name: string;
    /**
     * TSIG secret.
     */
    secret: string;
}

export interface GetEmailRoutingAddressFilter {
    /**
     * Sorts results in an ascending or descending order.
     * Available values: "asc", "desc".
     */
    direction: string;
    /**
     * Filter by verified destination addresses.
     */
    verified: boolean;
}

export interface GetEmailRoutingAddressesResult {
    /**
     * The date and time the destination address has been created.
     */
    created: string;
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Destination address identifier.
     */
    id: string;
    /**
     * The date and time the destination address was last modified.
     */
    modified: string;
    /**
     * Destination address tag. (Deprecated, replaced by destination address identifier)
     *
     * @deprecated This attribute is deprecated.
     */
    tag: string;
    /**
     * The date and time the destination address has been verified. Null means not verified yet.
     */
    verified: string;
}

export interface GetEmailRoutingCatchAllAction {
    /**
     * Type of action for catch-all rule.
     * Available values: "drop", "forward", "worker".
     */
    type: string;
    values: string[];
}

export interface GetEmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Default is 'all'.
     * Available values: "all".
     */
    type: string;
}

export interface GetEmailRoutingDnsError {
    code: number;
    documentationUrl: string;
    message: string;
    source: outputs.GetEmailRoutingDnsErrorSource;
}

export interface GetEmailRoutingDnsErrorSource {
    pointer: string;
}

export interface GetEmailRoutingDnsMessage {
    code: number;
    documentationUrl: string;
    message: string;
    source: outputs.GetEmailRoutingDnsMessageSource;
}

export interface GetEmailRoutingDnsMessageSource {
    pointer: string;
}

export interface GetEmailRoutingDnsResult {
    /**
     * DNS record content.
     */
    content: string;
    errors: outputs.GetEmailRoutingDnsResultError[];
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    records: outputs.GetEmailRoutingDnsResultRecord[];
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     * Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface GetEmailRoutingDnsResultError {
    code: string;
    /**
     * List of records needed to enable an Email Routing zone.
     */
    missing: outputs.GetEmailRoutingDnsResultErrorMissing;
}

export interface GetEmailRoutingDnsResultErrorMissing {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     * Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface GetEmailRoutingDnsResultInfo {
    /**
     * Total number of results for the requested service.
     */
    count: number;
    /**
     * Current page within paginated list of results.
     */
    page: number;
    /**
     * Number of results per page of results.
     */
    perPage: number;
    /**
     * Total results available without any search parameters.
     */
    totalCount: number;
}

export interface GetEmailRoutingDnsResultRecord {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     * Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
     */
    type: string;
}

export interface GetEmailRoutingRuleAction {
    /**
     * Type of supported action.
     * Available values: "drop", "forward", "worker".
     */
    type: string;
    values: string[];
}

export interface GetEmailRoutingRuleFilter {
    /**
     * Filter by enabled routing rules.
     */
    enabled?: boolean;
}

export interface GetEmailRoutingRuleMatcher {
    /**
     * Field for type matcher.
     * Available values: "to".
     */
    field: string;
    /**
     * Type of matcher.
     * Available values: "all", "literal".
     */
    type: string;
    /**
     * Value for matcher.
     */
    value: string;
}

export interface GetEmailRoutingRulesResult {
    /**
     * List actions patterns.
     */
    actions: outputs.GetEmailRoutingRulesResultAction[];
    /**
     * Routing rule status.
     */
    enabled: boolean;
    /**
     * Routing rule identifier.
     */
    id: string;
    /**
     * Matching patterns to forward to your actions.
     */
    matchers: outputs.GetEmailRoutingRulesResultMatcher[];
    /**
     * Routing rule name.
     */
    name: string;
    /**
     * Priority of the routing rule.
     */
    priority: number;
    /**
     * Routing rule tag. (Deprecated, replaced by routing rule identifier)
     *
     * @deprecated This attribute is deprecated.
     */
    tag: string;
}

export interface GetEmailRoutingRulesResultAction {
    /**
     * Type of supported action.
     * Available values: "drop", "forward", "worker".
     */
    type: string;
    values: string[];
}

export interface GetEmailRoutingRulesResultMatcher {
    /**
     * Field for type matcher.
     * Available values: "to".
     */
    field: string;
    /**
     * Type of matcher.
     * Available values: "all", "literal".
     */
    type: string;
    /**
     * Value for matcher.
     */
    value: string;
}

export interface GetEmailSecurityBlockSenderFilter {
    /**
     * The sorting direction.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * The field to sort by.
     * Available values: "pattern", "createdAt".
     */
    order?: string;
    pattern?: string;
    /**
     * Available values: "EMAIL", "DOMAIN", "IP", "UNKNOWN".
     */
    patternType?: string;
    /**
     * Allows searching in multiple properties of a record simultaneously.
     * This parameter is intended for human users, not automation. Its exact
     * behavior is intentionally left unspecified and is subject to change
     * in the future.
     */
    search?: string;
}

export interface GetEmailSecurityBlockSendersResult {
    comments: string;
    createdAt: string;
    /**
     * The unique identifier for the allow policy.
     */
    id: number;
    isRegex: boolean;
    lastModified: string;
    pattern: string;
    /**
     * Available values: "EMAIL", "DOMAIN", "IP", "UNKNOWN".
     */
    patternType: string;
}

export interface GetEmailSecurityImpersonationRegistriesResult {
    comments: string;
    createdAt: string;
    directoryId: number;
    directoryNodeId: number;
    email: string;
    /**
     * @deprecated This attribute is deprecated.
     */
    externalDirectoryNodeId: string;
    id: number;
    isEmailRegex: boolean;
    lastModified: string;
    name: string;
    provenance: string;
}

export interface GetEmailSecurityImpersonationRegistryFilter {
    /**
     * The sorting direction.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * The field to sort by.
     * Available values: "name", "email", "createdAt".
     */
    order?: string;
    /**
     * Available values: "A1S*INTERNAL", "SNOOPY-CASB*OFFICE*365", "SNOOPY-OFFICE*365", "SNOOPY-GOOGLE_DIRECTORY".
     */
    provenance?: string;
    /**
     * Allows searching in multiple properties of a record simultaneously.
     * This parameter is intended for human users, not automation. Its exact
     * behavior is intentionally left unspecified and is subject to change
     * in the future.
     */
    search?: string;
}

export interface GetEmailSecurityTrustedDomainsFilter {
    /**
     * The sorting direction.
     * Available values: "asc", "desc".
     */
    direction?: string;
    isRecent?: boolean;
    isSimilarity?: boolean;
    /**
     * The field to sort by.
     * Available values: "pattern", "createdAt".
     */
    order?: string;
    pattern?: string;
    /**
     * Allows searching in multiple properties of a record simultaneously.
     * This parameter is intended for human users, not automation. Its exact
     * behavior is intentionally left unspecified and is subject to change
     * in the future.
     */
    search?: string;
}

export interface GetEmailSecurityTrustedDomainsListResult {
    comments: string;
    createdAt: string;
    /**
     * The unique identifier for the trusted domain.
     */
    id: number;
    /**
     * Select to prevent recently registered domains from triggering a
     * Suspicious or Malicious disposition.
     */
    isRecent: boolean;
    isRegex: boolean;
    /**
     * Select for partner or other approved domains that have similar
     * spelling to your connected domains. Prevents listed domains from
     * triggering a Spoof disposition.
     */
    isSimilarity: boolean;
    lastModified: string;
    pattern: string;
}

export interface GetFilterFilter {
    /**
     * A case-insensitive string to find in the description.
     */
    description?: string;
    /**
     * A case-insensitive string to find in the expression.
     */
    expression?: string;
    /**
     * The unique identifier of the filter.
     */
    id?: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused?: boolean;
    /**
     * The filter ref (a short reference tag) to search for. Must be an exact match.
     */
    ref?: string;
}

export interface GetFiltersResult {
    /**
     * An informative summary of the filter.
     */
    description: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref: string;
}

export interface GetFirewallRulesResult {
    /**
     * The action to apply to a matched request. The `log` action is only available on an Enterprise plan.
     * Available values: "block", "challenge", "js*challenge", "managed*challenge", "allow", "log", "bypass".
     */
    action: string;
    /**
     * An informative summary of the firewall rule.
     */
    description: string;
    filter: outputs.GetFirewallRulesResultFilter;
    /**
     * The unique identifier of the firewall rule.
     */
    id: string;
    /**
     * When true, indicates that the firewall rule is currently paused.
     */
    paused: boolean;
    /**
     * The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority.
     */
    priority: number;
    products: string[];
    /**
     * A short reference tag. Allows you to select related firewall rules.
     */
    ref: string;
}

export interface GetFirewallRulesResultFilter {
    /**
     * When true, indicates that the firewall rule was deleted.
     */
    deleted: boolean;
    /**
     * An informative summary of the filter.
     */
    description: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref: string;
}

export interface GetHealthcheckHttpConfig {
    /**
     * Do not validate the certificate when the health check uses HTTPS.
     */
    allowInsecure: boolean;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
     */
    expectedBody: string;
    /**
     * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
     */
    expectedCodes: string[];
    /**
     * Follow redirects if the origin returns a 3xx status code.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
     */
    header: {[key: string]: string[]};
    /**
     * The HTTP method to use for the health check.
     * Available values: "GET", "HEAD".
     */
    method: string;
    /**
     * The endpoint path to health check against.
     */
    path: string;
    /**
     * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
     */
    port: number;
}

export interface GetHealthcheckTcpConfig {
    /**
     * The TCP connection method to use for the health check.
     * Available values: "connectionEstablished".
     */
    method: string;
    /**
     * Port number to connect to for the health check. Defaults to 80.
     */
    port: number;
}

export interface GetHealthchecksResult {
    /**
     * The hostname or IP address of the origin server to run health checks on.
     */
    address: string;
    /**
     * A list of regions from which to run health checks. Null means Cloudflare will pick a default region.
     */
    checkRegions: string[];
    /**
     * The number of consecutive fails required from a health check before changing the health to unhealthy.
     */
    consecutiveFails: number;
    /**
     * The number of consecutive successes required from a health check before changing the health to healthy.
     */
    consecutiveSuccesses: number;
    createdOn: string;
    /**
     * A human-readable description of the health check.
     */
    description: string;
    /**
     * The current failure reason if status is unhealthy.
     */
    failureReason: string;
    /**
     * Parameters specific to an HTTP or HTTPS health check.
     */
    httpConfig: outputs.GetHealthchecksResultHttpConfig;
    /**
     * Identifier
     */
    id: string;
    /**
     * The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations.
     */
    interval: number;
    modifiedOn: string;
    /**
     * A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: string;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    retries: number;
    /**
     * The current status of the origin server according to the health check.
     * Available values: "unknown", "healthy", "unhealthy", "suspended".
     */
    status: string;
    /**
     * If suspended, no health checks are sent to the origin.
     */
    suspended: boolean;
    /**
     * Parameters specific to TCP health check.
     */
    tcpConfig: outputs.GetHealthchecksResultTcpConfig;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    timeout: number;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'.
     */
    type: string;
}

export interface GetHealthchecksResultHttpConfig {
    /**
     * Do not validate the certificate when the health check uses HTTPS.
     */
    allowInsecure: boolean;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
     */
    expectedBody: string;
    /**
     * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
     */
    expectedCodes: string[];
    /**
     * Follow redirects if the origin returns a 3xx status code.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
     */
    header: {[key: string]: string[]};
    /**
     * The HTTP method to use for the health check.
     * Available values: "GET", "HEAD".
     */
    method: string;
    /**
     * The endpoint path to health check against.
     */
    path: string;
    /**
     * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
     */
    port: number;
}

export interface GetHealthchecksResultTcpConfig {
    /**
     * The TCP connection method to use for the health check.
     * Available values: "connectionEstablished".
     */
    method: string;
    /**
     * Port number to connect to for the health check. Defaults to 80.
     */
    port: number;
}

export interface GetHyperdriveConfigCaching {
    /**
     * Set to true to disable caching of SQL responses. Default is false.
     */
    disabled: boolean;
    /**
     * Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
     */
    maxAge: number;
    /**
     * Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
     */
    staleWhileRevalidate: number;
}

export interface GetHyperdriveConfigMtls {
    /**
     * Define CA certificate ID obtained after uploading CA cert.
     */
    caCertificateId: string;
    /**
     * Define mTLS certificate ID obtained after uploading client cert.
     */
    mtlsCertificateId: string;
    /**
     * Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
     */
    sslmode: string;
}

export interface GetHyperdriveConfigOrigin {
    /**
     * Defines the Client ID of the Access token to use when connecting to the origin database.
     */
    accessClientId: string;
    /**
     * Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
     */
    accessClientSecret: string;
    /**
     * Set the name of your origin database.
     */
    database: string;
    /**
     * Defines the host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * Set the password needed to access your origin database. The API never returns this write-only value.
     */
    password: string;
    /**
     * Defines the port (default: 5432 for Postgres) of your origin database.
     */
    port: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     * Available values: "postgres", "postgresql", "mysql".
     */
    scheme: string;
    /**
     * Set the user of your origin database.
     */
    user: string;
}

export interface GetHyperdriveConfigsResult {
    caching: outputs.GetHyperdriveConfigsResultCaching;
    /**
     * Defines the creation time of the Hyperdrive configuration.
     */
    createdOn: string;
    /**
     * Define configurations using a unique string identifier.
     */
    id: string;
    /**
     * Defines the last modified time of the Hyperdrive configuration.
     */
    modifiedOn: string;
    mtls: outputs.GetHyperdriveConfigsResultMtls;
    name: string;
    origin: outputs.GetHyperdriveConfigsResultOrigin;
    /**
     * The (soft) maximum number of connections the Hyperdrive is allowed to make to the origin database.
     */
    originConnectionLimit: number;
}

export interface GetHyperdriveConfigsResultCaching {
    /**
     * Set to true to disable caching of SQL responses. Default is false.
     */
    disabled: boolean;
    /**
     * Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
     */
    maxAge: number;
    /**
     * Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
     */
    staleWhileRevalidate: number;
}

export interface GetHyperdriveConfigsResultMtls {
    /**
     * Define CA certificate ID obtained after uploading CA cert.
     */
    caCertificateId: string;
    /**
     * Define mTLS certificate ID obtained after uploading client cert.
     */
    mtlsCertificateId: string;
    /**
     * Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
     */
    sslmode: string;
}

export interface GetHyperdriveConfigsResultOrigin {
    /**
     * Defines the Client ID of the Access token to use when connecting to the origin database.
     */
    accessClientId: string;
    /**
     * Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
     */
    accessClientSecret: string;
    /**
     * Set the name of your origin database.
     */
    database: string;
    /**
     * Defines the host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * Set the password needed to access your origin database. The API never returns this write-only value.
     */
    password: string;
    /**
     * Defines the port (default: 5432 for Postgres) of your origin database.
     */
    port: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     * Available values: "postgres", "postgresql", "mysql".
     */
    scheme: string;
    /**
     * Set the user of your origin database.
     */
    user: string;
}

export interface GetImageVariantVariant {
    id: string;
    /**
     * Indicates whether the variant can access an image without a signature, regardless of image access control.
     */
    neverRequireSignedUrls: boolean;
    /**
     * Allows you to define image resizing sizes for different use cases.
     */
    options: outputs.GetImageVariantVariantOptions;
}

export interface GetImageVariantVariantOptions {
    /**
     * The fit property describes how the width and height dimensions should be interpreted.
     * Available values: "scale-down", "contain", "cover", "crop", "pad".
     */
    fit: string;
    /**
     * Maximum height in image pixels.
     */
    height: number;
    /**
     * What EXIF data should be preserved in the output image.
     * Available values: "keep", "copyright", "none".
     */
    metadata: string;
    /**
     * Maximum width in image pixels.
     */
    width: number;
}

export interface GetImagesResult {
    images: outputs.GetImagesResultImage[];
}

export interface GetImagesResultImage {
    /**
     * Can set the creator field with an internal user ID.
     */
    creator: string;
    /**
     * Image file name.
     */
    filename: string;
    /**
     * Image unique identifier.
     */
    id: string;
    /**
     * User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes.
     */
    meta: string;
    /**
     * Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image.
     */
    requireSignedUrls: boolean;
    /**
     * When the media item was uploaded.
     */
    uploaded: string;
    /**
     * Object specifying available variants for an image.
     */
    variants: string[];
}

export interface GetKeylessCertificateTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetKeylessCertificatesResult {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     * Available values: "active", "deleted".
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.GetKeylessCertificatesResultTunnel;
}

export interface GetKeylessCertificatesResultTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetLeakedCredentialCheckRulesResult {
    /**
     * Defines the unique ID for this custom detection.
     */
    id: string;
    /**
     * Defines ehe ruleset expression to use in matching the password in a request.
     */
    password: string;
    /**
     * Defines the ruleset expression to use in matching the username in a request.
     */
    username: string;
}

export interface GetListItem {
    /**
     * A non-negative 32 bit integer
     */
    asn: number;
    /**
     * An informative summary of the list item.
     */
    comment: string;
    /**
     * Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
     */
    hostname: outputs.GetListItemHostname;
    /**
     * An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
     */
    ip: string;
    /**
     * The definition of the redirect.
     */
    redirect: outputs.GetListItemRedirect;
}

export interface GetListItemHostname {
    /**
     * Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
     */
    excludeExactHostname: boolean;
    urlHostname: string;
}

export interface GetListItemRedirect {
    includeSubdomains: boolean;
    preservePathSuffix: boolean;
    preserveQueryString: boolean;
    sourceUrl: string;
    /**
     * Available values: 301, 302, 307, 308.
     */
    statusCode: number;
    subpathMatching: boolean;
    targetUrl: string;
}

export interface GetListItemsResult {
    /**
     * Defines a non-negative 32 bit integer.
     */
    asn: number;
    /**
     * Defines	an informative summary of the list item.
     */
    comment: string;
    /**
     * The RFC 3339 timestamp of when the item was created.
     */
    createdOn: string;
    /**
     * Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
     */
    hostname: outputs.GetListItemsResultHostname;
    /**
     * Defines the unique ID of the item in the List.
     */
    id: string;
    /**
     * An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
     */
    ip: string;
    /**
     * The RFC 3339 timestamp of when the item was last modified.
     */
    modifiedOn: string;
    /**
     * The definition of the redirect.
     */
    redirect: outputs.GetListItemsResultRedirect;
}

export interface GetListItemsResultHostname {
    /**
     * Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
     */
    excludeExactHostname: boolean;
    urlHostname: string;
}

export interface GetListItemsResultRedirect {
    includeSubdomains: boolean;
    preservePathSuffix: boolean;
    preserveQueryString: boolean;
    sourceUrl: string;
    /**
     * Available values: 301, 302, 307, 308.
     */
    statusCode: number;
    subpathMatching: boolean;
    targetUrl: string;
}

export interface GetListsResult {
    /**
     * The RFC 3339 timestamp of when the list was created.
     */
    createdOn: string;
    /**
     * An informative summary of the list.
     */
    description: string;
    /**
     * The unique ID of the list.
     */
    id: string;
    /**
     * The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects).
     * Available values: "ip", "redirect", "hostname", "asn".
     */
    kind: string;
    /**
     * The RFC 3339 timestamp of when the list was last modified.
     */
    modifiedOn: string;
    /**
     * An informative name for the list. Use this name in filter and rule expressions.
     */
    name: string;
    /**
     * The number of items in the list.
     */
    numItems: number;
    /**
     * The number of [filters](https://www.terraform.io/api/resources/filters/) referencing the list.
     */
    numReferencingFilters: number;
}

export interface GetLoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancerMonitorsResult {
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     */
    allowInsecure: boolean;
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     */
    consecutiveDown: number;
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     */
    consecutiveUp: number;
    createdOn: string;
    /**
     * Object description.
     */
    description: string;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedBody: string;
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedCodes: string;
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     */
    header: {[key: string]: string[]};
    id: string;
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     */
    interval: number;
    /**
     * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
     */
    method: string;
    modifiedOn: string;
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     */
    path: string;
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     */
    port: number;
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     */
    probeZone: string;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    retries: number;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    timeout: number;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
     * Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
     */
    type: string;
}

export interface GetLoadBalancerPoolFilter {
    /**
     * The ID of the Monitor to use for checking the health of origins within this pool.
     */
    monitor?: string;
}

export interface GetLoadBalancerPoolLoadShedding {
    /**
     * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
     */
    defaultPercent: number;
    /**
     * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
     * Available values: "random", "hash".
     */
    defaultPolicy: string;
    /**
     * The percent of existing sessions to shed from the pool, according to the session policy.
     */
    sessionPercent: number;
    /**
     * Only the hash policy is supported for existing sessions (to avoid exponential decay).
     * Available values: "hash".
     */
    sessionPolicy: string;
}

export interface GetLoadBalancerPoolNotificationFilter {
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    origin: outputs.GetLoadBalancerPoolNotificationFilterOrigin;
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    pool: outputs.GetLoadBalancerPoolNotificationFilterPool;
}

export interface GetLoadBalancerPoolNotificationFilterOrigin {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolNotificationFilterPool {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
     */
    address: string;
    /**
     * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled: boolean;
    /**
     * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
     */
    header: outputs.GetLoadBalancerPoolOriginHeader;
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The port for upstream connections. A value of 0 means the default port for the protocol will be used.
     */
    port: number;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId: string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     */
    weight: number;
}

export interface GetLoadBalancerPoolOriginHeader {
    /**
     * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
     */
    hosts: string[];
}

export interface GetLoadBalancerPoolOriginSteering {
    /**
     * The type of origin steering policy to use.
     */
    policy: string;
}

export interface GetLoadBalancerPoolsResult {
    /**
     * A list of regions from which to run health checks. Null means every Cloudflare data center.
     */
    checkRegions: string[];
    createdOn: string;
    /**
     * A human-readable description of the pool.
     */
    description: string;
    /**
     * This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any).
     */
    enabled: boolean;
    id: string;
    /**
     * The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set.
     */
    latitude: number;
    /**
     * Configures load shedding policies and percentages for the pool.
     */
    loadShedding: outputs.GetLoadBalancerPoolsResultLoadShedding;
    /**
     * The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set.
     */
    longitude: number;
    /**
     * The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool.
     */
    minimumOrigins: number;
    modifiedOn: string;
    /**
     * The ID of the Monitor to use for checking the health of origins within this pool.
     */
    monitor: string;
    /**
     * The ID of the Monitor Group to use for checking the health of origins within this pool.
     */
    monitorGroup: string;
    /**
     * A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed.
     */
    name: string;
    /**
     * List of networks where Load Balancer or Pool is enabled.
     */
    networks: string[];
    /**
     * This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
     */
    notificationEmail: string;
    /**
     * Filter pool and origin health notifications by resource type or health status. Use null to reset.
     */
    notificationFilter: outputs.GetLoadBalancerPoolsResultNotificationFilter;
    /**
     * Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity.
     */
    originSteering: outputs.GetLoadBalancerPoolsResultOriginSteering;
    /**
     * The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
     */
    origins: outputs.GetLoadBalancerPoolsResultOrigin[];
}

export interface GetLoadBalancerPoolsResultLoadShedding {
    /**
     * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
     */
    defaultPercent: number;
    /**
     * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
     * Available values: "random", "hash".
     */
    defaultPolicy: string;
    /**
     * The percent of existing sessions to shed from the pool, according to the session policy.
     */
    sessionPercent: number;
    /**
     * Only the hash policy is supported for existing sessions (to avoid exponential decay).
     * Available values: "hash".
     */
    sessionPolicy: string;
}

export interface GetLoadBalancerPoolsResultNotificationFilter {
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    origin: outputs.GetLoadBalancerPoolsResultNotificationFilterOrigin;
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    pool: outputs.GetLoadBalancerPoolsResultNotificationFilterPool;
}

export interface GetLoadBalancerPoolsResultNotificationFilterOrigin {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolsResultNotificationFilterPool {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolsResultOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
     */
    address: string;
    /**
     * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled: boolean;
    /**
     * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
     */
    header: outputs.GetLoadBalancerPoolsResultOriginHeader;
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The port for upstream connections. A value of 0 means the default port for the protocol will be used.
     */
    port: number;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId: string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     */
    weight: number;
}

export interface GetLoadBalancerPoolsResultOriginHeader {
    /**
     * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
     */
    hosts: string[];
}

export interface GetLoadBalancerPoolsResultOriginSteering {
    /**
     * The type of origin steering policy to use.
     */
    policy: string;
}

export interface GetLoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancerRule {
    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixedResponse in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     */
    condition: string;
    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     */
    disabled: boolean;
    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     */
    fixedResponse: outputs.GetLoadBalancerRuleFixedResponse;
    /**
     * Name of this rule. Only used for human readability.
     */
    name: string;
    /**
     * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
     */
    overrides: outputs.GetLoadBalancerRuleOverrides;
    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     */
    priority: number;
    /**
     * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
     */
    terminates: boolean;
}

export interface GetLoadBalancerRuleFixedResponse {
    /**
     * The http 'Content-Type' header to include in the response.
     */
    contentType: string;
    /**
     * The http 'Location' header to include in the response.
     */
    location: string;
    /**
     * Text to include as the http body.
     */
    messageBody: string;
    /**
     * The http status code to respond with.
     */
    statusCode: number;
}

export interface GetLoadBalancerRuleOverrides {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.GetLoadBalancerRuleOverridesAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.GetLoadBalancerRuleOverridesLocationStrategy;
    /**
     * Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.GetLoadBalancerRuleOverridesRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ipCookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `sessionAffinityTtl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `sessionAffinityAttributes` for additional required configuration.
     * Available values: "none", "cookie", "ipCookie", "header".
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.GetLoadBalancerRuleOverridesSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are: - `"cookie"` / `"ipCookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface GetLoadBalancerRuleOverridesAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancerRuleOverridesLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancerRuleOverridesRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancerRuleOverridesSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     * Available values: "Auto", "Lax", "None", "Strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     * Available values: "Auto", "Always", "Never".
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
     * Available values: "none", "temporary", "sticky".
     */
    zeroDowntimeFailover: string;
}

export interface GetLoadBalancerSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     * Available values: "Auto", "Lax", "None", "Strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     * Available values: "Auto", "Always", "Never".
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
     * Available values: "none", "temporary", "sticky".
     */
    zeroDowntimeFailover: string;
}

export interface GetLoadBalancersResult {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.GetLoadBalancersResultAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    createdOn: string;
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools: string[];
    /**
     * Object description.
     */
    description: string;
    /**
     * Whether to enable (the default) this load balancer.
     */
    enabled: boolean;
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool: string;
    id: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.GetLoadBalancersResultLocationStrategy;
    modifiedOn: string;
    /**
     * The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used.
     */
    name: string;
    /**
     * List of networks where Load Balancer or Pool is enabled.
     */
    networks: string[];
    /**
     * Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Whether the hostname should be gray clouded (false) or orange clouded (true).
     */
    proxied: boolean;
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.GetLoadBalancersResultRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * BETA Field Not General Access: A list of rules for this load balancer to execute.
     */
    rules: outputs.GetLoadBalancersResultRule[];
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ipCookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `sessionAffinityTtl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `sessionAffinityAttributes` for additional required configuration.
     * Available values: "none", "cookie", "ipCookie", "header".
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.GetLoadBalancersResultSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are: - `"cookie"` / `"ipCookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
    zoneName: string;
}

export interface GetLoadBalancersResultAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancersResultLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancersResultRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancersResultRule {
    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixedResponse in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     */
    condition: string;
    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     */
    disabled: boolean;
    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     */
    fixedResponse: outputs.GetLoadBalancersResultRuleFixedResponse;
    /**
     * Name of this rule. Only used for human readability.
     */
    name: string;
    /**
     * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
     */
    overrides: outputs.GetLoadBalancersResultRuleOverrides;
    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     */
    priority: number;
    /**
     * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
     */
    terminates: boolean;
}

export interface GetLoadBalancersResultRuleFixedResponse {
    /**
     * The http 'Content-Type' header to include in the response.
     */
    contentType: string;
    /**
     * The http 'Location' header to include in the response.
     */
    location: string;
    /**
     * Text to include as the http body.
     */
    messageBody: string;
    /**
     * The http status code to respond with.
     */
    statusCode: number;
}

export interface GetLoadBalancersResultRuleOverrides {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.GetLoadBalancersResultRuleOverridesAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.GetLoadBalancersResultRuleOverridesLocationStrategy;
    /**
     * Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.GetLoadBalancersResultRuleOverridesRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ipCookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `sessionAffinityTtl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `sessionAffinityAttributes` for additional required configuration.
     * Available values: "none", "cookie", "ipCookie", "header".
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.GetLoadBalancersResultRuleOverridesSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are: - `"cookie"` / `"ipCookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface GetLoadBalancersResultRuleOverridesAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancersResultRuleOverridesLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancersResultRuleOverridesRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancersResultRuleOverridesSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     * Available values: "Auto", "Lax", "None", "Strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     * Available values: "Auto", "Always", "Never".
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
     * Available values: "none", "temporary", "sticky".
     */
    zeroDowntimeFailover: string;
}

export interface GetLoadBalancersResultSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     * Available values: "Auto", "Lax", "None", "Strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     * Available values: "Auto", "Always", "Never".
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
     * Available values: "none", "temporary", "sticky".
     */
    zeroDowntimeFailover: string;
}

export interface GetLogpushDatasetJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve202144228: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     * Available values: "ndjson", "csv".
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     * Available values: "unixnano", "unix", "rfc3339".
     */
    timestampFormat: string;
}

export interface GetLogpushJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve202144228: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     * Available values: "ndjson", "csv".
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     * Available values: "unixnano", "unix", "rfc3339".
     */
    timestampFormat: string;
}

export interface GetLogpushJobsResult {
    /**
     * Name of the dataset. A list of supported datasets can be found on the [Developer Docs](https://developers.cloudflare.com/logs/reference/log-fields/).
     * Available values: "access*requests", "audit*logs", "audit*logs*v2", "biso*user*actions", "casb*findings", "device*posture*results", "dlp*forensic*copies", "dns*firewall*logs", "dns*logs", "email*security*alerts", "firewall*events", "gateway*dns", "gateway*http", "gateway*network", "http*requests", "magic*ids*detections", "nel*reports", "network*analytics*logs", "page*shield*events", "sinkhole*http*logs", "spectrum*events", "ssh*logs", "workers*trace*events", "zaraz*events", "zero*trust*network*sessions".
     */
    dataset: string;
    /**
     * Uniquely identifies a resource (such as an s3 bucket) where data. will be pushed. Additional configuration parameters supported by the destination may be included.
     */
    destinationConf: string;
    /**
     * Flag that indicates if the job is enabled.
     */
    enabled: boolean;
    /**
     * If not null, the job is currently failing. Failures are usually. repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error*message and last*error are set to null.
     */
    errorMessage: string;
    /**
     * This field is deprecated. Please use `max_upload_*` parameters instead. . The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files.
     * Available values: "high", "low".
     *
     * @deprecated This attribute is deprecated.
     */
    frequency: string;
    /**
     * Unique id of the job.
     */
    id: number;
    /**
     * The kind parameter (optional) is used to differentiate between Logpush and Edge Log Delivery jobs (when supported by the dataset).
     * Available values: "", "edge".
     */
    kind: string;
    /**
     * Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty.
     */
    lastComplete: string;
    /**
     * Records the last time the job failed. If not null, the job is currently. failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the errorMessage field.
     */
    lastError: string;
    /**
     * This field is deprecated. Use `outputOptions` instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately.
     *
     * @deprecated This attribute is deprecated.
     */
    logpullOptions: string;
    /**
     * The maximum uncompressed file size of a batch of logs. This setting value must be between `5 MB` and `1 GB`, or `0` to disable it. Note that you cannot set a minimum file size; this means that log files may be much smaller than this batch size.
     */
    maxUploadBytes: number;
    /**
     * The maximum interval in seconds for log batches. This setting must be between 30 and 300 seconds (5 minutes), or `0` to disable it. Note that you cannot specify a minimum interval for log batches; this means that log files may be sent in shorter intervals than this.
     */
    maxUploadIntervalSeconds: number;
    /**
     * The maximum number of log lines per batch. This setting must be between 1000 and 1,000,000 lines, or `0` to disable it. Note that you cannot specify a minimum number of log lines per batch; this means that log files may contain many fewer lines than this.
     */
    maxUploadRecords: number;
    /**
     * Optional human readable job name. Not unique. Cloudflare suggests. that you set this to a meaningful string, like the domain name, to make it easier to identify your job.
     */
    name: string;
    /**
     * The structured replacement for `logpullOptions`. When including this field, the `logpullOption` field will be ignored.
     */
    outputOptions: outputs.GetLogpushJobsResultOutputOptions;
}

export interface GetLogpushJobsResultOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve202144228: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     * Available values: "ndjson", "csv".
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     * Available values: "unixnano", "unix", "rfc3339".
     */
    timestampFormat: string;
}

export interface GetMagicNetworkMonitoringConfigurationWarpDevice {
    /**
     * Unique identifier for the warp device.
     */
    id: string;
    /**
     * Name of the warp device.
     */
    name: string;
    /**
     * IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
     */
    routerIp: string;
}

export interface GetMagicNetworkMonitoringRulesResult {
    /**
     * Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit.
     */
    automaticAdvertisement: boolean;
    /**
     * The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
     */
    bandwidthThreshold: number;
    /**
     * The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"].
     * Available values: "1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m".
     */
    duration: string;
    /**
     * The id of the rule. Must be unique.
     */
    id: string;
    /**
     * The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters.
     */
    name: string;
    /**
     * The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
     */
    packetThreshold: number;
    /**
     * Prefix match type to be applied for a prefix auto advertisement when using an advancedDdos rule.
     * Available values: "exact", "subnet", "supernet".
     */
    prefixMatch: string;
    prefixes: string[];
    /**
     * MNM rule type.
     * Available values: "threshold", "zscore", "advancedDdos".
     */
    type: string;
    /**
     * Level of sensitivity set for zscore rules.
     * Available values: "low", "medium", "high".
     */
    zscoreSensitivity: string;
    /**
     * Target of the zscore rule analysis.
     * Available values: "bits", "packets".
     */
    zscoreTarget: string;
}

export interface GetMagicTransitConnectorDevice {
    id: string;
    serialNumber: string;
}

export interface GetMagicTransitConnectorsResult {
    activated: boolean;
    device: outputs.GetMagicTransitConnectorsResultDevice;
    id: string;
    interruptWindowDurationHours: number;
    interruptWindowHourOfDay: number;
    lastHeartbeat: string;
    lastSeenVersion: string;
    lastUpdated: string;
    notes: string;
    timezone: string;
}

export interface GetMagicTransitConnectorsResultDevice {
    id: string;
    serialNumber: string;
}

export interface GetMagicTransitSiteAclLan1 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteAclLan2 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteAclsResult {
    /**
     * Description for the ACL.
     */
    description: string;
    /**
     * The desired forwarding action for this ACL policy. If set to "false", the policy will forward traffic to Cloudflare. If set to "true", the policy will forward traffic locally on the Magic Connector. If not included in request, will default to false.
     */
    forwardLocally: boolean;
    /**
     * Identifier
     */
    id: string;
    lan1: outputs.GetMagicTransitSiteAclsResultLan1;
    lan2: outputs.GetMagicTransitSiteAclsResultLan2;
    /**
     * The name of the ACL.
     */
    name: string;
    protocols: string[];
    /**
     * The desired traffic direction for this ACL policy. If set to "false", the policy will allow bidirectional traffic. If set to "true", the policy will only allow traffic in one direction. If not included in request, will default to false.
     */
    unidirectional: boolean;
}

export interface GetMagicTransitSiteAclsResultLan1 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteAclsResultLan2 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteFilter {
    /**
     * Identifier
     */
    connectorid?: string;
}

export interface GetMagicTransitSiteLanNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLanRoutedSubnet {
    nat: outputs.GetMagicTransitSiteLanRoutedSubnetNat;
    /**
     * A valid IPv4 address.
     */
    nextHop: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    prefix: string;
}

export interface GetMagicTransitSiteLanRoutedSubnetNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    dhcpRelay: outputs.GetMagicTransitSiteLanStaticAddressingDhcpRelay;
    dhcpServer: outputs.GetMagicTransitSiteLanStaticAddressingDhcpServer;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    virtualAddress: string;
}

export interface GetMagicTransitSiteLanStaticAddressingDhcpRelay {
    /**
     * List of DHCP server IPs.
     */
    serverAddresses: string[];
}

export interface GetMagicTransitSiteLanStaticAddressingDhcpServer {
    /**
     * A valid IPv4 address.
     */
    dhcpPoolEnd: string;
    /**
     * A valid IPv4 address.
     */
    dhcpPoolStart: string;
    /**
     * A valid IPv4 address.
     */
    dnsServer: string;
    dnsServers: string[];
    /**
     * Mapping of MAC addresses to IP addresses
     */
    reservations: {[key: string]: string};
}

export interface GetMagicTransitSiteLansResult {
    /**
     * mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
     */
    haLink: boolean;
    /**
     * Identifier
     */
    id: string;
    name: string;
    nat: outputs.GetMagicTransitSiteLansResultNat;
    physport: number;
    routedSubnets: outputs.GetMagicTransitSiteLansResultRoutedSubnet[];
    /**
     * Identifier
     */
    siteId: string;
    /**
     * If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
     */
    staticAddressing: outputs.GetMagicTransitSiteLansResultStaticAddressing;
    /**
     * VLAN ID. Use zero for untagged.
     */
    vlanTag: number;
}

export interface GetMagicTransitSiteLansResultNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLansResultRoutedSubnet {
    nat: outputs.GetMagicTransitSiteLansResultRoutedSubnetNat;
    /**
     * A valid IPv4 address.
     */
    nextHop: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    prefix: string;
}

export interface GetMagicTransitSiteLansResultRoutedSubnetNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLansResultStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    dhcpRelay: outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpRelay;
    dhcpServer: outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpServer;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    virtualAddress: string;
}

export interface GetMagicTransitSiteLansResultStaticAddressingDhcpRelay {
    /**
     * List of DHCP server IPs.
     */
    serverAddresses: string[];
}

export interface GetMagicTransitSiteLansResultStaticAddressingDhcpServer {
    /**
     * A valid IPv4 address.
     */
    dhcpPoolEnd: string;
    /**
     * A valid IPv4 address.
     */
    dhcpPoolStart: string;
    /**
     * A valid IPv4 address.
     */
    dnsServer: string;
    dnsServers: string[];
    /**
     * Mapping of MAC addresses to IP addresses
     */
    reservations: {[key: string]: string};
}

export interface GetMagicTransitSiteLocation {
    /**
     * Latitude
     */
    lat: string;
    /**
     * Longitude
     */
    lon: string;
}

export interface GetMagicTransitSiteWanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    /**
     * A valid IPv4 address.
     */
    gatewayAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
}

export interface GetMagicTransitSiteWansResult {
    /**
     * Magic WAN health check rate for tunnels created on this link. The default value is `mid`.
     * Available values: "low", "mid", "high".
     */
    healthCheckRate: string;
    /**
     * Identifier
     */
    id: string;
    name: string;
    physport: number;
    /**
     * Priority of WAN for traffic loadbalancing.
     */
    priority: number;
    /**
     * Identifier
     */
    siteId: string;
    /**
     * (optional) if omitted, use DHCP. Submit secondary*address when site is in high availability mode.
     */
    staticAddressing: outputs.GetMagicTransitSiteWansResultStaticAddressing;
    /**
     * VLAN ID. Use zero for untagged.
     */
    vlanTag: number;
}

export interface GetMagicTransitSiteWansResultStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    /**
     * A valid IPv4 address.
     */
    gatewayAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
}

export interface GetMagicTransitSitesResult {
    /**
     * Magic Connector identifier tag.
     */
    connectorId: string;
    description: string;
    /**
     * Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
     */
    haMode: boolean;
    /**
     * Identifier
     */
    id: string;
    /**
     * Location of site in latitude and longitude.
     */
    location: outputs.GetMagicTransitSitesResultLocation;
    /**
     * The name of the site.
     */
    name: string;
    /**
     * Magic Connector identifier tag. Used when high availability mode is on.
     */
    secondaryConnectorId: string;
}

export interface GetMagicTransitSitesResultLocation {
    /**
     * Latitude
     */
    lat: string;
    /**
     * Longitude
     */
    lon: string;
}

export interface GetMagicWanGreTunnelGreTunnel {
    /**
     * True if automatic stateful return routing should be enabled for a tunnel, false otherwise.
     */
    automaticReturnRouting: boolean;
    bgp: outputs.GetMagicWanGreTunnelGreTunnelBgp;
    bgpStatus: outputs.GetMagicWanGreTunnelGreTunnelBgpStatus;
    /**
     * The IP address assigned to the Cloudflare side of the GRE tunnel.
     */
    cloudflareGreEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the GRE tunnel.
     */
    customerGreEndpoint: string;
    /**
     * An optional description of the GRE tunnel.
     */
    description: string;
    healthCheck: outputs.GetMagicWanGreTunnelGreTunnelHealthCheck;
    /**
     * Identifier
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * A 127 bit IPV6 prefix from within the virtual*subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual*subnet6. Eg if virtual*subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface*address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127
     */
    interfaceAddress6: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
     */
    mtu: number;
    /**
     * The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
     */
    name: string;
    /**
     * Time To Live (TTL) in number of hops of the GRE tunnel.
     */
    ttl: number;
}

export interface GetMagicWanGreTunnelGreTunnelBgp {
    /**
     * ASN used on the customer end of the BGP session
     */
    customerAsn: number;
    /**
     * Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.
     */
    extraPrefixes: string[];
    /**
     * MD5 key to use for session authentication.
     */
    md5Key: string;
}

export interface GetMagicWanGreTunnelGreTunnelBgpStatus {
    bgpState: string;
    cfSpeakerIp: string;
    cfSpeakerPort: number;
    customerSpeakerIp: string;
    customerSpeakerPort: number;
    /**
     * Available values: "BGP*DOWN", "BGP*UP", "BGP_ESTABLISHING".
     */
    state: string;
    tcpEstablished: boolean;
    updatedAt: string;
}

export interface GetMagicWanGreTunnelGreTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     * Available values: "unidirectional", "bidirectional".
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     * Available values: "low", "mid", "high".
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.GetMagicWanGreTunnelGreTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     * Available values: "reply", "request".
     */
    type: string;
}

export interface GetMagicWanGreTunnelGreTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnel {
    /**
     * When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
     */
    allowNullCipher: boolean;
    /**
     * True if automatic stateful return routing should be enabled for a tunnel, false otherwise.
     */
    automaticReturnRouting: boolean;
    bgp: outputs.GetMagicWanIpsecTunnelIpsecTunnelBgp;
    bgpStatus: outputs.GetMagicWanIpsecTunnelIpsecTunnelBgpStatus;
    /**
     * The IP address assigned to the Cloudflare side of the IPsec tunnel.
     */
    cloudflareEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    customRemoteIdentities: outputs.GetMagicWanIpsecTunnelIpsecTunnelCustomRemoteIdentities;
    /**
     * The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
     */
    customerEndpoint: string;
    /**
     * An optional description forthe IPsec tunnel.
     */
    description: string;
    healthCheck: outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheck;
    /**
     * Identifier
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * A 127 bit IPV6 prefix from within the virtual*subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual*subnet6. Eg if virtual*subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface*address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127
     */
    interfaceAddress6: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * The name of the IPsec tunnel. The name cannot share a name with other tunnels.
     */
    name: string;
    /**
     * The PSK metadata that includes when the PSK was generated.
     */
    pskMetadata: outputs.GetMagicWanIpsecTunnelIpsecTunnelPskMetadata;
    /**
     * If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
     */
    replayProtection: boolean;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelBgp {
    /**
     * ASN used on the customer end of the BGP session
     */
    customerAsn: number;
    /**
     * Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.
     */
    extraPrefixes: string[];
    /**
     * MD5 key to use for session authentication.
     */
    md5Key: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelBgpStatus {
    bgpState: string;
    cfSpeakerIp: string;
    cfSpeakerPort: number;
    customerSpeakerIp: string;
    customerSpeakerPort: number;
    /**
     * Available values: "BGP*DOWN", "BGP*UP", "BGP_ESTABLISHING".
     */
    state: string;
    tcpEstablished: boolean;
    updatedAt: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelCustomRemoteIdentities {
    /**
     * A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The
     * generated IKE IDs can still be used even if this custom value is specified.
     */
    fqdnId: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     * Available values: "unidirectional", "bidirectional".
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     * Available values: "low", "mid", "high".
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     * Available values: "reply", "request".
     */
    type: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelPskMetadata {
    /**
     * The date and time the tunnel was last modified.
     */
    lastGeneratedOn: string;
}

export interface GetMagicWanStaticRouteRoute {
    /**
     * When the route was created.
     */
    createdOn: string;
    /**
     * An optional human provided description of the static route.
     */
    description: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * When the route was last modified.
     */
    modifiedOn: string;
    /**
     * The next-hop IP Address for the static route.
     */
    nexthop: string;
    /**
     * IP Prefix in Classless Inter-Domain Routing format.
     */
    prefix: string;
    /**
     * Priority of the static route.
     */
    priority: number;
    /**
     * Used only for ECMP routes.
     */
    scope: outputs.GetMagicWanStaticRouteRouteScope;
    /**
     * Optional weight of the ECMP scope - if provided.
     */
    weight: number;
}

export interface GetMagicWanStaticRouteRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions: string[];
}

export interface GetManagedTransformsManagedRequestHeader {
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface GetManagedTransformsManagedResponseHeader {
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface GetMtlsCertificatesResult {
    /**
     * Indicates whether the certificate is a CA or leaf certificate.
     */
    ca: boolean;
    /**
     * The uploaded root CA certificate.
     */
    certificates: string;
    /**
     * When the certificate expires.
     */
    expiresOn: string;
    /**
     * Identifier.
     */
    id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    issuer: string;
    /**
     * Optional unique name for the certificate. Only used for human readability.
     */
    name: string;
    /**
     * The certificate serial number.
     */
    serialNumber: string;
    /**
     * The type of hash used for the certificate.
     */
    signature: string;
    /**
     * This is the time the certificate was uploaded.
     */
    uploadedOn: string;
}

export interface GetNotificationPoliciesResult {
    /**
     * Optional specification of how often to re-alert from the same incident, not support on all alert types.
     */
    alertInterval: string;
    /**
     * Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values.
     * Available values: "access*custom*certificate*expiration*type", "advanced*ddos*attack*l4*alert", "advanced*ddos*attack*l7*alert", "advanced*http*alert*error", "bgp*hijack*notification", "billing*usage*alert", "block*notification*block*removed", "block*notification*new*block", "block*notification*review*rejected", "bot*traffic*basic*alert", "brand*protection*alert", "brand*protection*digest", "clickhouse*alert*fw*anomaly", "clickhouse*alert*fw*ent*anomaly", "cloudforce*one*request*notification", "custom*analytics", "custom*bot*detection*alert", "custom*ssl*certificate*event*type", "dedicated*ssl*certificate*event*type", "device*connectivity*anomaly*alert", "dos*attack*l4", "dos*attack*l7", "expiring*service*token*alert", "failing*logpush*job*disabled*alert", "fbm*auto*advertisement", "fbm*dosd*attack", "fbm*volumetric*attack", "health*check*status*notification", "hostname*aop*custom*certificate*expiration*type", "http*alert*edge*error", "http*alert*origin*error", "image*notification", "image*resizing*notification", "incident*alert", "load*balancing*health*alert", "load*balancing*pool*enablement*alert", "logo*match*alert", "magic*tunnel*health*check*event", "magic*wan*tunnel*health", "maintenance*event*notification", "mtls*certificate*store*certificate*expiration*type", "pages*event*alert", "radar*notification", "real*origin*monitoring", "scriptmonitor*alert*new*code*change*detections", "scriptmonitor*alert*new*hosts", "scriptmonitor*alert*new*malicious*hosts", "scriptmonitor*alert*new*malicious*scripts", "scriptmonitor*alert*new*malicious*url", "scriptmonitor*alert*new*max*length*resource*url", "scriptmonitor*alert*new*resources", "secondary*dns*all*primaries*failing", "secondary*dns*primaries*failing", "secondary*dns*warning", "secondary*dns*zone*successfully*updated", "secondary*dns*zone*validation*warning", "security*insights*alert", "sentinel*alert", "stream*live*notifications", "synthetic*test*latency*alert", "synthetic*test*low*availability*alert", "traffic*anomalies*alert", "tunnel*health*event", "tunnel*update*event", "universal*ssl*event*type", "web*analytics*metrics*update", "zone*aop*custom*certificate*expiration*type".
     */
    alertType: string;
    created: string;
    /**
     * Optional description for the Notification policy.
     */
    description: string;
    /**
     * Whether or not the Notification policy is enabled.
     */
    enabled: boolean;
    /**
     * Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details.
     */
    filters: outputs.GetNotificationPoliciesResultFilters;
    /**
     * The unique identifier of a notification policy
     */
    id: string;
    /**
     * List of IDs that will be used when dispatching a notification. IDs for email type will be the email address.
     */
    mechanisms: outputs.GetNotificationPoliciesResultMechanisms;
    modified: string;
    /**
     * Name of the policy.
     */
    name: string;
}

export interface GetNotificationPoliciesResultFilters {
    /**
     * Usage depends on specific alert type
     */
    actions: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedAsns: string[];
    /**
     * Used for configuring incident_alert
     */
    affectedComponents: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedLocations: string[];
    /**
     * Used for configuring maintenance*event*notification
     */
    airportCodes: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferences: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferencesValues: string[];
    /**
     * Used for configuring load*balancing*pool*enablement*alert
     */
    enableds: string[];
    /**
     * Used for configuring pages*event*alert
     */
    environments: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    eventSources: string[];
    /**
     * Usage depends on specific alert type
     */
    eventTypes: string[];
    /**
     * Used for configuring pages*event*alert
     */
    events: string[];
    /**
     * Usage depends on specific alert type
     */
    groupBies: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    healthCheckIds: string[];
    /**
     * Used for configuring incident_alert
     */
    incidentImpacts: string[];
    /**
     * Used for configuring stream*live*notifications
     */
    inputIds: string[];
    /**
     * Used for configuring security*insights*alert
     */
    insightClasses: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    limits: string[];
    /**
     * Used for configuring logo*match*alert
     */
    logoTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    megabitsPerSeconds: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    newHealths: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    newStatuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    packetsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    poolIds: string[];
    /**
     * Usage depends on specific alert type
     */
    popNames: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    products: string[];
    /**
     * Used for configuring pages*event*alert
     */
    projectIds: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    protocols: string[];
    /**
     * Usage depends on specific alert type
     */
    queryTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    requestsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    selectors: string[];
    /**
     * Used for configuring clickhouse*alert*fw*ent*anomaly
     */
    services: string[];
    /**
     * Usage depends on specific alert type
     */
    slos: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    statuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetHostnames: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    targetIps: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetZoneNames: string[];
    /**
     * Used for configuring traffic*anomalies*alert
     */
    trafficExclusions: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    tunnelIds: string[];
    /**
     * Usage depends on specific alert type
     */
    tunnelNames: string[];
    /**
     * Usage depends on specific alert type
     */
    wheres: string[];
    /**
     * Usage depends on specific alert type
     */
    zones: string[];
}

export interface GetNotificationPoliciesResultMechanisms {
    emails: outputs.GetNotificationPoliciesResultMechanismsEmail[];
    pagerduties: outputs.GetNotificationPoliciesResultMechanismsPagerduty[];
    webhooks: outputs.GetNotificationPoliciesResultMechanismsWebhook[];
}

export interface GetNotificationPoliciesResultMechanismsEmail {
    /**
     * The email address
     */
    id: string;
}

export interface GetNotificationPoliciesResultMechanismsPagerduty {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPoliciesResultMechanismsWebhook {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPolicyFilters {
    /**
     * Usage depends on specific alert type
     */
    actions: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedAsns: string[];
    /**
     * Used for configuring incident_alert
     */
    affectedComponents: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedLocations: string[];
    /**
     * Used for configuring maintenance*event*notification
     */
    airportCodes: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferences: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferencesValues: string[];
    /**
     * Used for configuring load*balancing*pool*enablement*alert
     */
    enableds: string[];
    /**
     * Used for configuring pages*event*alert
     */
    environments: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    eventSources: string[];
    /**
     * Usage depends on specific alert type
     */
    eventTypes: string[];
    /**
     * Used for configuring pages*event*alert
     */
    events: string[];
    /**
     * Usage depends on specific alert type
     */
    groupBies: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    healthCheckIds: string[];
    /**
     * Used for configuring incident_alert
     */
    incidentImpacts: string[];
    /**
     * Used for configuring stream*live*notifications
     */
    inputIds: string[];
    /**
     * Used for configuring security*insights*alert
     */
    insightClasses: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    limits: string[];
    /**
     * Used for configuring logo*match*alert
     */
    logoTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    megabitsPerSeconds: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    newHealths: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    newStatuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    packetsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    poolIds: string[];
    /**
     * Usage depends on specific alert type
     */
    popNames: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    products: string[];
    /**
     * Used for configuring pages*event*alert
     */
    projectIds: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    protocols: string[];
    /**
     * Usage depends on specific alert type
     */
    queryTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    requestsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    selectors: string[];
    /**
     * Used for configuring clickhouse*alert*fw*ent*anomaly
     */
    services: string[];
    /**
     * Usage depends on specific alert type
     */
    slos: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    statuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetHostnames: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    targetIps: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetZoneNames: string[];
    /**
     * Used for configuring traffic*anomalies*alert
     */
    trafficExclusions: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    tunnelIds: string[];
    /**
     * Usage depends on specific alert type
     */
    tunnelNames: string[];
    /**
     * Usage depends on specific alert type
     */
    wheres: string[];
    /**
     * Usage depends on specific alert type
     */
    zones: string[];
}

export interface GetNotificationPolicyMechanisms {
    emails: outputs.GetNotificationPolicyMechanismsEmail[];
    pagerduties: outputs.GetNotificationPolicyMechanismsPagerduty[];
    webhooks: outputs.GetNotificationPolicyMechanismsWebhook[];
}

export interface GetNotificationPolicyMechanismsEmail {
    /**
     * The email address
     */
    id: string;
}

export interface GetNotificationPolicyMechanismsPagerduty {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPolicyMechanismsWebhook {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPolicyWebhooksListResult {
    /**
     * Timestamp of when the webhook destination was created.
     */
    createdAt: string;
    /**
     * The unique identifier of a webhook
     */
    id: string;
    /**
     * Timestamp of the last time an attempt to dispatch a notification to this webhook failed.
     */
    lastFailure: string;
    /**
     * Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook.
     */
    lastSuccess: string;
    /**
     * The name of the webhook destination. This will be included in the request body when you receive a webhook notification.
     */
    name: string;
    /**
     * Optional secret that will be passed in the `cf-webhook-auth` header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body.
     */
    secret: string;
    /**
     * Type of webhook endpoint.
     * Available values: "datadog", "discord", "feishu", "gchat", "generic", "opsgenie", "slack", "splunk".
     */
    type: string;
    /**
     * The POST endpoint to call when dispatching a notification.
     */
    url: string;
}

export interface GetOriginCaCertificateFilter {
    /**
     * Limit to the number of records returned.
     */
    limit?: number;
    /**
     * Offset the results
     */
    offset?: number;
    /**
     * Identifier.
     */
    zoneId: string;
}

export interface GetOriginCaCertificatesResult {
    /**
     * The Origin CA certificate. Will be newline-encoded.
     */
    certificate: string;
    /**
     * The Certificate Signing Request (CSR). Must be newline-encoded.
     */
    csr: string;
    /**
     * When the certificate will expire.
     */
    expiresOn: string;
    /**
     * Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate.
     */
    hostnames: string[];
    /**
     * Identifier.
     */
    id: string;
    /**
     * Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers).
     * Available values: "origin-rsa", "origin-ecc", "keyless-certificate".
     */
    requestType: string;
    /**
     * The number of days for which the certificate should be valid.
     * Available values: 7, 30, 90, 365, 730, 1095, 5475.
     */
    requestedValidity: number;
}

export interface GetPageShieldConnectionsListResult {
    addedAt: string;
    domainReportedMalicious: boolean;
    firstPageUrl: string;
    firstSeenAt: string;
    host: string;
    /**
     * Identifier
     */
    id: string;
    lastSeenAt: string;
    maliciousDomainCategories: string[];
    maliciousUrlCategories: string[];
    pageUrls: string[];
    url: string;
    urlContainsCdnCgiPath: boolean;
    urlReportedMalicious: boolean;
}

export interface GetPageShieldCookiesListResult {
    domainAttribute: string;
    expiresAttribute: string;
    firstSeenAt: string;
    host: string;
    httpOnlyAttribute: boolean;
    /**
     * Identifier
     */
    id: string;
    lastSeenAt: string;
    maxAgeAttribute: number;
    name: string;
    pageUrls: string[];
    pathAttribute: string;
    /**
     * Available values: "lax", "strict", "none".
     */
    sameSiteAttribute: string;
    secureAttribute: boolean;
    /**
     * Available values: "firstParty", "unknown".
     */
    type: string;
}

export interface GetPageShieldPoliciesResult {
    /**
     * The action to take if the expression matches
     * Available values: "allow", "log".
     */
    action: string;
    /**
     * A description for the policy
     */
    description: string;
    /**
     * Whether the policy is enabled
     */
    enabled: boolean;
    /**
     * The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax
     */
    expression: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The policy which will be applied
     */
    value: string;
}

export interface GetPageShieldScriptsListResult {
    addedAt: string;
    /**
     * The cryptomining score of the JavaScript content.
     */
    cryptominingScore: number;
    /**
     * The dataflow score of the JavaScript content.
     */
    dataflowScore: number;
    domainReportedMalicious: boolean;
    /**
     * The timestamp of when the script was last fetched.
     */
    fetchedAt: string;
    firstPageUrl: string;
    firstSeenAt: string;
    /**
     * The computed hash of the analyzed script.
     */
    hash: string;
    host: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The integrity score of the JavaScript content.
     */
    jsIntegrityScore: number;
    lastSeenAt: string;
    /**
     * The magecart score of the JavaScript content.
     */
    magecartScore: number;
    maliciousDomainCategories: string[];
    maliciousUrlCategories: string[];
    /**
     * The malware score of the JavaScript content.
     */
    malwareScore: number;
    /**
     * The obfuscation score of the JavaScript content.
     */
    obfuscationScore: number;
    pageUrls: string[];
    url: string;
    urlContainsCdnCgiPath: boolean;
    urlReportedMalicious: boolean;
}

export interface GetPageShieldScriptsVersion {
    /**
     * The cryptomining score of the JavaScript content.
     */
    cryptominingScore: number;
    /**
     * The dataflow score of the JavaScript content.
     */
    dataflowScore: number;
    /**
     * The timestamp of when the script was last fetched.
     */
    fetchedAt: string;
    /**
     * The computed hash of the analyzed script.
     */
    hash: string;
    /**
     * The integrity score of the JavaScript content.
     */
    jsIntegrityScore: number;
    /**
     * The magecart score of the JavaScript content.
     */
    magecartScore: number;
    /**
     * The malware score of the JavaScript content.
     */
    malwareScore: number;
    /**
     * The obfuscation score of the JavaScript content.
     */
    obfuscationScore: number;
}

export interface GetPagesDomainValidationData {
    errorMessage: string;
    /**
     * Available values: "http", "txt".
     */
    method: string;
    /**
     * Available values: "initializing", "pending", "active", "deactivated", "error".
     */
    status: string;
    txtName: string;
    txtValue: string;
}

export interface GetPagesDomainVerificationData {
    errorMessage: string;
    /**
     * Available values: "pending", "active", "deactivated", "blocked", "error".
     */
    status: string;
}

export interface GetPagesDomainsResult {
    /**
     * Available values: "google", "letsEncrypt".
     */
    certificateAuthority: string;
    createdOn: string;
    domainId: string;
    id: string;
    name: string;
    /**
     * Available values: "initializing", "pending", "active", "deactivated", "blocked", "error".
     */
    status: string;
    validationData: outputs.GetPagesDomainsResultValidationData;
    verificationData: outputs.GetPagesDomainsResultVerificationData;
    zoneTag: string;
}

export interface GetPagesDomainsResultValidationData {
    errorMessage: string;
    /**
     * Available values: "http", "txt".
     */
    method: string;
    /**
     * Available values: "initializing", "pending", "active", "deactivated", "error".
     */
    status: string;
    txtName: string;
    txtValue: string;
}

export interface GetPagesDomainsResultVerificationData {
    errorMessage: string;
    /**
     * Available values: "pending", "active", "deactivated", "blocked", "error".
     */
    status: string;
}

export interface GetPagesProjectBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectCanonicalDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.GetPagesProjectCanonicalDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.GetPagesProjectCanonicalDeploymentDeploymentTrigger;
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.GetPagesProjectCanonicalDeploymentEnvVars};
    /**
     * Type of deploy.
     * Available values: "preview", "production".
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.GetPagesProjectCanonicalDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.GetPagesProjectCanonicalDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.GetPagesProjectCanonicalDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface GetPagesProjectCanonicalDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectCanonicalDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     * Available values: "push", "adHoc".
     */
    type: string;
}

export interface GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface GetPagesProjectCanonicalDeploymentEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectCanonicalDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface GetPagesProjectCanonicalDeploymentSource {
    config: outputs.GetPagesProjectCanonicalDeploymentSourceConfig;
    type: string;
}

export interface GetPagesProjectCanonicalDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectCanonicalDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface GetPagesProjectDeploymentConfigs {
    /**
     * Configs for preview deploys.
     */
    preview: outputs.GetPagesProjectDeploymentConfigsPreview;
    /**
     * Configs for production deploys.
     */
    production: outputs.GetPagesProjectDeploymentConfigsProduction;
}

export interface GetPagesProjectDeploymentConfigsPreview {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewD1Databases};
    /**
     * Durable Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespaces};
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement: outputs.GetPagesProjectDeploymentConfigsPreviewPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewVectorizeBindings};
}

export interface GetPagesProjectDeploymentConfigsPreviewAiBindings {
    projectId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewBrowsers {
}

export interface GetPagesProjectDeploymentConfigsPreviewD1Databases {
    /**
     * UUID of the D1 database.
     */
    id: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespaces {
    /**
     * ID of the Durable Object namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewHyperdriveBindings {
    id: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewMtlsCertificates {
    certificateId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement mode.
     */
    mode: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewQueueProducers {
    /**
     * Name of the Queue.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction: string;
    /**
     * Name of the R2 bucket.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint: string;
    /**
     * The Service environment.
     */
    environment: string;
    /**
     * The Service name.
     */
    service: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewVectorizeBindings {
    indexName: string;
}

export interface GetPagesProjectDeploymentConfigsProduction {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionD1Databases};
    /**
     * Durable Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionDurableObjectNamespaces};
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement: outputs.GetPagesProjectDeploymentConfigsProductionPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionVectorizeBindings};
}

export interface GetPagesProjectDeploymentConfigsProductionAiBindings {
    projectId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset: string;
}

export interface GetPagesProjectDeploymentConfigsProductionBrowsers {
}

export interface GetPagesProjectDeploymentConfigsProductionD1Databases {
    /**
     * UUID of the D1 database.
     */
    id: string;
}

export interface GetPagesProjectDeploymentConfigsProductionDurableObjectNamespaces {
    /**
     * ID of the Durable Object namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectDeploymentConfigsProductionHyperdriveBindings {
    id: string;
}

export interface GetPagesProjectDeploymentConfigsProductionKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionMtlsCertificates {
    certificateId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement mode.
     */
    mode: string;
}

export interface GetPagesProjectDeploymentConfigsProductionQueueProducers {
    /**
     * Name of the Queue.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsProductionR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction: string;
    /**
     * Name of the R2 bucket.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsProductionServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint: string;
    /**
     * The Service environment.
     */
    environment: string;
    /**
     * The Service name.
     */
    service: string;
}

export interface GetPagesProjectDeploymentConfigsProductionVectorizeBindings {
    indexName: string;
}

export interface GetPagesProjectLatestDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.GetPagesProjectLatestDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.GetPagesProjectLatestDeploymentDeploymentTrigger;
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.GetPagesProjectLatestDeploymentEnvVars};
    /**
     * Type of deploy.
     * Available values: "preview", "production".
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.GetPagesProjectLatestDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.GetPagesProjectLatestDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.GetPagesProjectLatestDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface GetPagesProjectLatestDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectLatestDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.GetPagesProjectLatestDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     * Available values: "push", "adHoc".
     */
    type: string;
}

export interface GetPagesProjectLatestDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface GetPagesProjectLatestDeploymentEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectLatestDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface GetPagesProjectLatestDeploymentSource {
    config: outputs.GetPagesProjectLatestDeploymentSourceConfig;
    type: string;
}

export interface GetPagesProjectLatestDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectLatestDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface GetPagesProjectSource {
    config: outputs.GetPagesProjectSourceConfig;
    type: string;
}

export interface GetPagesProjectSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectsResult {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.GetPagesProjectsResultBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.GetPagesProjectsResultDeploymentTrigger;
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.GetPagesProjectsResultEnvVars};
    /**
     * Type of deploy.
     * Available values: "preview", "production".
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.GetPagesProjectsResultLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.GetPagesProjectsResultSource;
    /**
     * List of past stages.
     */
    stages: outputs.GetPagesProjectsResultStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface GetPagesProjectsResultBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectsResultDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.GetPagesProjectsResultDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     * Available values: "push", "adHoc".
     */
    type: string;
}

export interface GetPagesProjectsResultDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface GetPagesProjectsResultEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectsResultLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface GetPagesProjectsResultSource {
    config: outputs.GetPagesProjectsResultSourceConfig;
    type: string;
}

export interface GetPagesProjectsResultSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectsResultStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface GetQueueConsumer {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.GetQueueConsumerSettings;
    /**
     * Available values: "worker", "httpPull".
     */
    type: string;
}

export interface GetQueueConsumerSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency: number;
    /**
     * The maximum number of retries
     */
    maxRetries: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs: number;
}

export interface GetQueueConsumersResult {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.GetQueueConsumersResultSettings;
    /**
     * Available values: "worker", "httpPull".
     */
    type: string;
}

export interface GetQueueConsumersResultSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency: number;
    /**
     * The maximum number of retries
     */
    maxRetries: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs: number;
}

export interface GetQueueProducer {
    bucketName: string;
    script: string;
    /**
     * Available values: "worker", "r2Bucket".
     */
    type: string;
}

export interface GetQueueSettings {
    /**
     * Number of seconds to delay delivery of all messages to consumers.
     */
    deliveryDelay: number;
    /**
     * Indicates if message delivery to consumers is currently paused.
     */
    deliveryPaused: boolean;
    /**
     * Number of seconds after which an unconsumed message will be delayed.
     */
    messageRetentionPeriod: number;
}

export interface GetQueuesResult {
    consumers: outputs.GetQueuesResultConsumer[];
    consumersTotalCount: number;
    createdOn: string;
    modifiedOn: string;
    producers: outputs.GetQueuesResultProducer[];
    producersTotalCount: number;
    queueId: string;
    queueName: string;
    settings: outputs.GetQueuesResultSettings;
}

export interface GetQueuesResultConsumer {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.GetQueuesResultConsumerSettings;
    /**
     * Available values: "worker", "httpPull".
     */
    type: string;
}

export interface GetQueuesResultConsumerSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency: number;
    /**
     * The maximum number of retries
     */
    maxRetries: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs: number;
}

export interface GetQueuesResultProducer {
    bucketName: string;
    script: string;
    /**
     * Available values: "worker", "r2Bucket".
     */
    type: string;
}

export interface GetQueuesResultSettings {
    /**
     * Number of seconds to delay delivery of all messages to consumers.
     */
    deliveryDelay: number;
    /**
     * Indicates if message delivery to consumers is currently paused.
     */
    deliveryPaused: boolean;
    /**
     * Number of seconds after which an unconsumed message will be delayed.
     */
    messageRetentionPeriod: number;
}

export interface GetR2BucketCorsRule {
    /**
     * Object specifying allowed origins, methods and headers for this CORS rule.
     */
    allowed: outputs.GetR2BucketCorsRuleAllowed;
    /**
     * Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
     */
    exposeHeaders: string[];
    /**
     * Identifier for this rule.
     */
    id: string;
    /**
     * Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
     */
    maxAgeSeconds: number;
}

export interface GetR2BucketCorsRuleAllowed {
    /**
     * Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
     */
    headers: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
     */
    methods: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
     */
    origins: string[];
}

export interface GetR2BucketEventNotificationRule {
    /**
     * Array of R2 object actions that will trigger notifications.
     */
    actions: string[];
    /**
     * Timestamp when the rule was created.
     */
    createdAt: string;
    /**
     * A description that can be used to identify the event notification rule after creation.
     */
    description: string;
    /**
     * Notifications will be sent only for objects with this prefix.
     */
    prefix: string;
    /**
     * Rule ID.
     */
    ruleId: string;
    /**
     * Notifications will be sent only for objects with this suffix.
     */
    suffix: string;
}

export interface GetR2BucketLifecycleRule {
    /**
     * Transition to abort ongoing multipart uploads.
     */
    abortMultipartUploadsTransition: outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransition;
    /**
     * Conditions that apply to all transitions of this rule.
     */
    conditions: outputs.GetR2BucketLifecycleRuleConditions;
    /**
     * Transition to delete objects.
     */
    deleteObjectsTransition: outputs.GetR2BucketLifecycleRuleDeleteObjectsTransition;
    /**
     * Whether or not this rule is in effect.
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule.
     */
    id: string;
    /**
     * Transitions to change the storage class of objects.
     */
    storageClassTransitions: outputs.GetR2BucketLifecycleRuleStorageClassTransition[];
}

export interface GetR2BucketLifecycleRuleAbortMultipartUploadsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition: outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition;
}

export interface GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition {
    maxAge: number;
    /**
     * Available values: "Age".
     */
    type: string;
}

export interface GetR2BucketLifecycleRuleConditions {
    /**
     * Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
     */
    prefix: string;
}

export interface GetR2BucketLifecycleRuleDeleteObjectsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition: outputs.GetR2BucketLifecycleRuleDeleteObjectsTransitionCondition;
}

export interface GetR2BucketLifecycleRuleDeleteObjectsTransitionCondition {
    date: string;
    maxAge: number;
    /**
     * Available values: "Age", "Date".
     */
    type: string;
}

export interface GetR2BucketLifecycleRuleStorageClassTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition: outputs.GetR2BucketLifecycleRuleStorageClassTransitionCondition;
    /**
     * Available values: "InfrequentAccess".
     */
    storageClass: string;
}

export interface GetR2BucketLifecycleRuleStorageClassTransitionCondition {
    date: string;
    maxAge: number;
    /**
     * Available values: "Age", "Date".
     */
    type: string;
}

export interface GetR2BucketLockRule {
    /**
     * Condition to apply a lock rule to an object for how long in seconds.
     */
    condition: outputs.GetR2BucketLockRuleCondition;
    /**
     * Whether or not this rule is in effect.
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule.
     */
    id: string;
    /**
     * Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
     */
    prefix: string;
}

export interface GetR2BucketLockRuleCondition {
    date: string;
    maxAgeSeconds: number;
    /**
     * Available values: "Age", "Date", "Indefinite".
     */
    type: string;
}

export interface GetR2BucketSippyDestination {
    /**
     * ID of the Cloudflare API token used when writing objects to this
     * bucket.
     */
    accessKeyId: string;
    account: string;
    /**
     * Name of the bucket on the provider.
     */
    bucket: string;
    /**
     * Available values: "r2".
     */
    provider: string;
}

export interface GetR2BucketSippySource {
    /**
     * Name of the bucket on the provider.
     */
    bucket: string;
    /**
     * Available values: "aws", "gcs".
     */
    provider: string;
    /**
     * Region where the bucket resides (AWS only).
     */
    region: string;
}

export interface GetR2CustomDomainStatus {
    /**
     * Ownership status of the domain.
     * Available values: "pending", "active", "deactivated", "blocked", "error", "unknown".
     */
    ownership: string;
    /**
     * SSL certificate status.
     * Available values: "initializing", "pending", "active", "deactivated", "error", "unknown".
     */
    ssl: string;
}

export interface GetRateLimitAction {
    /**
     * The action to perform.
     * Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
     */
    mode: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response: outputs.GetRateLimitActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout: number;
}

export interface GetRateLimitActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType: string;
}

export interface GetRateLimitBypass {
    /**
     * Available values: "url".
     */
    name: string;
    /**
     * The URL to bypass.
     */
    value: string;
}

export interface GetRateLimitMatch {
    headers: outputs.GetRateLimitMatchHeader[];
    request: outputs.GetRateLimitMatchRequest;
    response: outputs.GetRateLimitMatchResponse;
}

export interface GetRateLimitMatchHeader {
    /**
     * The name of the response header to match.
     */
    name: string;
    /**
     * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
     * Available values: "eq", "ne".
     */
    op: string;
    /**
     * The value of the response header, which must match exactly.
     */
    value: string;
}

export interface GetRateLimitMatchRequest {
    /**
     * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
     */
    methods: string[];
    /**
     * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
     */
    schemes: string[];
    /**
     * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
     */
    url: string;
}

export interface GetRateLimitMatchResponse {
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
     */
    originTraffic: boolean;
}

export interface GetRateLimitsResult {
    /**
     * The action to perform when the threshold of matched traffic within the configured period is exceeded.
     */
    action: outputs.GetRateLimitsResultAction;
    /**
     * Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
     */
    bypasses: outputs.GetRateLimitsResultBypass[];
    /**
     * An informative summary of the rule. This value is sanitized and any tags will be removed.
     */
    description: string;
    /**
     * When true, indicates that the rate limit is currently disabled.
     */
    disabled: boolean;
    /**
     * The unique identifier of the rate limit.
     */
    id: string;
    /**
     * Determines which traffic the rate limit counts towards the threshold.
     */
    match: outputs.GetRateLimitsResultMatch;
    /**
     * The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
     */
    period: number;
    /**
     * The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
     */
    threshold: number;
}

export interface GetRateLimitsResultAction {
    /**
     * The action to perform.
     * Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
     */
    mode: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response: outputs.GetRateLimitsResultActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout: number;
}

export interface GetRateLimitsResultActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType: string;
}

export interface GetRateLimitsResultBypass {
    /**
     * Available values: "url".
     */
    name: string;
    /**
     * The URL to bypass.
     */
    value: string;
}

export interface GetRateLimitsResultMatch {
    headers: outputs.GetRateLimitsResultMatchHeader[];
    request: outputs.GetRateLimitsResultMatchRequest;
    response: outputs.GetRateLimitsResultMatchResponse;
}

export interface GetRateLimitsResultMatchHeader {
    /**
     * The name of the response header to match.
     */
    name: string;
    /**
     * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
     * Available values: "eq", "ne".
     */
    op: string;
    /**
     * The value of the response header, which must match exactly.
     */
    value: string;
}

export interface GetRateLimitsResultMatchRequest {
    /**
     * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
     */
    methods: string[];
    /**
     * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
     */
    schemes: string[];
    /**
     * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
     */
    url: string;
}

export interface GetRateLimitsResultMatchResponse {
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
     */
    originTraffic: boolean;
}

export interface GetRegionalHostnamesResult {
    /**
     * When the regional hostname was created
     */
    createdOn: string;
    /**
     * DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g `*.example.com`
     */
    hostname: string;
    /**
     * Identifying key for the region
     */
    regionKey: string;
    /**
     * Configure which routing method to use for the regional hostname
     */
    routing: string;
}

export interface GetRegistrarDomainsResult {
    /**
     * Shows if a domain is available for transferring into Cloudflare Registrar.
     */
    available: boolean;
    /**
     * Indicates if the domain can be registered as a new domain.
     */
    canRegister: boolean;
    /**
     * Shows time of creation.
     */
    createdAt: string;
    /**
     * Shows name of current registrar.
     */
    currentRegistrar: string;
    /**
     * Shows when domain name registration expires.
     */
    expiresAt: string;
    /**
     * Domain identifier.
     */
    id: string;
    /**
     * Shows whether a registrar lock is in place for a domain.
     */
    locked: boolean;
    /**
     * Shows contact information for domain registrant.
     */
    registrantContact: outputs.GetRegistrarDomainsResultRegistrantContact;
    /**
     * A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en).
     */
    registryStatuses: string;
    /**
     * Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs.
     */
    supportedTld: boolean;
    /**
     * Statuses for domain transfers into Cloudflare Registrar.
     */
    transferIn: outputs.GetRegistrarDomainsResultTransferIn;
    /**
     * Last updated.
     */
    updatedAt: string;
}

export interface GetRegistrarDomainsResultRegistrantContact {
    /**
     * Address.
     */
    address: string;
    /**
     * Optional address line for unit, floor, suite, etc.
     */
    address2: string;
    /**
     * City.
     */
    city: string;
    /**
     * The country in which the user lives.
     */
    country: string;
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Contact fax number.
     */
    fax: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Contact Identifier.
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Name of organization.
     */
    organization: string;
    /**
     * User's telephone number
     */
    phone: string;
    /**
     * State.
     */
    state: string;
    /**
     * The zipcode or postal code where the user lives.
     */
    zip: string;
}

export interface GetRegistrarDomainsResultTransferIn {
    /**
     * Form of authorization has been accepted by the registrant.
     * Available values: "needed", "ok".
     */
    acceptFoa: string;
    /**
     * Shows transfer status with the registry.
     * Available values: "needed", "ok", "pending", "trying", "rejected", "unknown".
     */
    approveTransfer: string;
    /**
     * Indicates if cancellation is still possible.
     */
    canCancelTransfer: boolean;
    /**
     * Privacy guards are disabled at the foreign registrar.
     * Available values: "needed", "ok", "unknown".
     */
    disablePrivacy: string;
    /**
     * Auth code has been entered and verified.
     * Available values: "needed", "ok", "pending", "trying", "rejected".
     */
    enterAuthCode: string;
    /**
     * Domain is unlocked at the foreign registrar.
     * Available values: "needed", "ok", "pending", "trying", "unknown".
     */
    unlockDomain: string;
}

export interface GetResourceGroupMeta {
    key: string;
    value: string;
}

export interface GetResourceGroupScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetResourceGroupScopeObject[];
}

export interface GetResourceGroupScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetResourceGroupsResult {
    /**
     * Identifier of the resource group.
     */
    id: string;
    /**
     * Attributes associated to the resource group.
     */
    meta: outputs.GetResourceGroupsResultMeta;
    /**
     * Name of the resource group.
     */
    name: string;
    /**
     * The scope associated to the resource group
     */
    scopes: outputs.GetResourceGroupsResultScope[];
}

export interface GetResourceGroupsResultMeta {
    key: string;
    value: string;
}

export interface GetResourceGroupsResultScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetResourceGroupsResultScopeObject[];
}

export interface GetResourceGroupsResultScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetRulesetRule {
    /**
     * The action to perform when the rule matches.
     * Available values: "block", "challenge", "compress*response", "ddos*dynamic", "execute", "force*connection*close", "js*challenge", "log", "log*custom*field", "managed*challenge", "redirect", "rewrite", "route", "score", "serve*error", "set*cache*settings", "set*config", "skip".
     */
    action: string;
    /**
     * The parameters configuring the rule's action.
     */
    actionParameters: outputs.GetRulesetRuleActionParameters;
    /**
     * The categories of the rule.
     */
    categories: string[];
    /**
     * An informative description of the rule.
     */
    description: string;
    /**
     * Whether the rule should be executed.
     */
    enabled: boolean;
    /**
     * Configuration for exposed credential checking.
     */
    exposedCredentialCheck: outputs.GetRulesetRuleExposedCredentialCheck;
    /**
     * The expression defining which traffic will match the rule.
     */
    expression: string;
    /**
     * The unique ID of the rule.
     */
    id: string;
    /**
     * An object configuring the rule's logging behavior.
     */
    logging: outputs.GetRulesetRuleLogging;
    /**
     * An object configuring the rule's rate limit behavior.
     */
    ratelimit: outputs.GetRulesetRuleRatelimit;
    /**
     * The reference of the rule (the rule's ID by default).
     */
    ref: string;
}

export interface GetRulesetRuleActionParameters {
    /**
     * A list of additional ports that caching should be enabled on.
     */
    additionalCacheablePorts: number[];
    /**
     * Custom order for compression algorithms.
     */
    algorithms: outputs.GetRulesetRuleActionParametersAlgorithm[];
    /**
     * The name of a custom asset to serve as the response.
     */
    assetName: string;
    /**
     * Whether to enable Automatic HTTPS Rewrites.
     */
    automaticHttpsRewrites: boolean;
    /**
     * Which file extensions to minify automatically.
     */
    autominify: outputs.GetRulesetRuleActionParametersAutominify;
    /**
     * Whether to enable Browser Integrity Check (BIC).
     */
    bic: boolean;
    /**
     * How long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
     */
    browserTtl: outputs.GetRulesetRuleActionParametersBrowserTtl;
    /**
     * Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
     */
    cache: boolean;
    /**
     * Which components of the request are included in or excluded from the cache key Cloudflare uses to store the response in cache.
     */
    cacheKey: outputs.GetRulesetRuleActionParametersCacheKey;
    /**
     * Settings to determine whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
     */
    cacheReserve: outputs.GetRulesetRuleActionParametersCacheReserve;
    /**
     * The response content.
     */
    content: string;
    /**
     * The content type header to set with the error response.
     * Available values: "application/json", "text/html", "text/plain", "text/xml".
     */
    contentType: string;
    /**
     * The cookie fields to log.
     */
    cookieFields: outputs.GetRulesetRuleActionParametersCookieField[];
    /**
     * Whether to disable Cloudflare Apps.
     */
    disableApps: boolean;
    /**
     * Whether to disable Real User Monitoring (RUM).
     */
    disableRum: boolean;
    /**
     * Whether to disable Zaraz.
     */
    disableZaraz: boolean;
    /**
     * How long the Cloudflare edge network should cache the response.
     */
    edgeTtl: outputs.GetRulesetRuleActionParametersEdgeTtl;
    /**
     * Whether to enable Email Obfuscation.
     */
    emailObfuscation: boolean;
    /**
     * Whether to enable Cloudflare Fonts.
     */
    fonts: boolean;
    /**
     * A redirect based on a bulk list lookup.
     */
    fromList: outputs.GetRulesetRuleActionParametersFromList;
    /**
     * A redirect based on the request properties.
     */
    fromValue: outputs.GetRulesetRuleActionParametersFromValue;
    /**
     * A map of headers to rewrite.
     */
    headers: {[key: string]: outputs.GetRulesetRuleActionParametersHeaders};
    /**
     * A value to rewrite the HTTP host header to.
     */
    hostHeader: string;
    /**
     * Whether to enable Hotlink Protection.
     */
    hotlinkProtection: boolean;
    /**
     * The ID of the ruleset to execute.
     */
    id: string;
    /**
     * A delta to change the score by, which can be either positive or negative.
     */
    increment: number;
    /**
     * The configuration to use for matched data logging.
     */
    matchedData: outputs.GetRulesetRuleActionParametersMatchedData;
    /**
     * Whether to enable Mirage.
     */
    mirage: boolean;
    /**
     * Whether to enable Opportunistic Encryption.
     */
    opportunisticEncryption: boolean;
    /**
     * An origin to route to.
     */
    origin: outputs.GetRulesetRuleActionParametersOrigin;
    /**
     * Whether Cloudflare will aim to strictly adhere to RFC 7234.
     */
    originCacheControl: boolean;
    /**
     * Whether to generate Cloudflare error pages for issues from the origin server.
     */
    originErrorPagePassthru: boolean;
    /**
     * A set of overrides to apply to the target ruleset.
     */
    overrides: outputs.GetRulesetRuleActionParametersOverrides;
    /**
     * A list of phases to skip the execution of. This option is incompatible with the rulesets option.
     * Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
     */
    phases: string[];
    /**
     * The Polish level to configure.
     * Available values: "off", "lossless", "lossy", "webp".
     */
    polish: string;
    /**
     * A list of legacy security products to skip the execution of.
     * Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
     */
    products: string[];
    /**
     * The raw response fields to log.
     */
    rawResponseFields: outputs.GetRulesetRuleActionParametersRawResponseField[];
    /**
     * A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
     */
    readTimeout: number;
    /**
     * The raw request fields to log.
     */
    requestFields: outputs.GetRulesetRuleActionParametersRequestField[];
    /**
     * Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
     */
    respectStrongEtags: boolean;
    /**
     * The response to show when the block is applied.
     */
    response: outputs.GetRulesetRuleActionParametersResponse;
    /**
     * The transformed response fields to log.
     */
    responseFields: outputs.GetRulesetRuleActionParametersResponseField[];
    /**
     * Whether to enable Rocket Loader.
     */
    rocketLoader: boolean;
    /**
     * A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
     */
    rules: {[key: string]: string[]};
    /**
     * A ruleset to skip the execution of. This option is incompatible with the rulesets option.
     * Available values: "current".
     */
    ruleset: string;
    /**
     * A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
     */
    rulesets: string[];
    /**
     * The Security Level to configure.
     * Available values: "off", "essentially*off", "low", "medium", "high", "under*attack".
     */
    securityLevel: string;
    /**
     * When to serve stale content from cache.
     */
    serveStale: outputs.GetRulesetRuleActionParametersServeStale;
    /**
     * Whether to enable Server-Side Excludes.
     */
    serverSideExcludes: boolean;
    /**
     * A Server Name Indication (SNI) override.
     */
    sni: outputs.GetRulesetRuleActionParametersSni;
    /**
     * The SSL level to configure.
     * Available values: "off", "flexible", "full", "strict", "originPull".
     */
    ssl: string;
    /**
     * The status code to use for the error.
     */
    statusCode: number;
    /**
     * Whether to enable Signed Exchanges (SXG).
     */
    sxg: boolean;
    /**
     * The transformed request fields to log.
     */
    transformedRequestFields: outputs.GetRulesetRuleActionParametersTransformedRequestField[];
    /**
     * A URI rewrite.
     */
    uri: outputs.GetRulesetRuleActionParametersUri;
}

export interface GetRulesetRuleActionParametersAlgorithm {
    /**
     * Name of the compression algorithm to enable.
     * Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
     */
    name: string;
}

export interface GetRulesetRuleActionParametersAutominify {
    /**
     * Whether to minify CSS files.
     */
    css: boolean;
    /**
     * Whether to minify HTML files.
     */
    html: boolean;
    /**
     * Whether to minify JavaScript files.
     */
    js: boolean;
}

export interface GetRulesetRuleActionParametersBrowserTtl {
    /**
     * The browser TTL (in seconds) if you choose the "overrideOrigin" mode.
     */
    default: number;
    /**
     * The browser TTL mode.
     * Available values: "respect*origin", "bypass*by*default", "override*origin", "bypass".
     */
    mode: string;
}

export interface GetRulesetRuleActionParametersCacheKey {
    /**
     * Whether to separate cached content based on the visitor's device type.
     */
    cacheByDeviceType: boolean;
    /**
     * Whether to protect from web cache deception attacks, while allowing static assets to be cached.
     */
    cacheDeceptionArmor: boolean;
    /**
     * Which components of the request are included or excluded from the cache key.
     */
    customKey: outputs.GetRulesetRuleActionParametersCacheKeyCustomKey;
    /**
     * Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
     */
    ignoreQueryStringsOrder: boolean;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * Which cookies to include in the cache key.
     */
    cookie: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyCookie;
    /**
     * Which headers to include in the cache key.
     */
    header: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHeader;
    /**
     * How to use the host in the cache key.
     */
    host: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHost;
    /**
     * Which query string parameters to include in or exclude from the cache key.
     */
    queryString: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    /**
     * How to use characteristics of the request user agent in the cache key.
     */
    user: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
     */
    checkPresences: string[];
    /**
     * A list of cookies to include in the cache key.
     */
    includes: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * A list of headers to check for the presence of. The presence of these headers is included in the cache key.
     */
    checkPresences: string[];
    /**
     * A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
     */
    contains: {[key: string]: string[]};
    /**
     * Whether to exclude the origin header in the cache key.
     */
    excludeOrigin: boolean;
    /**
     * A list of headers to include in the cache key.
     */
    includes: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Whether to use the resolved host in the cache key.
     */
    resolved: boolean;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * Which query string parameters to exclude from the cache key.
     */
    exclude: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude;
    /**
     * Which query string parameters to include in the cache key.
     */
    include: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude {
    /**
     * Whether to exclude all query string parameters from the cache key.
     */
    all: boolean;
    /**
     * A list of query string parameters to exclude from the cache key.
     */
    lists: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude {
    /**
     * Whether to include all query string parameters in the cache key.
     */
    all: boolean;
    /**
     * A list of query string parameters to include in the cache key.
     */
    lists: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Whether to use the user agent's device type in the cache key.
     */
    deviceType: boolean;
    /**
     * Whether to use the user agents's country in the cache key.
     */
    geo: boolean;
    /**
     * Whether to use the user agent's language in the cache key.
     */
    lang: boolean;
}

export interface GetRulesetRuleActionParametersCacheReserve {
    /**
     * Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
     */
    eligible: boolean;
    /**
     * The minimum file size eligible for storage in Cache Reserve.
     */
    minimumFileSize: number;
}

export interface GetRulesetRuleActionParametersCookieField {
    /**
     * The name of the cookie.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersEdgeTtl {
    /**
     * The edge TTL (in seconds) if you choose the "overrideOrigin" mode.
     */
    default: number;
    /**
     * The edge TTL mode.
     * Available values: "respect*origin", "bypass*by*default", "override*origin".
     */
    mode: string;
    /**
     * A list of TTLs to apply to specific status codes or status code ranges.
     */
    statusCodeTtls: outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface GetRulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * A single status code to apply the TTL to.
     */
    statusCode: number;
    /**
     * A range of status codes to apply the TTL to.
     */
    statusCodeRange: outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange;
    /**
     * The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
     */
    value: number;
}

export interface GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * The lower bound of the range.
     */
    from: number;
    /**
     * The upper bound of the range.
     */
    to: number;
}

export interface GetRulesetRuleActionParametersFromList {
    /**
     * An expression that evaluates to the list lookup key.
     */
    key: string;
    /**
     * The name of the list to match against.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersFromValue {
    /**
     * Whether to keep the query string of the original request.
     */
    preserveQueryString: boolean;
    /**
     * The status code to use for the redirect.
     */
    statusCode: number;
    /**
     * A URL to redirect the request to.
     */
    targetUrl: outputs.GetRulesetRuleActionParametersFromValueTargetUrl;
}

export interface GetRulesetRuleActionParametersFromValueTargetUrl {
    /**
     * An expression that evaluates to a URL to redirect the request to.
     */
    expression: string;
    /**
     * A URL to redirect the request to.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersHeaders {
    /**
     * An expression that evaluates to a value for the header.
     */
    expression: string;
    /**
     * The operation to perform on the header.
     * Available values: "add", "set", "remove".
     */
    operation: string;
    /**
     * A static value for the header.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersMatchedData {
    /**
     * The public key to encrypt matched data logs with.
     */
    publicKey: string;
}

export interface GetRulesetRuleActionParametersOrigin {
    /**
     * A resolved host to route to.
     */
    host: string;
    /**
     * A destination port to route to.
     */
    port: number;
}

export interface GetRulesetRuleActionParametersOverrides {
    /**
     * An action to override all rules with. This option has lower precedence than rule and category overrides.
     */
    action: string;
    /**
     * A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
     */
    categories: outputs.GetRulesetRuleActionParametersOverridesCategory[];
    /**
     * Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
     */
    enabled: boolean;
    /**
     * A list of rule-level overrides. This option has the highest precedence.
     */
    rules: outputs.GetRulesetRuleActionParametersOverridesRule[];
    /**
     * A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
     * Available values: "default", "medium", "low", "eoff".
     */
    sensitivityLevel: string;
}

export interface GetRulesetRuleActionParametersOverridesCategory {
    /**
     * The action to override rules in the category with.
     */
    action: string;
    /**
     * The name of the category to override.
     */
    category: string;
    /**
     * Whether to enable execution of rules in the category.
     */
    enabled: boolean;
    /**
     * The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
     * Available values: "default", "medium", "low", "eoff".
     */
    sensitivityLevel: string;
}

export interface GetRulesetRuleActionParametersOverridesRule {
    /**
     * The action to override the rule with.
     */
    action: string;
    /**
     * Whether to enable execution of the rule.
     */
    enabled: boolean;
    /**
     * The ID of the rule to override.
     */
    id: string;
    /**
     * The score threshold to use for the rule.
     */
    scoreThreshold: number;
    /**
     * The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
     * Available values: "default", "medium", "low", "eoff".
     */
    sensitivityLevel: string;
}

export interface GetRulesetRuleActionParametersRawResponseField {
    /**
     * The name of the response header.
     */
    name: string;
    /**
     * Whether to log duplicate values of the same header.
     */
    preserveDuplicates: boolean;
}

export interface GetRulesetRuleActionParametersRequestField {
    /**
     * The name of the header.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersResponse {
    /**
     * The content to return.
     */
    content: string;
    /**
     * The type of the content to return.
     */
    contentType: string;
    /**
     * The status code to return.
     */
    statusCode: number;
}

export interface GetRulesetRuleActionParametersResponseField {
    /**
     * The name of the response header.
     */
    name: string;
    /**
     * Whether to log duplicate values of the same header.
     */
    preserveDuplicates: boolean;
}

export interface GetRulesetRuleActionParametersServeStale {
    /**
     * Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
     */
    disableStaleWhileUpdating: boolean;
}

export interface GetRulesetRuleActionParametersSni {
    /**
     * A value to override the SNI to.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersTransformedRequestField {
    /**
     * The name of the header.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersUri {
    /**
     * Whether to propagate the rewritten URI to origin.
     */
    origin: boolean;
    /**
     * A URI path rewrite.
     */
    path: outputs.GetRulesetRuleActionParametersUriPath;
    /**
     * A URI query rewrite.
     */
    query: outputs.GetRulesetRuleActionParametersUriQuery;
}

export interface GetRulesetRuleActionParametersUriPath {
    /**
     * An expression that evaluates to a value to rewrite the URI path to.
     */
    expression: string;
    /**
     * A value to rewrite the URI path to.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersUriQuery {
    /**
     * An expression that evaluates to a value to rewrite the URI query to.
     */
    expression: string;
    /**
     * A value to rewrite the URI query to.
     */
    value: string;
}

export interface GetRulesetRuleExposedCredentialCheck {
    /**
     * An expression that selects the password used in the credentials check.
     */
    passwordExpression: string;
    /**
     * An expression that selects the user ID used in the credentials check.
     */
    usernameExpression: string;
}

export interface GetRulesetRuleLogging {
    /**
     * Whether to generate a log when the rule matches.
     */
    enabled: boolean;
}

export interface GetRulesetRuleRatelimit {
    /**
     * Characteristics of the request on which the rate limit counter will be incremented.
     */
    characteristics: string[];
    /**
     * An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
     */
    countingExpression: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     */
    mitigationTimeout: number;
    /**
     * Period in seconds over which the counter is being incremented.
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     */
    requestsPerPeriod: number;
    /**
     * Whether counting is only performed when an origin is reached.
     */
    requestsToOrigin: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     */
    scorePerPeriod: number;
    /**
     * A response header name provided by the origin, which contains the score to increment rate limit counter with.
     */
    scoreResponseHeaderName: string;
}

export interface GetRulesetsResult {
    /**
     * An informative description of the ruleset.
     *
     * @deprecated Use rulesets.description instead. This attribute will be removed in the next major version of the provider.
     */
    description: string;
    /**
     * The unique ID of the ruleset.
     *
     * @deprecated Use rulesets.id instead. This attribute will be removed in the next major version of the provider.
     */
    id: string;
    /**
     * The kind of the ruleset.
     * Available values: "managed", "custom", "root", "zone".
     *
     * @deprecated Use rulesets.kind instead. This attribute will be removed in the next major version of the provider.
     */
    kind: string;
    /**
     * The timestamp of when the ruleset was last modified.
     */
    lastUpdated: string;
    /**
     * The human-readable name of the ruleset.
     *
     * @deprecated Use rulesets.name instead. This attribute will be removed in the next major version of the provider.
     */
    name: string;
    /**
     * The phase of the ruleset.
     * Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
     *
     * @deprecated Use rulesets.phase instead. This attribute will be removed in the next major version of the provider.
     */
    phase: string;
    /**
     * The version of the ruleset.
     */
    version: string;
}

export interface GetRulesetsRuleset {
    /**
     * An informative description of the ruleset.
     */
    description: string;
    /**
     * The unique ID of the ruleset.
     */
    id: string;
    /**
     * The kind of the ruleset.
     * Available values: "managed", "custom", "root", "zone".
     */
    kind: string;
    /**
     * The timestamp of when the ruleset was last modified.
     */
    lastUpdated: string;
    /**
     * The human-readable name of the ruleset.
     */
    name: string;
    /**
     * The phase of the ruleset.
     * Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
     */
    phase: string;
    /**
     * The version of the ruleset.
     */
    version: string;
}

export interface GetSchemaValidationOperationSettingsListResult {
    /**
     * When set, this applies a mitigation action to this operation which supersedes a global schema validation setting just for this operation
     *
     *   - `"log"` - log request when request does not conform to schema for this operation
     *   - `"block"` - deny access to the site when request does not conform to schema for this operation
     *   - `"none"` - will skip mitigation for this operation
     * Available values: "log", "block", "none".
     */
    mitigationAction: string;
    /**
     * UUID.
     */
    operationId: string;
}

export interface GetSchemaValidationSchemasFilter {
    /**
     * Omit the source-files of schemas and only retrieve their meta-data.
     */
    omitSource: boolean;
    /**
     * Filter for enabled schemas
     */
    validationEnabled?: boolean;
}

export interface GetSchemaValidationSchemasListResult {
    createdAt: string;
    /**
     * The kind of the schema
     * Available values: "openapiV3".
     */
    kind: string;
    /**
     * A human-readable name for the schema
     */
    name: string;
    /**
     * A unique identifier of this schema
     */
    schemaId: string;
    /**
     * The raw schema, e.g., the OpenAPI schema, either as JSON or YAML
     */
    source: string;
    /**
     * An indicator if this schema is enabled
     */
    validationEnabled: boolean;
}

export interface GetSnippetListResult {
    /**
     * The timestamp of when the snippet was created.
     */
    createdOn: string;
    /**
     * The timestamp of when the snippet was last modified.
     */
    modifiedOn: string;
    /**
     * The identifying name of the snippet.
     */
    snippetName: string;
}

export interface GetSnippetRulesListResult {
    /**
     * An informative description of the rule.
     */
    description: string;
    /**
     * Whether the rule should be executed.
     */
    enabled: boolean;
    /**
     * The expression defining which traffic will match the rule.
     */
    expression: string;
    /**
     * The unique ID of the rule.
     */
    id: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    lastUpdated: string;
    /**
     * The identifying name of the snippet.
     */
    snippetName: string;
}

export interface GetSnippetsListResult {
    /**
     * The timestamp of when the snippet was created.
     */
    createdOn: string;
    /**
     * The timestamp of when the snippet was last modified.
     */
    modifiedOn: string;
    /**
     * The identifying name of the snippet.
     */
    snippetName: string;
}

export interface GetSpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name: string;
    /**
     * The type of DNS record associated with the application.
     * Available values: "CNAME", "ADDRESS".
     */
    type: string;
}

export interface GetSpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs.
     * Available values: "all", "ipv4", "ipv6".
     */
    connectivity: string;
    /**
     * The array of customer owned IPs we broadcast via anycast for this hostname and application.
     */
    ips: string[];
    /**
     * The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
     * Available values: "dynamic", "static".
     */
    type: string;
}

export interface GetSpectrumApplicationOriginDns {
    /**
     * The name of the DNS record associated with the origin.
     */
    name: string;
    /**
     * The TTL of our resolution of your DNS record in seconds.
     */
    ttl: number;
    /**
     * The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
     * Available values: "", "A", "AAAA", "SRV".
     */
    type: string;
}

export interface GetSpectrumApplicationsResult {
}

export interface GetStreamInput {
    /**
     * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
     */
    height: number;
    /**
     * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
     */
    width: number;
}

export interface GetStreamLiveInputRecording {
    /**
     * Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
     */
    allowedOrigins: string[];
    /**
     * Disables reporting the number of live viewers when this property is set to `true`.
     */
    hideLiveViewerCount: boolean;
    /**
     * Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
     * Available values: "off", "automatic".
     */
    mode: string;
    /**
     * Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
     */
    requireSignedUrls: boolean;
    /**
     * Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
     */
    timeoutSeconds: number;
}

export interface GetStreamLiveInputRtmps {
    /**
     * The secret key to use when streaming via RTMPS to a live input.
     */
    streamKey: string;
    /**
     * The RTMPS URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface GetStreamLiveInputRtmpsPlayback {
    /**
     * The secret key to use for playback via RTMPS.
     */
    streamKey: string;
    /**
     * The URL used to play live video over RTMPS.
     */
    url: string;
}

export interface GetStreamLiveInputSrt {
    /**
     * The secret key to use when streaming via SRT to a live input.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use when streaming via SRT.
     */
    streamId: string;
    /**
     * The SRT URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface GetStreamLiveInputSrtPlayback {
    /**
     * The secret key to use for playback via SRT.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use for playback via SRT.
     */
    streamId: string;
    /**
     * The URL used to play live video over SRT.
     */
    url: string;
}

export interface GetStreamLiveInputWebRtc {
    /**
     * The WebRTC URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface GetStreamLiveInputWebRtcPlayback {
    /**
     * The URL used to play live video over WebRTC.
     */
    url: string;
}

export interface GetStreamPlayback {
    /**
     * DASH Media Presentation Description for the video.
     */
    dash: string;
    /**
     * The HLS manifest for the video.
     */
    hls: string;
}

export interface GetStreamStatus {
    /**
     * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
     */
    errorReasonCode: string;
    /**
     * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
     */
    errorReasonText: string;
    /**
     * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
     */
    pctComplete: string;
    /**
     * Specifies the processing status for all quality levels for a video.
     * Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
     */
    state: string;
}

export interface GetStreamWatermark {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface GetStreamWatermarksResult {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface GetStreamsResult {
    /**
     * Lists the origins allowed to display the video. Enter allowed origin domains in an array and use `*` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin.
     */
    allowedOrigins: string[];
    /**
     * The date and time the media item was created.
     */
    created: string;
    /**
     * A user-defined identifier for the media creator.
     */
    creator: string;
    /**
     * The duration of the video in seconds. A value of `-1` means the duration is unknown. The duration becomes available after the upload and before the video is ready.
     */
    duration: number;
    input: outputs.GetStreamsResultInput;
    /**
     * The live input ID used to upload a video with Stream Live.
     */
    liveInput: string;
    /**
     * The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of `-1` means the value is unknown.
     */
    maxDurationSeconds: number;
    /**
     * A user modifiable key-value store used to reference other systems of record for managing videos.
     */
    meta: string;
    /**
     * The date and time the media item was last modified.
     */
    modified: string;
    playback: outputs.GetStreamsResultPlayback;
    /**
     * The video's preview page URI. This field is omitted until encoding is complete.
     */
    preview: string;
    /**
     * Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
     */
    readyToStream: boolean;
    /**
     * Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
     */
    readyToStreamAt: string;
    /**
     * Indicates whether the video can be a accessed using the UID. When set to `true`, a signed token must be generated with a signing key to view the video.
     */
    requireSignedUrls: boolean;
    /**
     * Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a `null` value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time.
     */
    scheduledDeletion: string;
    /**
     * The size of the media item in bytes.
     */
    size: number;
    /**
     * Specifies a detailed status for a video. If the `state` is `inprogress` or `error`, the `step` field returns `encoding` or `manifest`. If the `state` is `inprogress`, `pctComplete` returns a number between 0 and 100 to indicate the approximate percent of completion. If the `state` is `error`, `errorReasonCode` and `errorReasonText` provide additional details.
     */
    status: outputs.GetStreamsResultStatus;
    /**
     * The media item's thumbnail URI. This field is omitted until encoding is complete.
     */
    thumbnail: string;
    /**
     * The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video.
     */
    thumbnailTimestampPct: number;
    /**
     * A Cloudflare-generated unique identifier for a media item.
     */
    uid: string;
    /**
     * The date and time when the video upload URL is no longer valid for direct user uploads.
     */
    uploadExpiry: string;
    /**
     * The date and time the media item was uploaded.
     */
    uploaded: string;
    watermark: outputs.GetStreamsResultWatermark;
}

export interface GetStreamsResultInput {
    /**
     * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
     */
    height: number;
    /**
     * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
     */
    width: number;
}

export interface GetStreamsResultPlayback {
    /**
     * DASH Media Presentation Description for the video.
     */
    dash: string;
    /**
     * The HLS manifest for the video.
     */
    hls: string;
}

export interface GetStreamsResultStatus {
    /**
     * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
     */
    errorReasonCode: string;
    /**
     * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
     */
    errorReasonText: string;
    /**
     * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
     */
    pctComplete: string;
    /**
     * Specifies the processing status for all quality levels for a video.
     * Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
     */
    state: string;
}

export interface GetStreamsResultWatermark {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface GetTurnstileWidgetFilter {
    /**
     * Direction to order widgets.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Field to order widgets by.
     * Available values: "id", "sitekey", "name", "created*on", "modified*on".
     */
    order?: string;
}

export interface GetTurnstileWidgetsResult {
    /**
     * If bot*fight*mode is set to `true`, Cloudflare issues computationally
     * expensive challenges in response to malicious bots (ENT only).
     */
    botFightMode: boolean;
    /**
     * If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
     * this setting can determine the clearance level to be set
     * Available values: "noClearance", "jschallenge", "managed", "interactive".
     */
    clearanceLevel: string;
    /**
     * When the widget was created.
     */
    createdOn: string;
    domains: string[];
    /**
     * Return the Ephemeral ID in /siteverify (ENT only).
     */
    ephemeralId: boolean;
    /**
     * Widget Mode
     * Available values: "non-interactive", "invisible", "managed".
     */
    mode: string;
    /**
     * When the widget was modified.
     */
    modifiedOn: string;
    /**
     * Human readable widget name. Not unique. Cloudflare suggests that you
     * set this to a meaningful string to make it easier to identify your
     * widget, and where it is used.
     */
    name: string;
    /**
     * Do not show any Cloudflare branding on the widget (ENT only).
     */
    offlabel: boolean;
    /**
     * Region where this widget can be used. This cannot be changed after creation.
     * Available values: "world", "china".
     */
    region: string;
    /**
     * Widget item identifier tag.
     */
    sitekey: string;
}

export interface GetUserAgentBlockingRuleConfiguration {
    /**
     * The configuration target for this rule. You must set the target to `ua` for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received `User-Agent` HTTP header value.
     */
    value: string;
}

export interface GetUserAgentBlockingRuleFilter {
    /**
     * A string to search for in the description of existing rules.
     */
    description?: string;
    /**
     * When true, indicates that the rule is currently paused.
     */
    paused?: boolean;
    /**
     * A string to search for in the user agent values of existing rules.
     */
    userAgent?: string;
}

export interface GetUserAgentBlockingRulesResult {
    /**
     * The configuration object for the current rule.
     */
    configuration: outputs.GetUserAgentBlockingRulesResultConfiguration;
    /**
     * An informative summary of the rule.
     */
    description: string;
    /**
     * The unique identifier of the User Agent Blocking rule.
     */
    id: string;
    /**
     * The action to apply to a matched request.
     * Available values: "block", "challenge", "js*challenge", "managed*challenge".
     */
    mode: string;
    /**
     * When true, indicates that the rule is currently paused.
     */
    paused: boolean;
}

export interface GetUserAgentBlockingRulesResultConfiguration {
    /**
     * The configuration target for this rule. You must set the target to `ua` for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received `User-Agent` HTTP header value.
     */
    value: string;
}

export interface GetUserOrganization {
    /**
     * Identifier
     */
    id: string;
    /**
     * Organization name.
     */
    name: string;
    /**
     * Access permissions for this User.
     */
    permissions: string[];
    /**
     * List of roles that a user has within an organization.
     */
    roles: string[];
    /**
     * Whether the user is a member of the organization or has an invitation pending.
     * Available values: "member", "invited".
     */
    status: string;
}

export interface GetWaitingRoomAdditionalRoute {
    /**
     * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
     */
    host: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
}

export interface GetWaitingRoomCookieAttributes {
    /**
     * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
     * Available values: "auto", "lax", "none", "strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
     * Available values: "auto", "always", "never".
     */
    secure: string;
}

export interface GetWaitingRoomEventsResult {
    createdOn: string;
    /**
     * If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
     */
    customPageHtml: string;
    /**
     * A note that you can use to add more details about the event.
     */
    description: string;
    /**
     * If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
     */
    disableSessionRenewal: boolean;
    /**
     * An ISO 8601 timestamp that marks the end of the event.
     */
    eventEndTime: string;
    /**
     * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
     */
    eventStartTime: string;
    id: string;
    modifiedOn: string;
    /**
     * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: string;
    /**
     * If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
     */
    newUsersPerMinute: number;
    /**
     * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
     */
    prequeueStartTime: string;
    /**
     * If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
     */
    queueingMethod: string;
    /**
     * If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
     */
    sessionDuration: number;
    /**
     * If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     */
    shuffleAtEventStart: boolean;
    /**
     * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     */
    suspended: boolean;
    /**
     * If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
     */
    totalActiveUsers: number;
    /**
     * If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
     * Available values: "log", "infiniteQueue".
     */
    turnstileAction: string;
    /**
     * If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
     * Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
     */
    turnstileMode: string;
}

export interface GetWaitingRoomsResult {
    /**
     * Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms.
     */
    additionalRoutes: outputs.GetWaitingRoomsResultAdditionalRoute[];
    /**
     * Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position.
     */
    cookieAttributes: outputs.GetWaitingRoomsResultCookieAttributes;
    /**
     * Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(_*cf*waitingroom). If `cookieSuffix` is "abcd", the cookie name will be `__cf_waitingroom_abcd`. This field is required if using `additionalRoutes`.
     */
    cookieSuffix: string;
    createdOn: string;
    /**
     * Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom*page*html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:
     */
    customPageHtml: string;
    /**
     * The language of the default page template. If no defaultTemplateLanguage is provided, then `en-US` (English) will be used.
     * Available values: "en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN".
     */
    defaultTemplateLanguage: string;
    /**
     * A note that you can use to add more details about the waiting room.
     */
    description: string;
    /**
     * Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If `true`, an accepted user will have sessionDuration minutes to browse the site. After that, they will have to go through the waiting room again. If `false`, a user's session cookie will be automatically renewed on every request.
     */
    disableSessionRenewal: boolean;
    /**
     * A list of enabled origin commands.
     */
    enabledOriginCommands: string[];
    /**
     * The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique.
     */
    host: string;
    id: string;
    /**
     * Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:
     * 1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).
     * 2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.
     * 3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.
     * 4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).
     * 5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.
     * 6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).
     * 7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.
     * 8. `queueIsFull`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
     * 9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.
     * 10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.
     * 11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time —\_it will always be **zero**.
     * 12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.
     * 13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.
     * 14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.
     * 15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.
     * 16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.
     * 17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties `prequeueStartTime`, `eventStartTime`, and `eventEndTime` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.
     * 18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.
     * 19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.
     * 20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.
     * 21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.
     * 22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.
     * 23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.
     * 24. `turnstile`: Empty when turnstile isn't enabled. String displaying an html tag to display the Turnstile widget. Please add the `{{{turnstile}}}` tag to the `customHtml` template to ensure the Turnstile widget appears.
     * 25. `infiniteQueue`: Boolean indicating whether the response is for a user in the infinite queue.
     *
     * An example cURL to a waiting room could be:
     *
     * 	curl -X GET "https://example.com/waitingroom" \
     * 		-H "Accept: application/json"
     *
     * If `jsonResponseEnabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:
     *
     * 	{
     * 		"cfWaitingRoom": {
     * 			"inWaitingRoom": true,
     * 			"waitTimeKnown": true,
     * 			"waitTime": 10,
     * 			"waitTime25Percentile": 0,
     * 			"waitTime50Percentile": 0,
     * 			"waitTime75Percentile": 0,
     * 			"waitTimeFormatted": "10 minutes",
     * 			"queueIsFull": false,
     * 			"queueAll": false,
     * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
     * 			"refreshIntervalSeconds": 20,
     * 			"queueingMethod": "fifo",
     * 			"isFIFOQueue": true,
     * 			"isRandomQueue": false,
     * 			"isPassthroughQueue": false,
     * 			"isRejectQueue": false,
     * 			"isEventActive": false,
     * 			"isEventPrequeueing": false,
     * 			"timeUntilEventStart": 0,
     * 			"timeUntilEventStartFormatted": "unavailable",
     * 			"timeUntilEventEnd": 0,
     * 			"timeUntilEventEndFormatted": "unavailable",
     * 			"shuffleAtEventStart": false
     * 		}
     * 	}
     *
     * If `jsonResponseEnabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:
     *
     * 	{
     * 		"cfWaitingRoom": {
     * 			"inWaitingRoom": true,
     * 			"waitTimeKnown": true,
     * 			"waitTime": 10,
     * 			"waitTime25Percentile": 5,
     * 			"waitTime50Percentile": 10,
     * 			"waitTime75Percentile": 15,
     * 			"waitTimeFormatted": "5 minutes to 15 minutes",
     * 			"queueIsFull": false,
     * 			"queueAll": false,
     * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
     * 			"refreshIntervalSeconds": 20,
     * 			"queueingMethod": "random",
     * 			"isFIFOQueue": false,
     * 			"isRandomQueue": true,
     * 			"isPassthroughQueue": false,
     * 			"isRejectQueue": false,
     * 			"isEventActive": true,
     * 			"isEventPrequeueing": false,
     * 			"timeUntilEventStart": 0,
     * 			"timeUntilEventStartFormatted": "unavailable",
     * 			"timeUntilEventEnd": 15,
     * 			"timeUntilEventEndFormatted": "15 minutes",
     * 			"shuffleAtEventStart": true
     * 		}
     * 	}
     */
    jsonResponseEnabled: boolean;
    modifiedOn: string;
    /**
     * A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: string;
    /**
     * Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world.
     */
    newUsersPerMinute: number;
    /**
     * An ISO 8601 timestamp that marks when the next event will begin queueing.
     */
    nextEventPrequeueStartTime: string;
    /**
     * An ISO 8601 timestamp that marks when the next event will start.
     */
    nextEventStartTime: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
    /**
     * If queueAll is `true`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable.
     */
    queueAll: boolean;
    /**
     * Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if `queueAll` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:
     * 1. `fifo` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.
     * 2. `random`: Random queue where customers gain access randomly, regardless of arrival time.
     * 3. `passthrough`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with `suspended`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.
     * 4. `reject`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses `reject`, and its events override this with `fifo`, `random`, or `passthrough`. When this queueing method is enabled and neither `queueAll` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**.
     * Available values: "fifo", "random", "passthrough", "reject".
     */
    queueingMethod: string;
    /**
     * HTTP status code returned to a user while in the queue.
     * Available values: 200, 202, 429.
     */
    queueingStatusCode: number;
    /**
     * Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route.
     */
    sessionDuration: number;
    /**
     * Suspends or allows traffic going to the waiting room. If set to `true`, the traffic will not go to the waiting room.
     */
    suspended: boolean;
    /**
     * Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world.
     */
    totalActiveUsers: number;
    /**
     * Which action to take when a bot is detected using Turnstile. `log` will
     * have no impact on queueing behavior, simply keeping track of how many
     * bots are detected in Waiting Room Analytics. `infiniteQueue` will send
     * bots to a false queueing state, where they will never reach your
     * origin. `infiniteQueue` requires Advanced Waiting Room.
     * Available values: "log", "infiniteQueue".
     */
    turnstileAction: string;
    /**
     * Which Turnstile widget type to use for detecting bot traffic. See
     * [the Turnstile documentation](https://developers.cloudflare.com/turnstile/concepts/widget/#widget-types)
     * for the definitions of these widget types. Set to `off` to disable the
     * Turnstile integration entirely. Setting this to anything other than
     * `off` or `invisible` requires Advanced Waiting Room.
     * Available values: "off", "invisible", "visibleNonInteractive", "visibleManaged".
     */
    turnstileMode: string;
}

export interface GetWaitingRoomsResultAdditionalRoute {
    /**
     * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
     */
    host: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
}

export interface GetWaitingRoomsResultCookieAttributes {
    /**
     * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
     * Available values: "auto", "lax", "none", "strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
     * Available values: "auto", "always", "never".
     */
    secure: string;
}

export interface GetWeb3HostnamesResult {
    createdOn: string;
    /**
     * Specify an optional description of the hostname.
     */
    description: string;
    /**
     * Specify the DNSLink value used if the target is ipfs.
     */
    dnslink: string;
    /**
     * Specify the identifier of the hostname.
     */
    id: string;
    modifiedOn: string;
    /**
     * Specify the hostname that points to the target gateway via CNAME.
     */
    name: string;
    /**
     * Specifies the status of the hostname's activation.
     * Available values: "active", "pending", "deleting", "error".
     */
    status: string;
    /**
     * Specify the target gateway of the hostname.
     * Available values: "ethereum", "ipfs", "ipfs*universal*path".
     */
    target: string;
}

export interface GetWebAnalyticsSiteFilter {
    /**
     * The property used to sort the list of results.
     * Available values: "host", "created".
     */
    orderBy?: string;
}

export interface GetWebAnalyticsSiteRule {
    created: string;
    /**
     * The hostname the rule will be applied to.
     */
    host: string;
    /**
     * The Web Analytics rule identifier.
     */
    id: string;
    /**
     * Whether the rule includes or excludes traffic from being measured.
     */
    inclusive: boolean;
    /**
     * Whether the rule is paused or not.
     */
    isPaused: boolean;
    /**
     * The paths the rule will be applied to.
     */
    paths: string[];
    priority: number;
}

export interface GetWebAnalyticsSiteRuleset {
    /**
     * Whether the ruleset is enabled.
     */
    enabled: boolean;
    /**
     * The Web Analytics ruleset identifier.
     */
    id: string;
    zoneName: string;
    /**
     * The zone identifier.
     */
    zoneTag: string;
}

export interface GetWebAnalyticsSitesResult {
    /**
     * If enabled, the JavaScript snippet is automatically injected for orange-clouded sites.
     */
    autoInstall: boolean;
    created: string;
    /**
     * A list of rules.
     */
    rules: outputs.GetWebAnalyticsSitesResultRule[];
    ruleset: outputs.GetWebAnalyticsSitesResultRuleset;
    /**
     * The Web Analytics site identifier.
     */
    siteTag: string;
    /**
     * The Web Analytics site token.
     */
    siteToken: string;
    /**
     * Encoded JavaScript snippet.
     */
    snippet: string;
}

export interface GetWebAnalyticsSitesResultRule {
    created: string;
    /**
     * The hostname the rule will be applied to.
     */
    host: string;
    /**
     * The Web Analytics rule identifier.
     */
    id: string;
    /**
     * Whether the rule includes or excludes traffic from being measured.
     */
    inclusive: boolean;
    /**
     * Whether the rule is paused or not.
     */
    isPaused: boolean;
    /**
     * The paths the rule will be applied to.
     */
    paths: string[];
    priority: number;
}

export interface GetWebAnalyticsSitesResultRuleset {
    /**
     * Whether the ruleset is enabled.
     */
    enabled: boolean;
    /**
     * The Web Analytics ruleset identifier.
     */
    id: string;
    zoneName: string;
    /**
     * The zone identifier.
     */
    zoneTag: string;
}

export interface GetWorkerObservability {
    /**
     * Whether observability is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
     */
    headSamplingRate: number;
    /**
     * Log settings for the Worker.
     */
    logs: outputs.GetWorkerObservabilityLogs;
}

export interface GetWorkerObservabilityLogs {
    /**
     * Whether logs are enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%).
     */
    headSamplingRate: number;
    /**
     * Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
     */
    invocationLogs: boolean;
}

export interface GetWorkerSubdomain {
    /**
     * Whether the *.workers.dev subdomain is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * Whether [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/) are enabled for the Worker.
     */
    previewsEnabled: boolean;
}

export interface GetWorkerTailConsumer {
    /**
     * Name of the consumer Worker.
     */
    name: string;
}

export interface GetWorkerVersionAnnotations {
    /**
     * Human-readable message about the version.
     */
    workersMessage: string;
    /**
     * User-provided identifier for the version.
     */
    workersTag: string;
    /**
     * Operation that triggered the creation of the version.
     */
    workersTriggeredBy: string;
}

export interface GetWorkerVersionAssets {
    /**
     * Configuration for assets within a Worker.
     */
    config: outputs.GetWorkerVersionAssetsConfig;
    /**
     * Token provided upon successful upload of all files from a registered manifest.
     */
    jwt: string;
}

export interface GetWorkerVersionAssetsConfig {
    /**
     * Determines the redirects and rewrites of requests for HTML content.
     * Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
     */
    htmlHandling: string;
    /**
     * Determines the response when a request does not match a static asset, and there is no Worker script.
     * Available values: "none", "404-page", "single-page-application".
     */
    notFoundHandling: string;
    /**
     * Contains a list path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
     */
    runWorkerFirsts: string[];
}

export interface GetWorkerVersionBinding {
    /**
     * Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
     */
    algorithm: string;
    /**
     * List of allowed destination addresses.
     */
    allowedDestinationAddresses: string[];
    /**
     * List of allowed sender addresses.
     */
    allowedSenderAddresses: string[];
    /**
     * R2 bucket to bind to.
     */
    bucketName: string;
    /**
     * Identifier of the certificate to bind to.
     */
    certificateId: string;
    /**
     * The exported class name of the Durable Object.
     */
    className: string;
    /**
     * The name of the dataset to bind to.
     */
    dataset: string;
    /**
     * Destination address for the email.
     */
    destinationAddress: string;
    /**
     * The environment of the scriptName to bind to.
     */
    environment: string;
    /**
     * Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
     * Available values: "raw", "pkcs8", "spki", "jwk".
     */
    format: string;
    /**
     * Identifier of the D1 database to bind to.
     */
    id: string;
    /**
     * Name of the Vectorize index to bind to.
     */
    indexName: string;
    /**
     * JSON data to use.
     */
    json: string;
    /**
     * The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
     * Available values: "eu", "fedramp".
     */
    jurisdiction: string;
    /**
     * Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
     */
    keyBase64: string;
    /**
     * Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
     */
    keyJwk: string;
    /**
     * A JavaScript variable name for the binding.
     */
    name: string;
    /**
     * Namespace to bind to.
     */
    namespace: string;
    /**
     * Namespace identifier tag.
     */
    namespaceId: string;
    /**
     * The old name of the inherited binding. If set, the binding will be renamed from `oldName` to `name` in the new version. If not set, the binding will keep the same name between versions.
     */
    oldName: string;
    /**
     * Outbound worker.
     */
    outbound: outputs.GetWorkerVersionBindingOutbound;
    /**
     * The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
     */
    part: string;
    /**
     * Name of the Pipeline to bind to.
     */
    pipeline: string;
    /**
     * Name of the Queue to bind to.
     */
    queueName: string;
    /**
     * The script where the Durable Object is defined, if it is external to this Worker.
     */
    scriptName: string;
    /**
     * Name of the secret in the store.
     */
    secretName: string;
    /**
     * Name of Worker to bind to.
     */
    service: string;
    /**
     * ID of the store containing the secret.
     */
    storeId: string;
    /**
     * The text value to use.
     */
    text: string;
    /**
     * The kind of resource that the binding provides.
     * Available values: "ai", "analytics*engine", "assets", "browser", "d1", "data*blob", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "inherit", "images", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "send*email", "service", "tail*consumer", "text*blob", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow", "wasm*module".
     */
    type: string;
    /**
     * Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
     */
    usages: string[];
    /**
     * Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
     */
    versionId: string;
    /**
     * Name of the Workflow to bind to.
     */
    workflowName: string;
}

export interface GetWorkerVersionBindingOutbound {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params: string[];
    /**
     * Outbound worker.
     */
    worker: outputs.GetWorkerVersionBindingOutboundWorker;
}

export interface GetWorkerVersionBindingOutboundWorker {
    /**
     * Environment of the outbound worker.
     */
    environment: string;
    /**
     * Name of the outbound worker.
     */
    service: string;
}

export interface GetWorkerVersionLimits {
    /**
     * CPU time limit in milliseconds.
     */
    cpuMs: number;
}

export interface GetWorkerVersionMigrations {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses: string[];
    /**
     * Tag to set as the latest migration tag.
     */
    newTag: string;
    /**
     * Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
     */
    oldTag: string;
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses: outputs.GetWorkerVersionMigrationsRenamedClass[];
    /**
     * Migrations to apply in order.
     */
    steps: outputs.GetWorkerVersionMigrationsStep[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses: outputs.GetWorkerVersionMigrationsTransferredClass[];
}

export interface GetWorkerVersionMigrationsRenamedClass {
    from: string;
    to: string;
}

export interface GetWorkerVersionMigrationsStep {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses: string[];
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses: outputs.GetWorkerVersionMigrationsStepRenamedClass[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses: outputs.GetWorkerVersionMigrationsStepTransferredClass[];
}

export interface GetWorkerVersionMigrationsStepRenamedClass {
    from: string;
    to: string;
}

export interface GetWorkerVersionMigrationsStepTransferredClass {
    from: string;
    fromScript: string;
    to: string;
}

export interface GetWorkerVersionMigrationsTransferredClass {
    from: string;
    fromScript: string;
    to: string;
}

export interface GetWorkerVersionModule {
    /**
     * The base64-encoded module content.
     */
    contentBase64: string;
    /**
     * The content type of the module.
     */
    contentType: string;
    /**
     * The name of the module.
     */
    name: string;
}

export interface GetWorkerVersionPlacement {
    /**
     * Placement mode for the version.
     * Available values: "smart".
     */
    mode: string;
}

export interface GetWorkerVersionsResult {
    /**
     * Metadata about the version.
     */
    annotations: outputs.GetWorkerVersionsResultAnnotations;
    /**
     * Configuration for assets within a Worker.
     */
    assets: outputs.GetWorkerVersionsResultAssets;
    /**
     * List of bindings attached to a Worker. You can find more about bindings on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/#bindings.
     */
    bindings: outputs.GetWorkerVersionsResultBinding[];
    /**
     * Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
     */
    compatibilityDate: string;
    /**
     * Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibilityDate`.
     */
    compatibilityFlags: string[];
    /**
     * When the version was created.
     */
    createdOn: string;
    /**
     * Version identifier.
     */
    id: string;
    /**
     * Resource limits enforced at runtime.
     */
    limits: outputs.GetWorkerVersionsResultLimits;
    /**
     * The name of the main module in the `modules` array (e.g. the name of the module that exports a `fetch` handler).
     */
    mainModule: string;
    /**
     * Migrations for Durable Objects associated with the version. Migrations are applied when the version is deployed.
     */
    migrations: outputs.GetWorkerVersionsResultMigrations;
    /**
     * Code, sourcemaps, and other content used at runtime.
     *
     * This includes [`_headers`](https://developers.cloudflare.com/workers/static-assets/headers/#custom-headers) and
     * [`_redirects`](https://developers.cloudflare.com/workers/static-assets/redirects/) files used to configure 
     * [Static Assets](https://developers.cloudflare.com/workers/static-assets/). `_headers` and `_redirects` files should be 
     * included as modules named `_headers` and `_redirects` with content type `text/plain`.
     */
    modules: outputs.GetWorkerVersionsResultModule[];
    /**
     * The integer version number, starting from one.
     */
    number: number;
    /**
     * Placement settings for the version.
     */
    placement: outputs.GetWorkerVersionsResultPlacement;
    /**
     * The client used to create the version.
     */
    source: string;
    /**
     * Usage model for the version.
     * Available values: "standard", "bundled", "unbound".
     *
     * @deprecated This attribute is deprecated.
     */
    usageModel: string;
}

export interface GetWorkerVersionsResultAnnotations {
    /**
     * Human-readable message about the version.
     */
    workersMessage: string;
    /**
     * User-provided identifier for the version.
     */
    workersTag: string;
    /**
     * Operation that triggered the creation of the version.
     */
    workersTriggeredBy: string;
}

export interface GetWorkerVersionsResultAssets {
    /**
     * Configuration for assets within a Worker.
     */
    config: outputs.GetWorkerVersionsResultAssetsConfig;
    /**
     * Token provided upon successful upload of all files from a registered manifest.
     */
    jwt: string;
}

export interface GetWorkerVersionsResultAssetsConfig {
    /**
     * Determines the redirects and rewrites of requests for HTML content.
     * Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
     */
    htmlHandling: string;
    /**
     * Determines the response when a request does not match a static asset, and there is no Worker script.
     * Available values: "none", "404-page", "single-page-application".
     */
    notFoundHandling: string;
    /**
     * Contains a list path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
     */
    runWorkerFirsts: string[];
}

export interface GetWorkerVersionsResultBinding {
    /**
     * Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
     */
    algorithm: string;
    /**
     * List of allowed destination addresses.
     */
    allowedDestinationAddresses: string[];
    /**
     * List of allowed sender addresses.
     */
    allowedSenderAddresses: string[];
    /**
     * R2 bucket to bind to.
     */
    bucketName: string;
    /**
     * Identifier of the certificate to bind to.
     */
    certificateId: string;
    /**
     * The exported class name of the Durable Object.
     */
    className: string;
    /**
     * The name of the dataset to bind to.
     */
    dataset: string;
    /**
     * Destination address for the email.
     */
    destinationAddress: string;
    /**
     * The environment of the scriptName to bind to.
     */
    environment: string;
    /**
     * Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
     * Available values: "raw", "pkcs8", "spki", "jwk".
     */
    format: string;
    /**
     * Identifier of the D1 database to bind to.
     */
    id: string;
    /**
     * Name of the Vectorize index to bind to.
     */
    indexName: string;
    /**
     * JSON data to use.
     */
    json: string;
    /**
     * The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
     * Available values: "eu", "fedramp".
     */
    jurisdiction: string;
    /**
     * Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
     */
    keyBase64: string;
    /**
     * Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
     */
    keyJwk: string;
    /**
     * A JavaScript variable name for the binding.
     */
    name: string;
    /**
     * Namespace to bind to.
     */
    namespace: string;
    /**
     * Namespace identifier tag.
     */
    namespaceId: string;
    /**
     * The old name of the inherited binding. If set, the binding will be renamed from `oldName` to `name` in the new version. If not set, the binding will keep the same name between versions.
     */
    oldName: string;
    /**
     * Outbound worker.
     */
    outbound: outputs.GetWorkerVersionsResultBindingOutbound;
    /**
     * The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
     */
    part: string;
    /**
     * Name of the Pipeline to bind to.
     */
    pipeline: string;
    /**
     * Name of the Queue to bind to.
     */
    queueName: string;
    /**
     * The script where the Durable Object is defined, if it is external to this Worker.
     */
    scriptName: string;
    /**
     * Name of the secret in the store.
     */
    secretName: string;
    /**
     * Name of Worker to bind to.
     */
    service: string;
    /**
     * ID of the store containing the secret.
     */
    storeId: string;
    /**
     * The text value to use.
     */
    text: string;
    /**
     * The kind of resource that the binding provides.
     * Available values: "ai", "analytics*engine", "assets", "browser", "d1", "data*blob", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "inherit", "images", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "send*email", "service", "tail*consumer", "text*blob", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow", "wasm*module".
     */
    type: string;
    /**
     * Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
     */
    usages: string[];
    /**
     * Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
     */
    versionId: string;
    /**
     * Name of the Workflow to bind to.
     */
    workflowName: string;
}

export interface GetWorkerVersionsResultBindingOutbound {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params: string[];
    /**
     * Outbound worker.
     */
    worker: outputs.GetWorkerVersionsResultBindingOutboundWorker;
}

export interface GetWorkerVersionsResultBindingOutboundWorker {
    /**
     * Environment of the outbound worker.
     */
    environment: string;
    /**
     * Name of the outbound worker.
     */
    service: string;
}

export interface GetWorkerVersionsResultLimits {
    /**
     * CPU time limit in milliseconds.
     */
    cpuMs: number;
}

export interface GetWorkerVersionsResultMigrations {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses: string[];
    /**
     * Tag to set as the latest migration tag.
     */
    newTag: string;
    /**
     * Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
     */
    oldTag: string;
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses: outputs.GetWorkerVersionsResultMigrationsRenamedClass[];
    /**
     * Migrations to apply in order.
     */
    steps: outputs.GetWorkerVersionsResultMigrationsStep[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses: outputs.GetWorkerVersionsResultMigrationsTransferredClass[];
}

export interface GetWorkerVersionsResultMigrationsRenamedClass {
    from: string;
    to: string;
}

export interface GetWorkerVersionsResultMigrationsStep {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses: string[];
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses: outputs.GetWorkerVersionsResultMigrationsStepRenamedClass[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses: outputs.GetWorkerVersionsResultMigrationsStepTransferredClass[];
}

export interface GetWorkerVersionsResultMigrationsStepRenamedClass {
    from: string;
    to: string;
}

export interface GetWorkerVersionsResultMigrationsStepTransferredClass {
    from: string;
    fromScript: string;
    to: string;
}

export interface GetWorkerVersionsResultMigrationsTransferredClass {
    from: string;
    fromScript: string;
    to: string;
}

export interface GetWorkerVersionsResultModule {
    /**
     * The base64-encoded module content.
     */
    contentBase64: string;
    /**
     * The content type of the module.
     */
    contentType: string;
    /**
     * The name of the module.
     */
    name: string;
}

export interface GetWorkerVersionsResultPlacement {
    /**
     * Placement mode for the version.
     * Available values: "smart".
     */
    mode: string;
}

export interface GetWorkersCronTriggerSchedule {
    createdOn: string;
    cron: string;
    modifiedOn: string;
}

export interface GetWorkersCustomDomainFilter {
    /**
     * Worker environment associated with the zone and hostname.
     */
    environment?: string;
    /**
     * Hostname of the Worker Domain.
     */
    hostname?: string;
    /**
     * Worker service associated with the zone and hostname.
     */
    service?: string;
    /**
     * Identifier of the zone.
     */
    zoneId?: string;
    /**
     * Name of the zone.
     */
    zoneName?: string;
}

export interface GetWorkersCustomDomainsResult {
    /**
     * Worker environment associated with the zone and hostname.
     */
    environment: string;
    /**
     * Hostname of the Worker Domain.
     */
    hostname: string;
    /**
     * Identifer of the Worker Domain.
     */
    id: string;
    /**
     * Worker service associated with the zone and hostname.
     */
    service: string;
    /**
     * Identifier of the zone.
     */
    zoneId: string;
    /**
     * Name of the zone.
     */
    zoneName: string;
}

export interface GetWorkersDeploymentAnnotations {
    /**
     * Human-readable message about the deployment. Truncated to 100 bytes.
     */
    workersMessage: string;
    /**
     * Operation that triggered the creation of the deployment.
     */
    workersTriggeredBy: string;
}

export interface GetWorkersDeploymentVersion {
    percentage: number;
    versionId: string;
}

export interface GetWorkersForPlatformsDispatchNamespacesResult {
    /**
     * Identifier.
     */
    createdBy: string;
    /**
     * When the script was created.
     */
    createdOn: string;
    /**
     * Identifier.
     */
    modifiedBy: string;
    /**
     * When the script was last modified.
     */
    modifiedOn: string;
    /**
     * API Resource UUID tag.
     */
    namespaceId: string;
    /**
     * Name of the Workers for Platforms dispatch namespace.
     */
    namespaceName: string;
    /**
     * The current number of scripts in this Dispatch Namespace.
     */
    scriptCount: number;
    /**
     * Whether the Workers in the namespace are executed in a "trusted" manner. When a Worker is trusted, it has access to the shared caches for the zone in the Cache API, and has access to the `request.cf` object on incoming Requests. When a Worker is untrusted, caches are not shared across the zone, and `request.cf` is undefined. By default, Workers in a namespace are "untrusted".
     */
    trustedWorkers: boolean;
}

export interface GetWorkersKvNamespaceFilter {
    /**
     * Direction to order namespaces.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Field to order results by.
     * Available values: "id", "title".
     */
    order?: string;
}

export interface GetWorkersKvNamespacesResult {
    /**
     * Namespace identifier tag.
     */
    id: string;
    /**
     * True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?".
     */
    supportsUrlEncoding: boolean;
    /**
     * A human-readable string name for a Namespace.
     */
    title: string;
}

export interface GetWorkersResult {
    /**
     * When the Worker was created.
     */
    createdOn: string;
    /**
     * Immutable ID of the Worker.
     */
    id: string;
    /**
     * Whether logpush is enabled for the Worker.
     */
    logpush: boolean;
    /**
     * Name of the Worker.
     */
    name: string;
    /**
     * Observability settings for the Worker.
     */
    observability: outputs.GetWorkersResultObservability;
    /**
     * Subdomain settings for the Worker.
     */
    subdomain: outputs.GetWorkersResultSubdomain;
    /**
     * Tags associated with the Worker.
     */
    tags: string[];
    /**
     * Other Workers that should consume logs from the Worker.
     */
    tailConsumers: outputs.GetWorkersResultTailConsumer[];
    /**
     * When the Worker was most recently updated.
     */
    updatedOn: string;
}

export interface GetWorkersResultObservability {
    /**
     * Whether observability is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
     */
    headSamplingRate: number;
    /**
     * Log settings for the Worker.
     */
    logs: outputs.GetWorkersResultObservabilityLogs;
}

export interface GetWorkersResultObservabilityLogs {
    /**
     * Whether logs are enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%).
     */
    headSamplingRate: number;
    /**
     * Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
     */
    invocationLogs: boolean;
}

export interface GetWorkersResultSubdomain {
    /**
     * Whether the *.workers.dev subdomain is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * Whether [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/) are enabled for the Worker.
     */
    previewsEnabled: boolean;
}

export interface GetWorkersResultTailConsumer {
    /**
     * Name of the consumer Worker.
     */
    name: string;
}

export interface GetWorkersRoutesResult {
    /**
     * Identifier.
     */
    id: string;
    /**
     * Pattern to match incoming requests against. [Learn more](https://developers.cloudflare.com/workers/configuration/routing/routes/#matching-behavior).
     */
    pattern: string;
    /**
     * Name of the script to run if the route matches.
     */
    script: string;
}

export interface GetWorkersScriptsResult {
    /**
     * Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
     */
    compatibilityDate: string;
    /**
     * Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibilityDate`.
     */
    compatibilityFlags: string[];
    /**
     * When the script was created.
     */
    createdOn: string;
    /**
     * Hashed script content, can be used in a If-None-Match header when updating.
     */
    etag: string;
    /**
     * The names of handlers exported as part of the default export.
     */
    handlers: string[];
    /**
     * Whether a Worker contains assets.
     */
    hasAssets: boolean;
    /**
     * Whether a Worker contains modules.
     */
    hasModules: boolean;
    /**
     * The id of the script in the Workers system. Usually the script name.
     */
    id: string;
    /**
     * The client most recently used to deploy this Worker.
     */
    lastDeployedFrom: string;
    /**
     * Whether Logpush is turned on for the Worker.
     */
    logpush: boolean;
    /**
     * The tag of the Durable Object migration that was most recently applied for this Worker.
     */
    migrationTag: string;
    /**
     * When the script was last modified.
     */
    modifiedOn: string;
    /**
     * Named exports, such as Durable Object class implementations and named entrypoints.
     */
    namedHandlers: outputs.GetWorkersScriptsResultNamedHandler[];
    /**
     * Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    placement: outputs.GetWorkersScriptsResultPlacement;
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "smart".
     *
     * @deprecated This attribute is deprecated.
     */
    placementMode: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
     *
     * @deprecated This attribute is deprecated.
     */
    placementStatus: string;
    /**
     * List of Workers that will consume logs from the attached Worker.
     */
    tailConsumers: outputs.GetWorkersScriptsResultTailConsumer[];
    /**
     * Usage model for the Worker invocations.
     * Available values: "standard", "bundled", "unbound".
     */
    usageModel: string;
}

export interface GetWorkersScriptsResultNamedHandler {
    /**
     * The names of handlers exported as part of the named export.
     */
    handlers: string[];
    /**
     * The name of the export.
     */
    name: string;
}

export interface GetWorkersScriptsResultPlacement {
    /**
     * The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    lastAnalyzedAt: string;
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "smart".
     */
    mode: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
     */
    status: string;
}

export interface GetWorkersScriptsResultTailConsumer {
    /**
     * Optional environment if the Worker utilizes one.
     */
    environment: string;
    /**
     * Optional dispatch namespace the script belongs to.
     */
    namespace: string;
    /**
     * Name of Worker that is to be the consumer.
     */
    service: string;
}

export interface GetWorkflowFilter {
    /**
     * Allows filtering workflows` name.
     */
    search?: string;
}

export interface GetWorkflowInstances {
    complete: number;
    errored: number;
    paused: number;
    queued: number;
    running: number;
    terminated: number;
    waiting: number;
    waitingForPause: number;
}

export interface GetWorkflowsResult {
    className: string;
    createdOn: string;
    id: string;
    instances: outputs.GetWorkflowsResultInstances;
    modifiedOn: string;
    name: string;
    scriptName: string;
    triggeredOn: string;
}

export interface GetWorkflowsResultInstances {
    complete: number;
    errored: number;
    paused: number;
    queued: number;
    running: number;
    terminated: number;
    waiting: number;
    waitingForPause: number;
}

export interface GetZeroTrustAccessApplicationCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge: number;
}

export interface GetZeroTrustAccessApplicationDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     * Available values: "tcp", "udp".
     */
    l4Protocol: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange: string;
    /**
     * Available values: "public", "private".
     */
    type: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId: string;
}

export interface GetZeroTrustAccessApplicationFilter {
    /**
     * The aud of the app.
     */
    aud?: string;
    /**
     * The domain of the app.
     */
    domain?: string;
    /**
     * True for only exact string matches against passed name/domain query parameters.
     */
    exact?: boolean;
    /**
     * The name of the app.
     */
    name?: string;
    /**
     * Search for apps by other listed query parameters.
     */
    search?: string;
}

export interface GetZeroTrustAccessApplicationFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface GetZeroTrustAccessApplicationLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl: string;
    /**
     * The message shown on the landing page.
     */
    message: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface GetZeroTrustAccessApplicationPolicy {
    /**
     * Administrators who can approve a temporary authentication request.
     */
    approvalGroups: outputs.GetZeroTrustAccessApplicationPolicyApprovalGroup[];
    /**
     * Requires the user to request access from an administrator at the start of each session.
     */
    approvalRequired: boolean;
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules: outputs.GetZeroTrustAccessApplicationPolicyConnectionRules;
    createdAt: string;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     * Available values: "allow", "deny", "nonIdentity", "bypass".
     */
    decision: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessApplicationPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessApplicationPolicyInclude[];
    /**
     * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
     */
    isolationRequired: boolean;
    /**
     * The name of the Access policy.
     */
    name: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence: number;
    /**
     * A custom message that will appear on the purpose justification screen.
     */
    purposeJustificationPrompt: string;
    /**
     * Require users to enter a justification when they log in to the application.
     */
    purposeJustificationRequired: boolean;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessApplicationPolicyRequire[];
    /**
     * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessApplicationPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh: outputs.GetZeroTrustAccessApplicationPolicyConnectionRulesSsh;
}

export interface GetZeroTrustAccessApplicationPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface GetZeroTrustAccessApplicationPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationPolicyExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationPolicyExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationPolicyExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationPolicyExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationPolicyExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationPolicyExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationPolicyExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationPolicyExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationPolicyExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationPolicyExcludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationPolicyExcludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationPolicyExcludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessApplicationPolicyExcludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessApplicationPolicyExcludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessApplicationPolicyExcludeOidc;
    okta: outputs.GetZeroTrustAccessApplicationPolicyExcludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationPolicyExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationPolicyExcludeServiceToken;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeCertificate {
}

export interface GetZeroTrustAccessApplicationPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEveryone {
}

export interface GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationPolicyIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationPolicyIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationPolicyIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationPolicyIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationPolicyIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationPolicyIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationPolicyIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationPolicyIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationPolicyIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationPolicyIncludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationPolicyIncludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationPolicyIncludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessApplicationPolicyIncludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessApplicationPolicyIncludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessApplicationPolicyIncludeOidc;
    okta: outputs.GetZeroTrustAccessApplicationPolicyIncludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationPolicyIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationPolicyIncludeServiceToken;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeCertificate {
}

export interface GetZeroTrustAccessApplicationPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEveryone {
}

export interface GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationPolicyRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationPolicyRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationPolicyRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationPolicyRequireCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationPolicyRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationPolicyRequireDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationPolicyRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationPolicyRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationPolicyRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationPolicyRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationPolicyRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationPolicyRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationPolicyRequireGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationPolicyRequireGsuite;
    ip: outputs.GetZeroTrustAccessApplicationPolicyRequireIp;
    ipList: outputs.GetZeroTrustAccessApplicationPolicyRequireIpList;
    linkedAppToken: outputs.GetZeroTrustAccessApplicationPolicyRequireLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessApplicationPolicyRequireLoginMethod;
    oidc: outputs.GetZeroTrustAccessApplicationPolicyRequireOidc;
    okta: outputs.GetZeroTrustAccessApplicationPolicyRequireOkta;
    saml: outputs.GetZeroTrustAccessApplicationPolicyRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationPolicyRequireServiceToken;
}

export interface GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireCertificate {
}

export interface GetZeroTrustAccessApplicationPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEveryone {
}

export interface GetZeroTrustAccessApplicationPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     * Available values: "saml", "oidc".
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: string;
    customAttributes: outputs.GetZeroTrustAccessApplicationSaasAppCustomAttribute[];
    customClaims: outputs.GetZeroTrustAccessApplicationSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex: string;
    hybridAndImplicitOptions: outputs.GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     * Available values: "id", "email".
     */
    nameIdFormat: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris: string[];
    refreshTokenOptions: outputs.GetZeroTrustAccessApplicationSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName: string;
    /**
     * The name of the attribute.
     */
    name: string;
    /**
     * A globally unique name for an identity or service provider.
     * Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
     */
    nameFormat: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required: boolean;
    source: outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSource;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
    nameByIdps: outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp[];
}

export interface GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName: string;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name: string;
    /**
     * If the claim is required when building an OIDC token.
     */
    required: boolean;
    /**
     * The scope of the claim.
     * Available values: "groups", "profile", "email", "openid".
     */
    scope: string;
    source: outputs.GetZeroTrustAccessApplicationSaasAppCustomClaimSource;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp: {[key: string]: string};
}

export interface GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint: boolean;
}

export interface GetZeroTrustAccessApplicationSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime: string;
}

export interface GetZeroTrustAccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication: outputs.GetZeroTrustAccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings: outputs.GetZeroTrustAccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface GetZeroTrustAccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     * Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user: string;
}

export interface GetZeroTrustAccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations: outputs.GetZeroTrustAccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     * Available values: "strict", "passthrough".
     */
    strictness: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata: string;
}

export interface GetZeroTrustAccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update: boolean;
}

export interface GetZeroTrustAccessApplicationTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     * Available values: "SSH", "RDP".
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface GetZeroTrustAccessApplicationsResult {
    /**
     * When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
     */
    allowAuthenticateViaWarp: boolean;
    /**
     * Enables loading application content in an iFrame.
     */
    allowIframe: boolean;
    /**
     * The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account.
     */
    allowedIdps: string[];
    /**
     * The image URL of the logo shown in the App Launcher header.
     */
    appLauncherLogoUrl: string;
    /**
     * Displays the application in the App Launcher.
     */
    appLauncherVisible: boolean;
    /**
     * Audience tag.
     */
    aud: string;
    /**
     * When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps.
     */
    autoRedirectToIdentity: boolean;
    /**
     * The background color of the App Launcher page.
     */
    bgColor: string;
    corsHeaders: outputs.GetZeroTrustAccessApplicationsResultCorsHeaders;
    /**
     * The custom error message shown to a user when they are denied access to the application.
     */
    customDenyMessage: string;
    /**
     * The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules.
     */
    customDenyUrl: string;
    /**
     * The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules.
     */
    customNonIdentityDenyUrl: string;
    /**
     * The custom pages that will be displayed when applicable for this application
     */
    customPages: string[];
    /**
     * List of destinations secured by Access. This supersedes `selfHostedDomains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `selfHostedDomains` will be ignored.
     */
    destinations: outputs.GetZeroTrustAccessApplicationsResultDestination[];
    /**
     * The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher.
     */
    domain: string;
    /**
     * Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks.
     */
    enableBindingCookie: boolean;
    /**
     * The links in the App Launcher footer.
     */
    footerLinks: outputs.GetZeroTrustAccessApplicationsResultFooterLink[];
    /**
     * The background color of the App Launcher header.
     */
    headerBgColor: string;
    /**
     * Enables the HttpOnly cookie attribute, which increases security against XSS attacks.
     */
    httpOnlyCookieAttribute: boolean;
    /**
     * UUID.
     */
    id: string;
    /**
     * The design of the App Launcher landing page shown to users when they log in.
     */
    landingPageDesign: outputs.GetZeroTrustAccessApplicationsResultLandingPageDesign;
    /**
     * The image URL for the logo shown in the App Launcher dashboard.
     */
    logoUrl: string;
    /**
     * The name of the application.
     */
    name: string;
    /**
     * Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if corsHeaders is set.
     */
    optionsPreflightBypass: boolean;
    /**
     * Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default
     */
    pathCookieAttribute: boolean;
    policies: outputs.GetZeroTrustAccessApplicationsResultPolicy[];
    /**
     * Allows matching Access Service Tokens passed HTTP in a single header with this name.
     * This works as an alternative to the (CF-Access-Client-Id, CF-Access-Client-Secret) pair of headers.
     * The header value will be interpreted as a json object similar to:
     * {
     * "cf-access-client-id": "88bf3b6d86161464f6509f7219099e57.access.example.com",
     * "cf-access-client-secret": "bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5"
     * }
     */
    readServiceTokensFromHeader: string;
    saasApp: outputs.GetZeroTrustAccessApplicationsResultSaasApp;
    /**
     * Sets the SameSite cookie setting, which provides increased security against CSRF attacks.
     */
    sameSiteCookieAttribute: string;
    /**
     * Configuration for provisioning to this application via SCIM. This is currently in closed beta.
     */
    scimConfig: outputs.GetZeroTrustAccessApplicationsResultScimConfig;
    /**
     * List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until **November 21, 2025.** If `destinations` are provided, then `selfHostedDomains` will be ignored.
     *
     * @deprecated This attribute is deprecated.
     */
    selfHostedDomains: string[];
    /**
     * Returns a 401 status code when the request is blocked by a Service Auth policy.
     */
    serviceAuth401Redirect: boolean;
    /**
     * The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. Note: unsupported for infrastructure type applications.
     */
    sessionDuration: string;
    /**
     * Determines when to skip the App Launcher landing page.
     */
    skipAppLauncherLoginPage: boolean;
    /**
     * Enables automatic authentication through cloudflared.
     */
    skipInterstitial: boolean;
    /**
     * The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard.
     */
    tags: string[];
    targetCriterias: outputs.GetZeroTrustAccessApplicationsResultTargetCriteria[];
    /**
     * The application type.
     * Available values: "self*hosted", "saas", "ssh", "vnc", "app*launcher", "warp", "biso", "bookmark", "dashSso", "infrastructure", "rdp".
     */
    type: string;
}

export interface GetZeroTrustAccessApplicationsResultCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge: number;
}

export interface GetZeroTrustAccessApplicationsResultDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     * Available values: "tcp", "udp".
     */
    l4Protocol: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange: string;
    /**
     * Available values: "public", "private".
     */
    type: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId: string;
}

export interface GetZeroTrustAccessApplicationsResultFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface GetZeroTrustAccessApplicationsResultLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl: string;
    /**
     * The message shown on the landing page.
     */
    message: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicy {
    /**
     * Administrators who can approve a temporary authentication request.
     */
    approvalGroups: outputs.GetZeroTrustAccessApplicationsResultPolicyApprovalGroup[];
    /**
     * Requires the user to request access from an administrator at the start of each session.
     */
    approvalRequired: boolean;
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules: outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRules;
    createdAt: string;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     * Available values: "allow", "deny", "nonIdentity", "bypass".
     */
    decision: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessApplicationsResultPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessApplicationsResultPolicyInclude[];
    /**
     * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
     */
    isolationRequired: boolean;
    /**
     * The name of the Access policy.
     */
    name: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence: number;
    /**
     * A custom message that will appear on the purpose justification screen.
     */
    purposeJustificationPrompt: string;
    /**
     * Require users to enter a justification when they log in to the application.
     */
    purposeJustificationRequired: boolean;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessApplicationsResultPolicyRequire[];
    /**
     * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh: outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSsh;
}

export interface GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface GetZeroTrustAccessApplicationsResultPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeOidc;
    okta: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeServiceToken;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeCertificate {
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEveryone {
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeOidc;
    okta: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeServiceToken;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeCertificate {
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEveryone {
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGsuite;
    ip: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIp;
    ipList: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIpList;
    linkedAppToken: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethod;
    oidc: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireOidc;
    okta: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireOkta;
    saml: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireServiceToken;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireCertificate {
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEveryone {
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationsResultSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     * Available values: "saml", "oidc".
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: string;
    customAttributes: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttribute[];
    customClaims: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex: string;
    hybridAndImplicitOptions: outputs.GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     * Available values: "id", "email".
     */
    nameIdFormat: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris: string[];
    refreshTokenOptions: outputs.GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName: string;
    /**
     * The name of the attribute.
     */
    name: string;
    /**
     * A globally unique name for an identity or service provider.
     * Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
     */
    nameFormat: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required: boolean;
    source: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSource;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
    nameByIdps: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdp[];
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName: string;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name: string;
    /**
     * If the claim is required when building an OIDC token.
     */
    required: boolean;
    /**
     * The scope of the claim.
     * Available values: "groups", "profile", "email", "openid".
     */
    scope: string;
    source: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSource;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp: {[key: string]: string};
}

export interface GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint: boolean;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication: outputs.GetZeroTrustAccessApplicationsResultScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings: outputs.GetZeroTrustAccessApplicationsResultScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     * Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations: outputs.GetZeroTrustAccessApplicationsResultScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     * Available values: "strict", "passthrough".
     */
    strictness: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update: boolean;
}

export interface GetZeroTrustAccessApplicationsResultTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     * Available values: "SSH", "RDP".
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface GetZeroTrustAccessCustomPagesResult {
    /**
     * Custom page name.
     */
    name: string;
    /**
     * Custom page type.
     * Available values: "identityDenied", "forbidden".
     */
    type: string;
    /**
     * UUID.
     */
    uid: string;
}

export interface GetZeroTrustAccessGroupExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupExcludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupExcludeIp;
    ipList: outputs.GetZeroTrustAccessGroupExcludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupExcludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupExcludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupExcludeOidc;
    okta: outputs.GetZeroTrustAccessGroupExcludeOkta;
    saml: outputs.GetZeroTrustAccessGroupExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupExcludeServiceToken;
}

export interface GetZeroTrustAccessGroupExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeCertificate {
}

export interface GetZeroTrustAccessGroupExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupExcludeEveryone {
}

export interface GetZeroTrustAccessGroupExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupFilter {
    /**
     * The name of the group.
     */
    name?: string;
    /**
     * Search for groups by other listed query parameters.
     */
    search?: string;
}

export interface GetZeroTrustAccessGroupInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupIncludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupIncludeIp;
    ipList: outputs.GetZeroTrustAccessGroupIncludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupIncludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupIncludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupIncludeOidc;
    okta: outputs.GetZeroTrustAccessGroupIncludeOkta;
    saml: outputs.GetZeroTrustAccessGroupIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupIncludeServiceToken;
}

export interface GetZeroTrustAccessGroupIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeCertificate {
}

export interface GetZeroTrustAccessGroupIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIncludeEveryone {
}

export interface GetZeroTrustAccessGroupIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupIsDefault {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupIsDefaultAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupIsDefaultAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupIsDefaultAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupIsDefaultAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupIsDefaultCertificate;
    commonName: outputs.GetZeroTrustAccessGroupIsDefaultCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupIsDefaultDevicePosture;
    email: outputs.GetZeroTrustAccessGroupIsDefaultEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupIsDefaultEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupIsDefaultEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupIsDefaultEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupIsDefaultExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupIsDefaultGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupIsDefaultGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupIsDefaultGroup;
    gsuite: outputs.GetZeroTrustAccessGroupIsDefaultGsuite;
    ip: outputs.GetZeroTrustAccessGroupIsDefaultIp;
    ipList: outputs.GetZeroTrustAccessGroupIsDefaultIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupIsDefaultLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupIsDefaultLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupIsDefaultOidc;
    okta: outputs.GetZeroTrustAccessGroupIsDefaultOkta;
    saml: outputs.GetZeroTrustAccessGroupIsDefaultSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupIsDefaultServiceToken;
}

export interface GetZeroTrustAccessGroupIsDefaultAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupIsDefaultAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupIsDefaultAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultCertificate {
}

export interface GetZeroTrustAccessGroupIsDefaultCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupIsDefaultDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEveryone {
}

export interface GetZeroTrustAccessGroupIsDefaultExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupIsDefaultIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIsDefaultLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupIsDefaultLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIsDefaultOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupIsDefaultSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupRequireCertificate;
    commonName: outputs.GetZeroTrustAccessGroupRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupRequireDevicePosture;
    email: outputs.GetZeroTrustAccessGroupRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupRequireGroup;
    gsuite: outputs.GetZeroTrustAccessGroupRequireGsuite;
    ip: outputs.GetZeroTrustAccessGroupRequireIp;
    ipList: outputs.GetZeroTrustAccessGroupRequireIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupRequireLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupRequireLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupRequireOidc;
    okta: outputs.GetZeroTrustAccessGroupRequireOkta;
    saml: outputs.GetZeroTrustAccessGroupRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupRequireServiceToken;
}

export interface GetZeroTrustAccessGroupRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireCertificate {
}

export interface GetZeroTrustAccessGroupRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupRequireEveryone {
}

export interface GetZeroTrustAccessGroupRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResult {
    /**
     * Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessGroupsResultExclude[];
    /**
     * UUID.
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessGroupsResultInclude[];
    /**
     * Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
     */
    isDefaults: outputs.GetZeroTrustAccessGroupsResultIsDefault[];
    /**
     * The name of the Access group.
     */
    name: string;
    /**
     * Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessGroupsResultRequire[];
}

export interface GetZeroTrustAccessGroupsResultExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultExcludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultExcludeIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultExcludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupsResultExcludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupsResultExcludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupsResultExcludeOidc;
    okta: outputs.GetZeroTrustAccessGroupsResultExcludeOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultExcludeServiceToken;
}

export interface GetZeroTrustAccessGroupsResultExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeCertificate {
}

export interface GetZeroTrustAccessGroupsResultExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEveryone {
}

export interface GetZeroTrustAccessGroupsResultExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResultInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultIncludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultIncludeIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultIncludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupsResultIncludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupsResultIncludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupsResultIncludeOidc;
    okta: outputs.GetZeroTrustAccessGroupsResultIncludeOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultIncludeServiceToken;
}

export interface GetZeroTrustAccessGroupsResultIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeCertificate {
}

export interface GetZeroTrustAccessGroupsResultIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEveryone {
}

export interface GetZeroTrustAccessGroupsResultIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefault {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultIsDefaultAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultIsDefaultCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultIsDefaultCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultIsDefaultDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultIsDefaultEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultIsDefaultEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultIsDefaultGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultIsDefaultGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultIsDefaultGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultIsDefaultGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultIsDefaultIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultIsDefaultIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupsResultIsDefaultLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupsResultIsDefaultLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupsResultIsDefaultOidc;
    okta: outputs.GetZeroTrustAccessGroupsResultIsDefaultOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultIsDefaultSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultIsDefaultServiceToken;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultCertificate {
}

export interface GetZeroTrustAccessGroupsResultIsDefaultCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEveryone {
}

export interface GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResultRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultRequireCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultRequireDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultRequireGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultRequireGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultRequireIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultRequireIpList;
    linkedAppToken: outputs.GetZeroTrustAccessGroupsResultRequireLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessGroupsResultRequireLoginMethod;
    oidc: outputs.GetZeroTrustAccessGroupsResultRequireOidc;
    okta: outputs.GetZeroTrustAccessGroupsResultRequireOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultRequireServiceToken;
}

export interface GetZeroTrustAccessGroupsResultRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireCertificate {
}

export interface GetZeroTrustAccessGroupsResultRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEveryone {
}

export interface GetZeroTrustAccessGroupsResultRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessGroupsResultRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessIdentityProviderConfig {
    /**
     * Your companies TLD
     */
    appsDomain: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId: string;
    /**
     * Your centrify account url
     */
    centrifyAccount: string;
    /**
     * Your centrify app id
     */
    centrifyAppId: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl: string;
    /**
     * Custom claims
     */
    claims: string[];
    /**
     * Your OAuth Client ID
     */
    clientId: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes: outputs.GetZeroTrustAccessIdentityProviderConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl: string;
    /**
     * Your okta account url
     */
    oktaAccount: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     * Available values: "login", "selectAccount", "none".
     */
    prompt: string;
    redirectUrl: string;
    /**
     * OAuth scopes
     */
    scopes: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl: string;
}

export interface GetZeroTrustAccessIdentityProviderConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName: string;
}

export interface GetZeroTrustAccessIdentityProviderFilter {
    /**
     * Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
     */
    scimEnabled?: string;
}

export interface GetZeroTrustAccessIdentityProviderScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     * Available values: "automatic", "reauth", "no*action".
     */
    identityUpdateBehavior: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision: boolean;
}

export interface GetZeroTrustAccessIdentityProvidersResult {
    /**
     * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
     */
    config: outputs.GetZeroTrustAccessIdentityProvidersResultConfig;
    /**
     * UUID.
     */
    id: string;
    /**
     * The name of the identity provider, shown to users on the login page.
     */
    name: string;
    /**
     * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
     */
    scimConfig: outputs.GetZeroTrustAccessIdentityProvidersResultScimConfig;
    /**
     * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
     * Available values: "onetimepin", "azureAD", "saml", "centrify", "facebook", "github", "google-apps", "google", "linkedin", "oidc", "okta", "onelogin", "pingone", "yandex".
     */
    type: string;
}

export interface GetZeroTrustAccessIdentityProvidersResultConfig {
    /**
     * Your companies TLD
     */
    appsDomain: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId: string;
    /**
     * Your centrify account url
     */
    centrifyAccount: string;
    /**
     * Your centrify app id
     */
    centrifyAppId: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl: string;
    /**
     * Custom claims
     */
    claims: string[];
    /**
     * Your OAuth Client ID
     */
    clientId: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes: outputs.GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl: string;
    /**
     * Your okta account url
     */
    oktaAccount: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     * Available values: "login", "selectAccount", "none".
     */
    prompt: string;
    /**
     * OAuth scopes
     */
    scopes: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl: string;
}

export interface GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName: string;
}

export interface GetZeroTrustAccessIdentityProvidersResultScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     * Available values: "automatic", "reauth", "no*action".
     */
    identityUpdateBehavior: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision: boolean;
}

export interface GetZeroTrustAccessInfrastructureTargetFilter {
    /**
     * Date and time at which the target was created after (inclusive)
     */
    createdAfter?: string;
    /**
     * Date and time at which the target was created before (inclusive)
     */
    createdBefore?: string;
    /**
     * The sorting direction.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Hostname of a target
     */
    hostname?: string;
    /**
     * Partial match to the hostname of a target
     */
    hostnameContains?: string;
    /**
     * Filters for targets whose IP addresses look like the specified string.
     * Supports `*` as a wildcard character
     */
    ipLike?: string;
    /**
     * IPv4 address of the target
     */
    ipV4?: string;
    /**
     * IPv6 address of the target
     */
    ipV6?: string;
    /**
     * Filters for targets that have any of the following IP addresses. Specify
     * `ips` multiple times in query parameter to build list of candidates.
     */
    ips?: string[];
    /**
     * Defines an IPv4 filter range's ending value (inclusive). Requires
     * `ipv4Start` to be specified as well.
     */
    ipv4End?: string;
    /**
     * Defines an IPv4 filter range's starting value (inclusive). Requires
     * `ipv4End` to be specified as well.
     */
    ipv4Start?: string;
    /**
     * Defines an IPv6 filter range's ending value (inclusive). Requires
     * `ipv6Start` to be specified as well.
     */
    ipv6End?: string;
    /**
     * Defines an IPv6 filter range's starting value (inclusive). Requires
     * `ipv6End` to be specified as well.
     */
    ipv6Start?: string;
    /**
     * Date and time at which the target was modified after (inclusive)
     */
    modifiedAfter?: string;
    /**
     * Date and time at which the target was modified before (inclusive)
     */
    modifiedBefore?: string;
    /**
     * The field to sort by.
     * Available values: "hostname", "createdAt".
     */
    order?: string;
    /**
     * Filters for targets that have any of the following UUIDs. Specify
     * `targetIds` multiple times in query parameter to build list of
     * candidates.
     */
    targetIds?: string[];
    /**
     * Private virtual network identifier of the target
     */
    virtualNetworkId?: string;
}

export interface GetZeroTrustAccessInfrastructureTargetIp {
    /**
     * The target's IPv4 address
     */
    ipv4: outputs.GetZeroTrustAccessInfrastructureTargetIpIpv4;
    /**
     * The target's IPv6 address
     */
    ipv6: outputs.GetZeroTrustAccessInfrastructureTargetIpIpv6;
}

export interface GetZeroTrustAccessInfrastructureTargetIpIpv4 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessInfrastructureTargetIpIpv6 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessInfrastructureTargetsResult {
    /**
     * Date and time at which the target was created
     */
    createdAt: string;
    /**
     * A non-unique field that refers to a target
     */
    hostname: string;
    /**
     * Target identifier
     */
    id: string;
    /**
     * The IPv4/IPv6 address that identifies where to reach a target
     */
    ip: outputs.GetZeroTrustAccessInfrastructureTargetsResultIp;
    /**
     * Date and time at which the target was modified
     */
    modifiedAt: string;
}

export interface GetZeroTrustAccessInfrastructureTargetsResultIp {
    /**
     * The target's IPv4 address
     */
    ipv4: outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv4;
    /**
     * The target's IPv6 address
     */
    ipv6: outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv6;
}

export interface GetZeroTrustAccessInfrastructureTargetsResultIpIpv4 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessInfrastructureTargetsResultIpIpv6 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessMtlsCertificatesResult {
    /**
     * The hostnames of the applications that will use this certificate.
     */
    associatedHostnames: string[];
    expiresOn: string;
    /**
     * The MD5 fingerprint of the certificate.
     */
    fingerprint: string;
    /**
     * The ID of the application that will use this certificate.
     */
    id: string;
    /**
     * The name of the certificate.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResult {
    /**
     * Number of access applications currently using this policy.
     */
    appCount: number;
    /**
     * Administrators who can approve a temporary authentication request.
     */
    approvalGroups: outputs.GetZeroTrustAccessPoliciesResultApprovalGroup[];
    /**
     * Requires the user to request access from an administrator at the start of each session.
     */
    approvalRequired: boolean;
    createdAt: string;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     * Available values: "allow", "deny", "nonIdentity", "bypass".
     */
    decision: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessPoliciesResultExclude[];
    /**
     * The UUID of the policy
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessPoliciesResultInclude[];
    /**
     * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
     */
    isolationRequired: boolean;
    /**
     * The name of the Access policy.
     */
    name: string;
    /**
     * A custom message that will appear on the purpose justification screen.
     */
    purposeJustificationPrompt: string;
    /**
     * Require users to enter a justification when they log in to the application.
     */
    purposeJustificationRequired: boolean;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessPoliciesResultRequire[];
    reusable: boolean;
    /**
     * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessPoliciesResultApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessPoliciesResultExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPoliciesResultExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPoliciesResultExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPoliciesResultExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPoliciesResultExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessPoliciesResultExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPoliciesResultExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessPoliciesResultExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPoliciesResultExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPoliciesResultExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPoliciesResultExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPoliciesResultExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPoliciesResultExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPoliciesResultExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPoliciesResultExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessPoliciesResultExcludeGsuite;
    ip: outputs.GetZeroTrustAccessPoliciesResultExcludeIp;
    ipList: outputs.GetZeroTrustAccessPoliciesResultExcludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessPoliciesResultExcludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessPoliciesResultExcludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessPoliciesResultExcludeOidc;
    okta: outputs.GetZeroTrustAccessPoliciesResultExcludeOkta;
    saml: outputs.GetZeroTrustAccessPoliciesResultExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPoliciesResultExcludeServiceToken;
}

export interface GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPoliciesResultExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeCertificate {
}

export interface GetZeroTrustAccessPoliciesResultExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEveryone {
}

export interface GetZeroTrustAccessPoliciesResultExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPoliciesResultInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPoliciesResultIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPoliciesResultIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPoliciesResultIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPoliciesResultIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessPoliciesResultIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPoliciesResultIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessPoliciesResultIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPoliciesResultIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPoliciesResultIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPoliciesResultIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPoliciesResultIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPoliciesResultIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPoliciesResultIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPoliciesResultIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessPoliciesResultIncludeGsuite;
    ip: outputs.GetZeroTrustAccessPoliciesResultIncludeIp;
    ipList: outputs.GetZeroTrustAccessPoliciesResultIncludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessPoliciesResultIncludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessPoliciesResultIncludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessPoliciesResultIncludeOidc;
    okta: outputs.GetZeroTrustAccessPoliciesResultIncludeOkta;
    saml: outputs.GetZeroTrustAccessPoliciesResultIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPoliciesResultIncludeServiceToken;
}

export interface GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPoliciesResultIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeCertificate {
}

export interface GetZeroTrustAccessPoliciesResultIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEveryone {
}

export interface GetZeroTrustAccessPoliciesResultIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPoliciesResultRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPoliciesResultRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessPoliciesResultRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPoliciesResultRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessPoliciesResultRequireCertificate;
    commonName: outputs.GetZeroTrustAccessPoliciesResultRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessPoliciesResultRequireDevicePosture;
    email: outputs.GetZeroTrustAccessPoliciesResultRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessPoliciesResultRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessPoliciesResultRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPoliciesResultRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPoliciesResultRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPoliciesResultRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessPoliciesResultRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessPoliciesResultRequireGroup;
    gsuite: outputs.GetZeroTrustAccessPoliciesResultRequireGsuite;
    ip: outputs.GetZeroTrustAccessPoliciesResultRequireIp;
    ipList: outputs.GetZeroTrustAccessPoliciesResultRequireIpList;
    linkedAppToken: outputs.GetZeroTrustAccessPoliciesResultRequireLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessPoliciesResultRequireLoginMethod;
    oidc: outputs.GetZeroTrustAccessPoliciesResultRequireOidc;
    okta: outputs.GetZeroTrustAccessPoliciesResultRequireOkta;
    saml: outputs.GetZeroTrustAccessPoliciesResultRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessPoliciesResultRequireServiceToken;
}

export interface GetZeroTrustAccessPoliciesResultRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessPoliciesResultRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireCertificate {
}

export interface GetZeroTrustAccessPoliciesResultRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEveryone {
}

export interface GetZeroTrustAccessPoliciesResultRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPolicyExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPolicyExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPolicyExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPolicyExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPolicyExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessPolicyExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPolicyExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessPolicyExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPolicyExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPolicyExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPolicyExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPolicyExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPolicyExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPolicyExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessPolicyExcludeGsuite;
    ip: outputs.GetZeroTrustAccessPolicyExcludeIp;
    ipList: outputs.GetZeroTrustAccessPolicyExcludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessPolicyExcludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessPolicyExcludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessPolicyExcludeOidc;
    okta: outputs.GetZeroTrustAccessPolicyExcludeOkta;
    saml: outputs.GetZeroTrustAccessPolicyExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPolicyExcludeServiceToken;
}

export interface GetZeroTrustAccessPolicyExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeCertificate {
}

export interface GetZeroTrustAccessPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyExcludeEveryone {
}

export interface GetZeroTrustAccessPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPolicyIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPolicyIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPolicyIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPolicyIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPolicyIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessPolicyIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPolicyIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessPolicyIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPolicyIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPolicyIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPolicyIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPolicyIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPolicyIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPolicyIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessPolicyIncludeGsuite;
    ip: outputs.GetZeroTrustAccessPolicyIncludeIp;
    ipList: outputs.GetZeroTrustAccessPolicyIncludeIpList;
    linkedAppToken: outputs.GetZeroTrustAccessPolicyIncludeLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessPolicyIncludeLoginMethod;
    oidc: outputs.GetZeroTrustAccessPolicyIncludeOidc;
    okta: outputs.GetZeroTrustAccessPolicyIncludeOkta;
    saml: outputs.GetZeroTrustAccessPolicyIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPolicyIncludeServiceToken;
}

export interface GetZeroTrustAccessPolicyIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeCertificate {
}

export interface GetZeroTrustAccessPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyIncludeEveryone {
}

export interface GetZeroTrustAccessPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPolicyRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPolicyRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessPolicyRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPolicyRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessPolicyRequireCertificate;
    commonName: outputs.GetZeroTrustAccessPolicyRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessPolicyRequireDevicePosture;
    email: outputs.GetZeroTrustAccessPolicyRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessPolicyRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPolicyRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPolicyRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPolicyRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessPolicyRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessPolicyRequireGroup;
    gsuite: outputs.GetZeroTrustAccessPolicyRequireGsuite;
    ip: outputs.GetZeroTrustAccessPolicyRequireIp;
    ipList: outputs.GetZeroTrustAccessPolicyRequireIpList;
    linkedAppToken: outputs.GetZeroTrustAccessPolicyRequireLinkedAppToken;
    loginMethod: outputs.GetZeroTrustAccessPolicyRequireLoginMethod;
    oidc: outputs.GetZeroTrustAccessPolicyRequireOidc;
    okta: outputs.GetZeroTrustAccessPolicyRequireOkta;
    saml: outputs.GetZeroTrustAccessPolicyRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessPolicyRequireServiceToken;
}

export interface GetZeroTrustAccessPolicyRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireCertificate {
}

export interface GetZeroTrustAccessPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyRequireEveryone {
}

export interface GetZeroTrustAccessPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface GetZeroTrustAccessPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessServiceTokenFilter {
    /**
     * The name of the service token.
     */
    name?: string;
    /**
     * Search for service tokens by other listed query parameters.
     */
    search?: string;
}

export interface GetZeroTrustAccessServiceTokensResult {
    /**
     * The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header.
     */
    clientId: string;
    /**
     * The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. The default is 1 year in hours (8760h).
     */
    duration: string;
    expiresAt: string;
    /**
     * The ID of the service token.
     */
    id: string;
    /**
     * The name of the service token.
     */
    name: string;
}

export interface GetZeroTrustAccessShortLivedCertificatesResult {
    /**
     * The Application Audience (AUD) tag. Identifies the application associated with the CA.
     */
    aud: string;
    /**
     * The ID of the CA.
     */
    id: string;
    /**
     * The public key to add to your SSH server configuration.
     */
    publicKey: string;
}

export interface GetZeroTrustAccessTagsResult {
    /**
     * The name of the tag
     */
    name: string;
}

export interface GetZeroTrustDeviceCustomProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface GetZeroTrustDeviceCustomProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface GetZeroTrustDeviceCustomProfileTargetTest {
    /**
     * The id of the DEX test targeting this policy.
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy.
     */
    name: string;
}

export interface GetZeroTrustDeviceCustomProfilesResult {
    /**
     * Whether to allow the user to switch WARP between modes.
     */
    allowModeSwitch: boolean;
    /**
     * Whether to receive update notifications when a new version of the client is available.
     */
    allowUpdates: boolean;
    /**
     * Whether to allow devices to leave the organization.
     */
    allowedToLeave: boolean;
    /**
     * The amount of time in seconds to reconnect after having been disabled.
     */
    autoConnect: number;
    /**
     * Turn on the captive portal after the specified amount of time.
     */
    captivePortal: number;
    /**
     * Whether the policy is the default policy for an account.
     */
    default: boolean;
    /**
     * A description of the policy.
     */
    description: string;
    /**
     * If the `dnsServer` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`.
     */
    disableAutoFallback: boolean;
    /**
     * Whether the policy will be applied to matching devices.
     */
    enabled: boolean;
    /**
     * Whether to add Microsoft IPs to Split Tunnel exclusions.
     */
    excludeOfficeIps: boolean;
    /**
     * List of routes excluded in the WARP client's tunnel.
     */
    excludes: outputs.GetZeroTrustDeviceCustomProfilesResultExclude[];
    fallbackDomains: outputs.GetZeroTrustDeviceCustomProfilesResultFallbackDomain[];
    gatewayUniqueId: string;
    /**
     * List of routes included in the WARP client's tunnel.
     */
    includes: outputs.GetZeroTrustDeviceCustomProfilesResultInclude[];
    /**
     * The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
     */
    lanAllowMinutes: number;
    /**
     * The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
     */
    lanAllowSubnetSize: number;
    /**
     * The wirefilter expression to match devices. Available values: "identity.email", "identity.groups.id", "identity.groups.name", "identity.groups.email", "identity.service*token*uuid", "identity.saml_attributes", "network", "os.name", "os.version".
     */
    match: string;
    /**
     * The name of the device settings profile.
     */
    name: string;
    policyId: string;
    /**
     * The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
     */
    precedence: number;
    /**
     * Determines if the operating system will register WARP's local interface IP with your on-premises DNS server.
     */
    registerInterfaceIpWithDns: boolean;
    /**
     * Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only).
     */
    sccmVpnBoundarySupport: boolean;
    serviceModeV2: outputs.GetZeroTrustDeviceCustomProfilesResultServiceModeV2;
    /**
     * The URL to launch when the Send Feedback button is clicked.
     */
    supportUrl: string;
    /**
     * Whether to allow the user to turn off the WARP switch and disconnect the client.
     */
    switchLocked: boolean;
    targetTests: outputs.GetZeroTrustDeviceCustomProfilesResultTargetTest[];
    /**
     * Determines which tunnel protocol to use.
     */
    tunnelProtocol: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultInclude {
    /**
     * The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface GetZeroTrustDeviceCustomProfilesResultTargetTest {
    /**
     * The id of the DEX test targeting this policy.
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy.
     */
    name: string;
}

export interface GetZeroTrustDeviceDefaultProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceDefaultProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface GetZeroTrustDeviceDefaultProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceDefaultProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface GetZeroTrustDeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface GetZeroTrustDeviceManagedNetworksListResult {
    /**
     * The configuration object containing information for the WARP client to detect the managed network.
     */
    config: outputs.GetZeroTrustDeviceManagedNetworksListResultConfig;
    /**
     * The name of the device managed network. This name must be unique.
     */
    name: string;
    /**
     * API UUID.
     */
    networkId: string;
    /**
     * The type of device managed network.
     * Available values: "tls".
     */
    type: string;
}

export interface GetZeroTrustDeviceManagedNetworksListResultConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface GetZeroTrustDevicePostureIntegrationConfig {
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId: string;
}

export interface GetZeroTrustDevicePostureIntegrationsResult {
    /**
     * The configuration object containing third-party integration information.
     */
    config: outputs.GetZeroTrustDevicePostureIntegrationsResultConfig;
    /**
     * API UUID.
     */
    id: string;
    /**
     * The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`).
     */
    interval: string;
    /**
     * The name of the device posture integration.
     */
    name: string;
    /**
     * The type of device posture integration.
     * Available values: "workspace*one", "crowdstrike*s2s", "uptycs", "intune", "kolide", "tanium*s2s", "sentinelone*s2s", "customS2s".
     */
    type: string;
}

export interface GetZeroTrustDevicePostureIntegrationsResultConfig {
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId: string;
}

export interface GetZeroTrustDevicePostureRuleInput {
    /**
     * The Number of active threats.
     */
    activeThreats: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey: boolean;
    /**
     * Common Name that is protected by the certificate.
     */
    cn: string;
    /**
     * Compliance Status.
     * Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
     */
    complianceStatus: string;
    /**
     * Posture Integration ID.
     */
    connectionId: string;
    /**
     * Count Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    countOperator: string;
    /**
     * Domain.
     */
    domain: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen: string;
    /**
     * Enabled.
     */
    enabled: boolean;
    /**
     * Whether or not file exists.
     */
    exists: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used.
     */
    extendedKeyUsages: string[];
    /**
     * List ID.
     */
    id: string;
    /**
     * Whether device is infected.
     */
    infected: boolean;
    /**
     * Whether device is active.
     */
    isActive: boolean;
    /**
     * The Number of Issues.
     */
    issueCount: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen: string;
    locations: outputs.GetZeroTrustDevicePostureRuleInputLocations;
    /**
     * Network status of device.
     * Available values: "connected", "disconnected", "disconnecting", "connecting".
     */
    networkStatus: string;
    /**
     * Operating system.
     * Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
     */
    operatingSystem: string;
    /**
     * Agent operational state.
     * Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
     */
    operationalState: string;
    /**
     * Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    operator: string;
    /**
     * Os Version.
     */
    os: string;
    /**
     * Operating System Distribution Name (linux only).
     */
    osDistroName: string;
    /**
     * Version of OS Distribution (linux only).
     */
    osDistroRevision: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
     */
    osVersionExtra: string;
    /**
     * Overall.
     */
    overall: string;
    /**
     * File path.
     */
    path: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     * Available values: "low", "medium", "high", "critical".
     */
    riskLevel: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score: number;
    /**
     * Score Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    scoreOperator: string;
    /**
     * SensorConfig.
     */
    sensorConfig: string;
    /**
     * SHA-256.
     */
    sha256: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     * Available values: "online", "offline", "unknown".
     */
    state: string;
    /**
     * List of certificate Subject Alternative Names.
     */
    subjectAlternativeNames: string[];
    /**
     * Signing certificate thumbprint.
     */
    thumbprint: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore: number;
    /**
     * Version of OS.
     */
    version: string;
    /**
     * Version Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    versionOperator: string;
}

export interface GetZeroTrustDevicePostureRuleInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores: string[];
}

export interface GetZeroTrustDevicePostureRuleMatch {
    /**
     * Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
     */
    platform: string;
}

export interface GetZeroTrustDevicePostureRulesResult {
    /**
     * The description of the device posture rule.
     */
    description: string;
    /**
     * Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client.
     */
    expiration: string;
    /**
     * API UUID.
     */
    id: string;
    /**
     * The value to be checked against.
     */
    input: outputs.GetZeroTrustDevicePostureRulesResultInput;
    /**
     * The conditions that the client must match to run the rule.
     */
    matches: outputs.GetZeroTrustDevicePostureRulesResultMatch[];
    /**
     * The name of the device posture rule.
     */
    name: string;
    /**
     * Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`.
     */
    schedule: string;
    /**
     * The type of device posture rule.
     * Available values: "file", "application", "tanium", "gateway", "warp", "disk*encryption", "serial*number", "sentinelone", "carbonblack", "firewall", "os*version", "domain*joined", "client*certificate", "client*certificate*v2", "unique*client*id", "kolide", "tanium*s2s", "crowdstrike*s2s", "intune", "workspace*one", "sentinelone*s2s", "custom*s2s".
     */
    type: string;
}

export interface GetZeroTrustDevicePostureRulesResultInput {
    /**
     * The Number of active threats.
     */
    activeThreats: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey: boolean;
    /**
     * Common Name that is protected by the certificate.
     */
    cn: string;
    /**
     * Compliance Status.
     * Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
     */
    complianceStatus: string;
    /**
     * Posture Integration ID.
     */
    connectionId: string;
    /**
     * Count Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    countOperator: string;
    /**
     * Domain.
     */
    domain: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen: string;
    /**
     * Enabled.
     */
    enabled: boolean;
    /**
     * Whether or not file exists.
     */
    exists: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used.
     */
    extendedKeyUsages: string[];
    /**
     * List ID.
     */
    id: string;
    /**
     * Whether device is infected.
     */
    infected: boolean;
    /**
     * Whether device is active.
     */
    isActive: boolean;
    /**
     * The Number of Issues.
     */
    issueCount: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen: string;
    locations: outputs.GetZeroTrustDevicePostureRulesResultInputLocations;
    /**
     * Network status of device.
     * Available values: "connected", "disconnected", "disconnecting", "connecting".
     */
    networkStatus: string;
    /**
     * Operating system.
     * Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
     */
    operatingSystem: string;
    /**
     * Agent operational state.
     * Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
     */
    operationalState: string;
    /**
     * Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    operator: string;
    /**
     * Os Version.
     */
    os: string;
    /**
     * Operating System Distribution Name (linux only).
     */
    osDistroName: string;
    /**
     * Version of OS Distribution (linux only).
     */
    osDistroRevision: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
     */
    osVersionExtra: string;
    /**
     * Overall.
     */
    overall: string;
    /**
     * File path.
     */
    path: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     * Available values: "low", "medium", "high", "critical".
     */
    riskLevel: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score: number;
    /**
     * Score Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    scoreOperator: string;
    /**
     * SensorConfig.
     */
    sensorConfig: string;
    /**
     * SHA-256.
     */
    sha256: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     * Available values: "online", "offline", "unknown".
     */
    state: string;
    /**
     * List of certificate Subject Alternative Names.
     */
    subjectAlternativeNames: string[];
    /**
     * Signing certificate thumbprint.
     */
    thumbprint: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore: number;
    /**
     * Version of OS.
     */
    version: string;
    /**
     * Version Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    versionOperator: string;
}

export interface GetZeroTrustDevicePostureRulesResultInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores: string[];
}

export interface GetZeroTrustDevicePostureRulesResultMatch {
    /**
     * Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
     */
    platform: string;
}

export interface GetZeroTrustDexTestData {
    /**
     * The desired endpoint to test.
     */
    host: string;
    /**
     * The type of test.
     */
    kind: string;
    /**
     * The HTTP request method type.
     */
    method: string;
}

export interface GetZeroTrustDexTestTargetPolicy {
    /**
     * Whether the DEX rule is the account default
     */
    default: boolean;
    /**
     * The id of the DEX rule
     */
    id: string;
    /**
     * The name of the DEX rule
     */
    name: string;
}

export interface GetZeroTrustDexTestsResult {
    /**
     * The configuration object which contains the details for the WARP client to conduct the test.
     */
    data: outputs.GetZeroTrustDexTestsResultData;
    /**
     * Additional details about the test.
     */
    description: string;
    /**
     * Determines whether or not the test is active.
     */
    enabled: boolean;
    /**
     * How often the test will run.
     */
    interval: string;
    /**
     * The name of the DEX test. Must be unique.
     */
    name: string;
    /**
     * DEX rules targeted by this test
     */
    targetPolicies: outputs.GetZeroTrustDexTestsResultTargetPolicy[];
    targeted: boolean;
    /**
     * The unique identifier for the test.
     */
    testId: string;
}

export interface GetZeroTrustDexTestsResultData {
    /**
     * The desired endpoint to test.
     */
    host: string;
    /**
     * The type of test.
     */
    kind: string;
    /**
     * The HTTP request method type.
     */
    method: string;
}

export interface GetZeroTrustDexTestsResultTargetPolicy {
    /**
     * Whether the DEX rule is the account default
     */
    default: boolean;
    /**
     * The id of the DEX rule
     */
    id: string;
    /**
     * The name of the DEX rule
     */
    name: string;
}

export interface GetZeroTrustDlpCustomEntriesResult {
    /**
     * Only applies to custom word lists.
     * Determines if the words should be matched in a case-sensitive manner
     * Cannot be set to false if secret is true
     */
    caseSensitive: boolean;
    confidence: outputs.GetZeroTrustDlpCustomEntriesResultConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpCustomEntriesResultPattern;
    profileId: string;
    secret: boolean;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint", "wordList".
     */
    type: string;
    updatedAt: string;
    variant: outputs.GetZeroTrustDlpCustomEntriesResultVariant;
    wordList: string;
}

export interface GetZeroTrustDlpCustomEntriesResultConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpCustomEntriesResultPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpCustomEntriesResultVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpCustomEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpCustomEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpCustomEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpCustomProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.GetZeroTrustDlpCustomProfileContextAwarenessSkip;
}

export interface GetZeroTrustDlpCustomProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface GetZeroTrustDlpCustomProfileEntry {
    /**
     * Only applies to custom word lists.
     * Determines if the words should be matched in a case-sensitive manner
     * Cannot be set to false if secret is true
     */
    caseSensitive: boolean;
    confidence: outputs.GetZeroTrustDlpCustomProfileEntryConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpCustomProfileEntryPattern;
    profileId: string;
    secret: boolean;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint", "wordList".
     */
    type: string;
    updatedAt: string;
    variant: outputs.GetZeroTrustDlpCustomProfileEntryVariant;
    wordList: string;
}

export interface GetZeroTrustDlpCustomProfileEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpCustomProfileEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpCustomProfileEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    uploadStatus: string;
}

export interface GetZeroTrustDlpDatasetUpload {
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    status: string;
    version: number;
}

export interface GetZeroTrustDlpDatasetsResult {
    caseSensitive: boolean;
    columns: outputs.GetZeroTrustDlpDatasetsResultColumn[];
    createdAt: string;
    /**
     * The description of the dataset.
     */
    description: string;
    encodingVersion: number;
    id: string;
    name: string;
    numCells: number;
    secret: boolean;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    status: string;
    /**
     * When the dataset was last updated.
     */
    updatedAt: string;
    uploads: outputs.GetZeroTrustDlpDatasetsResultUpload[];
}

export interface GetZeroTrustDlpDatasetsResultColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    uploadStatus: string;
}

export interface GetZeroTrustDlpDatasetsResultUpload {
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    status: string;
    version: number;
}

export interface GetZeroTrustDlpEntriesResult {
    /**
     * Only applies to custom word lists.
     * Determines if the words should be matched in a case-sensitive manner
     * Cannot be set to false if secret is true
     */
    caseSensitive: boolean;
    confidence: outputs.GetZeroTrustDlpEntriesResultConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpEntriesResultPattern;
    profileId: string;
    secret: boolean;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint", "wordList".
     */
    type: string;
    updatedAt: string;
    variant: outputs.GetZeroTrustDlpEntriesResultVariant;
    wordList: string;
}

export interface GetZeroTrustDlpEntriesResultConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpEntriesResultPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpEntriesResultVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpIntegrationEntriesResult {
    /**
     * Only applies to custom word lists.
     * Determines if the words should be matched in a case-sensitive manner
     * Cannot be set to false if secret is true
     */
    caseSensitive: boolean;
    confidence: outputs.GetZeroTrustDlpIntegrationEntriesResultConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpIntegrationEntriesResultPattern;
    profileId: string;
    secret: boolean;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint", "wordList".
     */
    type: string;
    updatedAt: string;
    variant: outputs.GetZeroTrustDlpIntegrationEntriesResultVariant;
    wordList: string;
}

export interface GetZeroTrustDlpIntegrationEntriesResultConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpIntegrationEntriesResultPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpIntegrationEntriesResultVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpIntegrationEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpIntegrationEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpIntegrationEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpPredefinedEntriesResult {
    /**
     * Only applies to custom word lists.
     * Determines if the words should be matched in a case-sensitive manner
     * Cannot be set to false if secret is true
     */
    caseSensitive: boolean;
    confidence: outputs.GetZeroTrustDlpPredefinedEntriesResultConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpPredefinedEntriesResultPattern;
    profileId: string;
    secret: boolean;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint", "wordList".
     */
    type: string;
    updatedAt: string;
    variant: outputs.GetZeroTrustDlpPredefinedEntriesResultVariant;
    wordList: string;
}

export interface GetZeroTrustDlpPredefinedEntriesResultConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpPredefinedEntriesResultPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpPredefinedEntriesResultVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpPredefinedEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpPredefinedEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpPredefinedEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDlpPredefinedProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.GetZeroTrustDlpPredefinedProfileContextAwarenessSkip;
}

export interface GetZeroTrustDlpPredefinedProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface GetZeroTrustDlpPredefinedProfileEntry {
    /**
     * Only applies to custom word lists.
     * Determines if the words should be matched in a case-sensitive manner
     * Cannot be set to false if secret is true
     */
    caseSensitive: boolean;
    confidence: outputs.GetZeroTrustDlpPredefinedProfileEntryConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpPredefinedProfileEntryPattern;
    profileId: string;
    secret: boolean;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint", "wordList".
     */
    type: string;
    updatedAt: string;
    variant: outputs.GetZeroTrustDlpPredefinedProfileEntryVariant;
    wordList: string;
}

export interface GetZeroTrustDlpPredefinedProfileEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface GetZeroTrustDlpPredefinedProfileEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface GetZeroTrustDlpPredefinedProfileEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface GetZeroTrustDnsLocationEndpoints {
    doh: outputs.GetZeroTrustDnsLocationEndpointsDoh;
    dot: outputs.GetZeroTrustDnsLocationEndpointsDot;
    ipv4: outputs.GetZeroTrustDnsLocationEndpointsIpv4;
    ipv6: outputs.GetZeroTrustDnsLocationEndpointsIpv6;
}

export interface GetZeroTrustDnsLocationEndpointsDoh {
    /**
     * Indicate whether the DOH endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationEndpointsDohNetwork[];
    /**
     * Specify whether the DOH endpoint requires user identity authentication.
     */
    requireToken: boolean;
}

export interface GetZeroTrustDnsLocationEndpointsDohNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationEndpointsDot {
    /**
     * Indicate whether the DOT endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationEndpointsDotNetwork[];
}

export interface GetZeroTrustDnsLocationEndpointsDotNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationEndpointsIpv4 {
    /**
     * Indicate whether the IPv4 endpoint is enabled for this location.
     */
    enabled: boolean;
}

export interface GetZeroTrustDnsLocationEndpointsIpv6 {
    /**
     * Indicate whether the IPV6 endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IPv6 network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationEndpointsIpv6Network[];
}

export interface GetZeroTrustDnsLocationEndpointsIpv6Network {
    /**
     * Specify the IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationNetwork {
    /**
     * Specify the IPv4 address or IPv4 CIDR. Limit IPv4 CIDRs to a maximum of /24.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResult {
    /**
     * Indicate whether this location is the default location.
     */
    clientDefault: boolean;
    createdAt: string;
    /**
     * Indicate the identifier of the pair of IPv4 addresses assigned to this location.
     */
    dnsDestinationIpsId: string;
    /**
     * Specify the UUID of the IPv6 block brought to the gateway so that this location's IPv6 address is allocated from the Bring Your Own IPv6 (BYOIPv6) block rather than the standard Cloudflare IPv6 block.
     */
    dnsDestinationIpv6BlockId: string;
    /**
     * Specify the DNS over HTTPS domain that receives DNS requests. Gateway automatically generates this value.
     */
    dohSubdomain: string;
    /**
     * Indicate whether the location must resolve EDNS queries.
     */
    ecsSupport: boolean;
    /**
     * Configure the destination endpoints for this location.
     */
    endpoints: outputs.GetZeroTrustDnsLocationsResultEndpoints;
    id: string;
    /**
     * Defines the automatically generated IPv6 destination IP assigned to this location. Gateway counts all DNS requests sent to this IP as requests under this location.
     */
    ip: string;
    /**
     * Show the primary destination IPv4 address from the pair identified dns*destination*ips_id. This field read-only.
     */
    ipv4Destination: string;
    /**
     * Show the backup destination IPv4 address from the pair identified dns*destination*ips_id. This field read-only.
     */
    ipv4DestinationBackup: string;
    /**
     * Specify the location name.
     */
    name: string;
    /**
     * Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultNetwork[];
    updatedAt: string;
}

export interface GetZeroTrustDnsLocationsResultEndpoints {
    doh: outputs.GetZeroTrustDnsLocationsResultEndpointsDoh;
    dot: outputs.GetZeroTrustDnsLocationsResultEndpointsDot;
    ipv4: outputs.GetZeroTrustDnsLocationsResultEndpointsIpv4;
    ipv6: outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6;
}

export interface GetZeroTrustDnsLocationsResultEndpointsDoh {
    /**
     * Indicate whether the DOH endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultEndpointsDohNetwork[];
    /**
     * Specify whether the DOH endpoint requires user identity authentication.
     */
    requireToken: boolean;
}

export interface GetZeroTrustDnsLocationsResultEndpointsDohNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResultEndpointsDot {
    /**
     * Indicate whether the DOT endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultEndpointsDotNetwork[];
}

export interface GetZeroTrustDnsLocationsResultEndpointsDotNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResultEndpointsIpv4 {
    /**
     * Indicate whether the IPv4 endpoint is enabled for this location.
     */
    enabled: boolean;
}

export interface GetZeroTrustDnsLocationsResultEndpointsIpv6 {
    /**
     * Indicate whether the IPV6 endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IPv6 network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6Network[];
}

export interface GetZeroTrustDnsLocationsResultEndpointsIpv6Network {
    /**
     * Specify the IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResultNetwork {
    /**
     * Specify the IPv4 address or IPv4 CIDR. Limit IPv4 CIDRs to a maximum of /24.
     */
    network: string;
}

export interface GetZeroTrustGatewayAppTypesListResult {
    /**
     * Identify the type of this application. Multiple applications can share the same type. Refers to the `id` of a returned application type.
     */
    applicationTypeId: number;
    createdAt: string;
    /**
     * Provide a short summary of applications with this type.
     */
    description: string;
    /**
     * Identify this application. Only one application per ID.
     */
    id: number;
    /**
     * Specify the name of the application or application type.
     */
    name: string;
}

export interface GetZeroTrustGatewayCategoriesListResult {
    /**
     * Indicate whether the category is in beta and subject to change.
     */
    beta: boolean;
    /**
     * Specify which account types can create policies for this category. `blocked` Blocks unconditionally for all accounts. `removalPending` Allows removal from policies but disables addition. `noBlock` Prevents blocking.
     * Available values: "free", "premium", "blocked", "removalPending", "noBlock".
     */
    class: string;
    /**
     * Provide a short summary of domains in the category.
     */
    description: string;
    /**
     * Identify this category. Only one category per ID.
     */
    id: number;
    /**
     * Specify the category name.
     */
    name: string;
    /**
     * Provide all subcategories for this category.
     */
    subcategories: outputs.GetZeroTrustGatewayCategoriesListResultSubcategory[];
}

export interface GetZeroTrustGatewayCategoriesListResultSubcategory {
    /**
     * Indicate whether the category is in beta and subject to change.
     */
    beta: boolean;
    /**
     * Specify which account types can create policies for this category. `blocked` Blocks unconditionally for all accounts. `removalPending` Allows removal from policies but disables addition. `noBlock` Prevents blocking.
     * Available values: "free", "premium", "blocked", "removalPending", "noBlock".
     */
    class: string;
    /**
     * Provide a short summary of domains in the category.
     */
    description: string;
    /**
     * Identify this category. Only one category per ID.
     */
    id: number;
    /**
     * Specify the category name.
     */
    name: string;
}

export interface GetZeroTrustGatewayCertificatesResult {
    /**
     * Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state.
     * Available values: "pending*deployment", "available", "pending*deletion", "inactive".
     */
    bindingStatus: string;
    /**
     * Provide the CA certificate (read-only).
     */
    certificate: string;
    createdAt: string;
    expiresOn: string;
    /**
     * Provide the SHA256 fingerprint of the certificate (read-only).
     */
    fingerprint: string;
    /**
     * Identify the certificate with a UUID.
     */
    id: string;
    /**
     * Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named `certificate` (read-only).
     */
    inUse: boolean;
    /**
     * Indicate the organization that issued the certificate (read-only).
     */
    issuerOrg: string;
    /**
     * Provide the entire issuer field of the certificate (read-only).
     */
    issuerRaw: string;
    /**
     * Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed.
     * Available values: "custom", "gatewayManaged".
     */
    type: string;
    updatedAt: string;
    uploadedOn: string;
}

export interface GetZeroTrustGatewayLoggingSettingsByRuleType {
    /**
     * Configure logging settings for DNS firewall.
     */
    dns: outputs.GetZeroTrustGatewayLoggingSettingsByRuleTypeDns;
    /**
     * Configure logging settings for HTTP/HTTPS firewall.
     */
    http: outputs.GetZeroTrustGatewayLoggingSettingsByRuleTypeHttp;
    /**
     * Configure logging settings for Network firewall.
     */
    l4: outputs.GetZeroTrustGatewayLoggingSettingsByRuleTypeL4;
}

export interface GetZeroTrustGatewayLoggingSettingsByRuleTypeDns {
    /**
     * Specify whether to log all requests to this service.
     */
    logAll: boolean;
    /**
     * Specify whether to log only blocking requests to this service.
     */
    logBlocks: boolean;
}

export interface GetZeroTrustGatewayLoggingSettingsByRuleTypeHttp {
    /**
     * Specify whether to log all requests to this service.
     */
    logAll: boolean;
    /**
     * Specify whether to log only blocking requests to this service.
     */
    logBlocks: boolean;
}

export interface GetZeroTrustGatewayLoggingSettingsByRuleTypeL4 {
    /**
     * Specify whether to log all requests to this service.
     */
    logAll: boolean;
    /**
     * Specify whether to log only blocking requests to this service.
     */
    logBlocks: boolean;
}

export interface GetZeroTrustGatewayPoliciesResult {
    /**
     * Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `true`.
     * Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4Override", "egress", "resolve", "quarantine", "redirect".
     */
    action: string;
    createdAt: string;
    /**
     * Indicate the date of deletion, if any.
     */
    deletedAt: string;
    /**
     * Specify the rule description.
     */
    description: string;
    devicePosture: string;
    /**
     * Specify whether the rule is enabled.
     */
    enabled: boolean;
    /**
     * Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `dns` rules.
     */
    expiration: outputs.GetZeroTrustGatewayPoliciesResultExpiration;
    /**
     * Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions.
     */
    filters: string[];
    /**
     * Identify the API resource with a UUID.
     */
    id: string;
    identity: string;
    /**
     * Specify the rule name.
     */
    name: string;
    precedence: number;
    /**
     * Indicate that this rule is shared via the Orgs API and read only.
     */
    readOnly: boolean;
    ruleSettings: outputs.GetZeroTrustGatewayPoliciesResultRuleSettings;
    /**
     * Defines the schedule for activating DNS policies. Settable only for `dns` and `dnsResolver` rules.
     */
    schedule: outputs.GetZeroTrustGatewayPoliciesResultSchedule;
    /**
     * Indicate that this rule is sharable via the Orgs API.
     */
    sharable: boolean;
    /**
     * Provide the account tag of the account that created the rule.
     */
    sourceAccount: string;
    traffic: string;
    updatedAt: string;
    /**
     * Indicate the version number of the rule(read-only).
     */
    version: number;
    /**
     * Indicate a warning for a misconfigured rule, if any.
     */
    warningStatus: string;
}

export interface GetZeroTrustGatewayPoliciesResultExpiration {
    /**
     * Defines the default duration a policy active in minutes. Must set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration: number;
    /**
     * Indicates whether the policy is expired.
     */
    expired: boolean;
    /**
     * Show the timestamp when the policy expires and stops applying.  The value must follow RFC 3339 and include a UTC offset.  The system accepts non-zero offsets but converts them to the equivalent UTC+00:00  value and returns timestamps with a trailing Z. Expiration policies ignore client  timezones and expire globally at the specified expiresAt time.
     */
    expiresAt: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettings {
    /**
     * Add custom headers to allowed requests as key-value pairs. Use header names as keys that map to arrays of header values. Settable only for `http` rules with the action set to `allow`.
     */
    addHeaders: {[key: string]: string[]};
    /**
     * Set to enable MSP children to bypass this rule. Only parent MSP accounts can set this. this rule. Settable for all types of rules.
     */
    allowChildBypass: boolean;
    /**
     * Define the settings for the Audit SSH action. Settable only for `l4` rules with `auditSsh` action.
     */
    auditSsh: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSsh;
    /**
     * Configure browser isolation behavior. Settable only for `http` rules with the action set to `isolate`.
     */
    bisoAdminControls: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControls;
    /**
     * Configure custom block page settings. If missing or null, use the account settings. Settable only for `http` rules with the action set to `block`.
     */
    blockPage: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsBlockPage;
    /**
     * Enable the custom block page. Settable only for `dns` rules with action `block`.
     */
    blockPageEnabled: boolean;
    /**
     * Explain why the rule blocks the request. The custom block page shows this text (if enabled). Settable only for `dns`, `l4`, and `http` rules when the action set to `block`.
     */
    blockReason: string;
    /**
     * Set to enable MSP accounts to bypass their parent's rules. Only MSP child accounts can set this. Settable for all types of rules.
     */
    bypassParentRule: boolean;
    /**
     * Configure session check behavior. Settable only for `l4` and `http` rules with the action set to `allow`.
     */
    checkSession: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSession;
    /**
     * Configure custom resolvers to route queries that match the resolver policy. Unused with 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' settings. DNS queries get routed to the address closest to their origin. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    dnsResolvers: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. Settable only for `egress` rules.
     */
    egress: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsEgress;
    /**
     * Ignore category matches at CNAME domains in a response. When off, evaluate categories in this rule against all CNAME domain categories in the response. Settable only for `dns` and `dnsResolver` rules.
     */
    ignoreCnameCategoryMatches: boolean;
    /**
     * Specify whether to disable DNSSEC validation (for Allow actions) [INSECURE]. Settable only for `dns` rules.
     */
    insecureDisableDnssecValidation: boolean;
    /**
     * Enable IPs in DNS resolver category blocks. The system blocks only domain name categories unless you enable this setting. Settable only for `dns` and `dnsResolver` rules.
     */
    ipCategories: boolean;
    /**
     * Indicates whether to include IPs in DNS resolver indicator feed blocks. Default, indicator feeds block only domain names. Settable only for `dns` and `dnsResolver` rules.
     */
    ipIndicatorFeeds: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port. Settable only for `l4` rules with the action set to `l4Override`.
     */
    l4override: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule matched. Settable for all types of rules with the action set to `block`.
     */
    notificationSettings: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettings;
    /**
     * Defines a hostname for override, for the matching DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideHost: string;
    /**
     * Defines a an IP or set of IPs for overriding matched DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideIps: string[];
    /**
     * Configure DLP payload logging. Settable only for `http` rules.
     */
    payloadLog: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLog;
    /**
     * Configure settings that apply to quarantine rules. Settable only for `http` rules.
     */
    quarantine: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantine;
    /**
     * Apply settings to redirect rules. Settable only for `http` rules with the action set to `redirect`.
     */
    redirect: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsRedirect;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Not used when 'dns*resolvers' is specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsInternally: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot set when 'dns*resolvers' specified or 'resolve*dns_internally' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsThroughCloudflare: boolean;
    /**
     * Configure behavior when an upstream certificate is invalid or an SSL error occurs. Settable only for `http` rules with the action set to `allow`.
     */
    untrustedCert: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCert;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSsh {
    /**
     * Enable SSH command logging.
     */
    commandLogging: boolean;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControls {
    /**
     * Configure copy behavior. If set to remote*only, users cannot copy isolated content from the remote browser to the local clipboard. If this field is absent, copying remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    copy: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk: boolean;
    /**
     * Configure download behavior. When set to remote*only, users can view downloads but cannot save them. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    download: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du: boolean;
    /**
     * Configure keyboard usage behavior. If this field is absent, keyboard usage remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    keyboard: string;
    /**
     * Configure paste behavior. If set to remote*only, users cannot paste content from the local clipboard into isolated pages. If this field is absent, pasting remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    paste: string;
    /**
     * Configure print behavior. Default, Printing is enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    printing: string;
    /**
     * Configure upload behavior. If this field is absent, uploading remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    upload: string;
    /**
     * Indicate which version of the browser isolation controls should apply.
     * Available values: "v1", "v2".
     */
    version: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsBlockPage {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSession {
    /**
     * Sets the required session freshness threshold. The API returns a normalized version of this value.
     */
    duration: string;
    /**
     * Enable session enforcement.
     */
    enforce: boolean;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolvers {
    ipv4s: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4[];
    ipv6s: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6[];
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4 {
    /**
     * Specify the IPv4 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6 {
    /**
     * Specify the IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsEgress {
    /**
     * Specify the IPv4 address to use for egress.
     */
    ipv4: string;
    /**
     * Specify the fallback IPv4 address to use for egress when the primary IPv4 fails. Set '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback: string;
    /**
     * Specify the IPv6 range to use for egress.
     */
    ipv6: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsL4override {
    /**
     * Defines the IPv4 or IPv6 address.
     */
    ip: string;
    /**
     * Defines a port number to use for TCP/UDP overrides.
     */
    port: number;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettings {
    /**
     * Enable notification.
     */
    enabled: boolean;
    /**
     * Indicates whether to pass the context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg: string;
    /**
     * Defines an optional URL to direct users to additional information. If unset, the notification opens a block page.
     */
    supportUrl: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLog {
    /**
     * Enable DLP payload logging for this rule.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantine {
    /**
     * Specify the types of files to sandbox.
     */
    fileTypes: string[];
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsRedirect {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Specify whether to append the path and query parameters from the original request to target_uri.
     */
    preservePathAndQuery: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternally {
    /**
     * Specify the fallback behavior to apply when the internal DNS response code differs from 'NOERROR' or when the response data contains only CNAME records for 'A' or 'AAAA' queries.
     * Available values: "none", "publicDns".
     */
    fallback: string;
    /**
     * Specify the internal DNS view identifier to pass to the internal DNS service.
     */
    viewId: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCert {
    /**
     * Defines the action performed when an untrusted certificate seen. The default action an error with HTTP code 526.
     * Available values: "passThrough", "block", "error".
     */
    action: string;
}

export interface GetZeroTrustGatewayPoliciesResultSchedule {
    fri: string;
    mon: string;
    sat: string;
    sun: string;
    thu: string;
    /**
     * Specify the time zone for rule evaluation. When a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway always uses the current time for that time zone. When this parameter is omitted, Gateway uses the time zone determined from the user's IP address. Colo time zone is used when the user's IP address does not resolve to a location.
     */
    timeZone: string;
    tue: string;
    wed: string;
}

export interface GetZeroTrustGatewayPolicyExpiration {
    /**
     * Defines the default duration a policy active in minutes. Must set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration: number;
    /**
     * Indicates whether the policy is expired.
     */
    expired: boolean;
    /**
     * Show the timestamp when the policy expires and stops applying.  The value must follow RFC 3339 and include a UTC offset.  The system accepts non-zero offsets but converts them to the equivalent UTC+00:00  value and returns timestamps with a trailing Z. Expiration policies ignore client  timezones and expire globally at the specified expiresAt time.
     */
    expiresAt: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettings {
    /**
     * Add custom headers to allowed requests as key-value pairs. Use header names as keys that map to arrays of header values. Settable only for `http` rules with the action set to `allow`.
     */
    addHeaders: {[key: string]: string[]};
    /**
     * Set to enable MSP children to bypass this rule. Only parent MSP accounts can set this. this rule. Settable for all types of rules.
     */
    allowChildBypass: boolean;
    /**
     * Define the settings for the Audit SSH action. Settable only for `l4` rules with `auditSsh` action.
     */
    auditSsh: outputs.GetZeroTrustGatewayPolicyRuleSettingsAuditSsh;
    /**
     * Configure browser isolation behavior. Settable only for `http` rules with the action set to `isolate`.
     */
    bisoAdminControls: outputs.GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControls;
    /**
     * Configure custom block page settings. If missing or null, use the account settings. Settable only for `http` rules with the action set to `block`.
     */
    blockPage: outputs.GetZeroTrustGatewayPolicyRuleSettingsBlockPage;
    /**
     * Enable the custom block page. Settable only for `dns` rules with action `block`.
     */
    blockPageEnabled: boolean;
    /**
     * Explain why the rule blocks the request. The custom block page shows this text (if enabled). Settable only for `dns`, `l4`, and `http` rules when the action set to `block`.
     */
    blockReason: string;
    /**
     * Set to enable MSP accounts to bypass their parent's rules. Only MSP child accounts can set this. Settable for all types of rules.
     */
    bypassParentRule: boolean;
    /**
     * Configure session check behavior. Settable only for `l4` and `http` rules with the action set to `allow`.
     */
    checkSession: outputs.GetZeroTrustGatewayPolicyRuleSettingsCheckSession;
    /**
     * Configure custom resolvers to route queries that match the resolver policy. Unused with 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' settings. DNS queries get routed to the address closest to their origin. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    dnsResolvers: outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. Settable only for `egress` rules.
     */
    egress: outputs.GetZeroTrustGatewayPolicyRuleSettingsEgress;
    /**
     * Ignore category matches at CNAME domains in a response. When off, evaluate categories in this rule against all CNAME domain categories in the response. Settable only for `dns` and `dnsResolver` rules.
     */
    ignoreCnameCategoryMatches: boolean;
    /**
     * Specify whether to disable DNSSEC validation (for Allow actions) [INSECURE]. Settable only for `dns` rules.
     */
    insecureDisableDnssecValidation: boolean;
    /**
     * Enable IPs in DNS resolver category blocks. The system blocks only domain name categories unless you enable this setting. Settable only for `dns` and `dnsResolver` rules.
     */
    ipCategories: boolean;
    /**
     * Indicates whether to include IPs in DNS resolver indicator feed blocks. Default, indicator feeds block only domain names. Settable only for `dns` and `dnsResolver` rules.
     */
    ipIndicatorFeeds: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port. Settable only for `l4` rules with the action set to `l4Override`.
     */
    l4override: outputs.GetZeroTrustGatewayPolicyRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule matched. Settable for all types of rules with the action set to `block`.
     */
    notificationSettings: outputs.GetZeroTrustGatewayPolicyRuleSettingsNotificationSettings;
    /**
     * Defines a hostname for override, for the matching DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideHost: string;
    /**
     * Defines a an IP or set of IPs for overriding matched DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideIps: string[];
    /**
     * Configure DLP payload logging. Settable only for `http` rules.
     */
    payloadLog: outputs.GetZeroTrustGatewayPolicyRuleSettingsPayloadLog;
    /**
     * Configure settings that apply to quarantine rules. Settable only for `http` rules.
     */
    quarantine: outputs.GetZeroTrustGatewayPolicyRuleSettingsQuarantine;
    /**
     * Apply settings to redirect rules. Settable only for `http` rules with the action set to `redirect`.
     */
    redirect: outputs.GetZeroTrustGatewayPolicyRuleSettingsRedirect;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Not used when 'dns*resolvers' is specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsInternally: outputs.GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot set when 'dns*resolvers' specified or 'resolve*dns_internally' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsThroughCloudflare: boolean;
    /**
     * Configure behavior when an upstream certificate is invalid or an SSL error occurs. Settable only for `http` rules with the action set to `allow`.
     */
    untrustedCert: outputs.GetZeroTrustGatewayPolicyRuleSettingsUntrustedCert;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsAuditSsh {
    /**
     * Enable SSH command logging.
     */
    commandLogging: boolean;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControls {
    /**
     * Configure copy behavior. If set to remote*only, users cannot copy isolated content from the remote browser to the local clipboard. If this field is absent, copying remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    copy: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk: boolean;
    /**
     * Configure download behavior. When set to remote*only, users can view downloads but cannot save them. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    download: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du: boolean;
    /**
     * Configure keyboard usage behavior. If this field is absent, keyboard usage remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    keyboard: string;
    /**
     * Configure paste behavior. If set to remote*only, users cannot paste content from the local clipboard into isolated pages. If this field is absent, pasting remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    paste: string;
    /**
     * Configure print behavior. Default, Printing is enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    printing: string;
    /**
     * Configure upload behavior. If this field is absent, uploading remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    upload: string;
    /**
     * Indicate which version of the browser isolation controls should apply.
     * Available values: "v1", "v2".
     */
    version: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsBlockPage {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsCheckSession {
    /**
     * Sets the required session freshness threshold. The API returns a normalized version of this value.
     */
    duration: string;
    /**
     * Enable session enforcement.
     */
    enforce: boolean;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsDnsResolvers {
    ipv4s: outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4[];
    ipv6s: outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6[];
}

export interface GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4 {
    /**
     * Specify the IPv4 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6 {
    /**
     * Specify the IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsEgress {
    /**
     * Specify the IPv4 address to use for egress.
     */
    ipv4: string;
    /**
     * Specify the fallback IPv4 address to use for egress when the primary IPv4 fails. Set '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback: string;
    /**
     * Specify the IPv6 range to use for egress.
     */
    ipv6: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsL4override {
    /**
     * Defines the IPv4 or IPv6 address.
     */
    ip: string;
    /**
     * Defines a port number to use for TCP/UDP overrides.
     */
    port: number;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsNotificationSettings {
    /**
     * Enable notification.
     */
    enabled: boolean;
    /**
     * Indicates whether to pass the context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg: string;
    /**
     * Defines an optional URL to direct users to additional information. If unset, the notification opens a block page.
     */
    supportUrl: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsPayloadLog {
    /**
     * Enable DLP payload logging for this rule.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsQuarantine {
    /**
     * Specify the types of files to sandbox.
     */
    fileTypes: string[];
}

export interface GetZeroTrustGatewayPolicyRuleSettingsRedirect {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Specify whether to append the path and query parameters from the original request to target_uri.
     */
    preservePathAndQuery: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally {
    /**
     * Specify the fallback behavior to apply when the internal DNS response code differs from 'NOERROR' or when the response data contains only CNAME records for 'A' or 'AAAA' queries.
     * Available values: "none", "publicDns".
     */
    fallback: string;
    /**
     * Specify the internal DNS view identifier to pass to the internal DNS service.
     */
    viewId: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsUntrustedCert {
    /**
     * Defines the action performed when an untrusted certificate seen. The default action an error with HTTP code 526.
     * Available values: "passThrough", "block", "error".
     */
    action: string;
}

export interface GetZeroTrustGatewayPolicySchedule {
    fri: string;
    mon: string;
    sat: string;
    sun: string;
    thu: string;
    /**
     * Specify the time zone for rule evaluation. When a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway always uses the current time for that time zone. When this parameter is omitted, Gateway uses the time zone determined from the user's IP address. Colo time zone is used when the user's IP address does not resolve to a location.
     */
    timeZone: string;
    tue: string;
    wed: string;
}

export interface GetZeroTrustGatewaySettingsSettings {
    /**
     * Specify activity log settings.
     */
    activityLog: outputs.GetZeroTrustGatewaySettingsSettingsActivityLog;
    /**
     * Specify anti-virus settings.
     */
    antivirus: outputs.GetZeroTrustGatewaySettingsSettingsAntivirus;
    /**
     * Specify block page layout settings.
     */
    blockPage: outputs.GetZeroTrustGatewaySettingsSettingsBlockPage;
    /**
     * Specify the DLP inspection mode.
     */
    bodyScanning: outputs.GetZeroTrustGatewaySettingsSettingsBodyScanning;
    /**
     * Specify Clientless Browser Isolation settings.
     */
    browserIsolation: outputs.GetZeroTrustGatewaySettingsSettingsBrowserIsolation;
    /**
     * Specify certificate settings for Gateway TLS interception. If unset, the Cloudflare Root CA handles interception.
     */
    certificate: outputs.GetZeroTrustGatewaySettingsSettingsCertificate;
    /**
     * Specify custom certificate settings for BYO-PKI. This field is deprecated; use `certificate` instead.
     *
     * @deprecated This attribute is deprecated.
     */
    customCertificate: outputs.GetZeroTrustGatewaySettingsSettingsCustomCertificate;
    /**
     * Specify user email settings for the firewall policies. When this is enabled, we standardize the email addresses in the identity part of the rule, so that they match the extended email variants in the firewall policies. When this setting is turned off, the email addresses in the identity part of the rule will be matched exactly as provided. If your email has `.` or `+` modifiers, you should enable this setting.
     */
    extendedEmailMatching: outputs.GetZeroTrustGatewaySettingsSettingsExtendedEmailMatching;
    /**
     * Specify FIPS settings.
     */
    fips: outputs.GetZeroTrustGatewaySettingsSettingsFips;
    /**
     * Enable host selection in egress policies.
     */
    hostSelector: outputs.GetZeroTrustGatewaySettingsSettingsHostSelector;
    /**
     * Define the proxy inspection mode.
     */
    inspection: outputs.GetZeroTrustGatewaySettingsSettingsInspection;
    /**
     * Specify whether to detect protocols from the initial bytes of client traffic.
     */
    protocolDetection: outputs.GetZeroTrustGatewaySettingsSettingsProtocolDetection;
    /**
     * Specify whether to enable the sandbox.
     */
    sandbox: outputs.GetZeroTrustGatewaySettingsSettingsSandbox;
    /**
     * Specify whether to inspect encrypted HTTP traffic.
     */
    tlsDecrypt: outputs.GetZeroTrustGatewaySettingsSettingsTlsDecrypt;
}

export interface GetZeroTrustGatewaySettingsSettingsActivityLog {
    /**
     * Specify whether to log activity.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsAntivirus {
    /**
     * Specify whether to enable anti-virus scanning on downloads.
     */
    enabledDownloadPhase: boolean;
    /**
     * Specify whether to enable anti-virus scanning on uploads.
     */
    enabledUploadPhase: boolean;
    /**
     * Specify whether to block requests for unscannable files.
     */
    failClosed: boolean;
    /**
     * Configure the message the user's device shows during an antivirus scan.
     */
    notificationSettings: outputs.GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings;
}

export interface GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings {
    /**
     * Specify whether to enable notifications.
     */
    enabled: boolean;
    /**
     * Specify whether to include context information as query parameters.
     */
    includeContext: boolean;
    /**
     * Specify the message to show in the notification.
     */
    msg: string;
    /**
     * Specify a URL that directs users to more information. If unset, the notification opens a block page.
     */
    supportUrl: string;
}

export interface GetZeroTrustGatewaySettingsSettingsBlockPage {
    /**
     * Specify the block page background color in `#rrggbb` format when the mode is customized*block*page.
     */
    backgroundColor: string;
    /**
     * Specify whether to enable the custom block page.
     */
    enabled: boolean;
    /**
     * Specify the block page footer text when the mode is customized*block*page.
     */
    footerText: string;
    /**
     * Specify the block page header text when the mode is customized*block*page.
     */
    headerText: string;
    /**
     * Specify whether to append context to target*uri as query parameters. This applies only when the mode is redirect*uri.
     */
    includeContext: boolean;
    /**
     * Specify the full URL to the logo file when the mode is customized*block*page.
     */
    logoPath: string;
    /**
     * Specify the admin email for users to contact when the mode is customized*block*page.
     */
    mailtoAddress: string;
    /**
     * Specify the subject line for emails created from the block page when the mode is customized*block*page.
     */
    mailtoSubject: string;
    /**
     * Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
     * Available values: "", "customized*block*page", "redirectUri".
     */
    mode: string;
    /**
     * Specify the block page title when the mode is customized*block*page.
     */
    name: string;
    /**
     * Indicate that this setting was shared via the Orgs API and read only for the current account.
     */
    readOnly: boolean;
    /**
     * Indicate the account tag of the account that shared this setting.
     */
    sourceAccount: string;
    /**
     * Specify whether to suppress detailed information at the bottom of the block page when the mode is customized*block*page.
     */
    suppressFooter: boolean;
    /**
     * Specify the URI to redirect users to when the mode is redirect_uri.
     */
    targetUri: string;
    /**
     * Indicate the version number of the setting.
     */
    version: number;
}

export interface GetZeroTrustGatewaySettingsSettingsBodyScanning {
    /**
     * Specify the inspection mode as either `deep` or `shallow`.
     * Available values: "deep", "shallow".
     */
    inspectionMode: string;
}

export interface GetZeroTrustGatewaySettingsSettingsBrowserIsolation {
    /**
     * Specify whether to enable non-identity onramp support for Browser Isolation.
     */
    nonIdentityEnabled: boolean;
    /**
     * Specify whether to enable Clientless Browser Isolation.
     */
    urlBrowserIsolationEnabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsCertificate {
    /**
     * Specify the UUID of the certificate used for interception. Ensure the certificate is available at the edge(previously called 'active'). A nil UUID directs Cloudflare to use the Root CA.
     */
    id: string;
}

export interface GetZeroTrustGatewaySettingsSettingsCustomCertificate {
    /**
     * Indicate the internal certificate status.
     */
    bindingStatus: string;
    /**
     * Specify whether to enable a custom certificate authority for signing Gateway traffic.
     */
    enabled: boolean;
    /**
     * Specify the UUID of the certificate (ID from MTLS certificate store).
     */
    id: string;
    updatedAt: string;
}

export interface GetZeroTrustGatewaySettingsSettingsExtendedEmailMatching {
    /**
     * Specify whether to match all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
     */
    enabled: boolean;
    /**
     * Indicate that this setting was shared via the Orgs API and read only for the current account.
     */
    readOnly: boolean;
    /**
     * Indicate the account tag of the account that shared this setting.
     */
    sourceAccount: string;
    /**
     * Indicate the version number of the setting.
     */
    version: number;
}

export interface GetZeroTrustGatewaySettingsSettingsFips {
    /**
     * Enforce cipher suites and TLS versions compliant with FIPS 140-2.
     */
    tls: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsHostSelector {
    /**
     * Specify whether to enable filtering via hosts for egress policies.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsInspection {
    /**
     * Define the proxy inspection mode.   1. static: Gateway applies static inspection to HTTP on TCP(80). With TLS decryption on, Gateway inspects HTTPS traffic on TCP(443) and UDP(443).   2. dynamic: Gateway applies protocol detection to inspect HTTP and HTTPS traffic on any port. TLS decryption must remain on to inspect HTTPS traffic.
     * Available values: "static", "dynamic".
     */
    mode: string;
}

export interface GetZeroTrustGatewaySettingsSettingsProtocolDetection {
    /**
     * Specify whether to detect protocols from the initial bytes of client traffic.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsSandbox {
    /**
     * Specify whether to enable the sandbox.
     */
    enabled: boolean;
    /**
     * Specify the action to take when the system cannot scan the file.
     * Available values: "allow", "block".
     */
    fallbackAction: string;
}

export interface GetZeroTrustGatewaySettingsSettingsTlsDecrypt {
    /**
     * Specify whether to inspect encrypted HTTP traffic.
     */
    enabled: boolean;
}

export interface GetZeroTrustListFilter {
    /**
     * Specify the list type.
     * Available values: "SERIAL", "URL", "DOMAIN", "EMAIL", "IP".
     */
    type?: string;
}

export interface GetZeroTrustListItem {
    createdAt: string;
    /**
     * Provide the list item description (optional).
     */
    description: string;
    /**
     * Specify the item value.
     */
    value: string;
}

export interface GetZeroTrustListsResult {
    createdAt: string;
    /**
     * Provide the list description.
     */
    description: string;
    /**
     * Identify the API resource with a UUID.
     */
    id: string;
    /**
     * Provide the list items.
     */
    items: outputs.GetZeroTrustListsResultItem[];
    /**
     * Indicate the number of items in the list.
     */
    listCount: number;
    /**
     * Specify the list name.
     */
    name: string;
    /**
     * Specify the list type.
     * Available values: "SERIAL", "URL", "DOMAIN", "EMAIL", "IP".
     */
    type: string;
    updatedAt: string;
}

export interface GetZeroTrustListsResultItem {
    createdAt: string;
    /**
     * Provide the list item description (optional).
     */
    description: string;
    /**
     * Specify the item value.
     */
    value: string;
}

export interface GetZeroTrustNetworkHostnameRouteFilter {
    /**
     * If set, only list hostname routes with the given comment.
     */
    comment?: string;
    /**
     * If provided, include only resources that were created (and not deleted) before this time. URL encoded.
     */
    existedAt?: string;
    /**
     * If set, only list hostname routes that contain a substring of the given value, the filter is case-insensitive.
     */
    hostname?: string;
    /**
     * The hostname route ID.
     */
    id?: string;
    /**
     * If `true`, only return deleted hostname routes. If `false`, exclude deleted hostname routes.
     */
    isDeleted: boolean;
    /**
     * If set, only list hostname routes that point to a specific tunnel.
     */
    tunnelId?: string;
}

export interface GetZeroTrustNetworkHostnameRoutesResult {
    /**
     * An optional description of the hostname route.
     */
    comment: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * The hostname of the route.
     */
    hostname: string;
    /**
     * The hostname route ID.
     */
    id: string;
    /**
     * UUID of the tunnel.
     */
    tunnelId: string;
    /**
     * A user-friendly name for a tunnel.
     */
    tunnelName: string;
}

export interface GetZeroTrustOrganizationCustomPages {
    /**
     * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
     */
    forbidden: string;
    /**
     * The uid of the custom page to use when a user is denied access.
     */
    identityDenied: string;
}

export interface GetZeroTrustOrganizationLoginDesign {
    /**
     * The background color on your login page.
     */
    backgroundColor: string;
    /**
     * The text at the bottom of your login page.
     */
    footerText: string;
    /**
     * The text at the top of your login page.
     */
    headerText: string;
    /**
     * The URL of the logo on your login page.
     */
    logoPath: string;
    /**
     * The text color on your login page.
     */
    textColor: string;
}

export interface GetZeroTrustRiskBehaviorBehaviors {
    description: string;
    enabled: boolean;
    name: string;
    /**
     * Available values: "low", "medium", "high".
     */
    riskLevel: string;
}

export interface GetZeroTrustRiskScoringIntegrationsResult {
    /**
     * The Cloudflare account tag.
     */
    accountTag: string;
    /**
     * Whether this integration is enabled and should export changes in risk score.
     */
    active: boolean;
    /**
     * When the integration was created in RFC3339 format.
     */
    createdAt: string;
    /**
     * The id of the integration, a UUIDv4.
     */
    id: string;
    /**
     * Available values: "Okta".
     */
    integrationType: string;
    /**
     * A reference ID defined by the client.
     * Should be set to the Access-Okta IDP integration ID.
     * Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that ID.
     */
    referenceId: string;
    /**
     * The base URL for the tenant. E.g. "https://tenant.okta.com".
     */
    tenantUrl: string;
    /**
     * The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration*uuid}/". https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1.
     */
    wellKnownUrl: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfig {
    /**
     * List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
     */
    ingresses: outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngress[];
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest: outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequest;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigIngress {
    /**
     * Public hostname for this service.
     */
    hostname: string;
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest: outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest;
    /**
     * Requests with this path route to this public hostname.
     */
    path: string;
    /**
     * Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
     */
    service: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access: outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout: number;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required: boolean;
    teamName: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access: outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout: number;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required: boolean;
    teamName: string;
}

export interface GetZeroTrustTunnelCloudflaredConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface GetZeroTrustTunnelCloudflaredFilter {
    excludePrefix?: string;
    /**
     * If provided, include only resources that were created (and not deleted) before this time. URL encoded.
     */
    existedAt?: string;
    includePrefix?: string;
    /**
     * If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
     */
    isDeleted?: boolean;
    /**
     * A user-friendly name for a tunnel.
     */
    name?: string;
    /**
     * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
     * Available values: "inactive", "degraded", "healthy", "down".
     */
    status?: string;
    /**
     * UUID of the tunnel.
     */
    uuid?: string;
    wasActiveAt?: string;
    wasInactiveAt?: string;
}

export interface GetZeroTrustTunnelCloudflaredRouteFilter {
    /**
     * Optional remark describing the route.
     */
    comment: string;
    /**
     * If provided, include only resources that were created (and not deleted) before this time. URL encoded.
     */
    existedAt?: string;
    /**
     * If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
     */
    isDeleted?: boolean;
    /**
     * If set, only list routes that are contained within this IP range.
     */
    networkSubset?: string;
    /**
     * If set, only list routes that contain this IP range.
     */
    networkSuperset?: string;
    /**
     * UUID of the route.
     */
    routeId?: string;
    /**
     * The types of tunnels to filter by, separated by commas.
     */
    tunTypes?: string[];
    /**
     * UUID of the tunnel.
     */
    tunnelId?: string;
    /**
     * UUID of the virtual network.
     */
    virtualNetworkId?: string;
}

export interface GetZeroTrustTunnelCloudflaredRoutesResult {
    /**
     * Optional remark describing the route.
     */
    comment: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the route.
     */
    id: string;
    /**
     * The private IPv4 or IPv6 range connected by the route, in CIDR notation.
     */
    network: string;
    /**
     * The type of tunnel.
     * Available values: "cfd*tunnel", "warp*connector", "warp", "magic", "ipSec", "gre", "cni".
     */
    tunType: string;
    /**
     * UUID of the tunnel.
     */
    tunnelId: string;
    /**
     * A user-friendly name for a tunnel.
     */
    tunnelName: string;
    /**
     * UUID of the virtual network.
     */
    virtualNetworkId: string;
    /**
     * A user-friendly name for the virtual network.
     */
    virtualNetworkName: string;
}

export interface GetZeroTrustTunnelCloudflaredVirtualNetworkFilter {
    /**
     * UUID of the virtual network.
     */
    id?: string;
    /**
     * If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
     */
    isDefault?: boolean;
    /**
     * If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
     */
    isDefaultNetwork?: boolean;
    /**
     * If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
     */
    isDeleted?: boolean;
    /**
     * A user-friendly name for the virtual network.
     */
    name?: string;
}

export interface GetZeroTrustTunnelCloudflaredVirtualNetworksResult {
    /**
     * Optional remark describing the virtual network.
     */
    comment: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the virtual network.
     */
    id: string;
    /**
     * If `true`, this virtual network is the default for the account.
     */
    isDefaultNetwork: boolean;
    /**
     * A user-friendly name for the virtual network.
     */
    name: string;
}

export interface GetZeroTrustTunnelCloudflaredsResult {
    /**
     * Cloudflare account ID
     */
    accountTag: string;
    /**
     * Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
     * Available values: "local", "cloudflare".
     */
    configSrc: string;
    /**
     * The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
     *
     * @deprecated This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections`
     */
    connections: outputs.GetZeroTrustTunnelCloudflaredsResultConnection[];
    /**
     * Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
     */
    connsActiveAt: string;
    /**
     * Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
     */
    connsInactiveAt: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the tunnel.
     */
    id: string;
    /**
     * Metadata associated with the tunnel.
     */
    metadata: string;
    /**
     * A user-friendly name for a tunnel.
     */
    name: string;
    /**
     * If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
     *
     * @deprecated Use the configSrc field instead.
     */
    remoteConfig: boolean;
    /**
     * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
     * Available values: "inactive", "degraded", "healthy", "down".
     */
    status: string;
    /**
     * The type of tunnel.
     * Available values: "cfd*tunnel", "warp*connector", "warp", "magic", "ipSec", "gre", "cni".
     */
    tunType: string;
}

export interface GetZeroTrustTunnelCloudflaredsResultConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface GetZeroTrustTunnelWarpConnectorConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface GetZeroTrustTunnelWarpConnectorFilter {
    excludePrefix?: string;
    /**
     * If provided, include only resources that were created (and not deleted) before this time. URL encoded.
     */
    existedAt?: string;
    includePrefix?: string;
    /**
     * If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
     */
    isDeleted?: boolean;
    /**
     * A user-friendly name for the tunnel.
     */
    name?: string;
    /**
     * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
     * Available values: "inactive", "degraded", "healthy", "down".
     */
    status?: string;
    /**
     * UUID of the tunnel.
     */
    uuid?: string;
    wasActiveAt?: string;
    wasInactiveAt?: string;
}

export interface GetZeroTrustTunnelWarpConnectorsResult {
    /**
     * Cloudflare account ID
     */
    accountTag: string;
    /**
     * Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
     * Available values: "local", "cloudflare".
     */
    configSrc: string;
    /**
     * The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
     *
     * @deprecated This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections`
     */
    connections: outputs.GetZeroTrustTunnelWarpConnectorsResultConnection[];
    /**
     * Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
     */
    connsActiveAt: string;
    /**
     * Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
     */
    connsInactiveAt: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the tunnel.
     */
    id: string;
    /**
     * Metadata associated with the tunnel.
     */
    metadata: string;
    /**
     * A user-friendly name for a tunnel.
     */
    name: string;
    /**
     * If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
     *
     * @deprecated Use the configSrc field instead.
     */
    remoteConfig: boolean;
    /**
     * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
     * Available values: "inactive", "degraded", "healthy", "down".
     */
    status: string;
    /**
     * The type of tunnel.
     * Available values: "cfd*tunnel", "warp*connector", "warp", "magic", "ipSec", "gre", "cni".
     */
    tunType: string;
}

export interface GetZeroTrustTunnelWarpConnectorsResultConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface GetZoneAccount {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the account.
     */
    name: string;
}

export interface GetZoneCacheVariantsValue {
    /**
     * List of strings with the MIME types of all the variants that should be served for avif.
     */
    avifs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for bmp.
     */
    bmps: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for gif.
     */
    gifs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jp2.
     */
    jp2s: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpeg.
     */
    jpegs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpg2.
     */
    jpg2s: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpg.
     */
    jpgs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for png.
     */
    pngs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for tiff.
     */
    tiffs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for tif.
     */
    tifs: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for webp.
     */
    webps: string[];
}

export interface GetZoneDnsSettingsInternalDns {
    /**
     * The ID of the zone to fallback to.
     */
    referenceZoneId: string;
}

export interface GetZoneDnsSettingsNameservers {
    /**
     * Configured nameserver set to be used for this zone
     */
    nsSet: number;
    /**
     * Nameserver type
     * Available values: "cloudflare.standard", "custom.account", "custom.tenant", "custom.zone".
     */
    type: string;
}

export interface GetZoneDnsSettingsSoa {
    /**
     * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
     */
    expire: number;
    /**
     * The time to live (TTL) for negative caching of records within the zone.
     */
    minTtl: number;
    /**
     * The primary nameserver, which may be used for outbound zone transfers. If null, a Cloudflare-assigned value will be used.
     */
    mname: string;
    /**
     * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
     */
    refresh: number;
    /**
     * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
     */
    retry: number;
    /**
     * The email address of the zone administrator, with the first label representing the local part of the email address.
     */
    rname: string;
    /**
     * The time to live (TTL) of the SOA record itself.
     */
    ttl: number;
}

export interface GetZoneFilter {
    account?: outputs.GetZoneFilterAccount;
    /**
     * Direction to order zones.
     * Available values: "asc", "desc".
     */
    direction?: string;
    /**
     * Whether to match all search requirements or at least one (any).
     * Available values: "any", "all".
     */
    match: string;
    /**
     * A domain name. Optional filter operators can be provided to extend refine the search:
     *   * `equal` (default)
     *   * `notEqual`
     *   * `startsWith`
     *   * `endsWith`
     *   * `contains`
     *   * `startsWithCaseSensitive`
     *   * `endsWithCaseSensitive`
     *   * `containsCaseSensitive`
     */
    name?: string;
    /**
     * Field to order zones by.
     * Available values: "name", "status", "account.id", "account.name", "plan.id".
     */
    order?: string;
    /**
     * Specify a zone status to filter by.
     * Available values: "initializing", "pending", "active", "moved".
     */
    status?: string;
}

export interface GetZoneFilterAccount {
    /**
     * Filter by an account ID.
     */
    id?: string;
    /**
     * An account Name. Optional filter operators can be provided to extend refine the search:
     *   * `equal` (default)
     *   * `notEqual`
     *   * `startsWith`
     *   * `endsWith`
     *   * `contains`
     *   * `startsWithCaseSensitive`
     *   * `endsWithCaseSensitive`
     *   * `containsCaseSensitive`
     */
    name?: string;
}

export interface GetZoneLockdownConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
     * Available values: "ip", "ipRange".
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetZoneLockdownFilter {
    /**
     * The timestamp of when the rule was created.
     */
    createdOn?: string;
    /**
     * A string to search for in the description of existing rules.
     */
    description?: string;
    /**
     * A string to search for in the description of existing rules.
     */
    descriptionSearch?: string;
    /**
     * A single IP address to search for in existing rules.
     */
    ip?: string;
    /**
     * A single IP address range to search for in existing rules.
     */
    ipRangeSearch?: string;
    /**
     * A single IP address to search for in existing rules.
     */
    ipSearch?: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    modifiedOn?: string;
    /**
     * The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
     */
    priority?: number;
    /**
     * A single URI to search for in the list of URLs of existing rules.
     */
    uriSearch?: string;
}

export interface GetZoneLockdownsResult {
    /**
     * A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
     */
    configurations: outputs.GetZoneLockdownsResultConfiguration[];
    /**
     * The timestamp of when the rule was created.
     */
    createdOn: string;
    /**
     * An informative summary of the rule.
     */
    description: string;
    /**
     * The unique identifier of the Zone Lockdown rule.
     */
    id: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    modifiedOn: string;
    /**
     * When true, indicates that the rule is currently paused.
     */
    paused: boolean;
    /**
     * The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
     */
    urls: string[];
}

export interface GetZoneLockdownsResultConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
     * Available values: "ip", "ipRange".
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetZoneMeta {
    /**
     * The zone is only configured for CDN.
     */
    cdnOnly: boolean;
    /**
     * Number of Custom Certificates the zone can have.
     */
    customCertificateQuota: number;
    /**
     * The zone is only configured for DNS.
     */
    dnsOnly: boolean;
    /**
     * The zone is setup with Foundation DNS.
     */
    foundationDns: boolean;
    /**
     * Number of Page Rules a zone can have.
     */
    pageRuleQuota: number;
    /**
     * The zone has been flagged for phishing.
     */
    phishingDetected: boolean;
    step: number;
}

export interface GetZoneOwner {
    /**
     * Identifier
     */
    id: string;
    /**
     * Name of the owner.
     */
    name: string;
    /**
     * The type of owner.
     */
    type: string;
}

export interface GetZonePlan {
    /**
     * States if the subscription can be activated.
     */
    canSubscribe: boolean;
    /**
     * The denomination of the customer.
     */
    currency: string;
    /**
     * If this Zone is managed by another company.
     */
    externallyManaged: boolean;
    /**
     * How often the customer is billed.
     */
    frequency: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * States if the subscription active.
     */
    isSubscribed: boolean;
    /**
     * If the legacy discount applies to this Zone.
     */
    legacyDiscount: boolean;
    /**
     * The legacy name of the plan.
     */
    legacyId: string;
    /**
     * Name of the owner.
     */
    name: string;
    /**
     * How much the customer is paying.
     */
    price: number;
}

export interface GetZoneSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged: boolean;
    /**
     * The ID of the rate plan.
     * Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partnersEnterprise".
     */
    id: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets: string[];
}

export interface GetZoneTenant {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the Tenant account.
     */
    name: string;
}

export interface GetZoneTenantUnit {
    /**
     * Identifier
     */
    id: string;
}

export interface GetZonesAccount {
    /**
     * Filter by an account ID.
     */
    id?: string;
    /**
     * An account Name. Optional filter operators can be provided to extend refine the search:
     *   * `equal` (default)
     *   * `notEqual`
     *   * `startsWith`
     *   * `endsWith`
     *   * `contains`
     *   * `startsWithCaseSensitive`
     *   * `endsWithCaseSensitive`
     *   * `containsCaseSensitive`
     */
    name?: string;
}

export interface GetZonesResult {
    /**
     * The account the zone belongs to.
     */
    account: outputs.GetZonesResultAccount;
    /**
     * The last time proof of ownership was detected and the zone was made
     * active.
     */
    activatedOn: string;
    /**
     * Allows the customer to use a custom apex.
     * *Tenants Only Configuration*.
     */
    cnameSuffix: string;
    /**
     * When the zone was created.
     */
    createdOn: string;
    /**
     * The interval (in seconds) from when development mode expires
     * (positive integer) or last expired (negative integer) for the
     * domain. If development mode has never been enabled, this value is 0.
     */
    developmentMode: number;
    /**
     * Identifier
     */
    id: string;
    /**
     * Metadata about the zone.
     */
    meta: outputs.GetZonesResultMeta;
    /**
     * When the zone was last modified.
     */
    modifiedOn: string;
    /**
     * The domain name.
     */
    name: string;
    /**
     * The name servers Cloudflare assigns to a zone.
     */
    nameServers: string[];
    /**
     * DNS host at the time of switching to Cloudflare.
     */
    originalDnshost: string;
    /**
     * Original name servers before moving to Cloudflare.
     */
    originalNameServers: string[];
    /**
     * Registrar for the domain at the time of switching to Cloudflare.
     */
    originalRegistrar: string;
    /**
     * The owner of the zone.
     */
    owner: outputs.GetZonesResultOwner;
    /**
     * Indicates whether the zone is only using Cloudflare DNS services. A
     * true value means the zone will not receive security or performance
     * benefits.
     */
    paused: boolean;
    /**
     * Legacy permissions based on legacy user membership information.
     *
     * @deprecated This has been replaced by Account memberships.
     */
    permissions: string[];
    /**
     * A Zones subscription information.
     *
     * @deprecated Please use the `/zones/{zone_id}/subscription` API
to update a zone's plan. Changing this value will create/cancel
associated subscriptions. To view available plans for this zone,
see [Zone Plans](https://developers.cloudflare.com/api/resources/zones/subresources/plans/).
     */
    plan: outputs.GetZonesResultPlan;
    /**
     * The zone status on Cloudflare.
     * Available values: "initializing", "pending", "active", "moved".
     */
    status: string;
    /**
     * The root organizational unit that this zone belongs to (such as a tenant or organization).
     */
    tenant: outputs.GetZonesResultTenant;
    /**
     * The immediate parent organizational unit that this zone belongs to (such as under a tenant or sub-organization).
     */
    tenantUnit: outputs.GetZonesResultTenantUnit;
    /**
     * A full zone implies that DNS is hosted with Cloudflare. A partial zone is
     * typically a partner-hosted zone or a CNAME setup.
     * Available values: "full", "partial", "secondary", "internal".
     */
    type: string;
    /**
     * An array of domains used for custom name servers. This is only available for Business and Enterprise plans.
     */
    vanityNameServers: string[];
    /**
     * Verification key for partial zone setup.
     */
    verificationKey: string;
}

export interface GetZonesResultAccount {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the account.
     */
    name: string;
}

export interface GetZonesResultMeta {
    /**
     * The zone is only configured for CDN.
     */
    cdnOnly: boolean;
    /**
     * Number of Custom Certificates the zone can have.
     */
    customCertificateQuota: number;
    /**
     * The zone is only configured for DNS.
     */
    dnsOnly: boolean;
    /**
     * The zone is setup with Foundation DNS.
     */
    foundationDns: boolean;
    /**
     * Number of Page Rules a zone can have.
     */
    pageRuleQuota: number;
    /**
     * The zone has been flagged for phishing.
     */
    phishingDetected: boolean;
    step: number;
}

export interface GetZonesResultOwner {
    /**
     * Identifier
     */
    id: string;
    /**
     * Name of the owner.
     */
    name: string;
    /**
     * The type of owner.
     */
    type: string;
}

export interface GetZonesResultPlan {
    /**
     * States if the subscription can be activated.
     */
    canSubscribe: boolean;
    /**
     * The denomination of the customer.
     */
    currency: string;
    /**
     * If this Zone is managed by another company.
     */
    externallyManaged: boolean;
    /**
     * How often the customer is billed.
     */
    frequency: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * States if the subscription active.
     */
    isSubscribed: boolean;
    /**
     * If the legacy discount applies to this Zone.
     */
    legacyDiscount: boolean;
    /**
     * The legacy name of the plan.
     */
    legacyId: string;
    /**
     * Name of the owner.
     */
    name: string;
    /**
     * How much the customer is paying.
     */
    price: number;
}

export interface GetZonesResultTenant {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the Tenant account.
     */
    name: string;
}

export interface GetZonesResultTenantUnit {
    /**
     * Identifier
     */
    id: string;
}

export interface HealthcheckHttpConfig {
    /**
     * Do not validate the certificate when the health check uses HTTPS.
     */
    allowInsecure: boolean;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
     */
    expectedBody?: string;
    /**
     * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
     */
    expectedCodes?: string[];
    /**
     * Follow redirects if the origin returns a 3xx status code.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
     */
    header?: {[key: string]: string[]};
    /**
     * The HTTP method to use for the health check.
     * Available values: "GET", "HEAD".
     */
    method: string;
    /**
     * The endpoint path to health check against.
     */
    path: string;
    /**
     * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
     */
    port: number;
}

export interface HealthcheckTcpConfig {
    /**
     * The TCP connection method to use for the health check.
     * Available values: "connectionEstablished".
     */
    method: string;
    /**
     * Port number to connect to for the health check. Defaults to 80.
     */
    port: number;
}

export interface HyperdriveConfigCaching {
    /**
     * Set to true to disable caching of SQL responses. Default is false.
     */
    disabled: boolean;
    /**
     * Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
     */
    maxAge?: number;
    /**
     * Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
     */
    staleWhileRevalidate?: number;
}

export interface HyperdriveConfigMtls {
    /**
     * Define CA certificate ID obtained after uploading CA cert.
     */
    caCertificateId?: string;
    /**
     * Define mTLS certificate ID obtained after uploading client cert.
     */
    mtlsCertificateId?: string;
    /**
     * Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
     */
    sslmode?: string;
}

export interface HyperdriveConfigOrigin {
    /**
     * Defines the Client ID of the Access token to use when connecting to the origin database.
     */
    accessClientId?: string;
    /**
     * Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
     */
    accessClientSecret?: string;
    /**
     * Set the name of your origin database.
     */
    database: string;
    /**
     * Defines the host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * Set the password needed to access your origin database. The API never returns this write-only value.
     */
    password: string;
    /**
     * Defines the port (default: 5432 for Postgres) of your origin database.
     */
    port?: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     * Available values: "postgres", "postgresql", "mysql".
     */
    scheme: string;
    /**
     * Set the user of your origin database.
     */
    user: string;
}

export interface ImageVariantOptions {
    /**
     * The fit property describes how the width and height dimensions should be interpreted.
     * Available values: "scale-down", "contain", "cover", "crop", "pad".
     */
    fit: string;
    /**
     * Maximum height in image pixels.
     */
    height: number;
    /**
     * What EXIF data should be preserved in the output image.
     * Available values: "keep", "copyright", "none".
     */
    metadata: string;
    /**
     * Maximum width in image pixels.
     */
    width: number;
}

export interface ImageVariantVariant {
    id: string;
    /**
     * Indicates whether the variant can access an image without a signature, regardless of image access control.
     */
    neverRequireSignedUrls: boolean;
    /**
     * Allows you to define image resizing sizes for different use cases.
     */
    options: outputs.ImageVariantVariantOptions;
}

export interface ImageVariantVariantOptions {
    /**
     * The fit property describes how the width and height dimensions should be interpreted.
     * Available values: "scale-down", "contain", "cover", "crop", "pad".
     */
    fit: string;
    /**
     * Maximum height in image pixels.
     */
    height: number;
    /**
     * What EXIF data should be preserved in the output image.
     * Available values: "keep", "copyright", "none".
     */
    metadata: string;
    /**
     * Maximum width in image pixels.
     */
    width: number;
}

export interface KeylessCertificateTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface ListItem {
    /**
     * A non-negative 32 bit integer
     */
    asn?: number;
    /**
     * An informative summary of the list item.
     */
    comment?: string;
    /**
     * Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
     */
    hostname?: outputs.ListItemHostname;
    /**
     * An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
     */
    ip?: string;
    /**
     * The definition of the redirect.
     */
    redirect?: outputs.ListItemRedirect;
}

export interface ListItemHostname {
    /**
     * Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
     */
    excludeExactHostname?: boolean;
    urlHostname: string;
}

export interface ListItemRedirect {
    includeSubdomains: boolean;
    preservePathSuffix: boolean;
    preserveQueryString: boolean;
    sourceUrl: string;
    /**
     * Available values: 301, 302, 307, 308.
     */
    statusCode: number;
    subpathMatching: boolean;
    targetUrl: string;
}

export interface LoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface LoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
     */
    defaultPercent: number;
    /**
     * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
     * Available values: "random", "hash".
     */
    defaultPolicy: string;
    /**
     * The percent of existing sessions to shed from the pool, according to the session policy.
     */
    sessionPercent: number;
    /**
     * Only the hash policy is supported for existing sessions (to avoid exponential decay).
     * Available values: "hash".
     */
    sessionPolicy: string;
}

export interface LoadBalancerPoolNotificationFilter {
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    origin: outputs.LoadBalancerPoolNotificationFilterOrigin;
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    pool: outputs.LoadBalancerPoolNotificationFilterPool;
}

export interface LoadBalancerPoolNotificationFilterOrigin {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy?: boolean;
}

export interface LoadBalancerPoolNotificationFilterPool {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy?: boolean;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
     */
    address?: string;
    /**
     * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled: boolean;
    /**
     * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
     */
    header?: outputs.LoadBalancerPoolOriginHeader;
    /**
     * A human-identifiable name for the origin.
     */
    name?: string;
    /**
     * The port for upstream connections. A value of 0 means the default port for the protocol will be used.
     */
    port: number;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId?: string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     */
    weight: number;
}

export interface LoadBalancerPoolOriginHeader {
    /**
     * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
     */
    hosts?: string[];
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * The type of origin steering policy to use.
     */
    policy: string;
}

export interface LoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRule {
    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixedResponse in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     */
    condition?: string;
    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     */
    disabled: boolean;
    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     */
    fixedResponse?: outputs.LoadBalancerRuleFixedResponse;
    /**
     * Name of this rule. Only used for human readability.
     */
    name?: string;
    /**
     * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
     */
    overrides: outputs.LoadBalancerRuleOverrides;
    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     */
    priority: number;
    /**
     * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
     */
    terminates?: boolean;
}

export interface LoadBalancerRuleFixedResponse {
    /**
     * The http 'Content-Type' header to include in the response.
     */
    contentType?: string;
    /**
     * The http 'Location' header to include in the response.
     */
    location?: string;
    /**
     * Text to include as the http body.
     */
    messageBody?: string;
    /**
     * The http status code to respond with.
     */
    statusCode?: number;
}

export interface LoadBalancerRuleOverrides {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.LoadBalancerRuleOverridesAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools?: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool?: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.LoadBalancerRuleOverridesLocationStrategy;
    /**
     * Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.LoadBalancerRuleOverridesRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ipCookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `sessionAffinityTtl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `sessionAffinityAttributes` for additional required configuration.
     * Available values: "none", "cookie", "ipCookie", "header".
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.LoadBalancerRuleOverridesSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are: - `"cookie"` / `"ipCookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface LoadBalancerRuleOverridesAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface LoadBalancerRuleOverridesLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface LoadBalancerRuleOverridesRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRuleOverridesSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers?: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     * Available values: "Auto", "Lax", "None", "Strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     * Available values: "Auto", "Always", "Never".
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
     * Available values: "none", "temporary", "sticky".
     */
    zeroDowntimeFailover: string;
}

export interface LoadBalancerSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers?: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     * Available values: "Auto", "Lax", "None", "Strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     * Available values: "Auto", "Always", "Never".
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
     * Available values: "none", "temporary", "sticky".
     */
    zeroDowntimeFailover: string;
}

export interface LogpushJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix?: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix?: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve202144228?: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter?: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames?: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     * Available values: "ndjson", "csv".
     */
    outputType?: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter?: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix?: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix?: string;
    /**
     * String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate?: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate?: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     * Available values: "unixnano", "unix", "rfc3339".
     */
    timestampFormat?: string;
}

export interface MagicNetworkMonitoringConfigurationWarpDevice {
    /**
     * Unique identifier for the warp device.
     */
    id: string;
    /**
     * Name of the warp device.
     */
    name: string;
    /**
     * IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
     */
    routerIp: string;
}

export interface MagicTransitConnectorDevice {
    id: string;
    serialNumber: string;
}

export interface MagicTransitSiteAclLan1 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName?: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges?: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports?: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets?: string[];
}

export interface MagicTransitSiteAclLan2 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName?: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges?: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports?: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets?: string[];
}

export interface MagicTransitSiteLanNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix?: string;
}

export interface MagicTransitSiteLanRoutedSubnet {
    nat?: outputs.MagicTransitSiteLanRoutedSubnetNat;
    /**
     * A valid IPv4 address.
     */
    nextHop: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    prefix: string;
}

export interface MagicTransitSiteLanRoutedSubnetNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix?: string;
}

export interface MagicTransitSiteLanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    dhcpRelay?: outputs.MagicTransitSiteLanStaticAddressingDhcpRelay;
    dhcpServer?: outputs.MagicTransitSiteLanStaticAddressingDhcpServer;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress?: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    virtualAddress?: string;
}

export interface MagicTransitSiteLanStaticAddressingDhcpRelay {
    /**
     * List of DHCP server IPs.
     */
    serverAddresses?: string[];
}

export interface MagicTransitSiteLanStaticAddressingDhcpServer {
    /**
     * A valid IPv4 address.
     */
    dhcpPoolEnd?: string;
    /**
     * A valid IPv4 address.
     */
    dhcpPoolStart?: string;
    /**
     * A valid IPv4 address.
     */
    dnsServer?: string;
    dnsServers?: string[];
    /**
     * Mapping of MAC addresses to IP addresses
     */
    reservations?: {[key: string]: string};
}

export interface MagicTransitSiteLocation {
    /**
     * Latitude
     */
    lat?: string;
    /**
     * Longitude
     */
    lon?: string;
}

export interface MagicTransitSiteWanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    /**
     * A valid IPv4 address.
     */
    gatewayAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress?: string;
}

export interface MagicWanGreTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     * Available values: "unidirectional", "bidirectional".
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     * Available values: "low", "mid", "high".
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanGreTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     * Available values: "reply", "request".
     */
    type: string;
}

export interface MagicWanGreTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved?: string;
}

export interface MagicWanIpsecTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     * Available values: "unidirectional", "bidirectional".
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     * Available values: "low", "mid", "high".
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanIpsecTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     * Available values: "reply", "request".
     */
    type: string;
}

export interface MagicWanIpsecTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved?: string;
}

export interface MagicWanIpsecTunnelPskMetadata {
    /**
     * The date and time the tunnel was last modified.
     */
    lastGeneratedOn: string;
}

export interface MagicWanStaticRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames?: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions?: string[];
}

export interface ManagedHeadersManagedRequestHeader {
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface ManagedHeadersManagedResponseHeader {
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface ManagedTransformsManagedRequestHeader {
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface ManagedTransformsManagedResponseHeader {
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface NotificationPolicyFilters {
    /**
     * Usage depends on specific alert type
     */
    actions?: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedAsns?: string[];
    /**
     * Used for configuring incident_alert
     */
    affectedComponents?: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedLocations?: string[];
    /**
     * Used for configuring maintenance*event*notification
     */
    airportCodes?: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferences?: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferencesValues?: string[];
    /**
     * Used for configuring load*balancing*pool*enablement*alert
     */
    enableds?: string[];
    /**
     * Used for configuring pages*event*alert
     */
    environments?: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    eventSources?: string[];
    /**
     * Usage depends on specific alert type
     */
    eventTypes?: string[];
    /**
     * Used for configuring pages*event*alert
     */
    events?: string[];
    /**
     * Usage depends on specific alert type
     */
    groupBies?: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    healthCheckIds?: string[];
    /**
     * Used for configuring incident_alert
     */
    incidentImpacts?: string[];
    /**
     * Used for configuring stream*live*notifications
     */
    inputIds?: string[];
    /**
     * Used for configuring security*insights*alert
     */
    insightClasses?: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    limits?: string[];
    /**
     * Used for configuring logo*match*alert
     */
    logoTags?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    megabitsPerSeconds?: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    newHealths?: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    newStatuses?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    packetsPerSeconds?: string[];
    /**
     * Usage depends on specific alert type
     */
    poolIds?: string[];
    /**
     * Usage depends on specific alert type
     */
    popNames?: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    products?: string[];
    /**
     * Used for configuring pages*event*alert
     */
    projectIds?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    protocols?: string[];
    /**
     * Usage depends on specific alert type
     */
    queryTags?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    requestsPerSeconds?: string[];
    /**
     * Usage depends on specific alert type
     */
    selectors?: string[];
    /**
     * Used for configuring clickhouse*alert*fw*ent*anomaly
     */
    services?: string[];
    /**
     * Usage depends on specific alert type
     */
    slos?: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    statuses?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetHostnames?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    targetIps?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetZoneNames?: string[];
    /**
     * Used for configuring traffic*anomalies*alert
     */
    trafficExclusions?: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    tunnelIds?: string[];
    /**
     * Usage depends on specific alert type
     */
    tunnelNames?: string[];
    /**
     * Usage depends on specific alert type
     */
    wheres?: string[];
    /**
     * Usage depends on specific alert type
     */
    zones?: string[];
}

export interface NotificationPolicyMechanisms {
    emails?: outputs.NotificationPolicyMechanismsEmail[];
    pagerduties?: outputs.NotificationPolicyMechanismsPagerduty[];
    webhooks?: outputs.NotificationPolicyMechanismsWebhook[];
}

export interface NotificationPolicyMechanismsEmail {
    /**
     * The email address
     */
    id?: string;
}

export interface NotificationPolicyMechanismsPagerduty {
    /**
     * UUID
     */
    id?: string;
}

export interface NotificationPolicyMechanismsWebhook {
    /**
     * UUID
     */
    id?: string;
}

export interface ObservatoryScheduledTestSchedule {
    /**
     * The frequency of the test.
     * Available values: "DAILY", "WEEKLY".
     */
    frequency: string;
    /**
     * A test region.
     * Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
     */
    region: string;
    /**
     * A URL.
     */
    url: string;
}

export interface ObservatoryScheduledTestTest {
    date: string;
    /**
     * The Lighthouse report.
     */
    desktopReport: outputs.ObservatoryScheduledTestTestDesktopReport;
    /**
     * UUID.
     */
    id: string;
    /**
     * The Lighthouse report.
     */
    mobileReport: outputs.ObservatoryScheduledTestTestMobileReport;
    /**
     * A test region with a label.
     */
    region: outputs.ObservatoryScheduledTestTestRegion;
    /**
     * The frequency of the test.
     * Available values: "DAILY", "WEEKLY".
     */
    scheduleFrequency: string;
    /**
     * A URL.
     */
    url: string;
}

export interface ObservatoryScheduledTestTestDesktopReport {
    /**
     * Cumulative Layout Shift.
     */
    cls: number;
    /**
     * The type of device.
     * Available values: "DESKTOP", "MOBILE".
     */
    deviceType: string;
    error: outputs.ObservatoryScheduledTestTestDesktopReportError;
    /**
     * First Contentful Paint.
     */
    fcp: number;
    /**
     * The URL to the full Lighthouse JSON report.
     */
    jsonReportUrl: string;
    /**
     * Largest Contentful Paint.
     */
    lcp: number;
    /**
     * The Lighthouse performance score.
     */
    performanceScore: number;
    /**
     * Speed Index.
     */
    si: number;
    /**
     * The state of the Lighthouse report.
     * Available values: "RUNNING", "COMPLETE", "FAILED".
     */
    state: string;
    /**
     * Total Blocking Time.
     */
    tbt: number;
    /**
     * Time To First Byte.
     */
    ttfb: number;
    /**
     * Time To Interactive.
     */
    tti: number;
}

export interface ObservatoryScheduledTestTestDesktopReportError {
    /**
     * The error code of the Lighthouse result.
     * Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
     */
    code: string;
    /**
     * Detailed error message.
     */
    detail: string;
    /**
     * The final URL displayed to the user.
     */
    finalDisplayedUrl: string;
}

export interface ObservatoryScheduledTestTestMobileReport {
    /**
     * Cumulative Layout Shift.
     */
    cls: number;
    /**
     * The type of device.
     * Available values: "DESKTOP", "MOBILE".
     */
    deviceType: string;
    error: outputs.ObservatoryScheduledTestTestMobileReportError;
    /**
     * First Contentful Paint.
     */
    fcp: number;
    /**
     * The URL to the full Lighthouse JSON report.
     */
    jsonReportUrl: string;
    /**
     * Largest Contentful Paint.
     */
    lcp: number;
    /**
     * The Lighthouse performance score.
     */
    performanceScore: number;
    /**
     * Speed Index.
     */
    si: number;
    /**
     * The state of the Lighthouse report.
     * Available values: "RUNNING", "COMPLETE", "FAILED".
     */
    state: string;
    /**
     * Total Blocking Time.
     */
    tbt: number;
    /**
     * Time To First Byte.
     */
    ttfb: number;
    /**
     * Time To Interactive.
     */
    tti: number;
}

export interface ObservatoryScheduledTestTestMobileReportError {
    /**
     * The error code of the Lighthouse result.
     * Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
     */
    code: string;
    /**
     * Detailed error message.
     */
    detail: string;
    /**
     * The final URL displayed to the user.
     */
    finalDisplayedUrl: string;
}

export interface ObservatoryScheduledTestTestRegion {
    label: string;
    /**
     * A test region.
     * Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
     */
    value: string;
}

export interface PageRuleActions {
    alwaysUseHttps?: boolean;
    automaticHttpsRewrites?: string;
    browserCacheTtl?: number;
    browserCheck?: string;
    bypassCacheOnCookie?: string;
    cacheByDeviceType?: string;
    cacheDeceptionArmor?: string;
    cacheKeyFields?: outputs.PageRuleActionsCacheKeyFields;
    cacheLevel?: string;
    cacheOnCookie?: string;
    cacheTtlByStatus?: {[key: string]: string};
    disableApps?: boolean;
    disablePerformance?: boolean;
    disableSecurity?: boolean;
    disableZaraz?: boolean;
    edgeCacheTtl?: number;
    emailObfuscation?: string;
    explicitCacheControl?: string;
    forwardingUrl?: outputs.PageRuleActionsForwardingUrl;
    hostHeaderOverride?: string;
    ipGeolocation?: string;
    mirage?: string;
    opportunisticEncryption?: string;
    originErrorPagePassThru?: string;
    polish?: string;
    resolveOverride?: string;
    respectStrongEtag?: string;
    responseBuffering?: string;
    rocketLoader?: string;
    securityLevel?: string;
    sortQueryStringForCache?: string;
    ssl?: string;
    trueClientIpHeader?: string;
    waf?: string;
}

export interface PageRuleActionsCacheKeyFields {
    cookie?: outputs.PageRuleActionsCacheKeyFieldsCookie;
    header?: outputs.PageRuleActionsCacheKeyFieldsHeader;
    host: outputs.PageRuleActionsCacheKeyFieldsHost;
    queryString?: outputs.PageRuleActionsCacheKeyFieldsQueryString;
    user: outputs.PageRuleActionsCacheKeyFieldsUser;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    checkPresences: string[];
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    checkPresences: string[];
    excludes: string[];
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHost {
    resolved: boolean;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    excludes: string[];
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsUser {
    deviceType: boolean;
    geo: boolean;
    lang: boolean;
}

export interface PageRuleActionsForwardingUrl {
    statusCode: number;
    url: string;
}

export interface PagesDomainValidationData {
    errorMessage: string;
    /**
     * Available values: "http", "txt".
     */
    method: string;
    /**
     * Available values: "initializing", "pending", "active", "deactivated", "error".
     */
    status: string;
    txtName: string;
    txtValue: string;
}

export interface PagesDomainVerificationData {
    errorMessage: string;
    /**
     * Available values: "pending", "active", "deactivated", "blocked", "error".
     */
    status: string;
}

export interface PagesProjectBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching?: boolean;
    /**
     * Command used to build project.
     */
    buildCommand?: string;
    /**
     * Output directory of the build.
     */
    destinationDir?: string;
    /**
     * Directory to run the command.
     */
    rootDir?: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag?: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken?: string;
}

export interface PagesProjectCanonicalDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.PagesProjectCanonicalDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.PagesProjectCanonicalDeploymentDeploymentTrigger;
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.PagesProjectCanonicalDeploymentEnvVars};
    /**
     * Type of deploy.
     * Available values: "preview", "production".
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.PagesProjectCanonicalDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.PagesProjectCanonicalDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.PagesProjectCanonicalDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface PagesProjectCanonicalDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface PagesProjectCanonicalDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.PagesProjectCanonicalDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     * Available values: "push", "adHoc".
     */
    type: string;
}

export interface PagesProjectCanonicalDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface PagesProjectCanonicalDeploymentEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectCanonicalDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface PagesProjectCanonicalDeploymentSource {
    config: outputs.PagesProjectCanonicalDeploymentSourceConfig;
    type: string;
}

export interface PagesProjectCanonicalDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface PagesProjectCanonicalDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface PagesProjectDeploymentConfigs {
    /**
     * Configs for preview deploys.
     */
    preview?: outputs.PagesProjectDeploymentConfigsPreview;
    /**
     * Configs for production deploys.
     */
    production?: outputs.PagesProjectDeploymentConfigsProduction;
}

export interface PagesProjectDeploymentConfigsPreview {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate?: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags?: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewD1Databases};
    /**
     * Durable Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces};
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement?: outputs.PagesProjectDeploymentConfigsPreviewPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewVectorizeBindings};
}

export interface PagesProjectDeploymentConfigsPreviewAiBindings {
    projectId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset?: string;
}

export interface PagesProjectDeploymentConfigsPreviewBrowsers {
}

export interface PagesProjectDeploymentConfigsPreviewD1Databases {
    /**
     * UUID of the D1 database.
     */
    id?: string;
}

export interface PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces {
    /**
     * ID of the Durable Object namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectDeploymentConfigsPreviewHyperdriveBindings {
    id?: string;
}

export interface PagesProjectDeploymentConfigsPreviewKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewMtlsCertificates {
    certificateId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement mode.
     */
    mode?: string;
}

export interface PagesProjectDeploymentConfigsPreviewQueueProducers {
    /**
     * Name of the Queue.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsPreviewR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction?: string;
    /**
     * Name of the R2 bucket.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsPreviewServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint?: string;
    /**
     * The Service environment.
     */
    environment?: string;
    /**
     * The Service name.
     */
    service?: string;
}

export interface PagesProjectDeploymentConfigsPreviewVectorizeBindings {
    indexName?: string;
}

export interface PagesProjectDeploymentConfigsProduction {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate?: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags?: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionD1Databases};
    /**
     * Durable Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionDurableObjectNamespaces};
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement?: outputs.PagesProjectDeploymentConfigsProductionPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionVectorizeBindings};
}

export interface PagesProjectDeploymentConfigsProductionAiBindings {
    projectId?: string;
}

export interface PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset?: string;
}

export interface PagesProjectDeploymentConfigsProductionBrowsers {
}

export interface PagesProjectDeploymentConfigsProductionD1Databases {
    /**
     * UUID of the D1 database.
     */
    id?: string;
}

export interface PagesProjectDeploymentConfigsProductionDurableObjectNamespaces {
    /**
     * ID of the Durable Object namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsProductionEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectDeploymentConfigsProductionHyperdriveBindings {
    id?: string;
}

export interface PagesProjectDeploymentConfigsProductionKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsProductionMtlsCertificates {
    certificateId?: string;
}

export interface PagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement mode.
     */
    mode?: string;
}

export interface PagesProjectDeploymentConfigsProductionQueueProducers {
    /**
     * Name of the Queue.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsProductionR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction?: string;
    /**
     * Name of the R2 bucket.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsProductionServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint?: string;
    /**
     * The Service environment.
     */
    environment?: string;
    /**
     * The Service name.
     */
    service?: string;
}

export interface PagesProjectDeploymentConfigsProductionVectorizeBindings {
    indexName?: string;
}

export interface PagesProjectLatestDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.PagesProjectLatestDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.PagesProjectLatestDeploymentDeploymentTrigger;
    /**
     * Environment variables used for builds and Pages Functions.
     */
    envVars: {[key: string]: outputs.PagesProjectLatestDeploymentEnvVars};
    /**
     * Type of deploy.
     * Available values: "preview", "production".
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.PagesProjectLatestDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.PagesProjectLatestDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.PagesProjectLatestDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface PagesProjectLatestDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface PagesProjectLatestDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.PagesProjectLatestDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     * Available values: "push", "adHoc".
     */
    type: string;
}

export interface PagesProjectLatestDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface PagesProjectLatestDeploymentEnvVars {
    /**
     * Available values: "plain*text", "secret*text".
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectLatestDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface PagesProjectLatestDeploymentSource {
    config: outputs.PagesProjectLatestDeploymentSourceConfig;
    type: string;
}

export interface PagesProjectLatestDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface PagesProjectLatestDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     * Available values: "queued", "initialize", "cloneRepo", "build", "deploy".
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     * Available values: "success", "idle", "active", "failure", "canceled".
     */
    status: string;
}

export interface PagesProjectSource {
    config?: outputs.PagesProjectSourceConfig;
    type?: string;
}

export interface PagesProjectSourceConfig {
    deploymentsEnabled?: boolean;
    owner?: string;
    pathExcludes?: string[];
    pathIncludes?: string[];
    prCommentsEnabled?: boolean;
    previewBranchExcludes?: string[];
    previewBranchIncludes?: string[];
    /**
     * Available values: "all", "none", "custom".
     */
    previewDeploymentSetting?: string;
    productionBranch?: string;
    productionDeploymentsEnabled?: boolean;
    repoName?: string;
}

export interface QueueConsumer {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.QueueConsumerSettings;
    /**
     * Available values: "worker", "httpPull".
     */
    type: string;
}

export interface QueueConsumerSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize?: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency?: number;
    /**
     * The maximum number of retries
     */
    maxRetries?: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs?: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay?: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs?: number;
}

export interface QueueProducer {
    bucketName: string;
    script: string;
    /**
     * Available values: "worker", "r2Bucket".
     */
    type: string;
}

export interface QueueSettings {
    /**
     * Number of seconds to delay delivery of all messages to consumers.
     */
    deliveryDelay: number;
    /**
     * Indicates if message delivery to consumers is currently paused.
     */
    deliveryPaused: boolean;
    /**
     * Number of seconds after which an unconsumed message will be delayed.
     */
    messageRetentionPeriod: number;
}

export interface R2BucketCorsRule {
    /**
     * Object specifying allowed origins, methods and headers for this CORS rule.
     */
    allowed: outputs.R2BucketCorsRuleAllowed;
    /**
     * Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
     */
    exposeHeaders?: string[];
    /**
     * Identifier for this rule.
     */
    id?: string;
    /**
     * Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
     */
    maxAgeSeconds?: number;
}

export interface R2BucketCorsRuleAllowed {
    /**
     * Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
     */
    headers?: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
     */
    methods: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
     */
    origins: string[];
}

export interface R2BucketEventNotificationRule {
    /**
     * Array of R2 object actions that will trigger notifications.
     */
    actions: string[];
    /**
     * A description that can be used to identify the event notification rule after creation.
     */
    description?: string;
    /**
     * Notifications will be sent only for objects with this prefix.
     */
    prefix?: string;
    /**
     * Notifications will be sent only for objects with this suffix.
     */
    suffix?: string;
}

export interface R2BucketLifecycleRule {
    /**
     * Transition to abort ongoing multipart uploads.
     */
    abortMultipartUploadsTransition?: outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransition;
    /**
     * Conditions that apply to all transitions of this rule.
     */
    conditions: outputs.R2BucketLifecycleRuleConditions;
    /**
     * Transition to delete objects.
     */
    deleteObjectsTransition?: outputs.R2BucketLifecycleRuleDeleteObjectsTransition;
    /**
     * Whether or not this rule is in effect.
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule.
     */
    id: string;
    /**
     * Transitions to change the storage class of objects.
     */
    storageClassTransitions?: outputs.R2BucketLifecycleRuleStorageClassTransition[];
}

export interface R2BucketLifecycleRuleAbortMultipartUploadsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition?: outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition;
}

export interface R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition {
    maxAge: number;
    /**
     * Available values: "Age".
     */
    type: string;
}

export interface R2BucketLifecycleRuleConditions {
    /**
     * Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
     */
    prefix: string;
}

export interface R2BucketLifecycleRuleDeleteObjectsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition?: outputs.R2BucketLifecycleRuleDeleteObjectsTransitionCondition;
}

export interface R2BucketLifecycleRuleDeleteObjectsTransitionCondition {
    date?: string;
    maxAge?: number;
    /**
     * Available values: "Age", "Date".
     */
    type: string;
}

export interface R2BucketLifecycleRuleStorageClassTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition: outputs.R2BucketLifecycleRuleStorageClassTransitionCondition;
    /**
     * Available values: "InfrequentAccess".
     */
    storageClass: string;
}

export interface R2BucketLifecycleRuleStorageClassTransitionCondition {
    date?: string;
    maxAge?: number;
    /**
     * Available values: "Age", "Date".
     */
    type: string;
}

export interface R2BucketLockRule {
    /**
     * Condition to apply a lock rule to an object for how long in seconds.
     */
    condition: outputs.R2BucketLockRuleCondition;
    /**
     * Whether or not this rule is in effect.
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule.
     */
    id: string;
    /**
     * Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
     */
    prefix?: string;
}

export interface R2BucketLockRuleCondition {
    date?: string;
    maxAgeSeconds?: number;
    /**
     * Available values: "Age", "Date", "Indefinite".
     */
    type: string;
}

export interface R2BucketSippyDestination {
    /**
     * ID of a Cloudflare API token.
     * This is the value labelled "Access Key ID" when creating an API.
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     */
    accessKeyId?: string;
    /**
     * Available values: "r2".
     */
    cloudProvider?: string;
    /**
     * Value of a Cloudflare API token.
     * This is the value labelled "Secret Access Key" when creating an API.
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     *
     * Sippy will use this token when writing objects to R2, so it is
     * best to scope this token to the bucket you're enabling Sippy for.
     */
    secretAccessKey?: string;
}

export interface R2BucketSippySource {
    /**
     * Access Key ID of an IAM credential (ideally scoped to a single S3 bucket).
     */
    accessKeyId?: string;
    /**
     * Name of the AWS S3 bucket.
     */
    bucket?: string;
    /**
     * Client email of an IAM credential (ideally scoped to a single GCS bucket).
     */
    clientEmail?: string;
    /**
     * Available values: "aws", "gcs".
     */
    cloudProvider?: string;
    /**
     * Private Key of an IAM credential (ideally scoped to a single GCS bucket).
     */
    privateKey?: string;
    /**
     * Name of the AWS availability zone.
     */
    region?: string;
    /**
     * Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket).
     */
    secretAccessKey?: string;
}

export interface R2CustomDomainStatus {
    /**
     * Ownership status of the domain.
     * Available values: "pending", "active", "deactivated", "blocked", "error", "unknown".
     */
    ownership: string;
    /**
     * SSL certificate status.
     * Available values: "initializing", "pending", "active", "deactivated", "error", "unknown".
     */
    ssl: string;
}

export interface RateLimitAction {
    /**
     * The action to perform.
     * Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
     */
    mode?: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response?: outputs.RateLimitActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout?: number;
}

export interface RateLimitActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body?: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType?: string;
}

export interface RateLimitBypass {
    /**
     * Available values: "url".
     */
    name: string;
    /**
     * The URL to bypass.
     */
    value: string;
}

export interface RateLimitMatch {
    headers?: outputs.RateLimitMatchHeader[];
    request?: outputs.RateLimitMatchRequest;
    response?: outputs.RateLimitMatchResponse;
}

export interface RateLimitMatchHeader {
    /**
     * The name of the response header to match.
     */
    name?: string;
    /**
     * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
     * Available values: "eq", "ne".
     */
    op?: string;
    /**
     * The value of the response header, which must match exactly.
     */
    value?: string;
}

export interface RateLimitMatchRequest {
    /**
     * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
     */
    methods?: string[];
    /**
     * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
     */
    schemes?: string[];
    /**
     * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
     */
    url?: string;
}

export interface RateLimitMatchResponse {
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
     */
    originTraffic?: boolean;
}

export interface RecordData {
    /**
     * Algorithm.
     */
    algorithm?: number;
    /**
     * Altitude of location in meters.
     */
    altitude?: number;
    /**
     * Certificate.
     */
    certificate?: string;
    /**
     * Digest.
     */
    digest?: string;
    /**
     * Digest Type.
     */
    digestType?: number;
    /**
     * Fingerprint.
     */
    fingerprint?: string;
    /**
     * Flags for the CAA record.
     */
    flags?: any;
    /**
     * Key Tag.
     */
    keyTag?: number;
    /**
     * Degrees of latitude.
     */
    latDegrees?: number;
    /**
     * Latitude direction.
     * Available values: "N", "S".
     */
    latDirection?: string;
    /**
     * Minutes of latitude.
     */
    latMinutes?: number;
    /**
     * Seconds of latitude.
     */
    latSeconds?: number;
    /**
     * Degrees of longitude.
     */
    longDegrees?: number;
    /**
     * Longitude direction.
     * Available values: "E", "W".
     */
    longDirection?: string;
    /**
     * Minutes of longitude.
     */
    longMinutes?: number;
    /**
     * Seconds of longitude.
     */
    longSeconds?: number;
    /**
     * Matching Type.
     */
    matchingType?: number;
    /**
     * Order.
     */
    order?: number;
    /**
     * The port of the service.
     */
    port?: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz?: number;
    /**
     * Vertical precision of location.
     */
    precisionVert?: number;
    /**
     * Preference.
     */
    preference?: number;
    /**
     * Priority.
     */
    priority?: number;
    /**
     * Protocol.
     */
    protocol?: number;
    /**
     * Public Key.
     */
    publicKey?: string;
    /**
     * Regex.
     */
    regex?: string;
    /**
     * Replacement.
     */
    replacement?: string;
    /**
     * Selector.
     */
    selector?: number;
    /**
     * Service.
     */
    service?: string;
    /**
     * Size of location in meters.
     */
    size?: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag?: string;
    /**
     * Target.
     */
    target?: string;
    /**
     * Type.
     */
    type?: number;
    /**
     * Usage.
     */
    usage?: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value?: string;
    /**
     * The record weight.
     */
    weight?: number;
}

export interface RecordSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface RiskBehaviorBehaviors {
    enabled: boolean;
    /**
     * Available values: "low", "medium", "high".
     */
    riskLevel: string;
}

export interface RulesetRule {
    /**
     * The action to perform when the rule matches.
     * Available values: "block", "challenge", "compress*response", "ddos*dynamic", "execute", "force*connection*close", "js*challenge", "log", "log*custom*field", "managed*challenge", "redirect", "rewrite", "route", "score", "serve*error", "set*cache*settings", "set*config", "skip".
     */
    action: string;
    /**
     * The parameters configuring the rule's action.
     */
    actionParameters: outputs.RulesetRuleActionParameters;
    /**
     * An informative description of the rule.
     */
    description: string;
    /**
     * Whether the rule should be executed.
     */
    enabled: boolean;
    /**
     * Configuration for exposed credential checking.
     */
    exposedCredentialCheck?: outputs.RulesetRuleExposedCredentialCheck;
    /**
     * The expression defining which traffic will match the rule.
     */
    expression: string;
    /**
     * The unique ID of the rule.
     */
    id: string;
    /**
     * An object configuring the rule's logging behavior.
     */
    logging: outputs.RulesetRuleLogging;
    /**
     * An object configuring the rule's rate limit behavior.
     */
    ratelimit?: outputs.RulesetRuleRatelimit;
    /**
     * The reference of the rule (the rule's ID by default).
     */
    ref: string;
}

export interface RulesetRuleActionParameters {
    /**
     * A list of additional ports that caching should be enabled on.
     */
    additionalCacheablePorts?: number[];
    /**
     * Custom order for compression algorithms.
     */
    algorithms?: outputs.RulesetRuleActionParametersAlgorithm[];
    /**
     * The name of a custom asset to serve as the response.
     */
    assetName?: string;
    /**
     * Whether to enable Automatic HTTPS Rewrites.
     */
    automaticHttpsRewrites?: boolean;
    /**
     * Which file extensions to minify automatically.
     */
    autominify?: outputs.RulesetRuleActionParametersAutominify;
    /**
     * Whether to enable Browser Integrity Check (BIC).
     */
    bic?: boolean;
    /**
     * How long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
     */
    browserTtl?: outputs.RulesetRuleActionParametersBrowserTtl;
    /**
     * Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
     */
    cache?: boolean;
    /**
     * Which components of the request are included in or excluded from the cache key Cloudflare uses to store the response in cache.
     */
    cacheKey?: outputs.RulesetRuleActionParametersCacheKey;
    /**
     * Settings to determine whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
     */
    cacheReserve?: outputs.RulesetRuleActionParametersCacheReserve;
    /**
     * The response content.
     */
    content?: string;
    /**
     * The content type header to set with the error response.
     * Available values: "application/json", "text/html", "text/plain", "text/xml".
     */
    contentType?: string;
    /**
     * The cookie fields to log.
     */
    cookieFields?: outputs.RulesetRuleActionParametersCookieField[];
    /**
     * Whether to disable Cloudflare Apps.
     */
    disableApps?: boolean;
    /**
     * Whether to disable Real User Monitoring (RUM).
     */
    disableRum?: boolean;
    /**
     * Whether to disable Zaraz.
     */
    disableZaraz?: boolean;
    /**
     * How long the Cloudflare edge network should cache the response.
     */
    edgeTtl?: outputs.RulesetRuleActionParametersEdgeTtl;
    /**
     * Whether to enable Email Obfuscation.
     */
    emailObfuscation?: boolean;
    /**
     * Whether to enable Cloudflare Fonts.
     */
    fonts?: boolean;
    /**
     * A redirect based on a bulk list lookup.
     */
    fromList?: outputs.RulesetRuleActionParametersFromList;
    /**
     * A redirect based on the request properties.
     */
    fromValue?: outputs.RulesetRuleActionParametersFromValue;
    /**
     * A map of headers to rewrite.
     */
    headers?: {[key: string]: outputs.RulesetRuleActionParametersHeaders};
    /**
     * A value to rewrite the HTTP host header to.
     */
    hostHeader?: string;
    /**
     * Whether to enable Hotlink Protection.
     */
    hotlinkProtection?: boolean;
    /**
     * The ID of the ruleset to execute.
     */
    id?: string;
    /**
     * A delta to change the score by, which can be either positive or negative.
     */
    increment?: number;
    /**
     * The configuration to use for matched data logging.
     */
    matchedData?: outputs.RulesetRuleActionParametersMatchedData;
    /**
     * Whether to enable Mirage.
     */
    mirage?: boolean;
    /**
     * Whether to enable Opportunistic Encryption.
     */
    opportunisticEncryption?: boolean;
    /**
     * An origin to route to.
     */
    origin?: outputs.RulesetRuleActionParametersOrigin;
    /**
     * Whether Cloudflare will aim to strictly adhere to RFC 7234.
     */
    originCacheControl?: boolean;
    /**
     * Whether to generate Cloudflare error pages for issues from the origin server.
     */
    originErrorPagePassthru?: boolean;
    /**
     * A set of overrides to apply to the target ruleset.
     */
    overrides?: outputs.RulesetRuleActionParametersOverrides;
    /**
     * A list of phases to skip the execution of. This option is incompatible with the rulesets option.
     * Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
     */
    phases?: string[];
    /**
     * The Polish level to configure.
     * Available values: "off", "lossless", "lossy", "webp".
     */
    polish?: string;
    /**
     * A list of legacy security products to skip the execution of.
     * Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
     */
    products?: string[];
    /**
     * The raw response fields to log.
     */
    rawResponseFields?: outputs.RulesetRuleActionParametersRawResponseField[];
    /**
     * A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
     */
    readTimeout?: number;
    /**
     * The raw request fields to log.
     */
    requestFields?: outputs.RulesetRuleActionParametersRequestField[];
    /**
     * Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
     */
    respectStrongEtags?: boolean;
    /**
     * The response to show when the block is applied.
     */
    response?: outputs.RulesetRuleActionParametersResponse;
    /**
     * The transformed response fields to log.
     */
    responseFields?: outputs.RulesetRuleActionParametersResponseField[];
    /**
     * Whether to enable Rocket Loader.
     */
    rocketLoader?: boolean;
    /**
     * A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
     */
    rules?: {[key: string]: string[]};
    /**
     * A ruleset to skip the execution of. This option is incompatible with the rulesets option.
     * Available values: "current".
     */
    ruleset?: string;
    /**
     * A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
     */
    rulesets?: string[];
    /**
     * The Security Level to configure.
     * Available values: "off", "essentially*off", "low", "medium", "high", "under*attack".
     */
    securityLevel?: string;
    /**
     * When to serve stale content from cache.
     */
    serveStale?: outputs.RulesetRuleActionParametersServeStale;
    /**
     * Whether to enable Server-Side Excludes.
     */
    serverSideExcludes?: boolean;
    /**
     * A Server Name Indication (SNI) override.
     */
    sni?: outputs.RulesetRuleActionParametersSni;
    /**
     * The SSL level to configure.
     * Available values: "off", "flexible", "full", "strict", "originPull".
     */
    ssl?: string;
    /**
     * The status code to use for the error.
     */
    statusCode?: number;
    /**
     * Whether to enable Signed Exchanges (SXG).
     */
    sxg?: boolean;
    /**
     * The transformed request fields to log.
     */
    transformedRequestFields?: outputs.RulesetRuleActionParametersTransformedRequestField[];
    /**
     * A URI rewrite.
     */
    uri?: outputs.RulesetRuleActionParametersUri;
}

export interface RulesetRuleActionParametersAlgorithm {
    /**
     * Name of the compression algorithm to enable.
     * Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
     */
    name?: string;
}

export interface RulesetRuleActionParametersAutominify {
    /**
     * Whether to minify CSS files.
     */
    css: boolean;
    /**
     * Whether to minify HTML files.
     */
    html: boolean;
    /**
     * Whether to minify JavaScript files.
     */
    js: boolean;
}

export interface RulesetRuleActionParametersBrowserTtl {
    /**
     * The browser TTL (in seconds) if you choose the "overrideOrigin" mode.
     */
    default?: number;
    /**
     * The browser TTL mode.
     * Available values: "respect*origin", "bypass*by*default", "override*origin", "bypass".
     */
    mode: string;
}

export interface RulesetRuleActionParametersCacheKey {
    /**
     * Whether to separate cached content based on the visitor's device type.
     */
    cacheByDeviceType?: boolean;
    /**
     * Whether to protect from web cache deception attacks, while allowing static assets to be cached.
     */
    cacheDeceptionArmor?: boolean;
    /**
     * Which components of the request are included or excluded from the cache key.
     */
    customKey?: outputs.RulesetRuleActionParametersCacheKeyCustomKey;
    /**
     * Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
     */
    ignoreQueryStringsOrder?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * Which cookies to include in the cache key.
     */
    cookie?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie;
    /**
     * Which headers to include in the cache key.
     */
    header?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader;
    /**
     * How to use the host in the cache key.
     */
    host?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost;
    /**
     * Which query string parameters to include in or exclude from the cache key.
     */
    queryString?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    /**
     * How to use characteristics of the request user agent in the cache key.
     */
    user?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
     */
    checkPresences?: string[];
    /**
     * A list of cookies to include in the cache key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * A list of headers to check for the presence of. The presence of these headers is included in the cache key.
     */
    checkPresences?: string[];
    /**
     * A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
     */
    contains?: {[key: string]: string[]};
    /**
     * Whether to exclude the origin header in the cache key.
     */
    excludeOrigin?: boolean;
    /**
     * A list of headers to include in the cache key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Whether to use the resolved host in the cache key.
     */
    resolved?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * Which query string parameters to exclude from the cache key.
     */
    exclude?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude;
    /**
     * Which query string parameters to include in the cache key.
     */
    include?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude {
    /**
     * Whether to exclude all query string parameters from the cache key.
     */
    all?: boolean;
    /**
     * A list of query string parameters to exclude from the cache key.
     */
    lists?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude {
    /**
     * Whether to include all query string parameters in the cache key.
     */
    all?: boolean;
    /**
     * A list of query string parameters to include in the cache key.
     */
    lists?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Whether to use the user agent's device type in the cache key.
     */
    deviceType?: boolean;
    /**
     * Whether to use the user agents's country in the cache key.
     */
    geo?: boolean;
    /**
     * Whether to use the user agent's language in the cache key.
     */
    lang?: boolean;
}

export interface RulesetRuleActionParametersCacheReserve {
    /**
     * Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
     */
    eligible: boolean;
    /**
     * The minimum file size eligible for storage in Cache Reserve.
     */
    minimumFileSize?: number;
}

export interface RulesetRuleActionParametersCookieField {
    /**
     * The name of the cookie.
     */
    name: string;
}

export interface RulesetRuleActionParametersEdgeTtl {
    /**
     * The edge TTL (in seconds) if you choose the "overrideOrigin" mode.
     */
    default?: number;
    /**
     * The edge TTL mode.
     * Available values: "respect*origin", "bypass*by*default", "override*origin".
     */
    mode: string;
    /**
     * A list of TTLs to apply to specific status codes or status code ranges.
     */
    statusCodeTtls?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * A single status code to apply the TTL to.
     */
    statusCode?: number;
    /**
     * A range of status codes to apply the TTL to.
     */
    statusCodeRange?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange;
    /**
     * The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
     */
    value: number;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * The lower bound of the range.
     */
    from?: number;
    /**
     * The upper bound of the range.
     */
    to?: number;
}

export interface RulesetRuleActionParametersFromList {
    /**
     * An expression that evaluates to the list lookup key.
     */
    key: string;
    /**
     * The name of the list to match against.
     */
    name: string;
}

export interface RulesetRuleActionParametersFromValue {
    /**
     * Whether to keep the query string of the original request.
     */
    preserveQueryString: boolean;
    /**
     * The status code to use for the redirect.
     */
    statusCode?: number;
    /**
     * A URL to redirect the request to.
     */
    targetUrl: outputs.RulesetRuleActionParametersFromValueTargetUrl;
}

export interface RulesetRuleActionParametersFromValueTargetUrl {
    /**
     * An expression that evaluates to a URL to redirect the request to.
     */
    expression?: string;
    /**
     * A URL to redirect the request to.
     */
    value?: string;
}

export interface RulesetRuleActionParametersHeaders {
    /**
     * An expression that evaluates to a value for the header.
     */
    expression?: string;
    /**
     * The operation to perform on the header.
     * Available values: "add", "set", "remove".
     */
    operation: string;
    /**
     * A static value for the header.
     */
    value?: string;
}

export interface RulesetRuleActionParametersMatchedData {
    /**
     * The public key to encrypt matched data logs with.
     */
    publicKey: string;
}

export interface RulesetRuleActionParametersOrigin {
    /**
     * A resolved host to route to.
     */
    host?: string;
    /**
     * A destination port to route to.
     */
    port?: number;
}

export interface RulesetRuleActionParametersOverrides {
    /**
     * An action to override all rules with. This option has lower precedence than rule and category overrides.
     */
    action?: string;
    /**
     * A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
     */
    categories?: outputs.RulesetRuleActionParametersOverridesCategory[];
    /**
     * Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
     */
    enabled?: boolean;
    /**
     * A list of rule-level overrides. This option has the highest precedence.
     */
    rules?: outputs.RulesetRuleActionParametersOverridesRule[];
    /**
     * A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
     * Available values: "default", "medium", "low", "eoff".
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersOverridesCategory {
    /**
     * The action to override rules in the category with.
     */
    action?: string;
    /**
     * The name of the category to override.
     */
    category: string;
    /**
     * Whether to enable execution of rules in the category.
     */
    enabled?: boolean;
    /**
     * The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
     * Available values: "default", "medium", "low", "eoff".
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersOverridesRule {
    /**
     * The action to override the rule with.
     */
    action?: string;
    /**
     * Whether to enable execution of the rule.
     */
    enabled?: boolean;
    /**
     * The ID of the rule to override.
     */
    id: string;
    /**
     * The score threshold to use for the rule.
     */
    scoreThreshold?: number;
    /**
     * The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
     * Available values: "default", "medium", "low", "eoff".
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersRawResponseField {
    /**
     * The name of the response header.
     */
    name: string;
    /**
     * Whether to log duplicate values of the same header.
     */
    preserveDuplicates: boolean;
}

export interface RulesetRuleActionParametersRequestField {
    /**
     * The name of the header.
     */
    name: string;
}

export interface RulesetRuleActionParametersResponse {
    /**
     * The content to return.
     */
    content: string;
    /**
     * The type of the content to return.
     */
    contentType: string;
    /**
     * The status code to return.
     */
    statusCode: number;
}

export interface RulesetRuleActionParametersResponseField {
    /**
     * The name of the response header.
     */
    name: string;
    /**
     * Whether to log duplicate values of the same header.
     */
    preserveDuplicates: boolean;
}

export interface RulesetRuleActionParametersServeStale {
    /**
     * Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
     */
    disableStaleWhileUpdating?: boolean;
}

export interface RulesetRuleActionParametersSni {
    /**
     * A value to override the SNI to.
     */
    value: string;
}

export interface RulesetRuleActionParametersTransformedRequestField {
    /**
     * The name of the header.
     */
    name: string;
}

export interface RulesetRuleActionParametersUri {
    /**
     * A URI path rewrite.
     */
    path?: outputs.RulesetRuleActionParametersUriPath;
    /**
     * A URI query rewrite.
     */
    query?: outputs.RulesetRuleActionParametersUriQuery;
}

export interface RulesetRuleActionParametersUriPath {
    /**
     * An expression that evaluates to a value to rewrite the URI path to.
     */
    expression?: string;
    /**
     * A value to rewrite the URI path to.
     */
    value?: string;
}

export interface RulesetRuleActionParametersUriQuery {
    /**
     * An expression that evaluates to a value to rewrite the URI query to.
     */
    expression?: string;
    /**
     * A value to rewrite the URI query to.
     */
    value?: string;
}

export interface RulesetRuleExposedCredentialCheck {
    /**
     * An expression that selects the password used in the credentials check.
     */
    passwordExpression: string;
    /**
     * An expression that selects the user ID used in the credentials check.
     */
    usernameExpression: string;
}

export interface RulesetRuleLogging {
    /**
     * Whether to generate a log when the rule matches.
     */
    enabled: boolean;
}

export interface RulesetRuleRatelimit {
    /**
     * Characteristics of the request on which the rate limit counter will be incremented.
     */
    characteristics: string[];
    /**
     * An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
     */
    countingExpression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     */
    mitigationTimeout: number;
    /**
     * Period in seconds over which the counter is being incremented.
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     */
    requestsPerPeriod?: number;
    /**
     * Whether counting is only performed when an origin is reached.
     */
    requestsToOrigin: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     */
    scorePerPeriod?: number;
    /**
     * A response header name provided by the origin, which contains the score to increment rate limit counter with.
     */
    scoreResponseHeaderName?: string;
}

export interface SnippetFile {
    content: string;
    name: string;
}

export interface SnippetMetadata {
    /**
     * Name of the file that contains the main module of the snippet.
     */
    mainModule: string;
}

export interface SnippetRulesRule {
    /**
     * An informative description of the rule.
     */
    description: string;
    /**
     * Whether the rule should be executed.
     */
    enabled: boolean;
    /**
     * The expression defining which traffic will match the rule.
     */
    expression: string;
    /**
     * The unique ID of the rule.
     */
    id: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    lastUpdated: string;
    /**
     * The identifying name of the snippet.
     */
    snippetName: string;
}

export interface SnippetsMetadata {
    /**
     * Name of the file that contains the main module of the snippet.
     */
    mainModule: string;
}

export interface SpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name?: string;
    /**
     * The type of DNS record associated with the application.
     * Available values: "CNAME", "ADDRESS".
     */
    type?: string;
}

export interface SpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs.
     * Available values: "all", "ipv4", "ipv6".
     */
    connectivity?: string;
    /**
     * The array of customer owned IPs we broadcast via anycast for this hostname and application.
     */
    ips?: string[];
    /**
     * The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
     * Available values: "dynamic", "static".
     */
    type?: string;
}

export interface SpectrumApplicationOriginDns {
    /**
     * The name of the DNS record associated with the origin.
     */
    name?: string;
    /**
     * The TTL of our resolution of your DNS record in seconds.
     */
    ttl?: number;
    /**
     * The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
     * Available values: "", "A", "AAAA", "SRV".
     */
    type?: string;
}

export interface StaticRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames?: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions?: string[];
}

export interface StreamInput {
    /**
     * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
     */
    height: number;
    /**
     * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
     */
    width: number;
}

export interface StreamLiveInputRecording {
    /**
     * Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
     */
    allowedOrigins?: string[];
    /**
     * Disables reporting the number of live viewers when this property is set to `true`.
     */
    hideLiveViewerCount: boolean;
    /**
     * Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
     * Available values: "off", "automatic".
     */
    mode: string;
    /**
     * Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
     */
    requireSignedUrls: boolean;
    /**
     * Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
     */
    timeoutSeconds: number;
}

export interface StreamLiveInputRtmps {
    /**
     * The secret key to use when streaming via RTMPS to a live input.
     */
    streamKey: string;
    /**
     * The RTMPS URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface StreamLiveInputRtmpsPlayback {
    /**
     * The secret key to use for playback via RTMPS.
     */
    streamKey: string;
    /**
     * The URL used to play live video over RTMPS.
     */
    url: string;
}

export interface StreamLiveInputSrt {
    /**
     * The secret key to use when streaming via SRT to a live input.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use when streaming via SRT.
     */
    streamId: string;
    /**
     * The SRT URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface StreamLiveInputSrtPlayback {
    /**
     * The secret key to use for playback via SRT.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use for playback via SRT.
     */
    streamId: string;
    /**
     * The URL used to play live video over SRT.
     */
    url: string;
}

export interface StreamLiveInputWebRtc {
    /**
     * The WebRTC URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface StreamLiveInputWebRtcPlayback {
    /**
     * The URL used to play live video over WebRTC.
     */
    url: string;
}

export interface StreamPlayback {
    /**
     * DASH Media Presentation Description for the video.
     */
    dash: string;
    /**
     * The HLS manifest for the video.
     */
    hls: string;
}

export interface StreamStatus {
    /**
     * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
     */
    errorReasonCode: string;
    /**
     * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
     */
    errorReasonText: string;
    /**
     * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
     */
    pctComplete: string;
    /**
     * Specifies the processing status for all quality levels for a video.
     * Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
     */
    state: string;
}

export interface StreamWatermark {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface TeamsAccountSettings {
    /**
     * Specify activity log settings.
     */
    activityLog?: outputs.TeamsAccountSettingsActivityLog;
    /**
     * Specify anti-virus settings.
     */
    antivirus?: outputs.TeamsAccountSettingsAntivirus;
    /**
     * Specify block page layout settings.
     */
    blockPage?: outputs.TeamsAccountSettingsBlockPage;
    /**
     * Specify the DLP inspection mode.
     */
    bodyScanning?: outputs.TeamsAccountSettingsBodyScanning;
    /**
     * Specify Clientless Browser Isolation settings.
     */
    browserIsolation?: outputs.TeamsAccountSettingsBrowserIsolation;
    /**
     * Specify certificate settings for Gateway TLS interception. If unset, the Cloudflare Root CA handles interception.
     */
    certificate?: outputs.TeamsAccountSettingsCertificate;
    /**
     * Specify custom certificate settings for BYO-PKI. This field is deprecated; use `certificate` instead.
     *
     * @deprecated This attribute is deprecated.
     */
    customCertificate?: outputs.TeamsAccountSettingsCustomCertificate;
    /**
     * Specify user email settings for the firewall policies. When this is enabled, we standardize the email addresses in the identity part of the rule, so that they match the extended email variants in the firewall policies. When this setting is turned off, the email addresses in the identity part of the rule will be matched exactly as provided. If your email has `.` or `+` modifiers, you should enable this setting.
     */
    extendedEmailMatching?: outputs.TeamsAccountSettingsExtendedEmailMatching;
    /**
     * Specify FIPS settings.
     */
    fips?: outputs.TeamsAccountSettingsFips;
    /**
     * Enable host selection in egress policies.
     */
    hostSelector?: outputs.TeamsAccountSettingsHostSelector;
    /**
     * Define the proxy inspection mode.
     */
    inspection?: outputs.TeamsAccountSettingsInspection;
    /**
     * Specify whether to detect protocols from the initial bytes of client traffic.
     */
    protocolDetection?: outputs.TeamsAccountSettingsProtocolDetection;
    /**
     * Specify whether to enable the sandbox.
     */
    sandbox?: outputs.TeamsAccountSettingsSandbox;
    /**
     * Specify whether to inspect encrypted HTTP traffic.
     */
    tlsDecrypt?: outputs.TeamsAccountSettingsTlsDecrypt;
}

export interface TeamsAccountSettingsActivityLog {
    /**
     * Specify whether to log activity.
     */
    enabled?: boolean;
}

export interface TeamsAccountSettingsAntivirus {
    /**
     * Specify whether to enable anti-virus scanning on downloads.
     */
    enabledDownloadPhase: boolean;
    /**
     * Specify whether to enable anti-virus scanning on uploads.
     */
    enabledUploadPhase: boolean;
    /**
     * Specify whether to block requests for unscannable files.
     */
    failClosed: boolean;
    /**
     * Configure the message the user's device shows during an antivirus scan.
     */
    notificationSettings: outputs.TeamsAccountSettingsAntivirusNotificationSettings;
}

export interface TeamsAccountSettingsAntivirusNotificationSettings {
    /**
     * Specify whether to enable notifications.
     */
    enabled?: boolean;
    /**
     * Specify whether to include context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Specify the message to show in the notification.
     */
    msg?: string;
    /**
     * Specify a URL that directs users to more information. If unset, the notification opens a block page.
     */
    supportUrl?: string;
}

export interface TeamsAccountSettingsBlockPage {
    /**
     * Specify the block page background color in `#rrggbb` format when the mode is customized*block*page.
     */
    backgroundColor?: string;
    /**
     * Specify whether to enable the custom block page.
     */
    enabled?: boolean;
    /**
     * Specify the block page footer text when the mode is customized*block*page.
     */
    footerText?: string;
    /**
     * Specify the block page header text when the mode is customized*block*page.
     */
    headerText?: string;
    /**
     * Specify whether to append context to target*uri as query parameters. This applies only when the mode is redirect*uri.
     */
    includeContext?: boolean;
    /**
     * Specify the full URL to the logo file when the mode is customized*block*page.
     */
    logoPath?: string;
    /**
     * Specify the admin email for users to contact when the mode is customized*block*page.
     */
    mailtoAddress?: string;
    /**
     * Specify the subject line for emails created from the block page when the mode is customized*block*page.
     */
    mailtoSubject?: string;
    /**
     * Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
     * Available values: "", "customized*block*page", "redirectUri".
     */
    mode?: string;
    /**
     * Specify the block page title when the mode is customized*block*page.
     */
    name?: string;
    /**
     * Indicate that this setting was shared via the Orgs API and read only for the current account.
     */
    readOnly: boolean;
    /**
     * Indicate the account tag of the account that shared this setting.
     */
    sourceAccount: string;
    /**
     * Specify whether to suppress detailed information at the bottom of the block page when the mode is customized*block*page.
     */
    suppressFooter?: boolean;
    /**
     * Specify the URI to redirect users to when the mode is redirect_uri.
     */
    targetUri?: string;
    /**
     * Indicate the version number of the setting.
     */
    version: number;
}

export interface TeamsAccountSettingsBodyScanning {
    /**
     * Specify the inspection mode as either `deep` or `shallow`.
     * Available values: "deep", "shallow".
     */
    inspectionMode?: string;
}

export interface TeamsAccountSettingsBrowserIsolation {
    /**
     * Specify whether to enable non-identity onramp support for Browser Isolation.
     */
    nonIdentityEnabled?: boolean;
    /**
     * Specify whether to enable Clientless Browser Isolation.
     */
    urlBrowserIsolationEnabled?: boolean;
}

export interface TeamsAccountSettingsCertificate {
    /**
     * Specify the UUID of the certificate used for interception. Ensure the certificate is available at the edge(previously called 'active'). A nil UUID directs Cloudflare to use the Root CA.
     */
    id: string;
}

export interface TeamsAccountSettingsCustomCertificate {
    /**
     * Indicate the internal certificate status.
     */
    bindingStatus: string;
    /**
     * Specify whether to enable a custom certificate authority for signing Gateway traffic.
     */
    enabled: boolean;
    /**
     * Specify the UUID of the certificate (ID from MTLS certificate store).
     */
    id?: string;
    updatedAt: string;
}

export interface TeamsAccountSettingsExtendedEmailMatching {
    /**
     * Specify whether to match all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
     */
    enabled?: boolean;
    /**
     * Indicate that this setting was shared via the Orgs API and read only for the current account.
     */
    readOnly: boolean;
    /**
     * Indicate the account tag of the account that shared this setting.
     */
    sourceAccount: string;
    /**
     * Indicate the version number of the setting.
     */
    version: number;
}

export interface TeamsAccountSettingsFips {
    /**
     * Enforce cipher suites and TLS versions compliant with FIPS 140-2.
     */
    tls?: boolean;
}

export interface TeamsAccountSettingsHostSelector {
    /**
     * Specify whether to enable filtering via hosts for egress policies.
     */
    enabled?: boolean;
}

export interface TeamsAccountSettingsInspection {
    /**
     * Define the proxy inspection mode.   1. static: Gateway applies static inspection to HTTP on TCP(80). With TLS decryption on, Gateway inspects HTTPS traffic on TCP(443) and UDP(443).   2. dynamic: Gateway applies protocol detection to inspect HTTP and HTTPS traffic on any port. TLS decryption must remain on to inspect HTTPS traffic.
     * Available values: "static", "dynamic".
     */
    mode?: string;
}

export interface TeamsAccountSettingsProtocolDetection {
    /**
     * Specify whether to detect protocols from the initial bytes of client traffic.
     */
    enabled?: boolean;
}

export interface TeamsAccountSettingsSandbox {
    /**
     * Specify whether to enable the sandbox.
     */
    enabled?: boolean;
    /**
     * Specify the action to take when the system cannot scan the file.
     * Available values: "allow", "block".
     */
    fallbackAction?: string;
}

export interface TeamsAccountSettingsTlsDecrypt {
    /**
     * Specify whether to inspect encrypted HTTP traffic.
     */
    enabled?: boolean;
}

export interface TeamsListItem {
    /**
     * Provide the list item description (optional).
     */
    description?: string;
    /**
     * Specify the item value.
     */
    value?: string;
}

export interface TeamsLocationEndpoints {
    doh: outputs.TeamsLocationEndpointsDoh;
    dot: outputs.TeamsLocationEndpointsDot;
    ipv4: outputs.TeamsLocationEndpointsIpv4;
    ipv6: outputs.TeamsLocationEndpointsIpv6;
}

export interface TeamsLocationEndpointsDoh {
    /**
     * Indicate whether the DOH endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.TeamsLocationEndpointsDohNetwork[];
    /**
     * Specify whether the DOH endpoint requires user identity authentication.
     */
    requireToken: boolean;
}

export interface TeamsLocationEndpointsDohNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface TeamsLocationEndpointsDot {
    /**
     * Indicate whether the DOT endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.TeamsLocationEndpointsDotNetwork[];
}

export interface TeamsLocationEndpointsDotNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface TeamsLocationEndpointsIpv4 {
    /**
     * Indicate whether the IPv4 endpoint is enabled for this location.
     */
    enabled: boolean;
}

export interface TeamsLocationEndpointsIpv6 {
    /**
     * Indicate whether the IPV6 endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IPv6 network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.TeamsLocationEndpointsIpv6Network[];
}

export interface TeamsLocationEndpointsIpv6Network {
    /**
     * Specify the IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface TeamsLocationNetwork {
    /**
     * Specify the IPv4 address or IPv4 CIDR. Limit IPv4 CIDRs to a maximum of /24.
     */
    network: string;
}

export interface TeamsRuleExpiration {
    /**
     * Defines the default duration a policy active in minutes. Must set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration?: number;
    /**
     * Indicates whether the policy is expired.
     */
    expired: boolean;
    /**
     * Show the timestamp when the policy expires and stops applying.  The value must follow RFC 3339 and include a UTC offset.  The system accepts non-zero offsets but converts them to the equivalent UTC+00:00  value and returns timestamps with a trailing Z. Expiration policies ignore client  timezones and expire globally at the specified expiresAt time.
     */
    expiresAt: string;
}

export interface TeamsRuleRuleSettings {
    /**
     * Add custom headers to allowed requests as key-value pairs. Use header names as keys that map to arrays of header values. Settable only for `http` rules with the action set to `allow`.
     */
    addHeaders?: {[key: string]: string[]};
    /**
     * Set to enable MSP children to bypass this rule. Only parent MSP accounts can set this. this rule. Settable for all types of rules.
     */
    allowChildBypass: boolean;
    /**
     * Define the settings for the Audit SSH action. Settable only for `l4` rules with `auditSsh` action.
     */
    auditSsh?: outputs.TeamsRuleRuleSettingsAuditSsh;
    /**
     * Configure browser isolation behavior. Settable only for `http` rules with the action set to `isolate`.
     */
    bisoAdminControls?: outputs.TeamsRuleRuleSettingsBisoAdminControls;
    /**
     * Configure custom block page settings. If missing or null, use the account settings. Settable only for `http` rules with the action set to `block`.
     */
    blockPage?: outputs.TeamsRuleRuleSettingsBlockPage;
    /**
     * Enable the custom block page. Settable only for `dns` rules with action `block`.
     */
    blockPageEnabled: boolean;
    /**
     * Explain why the rule blocks the request. The custom block page shows this text (if enabled). Settable only for `dns`, `l4`, and `http` rules when the action set to `block`.
     */
    blockReason: string;
    /**
     * Set to enable MSP accounts to bypass their parent's rules. Only MSP child accounts can set this. Settable for all types of rules.
     */
    bypassParentRule?: boolean;
    /**
     * Configure session check behavior. Settable only for `l4` and `http` rules with the action set to `allow`.
     */
    checkSession?: outputs.TeamsRuleRuleSettingsCheckSession;
    /**
     * Configure custom resolvers to route queries that match the resolver policy. Unused with 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' settings. DNS queries get routed to the address closest to their origin. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    dnsResolvers?: outputs.TeamsRuleRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. Settable only for `egress` rules.
     */
    egress?: outputs.TeamsRuleRuleSettingsEgress;
    /**
     * Ignore category matches at CNAME domains in a response. When off, evaluate categories in this rule against all CNAME domain categories in the response. Settable only for `dns` and `dnsResolver` rules.
     */
    ignoreCnameCategoryMatches: boolean;
    /**
     * Specify whether to disable DNSSEC validation (for Allow actions) [INSECURE]. Settable only for `dns` rules.
     */
    insecureDisableDnssecValidation: boolean;
    /**
     * Enable IPs in DNS resolver category blocks. The system blocks only domain name categories unless you enable this setting. Settable only for `dns` and `dnsResolver` rules.
     */
    ipCategories: boolean;
    /**
     * Indicates whether to include IPs in DNS resolver indicator feed blocks. Default, indicator feeds block only domain names. Settable only for `dns` and `dnsResolver` rules.
     */
    ipIndicatorFeeds: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port. Settable only for `l4` rules with the action set to `l4Override`.
     */
    l4override?: outputs.TeamsRuleRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule matched. Settable for all types of rules with the action set to `block`.
     */
    notificationSettings?: outputs.TeamsRuleRuleSettingsNotificationSettings;
    /**
     * Defines a hostname for override, for the matching DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideHost: string;
    /**
     * Defines a an IP or set of IPs for overriding matched DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideIps: string[];
    /**
     * Configure DLP payload logging. Settable only for `http` rules.
     */
    payloadLog?: outputs.TeamsRuleRuleSettingsPayloadLog;
    /**
     * Configure settings that apply to quarantine rules. Settable only for `http` rules.
     */
    quarantine?: outputs.TeamsRuleRuleSettingsQuarantine;
    /**
     * Apply settings to redirect rules. Settable only for `http` rules with the action set to `redirect`.
     */
    redirect?: outputs.TeamsRuleRuleSettingsRedirect;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Not used when 'dns*resolvers' is specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsInternally?: outputs.TeamsRuleRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot set when 'dns*resolvers' specified or 'resolve*dns_internally' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsThroughCloudflare: boolean;
    /**
     * Configure behavior when an upstream certificate is invalid or an SSL error occurs. Settable only for `http` rules with the action set to `allow`.
     */
    untrustedCert?: outputs.TeamsRuleRuleSettingsUntrustedCert;
}

export interface TeamsRuleRuleSettingsAuditSsh {
    /**
     * Enable SSH command logging.
     */
    commandLogging?: boolean;
}

export interface TeamsRuleRuleSettingsBisoAdminControls {
    /**
     * Configure copy behavior. If set to remote*only, users cannot copy isolated content from the remote browser to the local clipboard. If this field is absent, copying remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    copy?: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp?: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd?: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk?: boolean;
    /**
     * Configure download behavior. When set to remote*only, users can view downloads but cannot save them. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    download?: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp?: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du?: boolean;
    /**
     * Configure keyboard usage behavior. If this field is absent, keyboard usage remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    keyboard?: string;
    /**
     * Configure paste behavior. If set to remote*only, users cannot paste content from the local clipboard into isolated pages. If this field is absent, pasting remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    paste?: string;
    /**
     * Configure print behavior. Default, Printing is enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    printing?: string;
    /**
     * Configure upload behavior. If this field is absent, uploading remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    upload?: string;
    /**
     * Indicate which version of the browser isolation controls should apply.
     * Available values: "v1", "v2".
     */
    version: string;
}

export interface TeamsRuleRuleSettingsBlockPage {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface TeamsRuleRuleSettingsCheckSession {
    /**
     * Sets the required session freshness threshold. The API returns a normalized version of this value.
     */
    duration?: string;
    /**
     * Enable session enforcement.
     */
    enforce?: boolean;
}

export interface TeamsRuleRuleSettingsDnsResolvers {
    ipv4s?: outputs.TeamsRuleRuleSettingsDnsResolversIpv4[];
    ipv6s?: outputs.TeamsRuleRuleSettingsDnsResolversIpv6[];
}

export interface TeamsRuleRuleSettingsDnsResolversIpv4 {
    /**
     * Specify the IPv4 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface TeamsRuleRuleSettingsDnsResolversIpv6 {
    /**
     * Specify the IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface TeamsRuleRuleSettingsEgress {
    /**
     * Specify the IPv4 address to use for egress.
     */
    ipv4?: string;
    /**
     * Specify the fallback IPv4 address to use for egress when the primary IPv4 fails. Set '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback?: string;
    /**
     * Specify the IPv6 range to use for egress.
     */
    ipv6?: string;
}

export interface TeamsRuleRuleSettingsL4override {
    /**
     * Defines the IPv4 or IPv6 address.
     */
    ip?: string;
    /**
     * Defines a port number to use for TCP/UDP overrides.
     */
    port?: number;
}

export interface TeamsRuleRuleSettingsNotificationSettings {
    /**
     * Enable notification.
     */
    enabled?: boolean;
    /**
     * Indicates whether to pass the context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg?: string;
    /**
     * Defines an optional URL to direct users to additional information. If unset, the notification opens a block page.
     */
    supportUrl?: string;
}

export interface TeamsRuleRuleSettingsPayloadLog {
    /**
     * Enable DLP payload logging for this rule.
     */
    enabled?: boolean;
}

export interface TeamsRuleRuleSettingsQuarantine {
    /**
     * Specify the types of files to sandbox.
     */
    fileTypes?: string[];
}

export interface TeamsRuleRuleSettingsRedirect {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Specify whether to append the path and query parameters from the original request to target_uri.
     */
    preservePathAndQuery?: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface TeamsRuleRuleSettingsResolveDnsInternally {
    /**
     * Specify the fallback behavior to apply when the internal DNS response code differs from 'NOERROR' or when the response data contains only CNAME records for 'A' or 'AAAA' queries.
     * Available values: "none", "publicDns".
     */
    fallback?: string;
    /**
     * Specify the internal DNS view identifier to pass to the internal DNS service.
     */
    viewId?: string;
}

export interface TeamsRuleRuleSettingsUntrustedCert {
    /**
     * Defines the action performed when an untrusted certificate seen. The default action an error with HTTP code 526.
     * Available values: "passThrough", "block", "error".
     */
    action?: string;
}

export interface TeamsRuleSchedule {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    /**
     * Specify the time zone for rule evaluation. When a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway always uses the current time for that time zone. When this parameter is omitted, Gateway uses the time zone determined from the user's IP address. Colo time zone is used when the user's IP address does not resolve to a location.
     */
    timeZone?: string;
    tue?: string;
    wed?: string;
}

export interface TunnelConfigConfig {
    /**
     * List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
     */
    ingresses?: outputs.TunnelConfigConfigIngress[];
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest?: outputs.TunnelConfigConfigOriginRequest;
    /**
     * Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
     */
    warpRouting: outputs.TunnelConfigConfigWarpRouting;
}

export interface TunnelConfigConfigIngress {
    /**
     * Public hostname for this service.
     */
    hostname?: string;
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest?: outputs.TunnelConfigConfigIngressOriginRequest;
    /**
     * Requests with this path route to this public hostname.
     */
    path?: string;
    /**
     * Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
     */
    service: string;
}

export interface TunnelConfigConfigIngressOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access?: outputs.TunnelConfigConfigIngressOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout?: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader?: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout?: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive?: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout?: number;
}

export interface TunnelConfigConfigIngressOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required?: boolean;
    teamName: string;
}

export interface TunnelConfigConfigOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access?: outputs.TunnelConfigConfigOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout?: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader?: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout?: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive?: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout?: number;
}

export interface TunnelConfigConfigOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required?: boolean;
    teamName: string;
}

export interface TunnelConfigConfigWarpRouting {
    enabled: boolean;
}

export interface TunnelConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target. You must set the target to `ua` when specifying a user agent in the rule.
     * Available values: "ua".
     */
    target?: string;
    /**
     * the user agent to exactly match
     */
    value?: string;
}

export interface UserOrganization {
    /**
     * Identifier
     */
    id: string;
    /**
     * Organization name.
     */
    name: string;
    /**
     * Access permissions for this User.
     */
    permissions: string[];
    /**
     * List of roles that a user has within an organization.
     */
    roles: string[];
    /**
     * Whether the user is a member of the organization or has an invitation pending.
     * Available values: "member", "invited".
     */
    status: string;
}

export interface WaitingRoomAdditionalRoute {
    /**
     * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
     */
    host?: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
}

export interface WaitingRoomCookieAttributes {
    /**
     * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
     * Available values: "auto", "lax", "none", "strict".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
     * Available values: "auto", "always", "never".
     */
    secure: string;
}

export interface WaitingRoomRulesRule {
    /**
     * The action to take when the expression matches.
     * Available values: "bypass*waiting*room".
     */
    action: string;
    /**
     * The description of the rule.
     */
    description: string;
    /**
     * When set to true, the rule is enabled.
     */
    enabled: boolean;
    /**
     * Criteria defining when there is a match for the current rule.
     */
    expression: string;
}

export interface WebAnalyticsSiteRule {
    created: string;
    /**
     * The hostname the rule will be applied to.
     */
    host: string;
    /**
     * The Web Analytics rule identifier.
     */
    id: string;
    /**
     * Whether the rule includes or excludes traffic from being measured.
     */
    inclusive: boolean;
    /**
     * Whether the rule is paused or not.
     */
    isPaused: boolean;
    /**
     * The paths the rule will be applied to.
     */
    paths: string[];
    priority: number;
}

export interface WebAnalyticsSiteRuleset {
    /**
     * Whether the ruleset is enabled.
     */
    enabled: boolean;
    /**
     * The Web Analytics ruleset identifier.
     */
    id: string;
    zoneName: string;
    /**
     * The zone identifier.
     */
    zoneTag: string;
}

export interface WorkerCronTriggerSchedule {
    createdOn: string;
    cron: string;
    modifiedOn: string;
}

export interface WorkerObservability {
    /**
     * Whether observability is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
     */
    headSamplingRate: number;
    /**
     * Log settings for the Worker.
     */
    logs: outputs.WorkerObservabilityLogs;
}

export interface WorkerObservabilityLogs {
    /**
     * Whether logs are enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%).
     */
    headSamplingRate: number;
    /**
     * Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
     */
    invocationLogs: boolean;
}

export interface WorkerScriptAssets {
    /**
     * The SHA-256 hash of the asset manifest of files to upload.
     */
    assetManifestSha256: string;
    /**
     * Configuration for assets within a Worker.
     */
    config?: outputs.WorkerScriptAssetsConfig;
    /**
     * Path to the directory containing asset files to upload.
     */
    directory?: string;
    /**
     * Token provided upon successful upload of all files from a registered manifest.
     */
    jwt?: string;
}

export interface WorkerScriptAssetsConfig {
    /**
     * The contents of a _headers file (used to attach custom headers on asset responses).
     */
    headers?: string;
    /**
     * Determines the redirects and rewrites of requests for HTML content.
     * Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
     */
    htmlHandling?: string;
    /**
     * Determines the response when a request does not match a static asset, and there is no Worker script.
     * Available values: "none", "404-page", "single-page-application".
     */
    notFoundHandling?: string;
    /**
     * The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
     */
    redirects?: string;
    /**
     * When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
     */
    runWorkerFirst: boolean;
    /**
     * When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
     *
     * @deprecated This attribute is deprecated.
     */
    serveDirectly?: boolean;
}

export interface WorkerScriptBinding {
    /**
     * Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
     */
    algorithm?: string;
    /**
     * List of allowed destination addresses.
     */
    allowedDestinationAddresses?: string[];
    /**
     * List of allowed sender addresses.
     */
    allowedSenderAddresses?: string[];
    /**
     * R2 bucket to bind to.
     */
    bucketName?: string;
    /**
     * Identifier of the certificate to bind to.
     */
    certificateId?: string;
    /**
     * The exported class name of the Durable Object.
     */
    className: string;
    /**
     * The name of the dataset to bind to.
     */
    dataset?: string;
    /**
     * Destination address for the email.
     */
    destinationAddress?: string;
    /**
     * The environment of the scriptName to bind to.
     */
    environment?: string;
    /**
     * Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
     * Available values: "raw", "pkcs8", "spki", "jwk".
     */
    format?: string;
    /**
     * Identifier of the D1 database to bind to.
     */
    id?: string;
    /**
     * Name of the Vectorize index to bind to.
     */
    indexName?: string;
    /**
     * JSON data to use.
     */
    json?: string;
    /**
     * The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
     * Available values: "eu", "fedramp".
     */
    jurisdiction?: string;
    /**
     * Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
     */
    keyBase64?: string;
    /**
     * Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
     */
    keyJwk?: string;
    /**
     * A JavaScript variable name for the binding.
     */
    name: string;
    /**
     * Namespace to bind to.
     */
    namespace?: string;
    /**
     * Namespace identifier tag.
     */
    namespaceId: string;
    /**
     * The old name of the inherited binding. If set, the binding will be renamed from `oldName` to `name` in the new version. If not set, the binding will keep the same name between versions.
     */
    oldName?: string;
    /**
     * Outbound worker.
     */
    outbound?: outputs.WorkerScriptBindingOutbound;
    /**
     * The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
     */
    part?: string;
    /**
     * Name of the Pipeline to bind to.
     */
    pipeline?: string;
    /**
     * Name of the Queue to bind to.
     */
    queueName?: string;
    /**
     * The script where the Durable Object is defined, if it is external to this Worker.
     */
    scriptName?: string;
    /**
     * Name of the secret in the store.
     */
    secretName?: string;
    /**
     * Name of Worker to bind to.
     */
    service?: string;
    /**
     * ID of the store containing the secret.
     */
    storeId?: string;
    /**
     * The text value to use.
     */
    text?: string;
    /**
     * The kind of resource that the binding provides.
     * Available values: "ai", "analytics*engine", "assets", "browser", "d1", "data*blob", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "inherit", "images", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "send*email", "service", "tail*consumer", "text*blob", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow", "wasm*module".
     */
    type: string;
    /**
     * Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
     */
    usages?: string[];
    /**
     * Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
     */
    versionId?: string;
    /**
     * Name of the Workflow to bind to.
     */
    workflowName?: string;
}

export interface WorkerScriptBindingOutbound {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params?: string[];
    /**
     * Outbound worker.
     */
    worker?: outputs.WorkerScriptBindingOutboundWorker;
}

export interface WorkerScriptBindingOutboundWorker {
    /**
     * Environment of the outbound worker.
     */
    environment?: string;
    /**
     * Name of the outbound worker.
     */
    service?: string;
}

export interface WorkerScriptLimits {
    /**
     * The amount of CPU time this Worker can use in milliseconds.
     */
    cpuMs?: number;
}

export interface WorkerScriptNamedHandler {
    /**
     * The names of handlers exported as part of the named export.
     */
    handlers: string[];
    /**
     * The name of the export.
     */
    name: string;
}

export interface WorkerScriptObservability {
    /**
     * Whether observability is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
     */
    headSamplingRate?: number;
    /**
     * Log settings for the Worker.
     */
    logs?: outputs.WorkerScriptObservabilityLogs;
}

export interface WorkerScriptObservabilityLogs {
    /**
     * A list of destinations where logs will be exported to.
     */
    destinations?: string[];
    /**
     * Whether logs are enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
     */
    headSamplingRate?: number;
    /**
     * Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
     */
    invocationLogs: boolean;
    /**
     * Whether log persistence is enabled for the Worker.
     */
    persist: boolean;
}

export interface WorkerScriptPlacement {
    /**
     * The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    lastAnalyzedAt: string;
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "smart".
     */
    mode?: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
     */
    status: string;
}

export interface WorkerScriptTailConsumer {
    /**
     * Optional environment if the Worker utilizes one.
     */
    environment?: string;
    /**
     * Optional dispatch namespace the script belongs to.
     */
    namespace?: string;
    /**
     * Name of Worker that is to be the consumer.
     */
    service: string;
}

export interface WorkerSubdomain {
    /**
     * Whether the *.workers.dev subdomain is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * Whether [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/) are enabled for the Worker.
     */
    previewsEnabled: boolean;
}

export interface WorkerTailConsumer {
    /**
     * Name of the consumer Worker.
     */
    name: string;
}

export interface WorkerVersionAnnotations {
    /**
     * Human-readable message about the version.
     */
    workersMessage?: string;
    /**
     * User-provided identifier for the version.
     */
    workersTag?: string;
    /**
     * Operation that triggered the creation of the version.
     */
    workersTriggeredBy: string;
}

export interface WorkerVersionAssets {
    /**
     * The SHA-256 hash of the asset manifest of files to upload.
     */
    assetManifestSha256: string;
    /**
     * Configuration for assets within a Worker.
     */
    config: outputs.WorkerVersionAssetsConfig;
    /**
     * Path to the directory containing asset files to upload.
     */
    directory?: string;
    /**
     * Token provided upon successful upload of all files from a registered manifest.
     */
    jwt?: string;
}

export interface WorkerVersionAssetsConfig {
    /**
     * Determines the redirects and rewrites of requests for HTML content.
     * Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
     */
    htmlHandling: string;
    /**
     * Determines the response when a request does not match a static asset, and there is no Worker script.
     * Available values: "none", "404-page", "single-page-application".
     */
    notFoundHandling: string;
    /**
     * Contains a list path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
     */
    runWorkerFirsts: string[];
}

export interface WorkerVersionBinding {
    /**
     * Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
     */
    algorithm?: string;
    /**
     * List of allowed destination addresses.
     */
    allowedDestinationAddresses?: string[];
    /**
     * List of allowed sender addresses.
     */
    allowedSenderAddresses?: string[];
    /**
     * R2 bucket to bind to.
     */
    bucketName?: string;
    /**
     * Identifier of the certificate to bind to.
     */
    certificateId?: string;
    /**
     * The exported class name of the Durable Object.
     */
    className: string;
    /**
     * The name of the dataset to bind to.
     */
    dataset?: string;
    /**
     * Destination address for the email.
     */
    destinationAddress?: string;
    /**
     * The environment of the scriptName to bind to.
     */
    environment?: string;
    /**
     * Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
     * Available values: "raw", "pkcs8", "spki", "jwk".
     */
    format?: string;
    /**
     * Identifier of the D1 database to bind to.
     */
    id?: string;
    /**
     * Name of the Vectorize index to bind to.
     */
    indexName?: string;
    /**
     * JSON data to use.
     */
    json?: string;
    /**
     * The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
     * Available values: "eu", "fedramp".
     */
    jurisdiction?: string;
    /**
     * Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
     */
    keyBase64?: string;
    /**
     * Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
     */
    keyJwk?: string;
    /**
     * A JavaScript variable name for the binding.
     */
    name: string;
    /**
     * Namespace to bind to.
     */
    namespace?: string;
    /**
     * Namespace identifier tag.
     */
    namespaceId: string;
    /**
     * The old name of the inherited binding. If set, the binding will be renamed from `oldName` to `name` in the new version. If not set, the binding will keep the same name between versions.
     */
    oldName?: string;
    /**
     * Outbound worker.
     */
    outbound?: outputs.WorkerVersionBindingOutbound;
    /**
     * The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
     */
    part?: string;
    /**
     * Name of the Pipeline to bind to.
     */
    pipeline?: string;
    /**
     * Name of the Queue to bind to.
     */
    queueName?: string;
    /**
     * The script where the Durable Object is defined, if it is external to this Worker.
     */
    scriptName: string;
    /**
     * Name of the secret in the store.
     */
    secretName?: string;
    /**
     * Name of Worker to bind to.
     */
    service?: string;
    /**
     * ID of the store containing the secret.
     */
    storeId?: string;
    /**
     * The text value to use.
     */
    text?: string;
    /**
     * The kind of resource that the binding provides.
     * Available values: "ai", "analytics*engine", "assets", "browser", "d1", "data*blob", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "inherit", "images", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "send*email", "service", "tail*consumer", "text*blob", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow", "wasm*module".
     */
    type: string;
    /**
     * Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
     */
    usages?: string[];
    /**
     * Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
     */
    versionId?: string;
    /**
     * Name of the Workflow to bind to.
     */
    workflowName?: string;
}

export interface WorkerVersionBindingOutbound {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params?: string[];
    /**
     * Outbound worker.
     */
    worker?: outputs.WorkerVersionBindingOutboundWorker;
}

export interface WorkerVersionBindingOutboundWorker {
    /**
     * Environment of the outbound worker.
     */
    environment?: string;
    /**
     * Name of the outbound worker.
     */
    service?: string;
}

export interface WorkerVersionLimits {
    /**
     * CPU time limit in milliseconds.
     */
    cpuMs: number;
}

export interface WorkerVersionMigrations {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses?: string[];
    /**
     * Tag to set as the latest migration tag.
     */
    newTag?: string;
    /**
     * Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
     */
    oldTag?: string;
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses?: outputs.WorkerVersionMigrationsRenamedClass[];
    /**
     * Migrations to apply in order.
     */
    steps?: outputs.WorkerVersionMigrationsStep[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses?: outputs.WorkerVersionMigrationsTransferredClass[];
}

export interface WorkerVersionMigrationsRenamedClass {
    from?: string;
    to?: string;
}

export interface WorkerVersionMigrationsStep {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses?: string[];
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses?: outputs.WorkerVersionMigrationsStepRenamedClass[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses?: outputs.WorkerVersionMigrationsStepTransferredClass[];
}

export interface WorkerVersionMigrationsStepRenamedClass {
    from?: string;
    to?: string;
}

export interface WorkerVersionMigrationsStepTransferredClass {
    from?: string;
    fromScript?: string;
    to?: string;
}

export interface WorkerVersionMigrationsTransferredClass {
    from?: string;
    fromScript?: string;
    to?: string;
}

export interface WorkerVersionModule {
    /**
     * The file path of the module content.
     */
    contentFile: string;
    /**
     * The SHA-256 hash of the module content.
     */
    contentSha256: string;
    /**
     * The content type of the module.
     */
    contentType: string;
    /**
     * The name of the module.
     */
    name: string;
}

export interface WorkerVersionPlacement {
    /**
     * Placement mode for the version.
     * Available values: "smart".
     */
    mode?: string;
}

export interface WorkersCronTriggerSchedule {
    createdOn: string;
    cron: string;
    modifiedOn: string;
}

export interface WorkersDeploymentAnnotations {
    /**
     * Human-readable message about the deployment. Truncated to 100 bytes.
     */
    workersMessage?: string;
    /**
     * Operation that triggered the creation of the deployment.
     */
    workersTriggeredBy: string;
}

export interface WorkersDeploymentVersion {
    percentage: number;
    versionId: string;
}

export interface WorkersScriptAssets {
    /**
     * The SHA-256 hash of the asset manifest of files to upload.
     */
    assetManifestSha256: string;
    /**
     * Configuration for assets within a Worker.
     */
    config?: outputs.WorkersScriptAssetsConfig;
    /**
     * Path to the directory containing asset files to upload.
     */
    directory?: string;
    /**
     * Token provided upon successful upload of all files from a registered manifest.
     */
    jwt?: string;
}

export interface WorkersScriptAssetsConfig {
    /**
     * The contents of a _headers file (used to attach custom headers on asset responses).
     */
    headers?: string;
    /**
     * Determines the redirects and rewrites of requests for HTML content.
     * Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
     */
    htmlHandling?: string;
    /**
     * Determines the response when a request does not match a static asset, and there is no Worker script.
     * Available values: "none", "404-page", "single-page-application".
     */
    notFoundHandling?: string;
    /**
     * The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
     */
    redirects?: string;
    /**
     * When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
     */
    runWorkerFirst: boolean;
    /**
     * When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
     *
     * @deprecated This attribute is deprecated.
     */
    serveDirectly?: boolean;
}

export interface WorkersScriptBinding {
    /**
     * Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
     */
    algorithm?: string;
    /**
     * List of allowed destination addresses.
     */
    allowedDestinationAddresses?: string[];
    /**
     * List of allowed sender addresses.
     */
    allowedSenderAddresses?: string[];
    /**
     * R2 bucket to bind to.
     */
    bucketName?: string;
    /**
     * Identifier of the certificate to bind to.
     */
    certificateId?: string;
    /**
     * The exported class name of the Durable Object.
     */
    className: string;
    /**
     * The name of the dataset to bind to.
     */
    dataset?: string;
    /**
     * Destination address for the email.
     */
    destinationAddress?: string;
    /**
     * The environment of the scriptName to bind to.
     */
    environment?: string;
    /**
     * Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
     * Available values: "raw", "pkcs8", "spki", "jwk".
     */
    format?: string;
    /**
     * Identifier of the D1 database to bind to.
     */
    id?: string;
    /**
     * Name of the Vectorize index to bind to.
     */
    indexName?: string;
    /**
     * JSON data to use.
     */
    json?: string;
    /**
     * The [jurisdiction](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions) of the R2 bucket.
     * Available values: "eu", "fedramp".
     */
    jurisdiction?: string;
    /**
     * Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
     */
    keyBase64?: string;
    /**
     * Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
     */
    keyJwk?: string;
    /**
     * A JavaScript variable name for the binding.
     */
    name: string;
    /**
     * Namespace to bind to.
     */
    namespace?: string;
    /**
     * Namespace identifier tag.
     */
    namespaceId: string;
    /**
     * The old name of the inherited binding. If set, the binding will be renamed from `oldName` to `name` in the new version. If not set, the binding will keep the same name between versions.
     */
    oldName?: string;
    /**
     * Outbound worker.
     */
    outbound?: outputs.WorkersScriptBindingOutbound;
    /**
     * The name of the file containing the data content. Only accepted for `service worker syntax` Workers.
     */
    part?: string;
    /**
     * Name of the Pipeline to bind to.
     */
    pipeline?: string;
    /**
     * Name of the Queue to bind to.
     */
    queueName?: string;
    /**
     * The script where the Durable Object is defined, if it is external to this Worker.
     */
    scriptName?: string;
    /**
     * Name of the secret in the store.
     */
    secretName?: string;
    /**
     * Name of Worker to bind to.
     */
    service?: string;
    /**
     * ID of the store containing the secret.
     */
    storeId?: string;
    /**
     * The text value to use.
     */
    text?: string;
    /**
     * The kind of resource that the binding provides.
     * Available values: "ai", "analytics*engine", "assets", "browser", "d1", "data*blob", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "inherit", "images", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "send*email", "service", "tail*consumer", "text*blob", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow", "wasm*module".
     */
    type: string;
    /**
     * Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
     */
    usages?: string[];
    /**
     * Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
     */
    versionId?: string;
    /**
     * Name of the Workflow to bind to.
     */
    workflowName?: string;
}

export interface WorkersScriptBindingOutbound {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params?: string[];
    /**
     * Outbound worker.
     */
    worker?: outputs.WorkersScriptBindingOutboundWorker;
}

export interface WorkersScriptBindingOutboundWorker {
    /**
     * Environment of the outbound worker.
     */
    environment?: string;
    /**
     * Name of the outbound worker.
     */
    service?: string;
}

export interface WorkersScriptLimits {
    /**
     * The amount of CPU time this Worker can use in milliseconds.
     */
    cpuMs?: number;
}

export interface WorkersScriptNamedHandler {
    /**
     * The names of handlers exported as part of the named export.
     */
    handlers: string[];
    /**
     * The name of the export.
     */
    name: string;
}

export interface WorkersScriptObservability {
    /**
     * Whether observability is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
     */
    headSamplingRate?: number;
    /**
     * Log settings for the Worker.
     */
    logs?: outputs.WorkersScriptObservabilityLogs;
}

export interface WorkersScriptObservabilityLogs {
    /**
     * A list of destinations where logs will be exported to.
     */
    destinations?: string[];
    /**
     * Whether logs are enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
     */
    headSamplingRate?: number;
    /**
     * Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
     */
    invocationLogs: boolean;
    /**
     * Whether log persistence is enabled for the Worker.
     */
    persist: boolean;
}

export interface WorkersScriptPlacement {
    /**
     * The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    lastAnalyzedAt: string;
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "smart".
     */
    mode?: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     * Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
     */
    status: string;
}

export interface WorkersScriptTailConsumer {
    /**
     * Optional environment if the Worker utilizes one.
     */
    environment?: string;
    /**
     * Optional dispatch namespace the script belongs to.
     */
    namespace?: string;
    /**
     * Name of Worker that is to be the consumer.
     */
    service: string;
}

export interface WorkflowInstances {
    complete: number;
    errored: number;
    paused: number;
    queued: number;
    running: number;
    terminated: number;
    waiting: number;
    waitingForPause: number;
}

export interface ZeroTrustAccessApplicationCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders?: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods?: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins?: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials?: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders?: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods?: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins?: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge?: number;
}

export interface ZeroTrustAccessApplicationDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr?: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname?: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     * Available values: "tcp", "udp".
     */
    l4Protocol?: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange?: string;
    /**
     * Available values: "public", "private".
     */
    type: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri?: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId?: string;
}

export interface ZeroTrustAccessApplicationFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface ZeroTrustAccessApplicationLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor?: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor?: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl?: string;
    /**
     * The message shown on the landing page.
     */
    message?: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface ZeroTrustAccessApplicationPolicy {
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules?: outputs.ZeroTrustAccessApplicationPolicyConnectionRules;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     * Available values: "allow", "deny", "nonIdentity", "bypass".
     */
    decision?: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes?: outputs.ZeroTrustAccessApplicationPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id?: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes?: outputs.ZeroTrustAccessApplicationPolicyInclude[];
    /**
     * The name of the Access policy.
     */
    name?: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence: number;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires?: outputs.ZeroTrustAccessApplicationPolicyRequire[];
}

export interface ZeroTrustAccessApplicationPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh?: outputs.ZeroTrustAccessApplicationPolicyConnectionRulesSsh;
}

export interface ZeroTrustAccessApplicationPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias?: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface ZeroTrustAccessApplicationPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessApplicationPolicyExcludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessApplicationPolicyExcludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessApplicationPolicyExcludeAzureAd;
    certificate?: outputs.ZeroTrustAccessApplicationPolicyExcludeCertificate;
    commonName?: outputs.ZeroTrustAccessApplicationPolicyExcludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessApplicationPolicyExcludeDevicePosture;
    email?: outputs.ZeroTrustAccessApplicationPolicyExcludeEmail;
    emailDomain?: outputs.ZeroTrustAccessApplicationPolicyExcludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessApplicationPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessApplicationPolicyExcludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessApplicationPolicyExcludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessApplicationPolicyExcludeGithubOrganization;
    group?: outputs.ZeroTrustAccessApplicationPolicyExcludeGroup;
    gsuite?: outputs.ZeroTrustAccessApplicationPolicyExcludeGsuite;
    ip?: outputs.ZeroTrustAccessApplicationPolicyExcludeIp;
    ipList?: outputs.ZeroTrustAccessApplicationPolicyExcludeIpList;
    linkedAppToken?: outputs.ZeroTrustAccessApplicationPolicyExcludeLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessApplicationPolicyExcludeLoginMethod;
    oidc?: outputs.ZeroTrustAccessApplicationPolicyExcludeOidc;
    okta?: outputs.ZeroTrustAccessApplicationPolicyExcludeOkta;
    saml?: outputs.ZeroTrustAccessApplicationPolicyExcludeSaml;
    serviceToken?: outputs.ZeroTrustAccessApplicationPolicyExcludeServiceToken;
}

export interface ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken {
}

export interface ZeroTrustAccessApplicationPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeCertificate {
}

export interface ZeroTrustAccessApplicationPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEveryone {
}

export interface ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessApplicationPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessApplicationPolicyIncludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessApplicationPolicyIncludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessApplicationPolicyIncludeAzureAd;
    certificate?: outputs.ZeroTrustAccessApplicationPolicyIncludeCertificate;
    commonName?: outputs.ZeroTrustAccessApplicationPolicyIncludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessApplicationPolicyIncludeDevicePosture;
    email?: outputs.ZeroTrustAccessApplicationPolicyIncludeEmail;
    emailDomain?: outputs.ZeroTrustAccessApplicationPolicyIncludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessApplicationPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessApplicationPolicyIncludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessApplicationPolicyIncludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessApplicationPolicyIncludeGithubOrganization;
    group?: outputs.ZeroTrustAccessApplicationPolicyIncludeGroup;
    gsuite?: outputs.ZeroTrustAccessApplicationPolicyIncludeGsuite;
    ip?: outputs.ZeroTrustAccessApplicationPolicyIncludeIp;
    ipList?: outputs.ZeroTrustAccessApplicationPolicyIncludeIpList;
    linkedAppToken?: outputs.ZeroTrustAccessApplicationPolicyIncludeLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessApplicationPolicyIncludeLoginMethod;
    oidc?: outputs.ZeroTrustAccessApplicationPolicyIncludeOidc;
    okta?: outputs.ZeroTrustAccessApplicationPolicyIncludeOkta;
    saml?: outputs.ZeroTrustAccessApplicationPolicyIncludeSaml;
    serviceToken?: outputs.ZeroTrustAccessApplicationPolicyIncludeServiceToken;
}

export interface ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken {
}

export interface ZeroTrustAccessApplicationPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeCertificate {
}

export interface ZeroTrustAccessApplicationPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEveryone {
}

export interface ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessApplicationPolicyRequireAuthContext;
    authMethod?: outputs.ZeroTrustAccessApplicationPolicyRequireAuthMethod;
    azureAd?: outputs.ZeroTrustAccessApplicationPolicyRequireAzureAd;
    certificate?: outputs.ZeroTrustAccessApplicationPolicyRequireCertificate;
    commonName?: outputs.ZeroTrustAccessApplicationPolicyRequireCommonName;
    devicePosture?: outputs.ZeroTrustAccessApplicationPolicyRequireDevicePosture;
    email?: outputs.ZeroTrustAccessApplicationPolicyRequireEmail;
    emailDomain?: outputs.ZeroTrustAccessApplicationPolicyRequireEmailDomain;
    emailList?: outputs.ZeroTrustAccessApplicationPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessApplicationPolicyRequireEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessApplicationPolicyRequireExternalEvaluation;
    geo?: outputs.ZeroTrustAccessApplicationPolicyRequireGeo;
    githubOrganization?: outputs.ZeroTrustAccessApplicationPolicyRequireGithubOrganization;
    group?: outputs.ZeroTrustAccessApplicationPolicyRequireGroup;
    gsuite?: outputs.ZeroTrustAccessApplicationPolicyRequireGsuite;
    ip?: outputs.ZeroTrustAccessApplicationPolicyRequireIp;
    ipList?: outputs.ZeroTrustAccessApplicationPolicyRequireIpList;
    linkedAppToken?: outputs.ZeroTrustAccessApplicationPolicyRequireLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessApplicationPolicyRequireLoginMethod;
    oidc?: outputs.ZeroTrustAccessApplicationPolicyRequireOidc;
    okta?: outputs.ZeroTrustAccessApplicationPolicyRequireOkta;
    saml?: outputs.ZeroTrustAccessApplicationPolicyRequireSaml;
    serviceToken?: outputs.ZeroTrustAccessApplicationPolicyRequireServiceToken;
}

export interface ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken {
}

export interface ZeroTrustAccessApplicationPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireCertificate {
}

export interface ZeroTrustAccessApplicationPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEveryone {
}

export interface ZeroTrustAccessApplicationPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessApplicationSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret?: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl?: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     * Available values: "saml", "oidc".
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl?: string;
    customAttributes?: outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute[];
    customClaims?: outputs.ZeroTrustAccessApplicationSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState?: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes?: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex?: string;
    hybridAndImplicitOptions?: outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     * Available values: "id", "email".
     */
    nameIdFormat: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata?: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris?: string[];
    refreshTokenOptions?: outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata?: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes?: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId?: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName?: string;
    /**
     * The name of the attribute.
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     * Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
     */
    nameFormat?: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required?: boolean;
    source?: outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource;
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name?: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
    nameByIdps?: outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp[];
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId?: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName?: string;
}

export interface ZeroTrustAccessApplicationSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name?: string;
    /**
     * If the claim is required when building an OIDC token.
     */
    required?: boolean;
    /**
     * The scope of the claim.
     * Available values: "groups", "profile", "email", "openid".
     */
    scope?: string;
    source?: outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource;
}

export interface ZeroTrustAccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name?: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint?: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint?: boolean;
}

export interface ZeroTrustAccessApplicationSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime?: string;
}

export interface ZeroTrustAccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication?: outputs.ZeroTrustAccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete?: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled?: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings?: outputs.ZeroTrustAccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface ZeroTrustAccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl?: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId?: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret?: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password?: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     * Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes?: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token?: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl?: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user?: string;
}

export interface ZeroTrustAccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled?: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter?: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations?: outputs.ZeroTrustAccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     * Available values: "strict", "passthrough".
     */
    strictness?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata?: string;
}

export interface ZeroTrustAccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
}

export interface ZeroTrustAccessApplicationTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     * Available values: "SSH", "RDP".
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface ZeroTrustAccessGroupExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessGroupExcludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessGroupExcludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessGroupExcludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessGroupExcludeAzureAd;
    certificate?: outputs.ZeroTrustAccessGroupExcludeCertificate;
    commonName?: outputs.ZeroTrustAccessGroupExcludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessGroupExcludeDevicePosture;
    email?: outputs.ZeroTrustAccessGroupExcludeEmail;
    emailDomain?: outputs.ZeroTrustAccessGroupExcludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessGroupExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessGroupExcludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessGroupExcludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessGroupExcludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessGroupExcludeGithubOrganization;
    group?: outputs.ZeroTrustAccessGroupExcludeGroup;
    gsuite?: outputs.ZeroTrustAccessGroupExcludeGsuite;
    ip?: outputs.ZeroTrustAccessGroupExcludeIp;
    ipList?: outputs.ZeroTrustAccessGroupExcludeIpList;
    linkedAppToken?: outputs.ZeroTrustAccessGroupExcludeLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessGroupExcludeLoginMethod;
    oidc?: outputs.ZeroTrustAccessGroupExcludeOidc;
    okta?: outputs.ZeroTrustAccessGroupExcludeOkta;
    saml?: outputs.ZeroTrustAccessGroupExcludeSaml;
    serviceToken?: outputs.ZeroTrustAccessGroupExcludeServiceToken;
}

export interface ZeroTrustAccessGroupExcludeAnyValidServiceToken {
}

export interface ZeroTrustAccessGroupExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessGroupExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeCertificate {
}

export interface ZeroTrustAccessGroupExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessGroupExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessGroupExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessGroupExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessGroupExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupExcludeEveryone {
}

export interface ZeroTrustAccessGroupExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessGroupExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessGroupExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessGroupExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessGroupExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessGroupExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessGroupExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessGroupExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessGroupExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessGroupInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessGroupIncludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessGroupIncludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessGroupIncludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessGroupIncludeAzureAd;
    certificate?: outputs.ZeroTrustAccessGroupIncludeCertificate;
    commonName?: outputs.ZeroTrustAccessGroupIncludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessGroupIncludeDevicePosture;
    email?: outputs.ZeroTrustAccessGroupIncludeEmail;
    emailDomain?: outputs.ZeroTrustAccessGroupIncludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessGroupIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessGroupIncludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessGroupIncludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessGroupIncludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessGroupIncludeGithubOrganization;
    group?: outputs.ZeroTrustAccessGroupIncludeGroup;
    gsuite?: outputs.ZeroTrustAccessGroupIncludeGsuite;
    ip?: outputs.ZeroTrustAccessGroupIncludeIp;
    ipList?: outputs.ZeroTrustAccessGroupIncludeIpList;
    linkedAppToken?: outputs.ZeroTrustAccessGroupIncludeLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessGroupIncludeLoginMethod;
    oidc?: outputs.ZeroTrustAccessGroupIncludeOidc;
    okta?: outputs.ZeroTrustAccessGroupIncludeOkta;
    saml?: outputs.ZeroTrustAccessGroupIncludeSaml;
    serviceToken?: outputs.ZeroTrustAccessGroupIncludeServiceToken;
}

export interface ZeroTrustAccessGroupIncludeAnyValidServiceToken {
}

export interface ZeroTrustAccessGroupIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessGroupIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeCertificate {
}

export interface ZeroTrustAccessGroupIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessGroupIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessGroupIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessGroupIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessGroupIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupIncludeEveryone {
}

export interface ZeroTrustAccessGroupIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessGroupIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessGroupIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessGroupIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessGroupIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessGroupIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessGroupIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessGroupIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessGroupIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessGroupRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessGroupRequireAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessGroupRequireAuthContext;
    authMethod?: outputs.ZeroTrustAccessGroupRequireAuthMethod;
    azureAd?: outputs.ZeroTrustAccessGroupRequireAzureAd;
    certificate?: outputs.ZeroTrustAccessGroupRequireCertificate;
    commonName?: outputs.ZeroTrustAccessGroupRequireCommonName;
    devicePosture?: outputs.ZeroTrustAccessGroupRequireDevicePosture;
    email?: outputs.ZeroTrustAccessGroupRequireEmail;
    emailDomain?: outputs.ZeroTrustAccessGroupRequireEmailDomain;
    emailList?: outputs.ZeroTrustAccessGroupRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessGroupRequireEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessGroupRequireExternalEvaluation;
    geo?: outputs.ZeroTrustAccessGroupRequireGeo;
    githubOrganization?: outputs.ZeroTrustAccessGroupRequireGithubOrganization;
    group?: outputs.ZeroTrustAccessGroupRequireGroup;
    gsuite?: outputs.ZeroTrustAccessGroupRequireGsuite;
    ip?: outputs.ZeroTrustAccessGroupRequireIp;
    ipList?: outputs.ZeroTrustAccessGroupRequireIpList;
    linkedAppToken?: outputs.ZeroTrustAccessGroupRequireLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessGroupRequireLoginMethod;
    oidc?: outputs.ZeroTrustAccessGroupRequireOidc;
    okta?: outputs.ZeroTrustAccessGroupRequireOkta;
    saml?: outputs.ZeroTrustAccessGroupRequireSaml;
    serviceToken?: outputs.ZeroTrustAccessGroupRequireServiceToken;
}

export interface ZeroTrustAccessGroupRequireAnyValidServiceToken {
}

export interface ZeroTrustAccessGroupRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessGroupRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireCertificate {
}

export interface ZeroTrustAccessGroupRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessGroupRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessGroupRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessGroupRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessGroupRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupRequireEveryone {
}

export interface ZeroTrustAccessGroupRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessGroupRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessGroupRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessGroupRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessGroupRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessGroupRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessGroupRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessGroupRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessGroupRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessIdentityProviderConfig {
    /**
     * Your companies TLD
     */
    appsDomain?: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes?: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl?: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId?: string;
    /**
     * Your centrify account url
     */
    centrifyAccount?: string;
    /**
     * Your centrify app id
     */
    centrifyAppId?: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl?: string;
    /**
     * Custom claims
     */
    claims?: string[];
    /**
     * Your OAuth Client ID
     */
    clientId?: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret?: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled?: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId?: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName?: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName?: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes?: outputs.ZeroTrustAccessIdentityProviderConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts?: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl?: string;
    /**
     * Your okta account url
     */
    oktaAccount?: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount?: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId?: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled?: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     * Available values: "login", "selectAccount", "none".
     */
    prompt?: string;
    redirectUrl: string;
    /**
     * OAuth scopes
     */
    scopes?: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest?: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl?: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups?: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl?: string;
}

export interface ZeroTrustAccessIdentityProviderConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName?: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName?: string;
}

export interface ZeroTrustAccessIdentityProviderScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     * Available values: "automatic", "reauth", "no*action".
     */
    identityUpdateBehavior: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision: boolean;
}

export interface ZeroTrustAccessInfrastructureTargetIp {
    /**
     * The target's IPv4 address
     */
    ipv4?: outputs.ZeroTrustAccessInfrastructureTargetIpIpv4;
    /**
     * The target's IPv6 address
     */
    ipv6?: outputs.ZeroTrustAccessInfrastructureTargetIpIpv6;
}

export interface ZeroTrustAccessInfrastructureTargetIpIpv4 {
    /**
     * IP address of the target
     */
    ipAddr?: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface ZeroTrustAccessInfrastructureTargetIpIpv6 {
    /**
     * IP address of the target
     */
    ipAddr?: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface ZeroTrustAccessMtlsHostnameSettingsSetting {
    /**
     * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
     */
    chinaNetwork: boolean;
    /**
     * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
     */
    clientCertificateForwarding: boolean;
    /**
     * The hostname that these settings apply to.
     */
    hostname: string;
}

export interface ZeroTrustAccessPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses?: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid?: string;
}

export interface ZeroTrustAccessPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessPolicyExcludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessPolicyExcludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessPolicyExcludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessPolicyExcludeAzureAd;
    certificate?: outputs.ZeroTrustAccessPolicyExcludeCertificate;
    commonName?: outputs.ZeroTrustAccessPolicyExcludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessPolicyExcludeDevicePosture;
    email?: outputs.ZeroTrustAccessPolicyExcludeEmail;
    emailDomain?: outputs.ZeroTrustAccessPolicyExcludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessPolicyExcludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessPolicyExcludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessPolicyExcludeGithubOrganization;
    group?: outputs.ZeroTrustAccessPolicyExcludeGroup;
    gsuite?: outputs.ZeroTrustAccessPolicyExcludeGsuite;
    ip?: outputs.ZeroTrustAccessPolicyExcludeIp;
    ipList?: outputs.ZeroTrustAccessPolicyExcludeIpList;
    linkedAppToken?: outputs.ZeroTrustAccessPolicyExcludeLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessPolicyExcludeLoginMethod;
    oidc?: outputs.ZeroTrustAccessPolicyExcludeOidc;
    okta?: outputs.ZeroTrustAccessPolicyExcludeOkta;
    saml?: outputs.ZeroTrustAccessPolicyExcludeSaml;
    serviceToken?: outputs.ZeroTrustAccessPolicyExcludeServiceToken;
}

export interface ZeroTrustAccessPolicyExcludeAnyValidServiceToken {
}

export interface ZeroTrustAccessPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeCertificate {
}

export interface ZeroTrustAccessPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyExcludeEveryone {
}

export interface ZeroTrustAccessPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyExcludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyExcludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessPolicyIncludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessPolicyIncludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessPolicyIncludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessPolicyIncludeAzureAd;
    certificate?: outputs.ZeroTrustAccessPolicyIncludeCertificate;
    commonName?: outputs.ZeroTrustAccessPolicyIncludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessPolicyIncludeDevicePosture;
    email?: outputs.ZeroTrustAccessPolicyIncludeEmail;
    emailDomain?: outputs.ZeroTrustAccessPolicyIncludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessPolicyIncludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessPolicyIncludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessPolicyIncludeGithubOrganization;
    group?: outputs.ZeroTrustAccessPolicyIncludeGroup;
    gsuite?: outputs.ZeroTrustAccessPolicyIncludeGsuite;
    ip?: outputs.ZeroTrustAccessPolicyIncludeIp;
    ipList?: outputs.ZeroTrustAccessPolicyIncludeIpList;
    linkedAppToken?: outputs.ZeroTrustAccessPolicyIncludeLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessPolicyIncludeLoginMethod;
    oidc?: outputs.ZeroTrustAccessPolicyIncludeOidc;
    okta?: outputs.ZeroTrustAccessPolicyIncludeOkta;
    saml?: outputs.ZeroTrustAccessPolicyIncludeSaml;
    serviceToken?: outputs.ZeroTrustAccessPolicyIncludeServiceToken;
}

export interface ZeroTrustAccessPolicyIncludeAnyValidServiceToken {
}

export interface ZeroTrustAccessPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeCertificate {
}

export interface ZeroTrustAccessPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyIncludeEveryone {
}

export interface ZeroTrustAccessPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyIncludeLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyIncludeOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessPolicyRequireAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessPolicyRequireAuthContext;
    authMethod?: outputs.ZeroTrustAccessPolicyRequireAuthMethod;
    azureAd?: outputs.ZeroTrustAccessPolicyRequireAzureAd;
    certificate?: outputs.ZeroTrustAccessPolicyRequireCertificate;
    commonName?: outputs.ZeroTrustAccessPolicyRequireCommonName;
    devicePosture?: outputs.ZeroTrustAccessPolicyRequireDevicePosture;
    email?: outputs.ZeroTrustAccessPolicyRequireEmail;
    emailDomain?: outputs.ZeroTrustAccessPolicyRequireEmailDomain;
    emailList?: outputs.ZeroTrustAccessPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessPolicyRequireEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessPolicyRequireExternalEvaluation;
    geo?: outputs.ZeroTrustAccessPolicyRequireGeo;
    githubOrganization?: outputs.ZeroTrustAccessPolicyRequireGithubOrganization;
    group?: outputs.ZeroTrustAccessPolicyRequireGroup;
    gsuite?: outputs.ZeroTrustAccessPolicyRequireGsuite;
    ip?: outputs.ZeroTrustAccessPolicyRequireIp;
    ipList?: outputs.ZeroTrustAccessPolicyRequireIpList;
    linkedAppToken?: outputs.ZeroTrustAccessPolicyRequireLinkedAppToken;
    loginMethod?: outputs.ZeroTrustAccessPolicyRequireLoginMethod;
    oidc?: outputs.ZeroTrustAccessPolicyRequireOidc;
    okta?: outputs.ZeroTrustAccessPolicyRequireOkta;
    saml?: outputs.ZeroTrustAccessPolicyRequireSaml;
    serviceToken?: outputs.ZeroTrustAccessPolicyRequireServiceToken;
}

export interface ZeroTrustAccessPolicyRequireAnyValidServiceToken {
}

export interface ZeroTrustAccessPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireCertificate {
}

export interface ZeroTrustAccessPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyRequireEveryone {
}

export interface ZeroTrustAccessPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyRequireLinkedAppToken {
    /**
     * The ID of an Access OIDC SaaS application
     */
    appUid: string;
}

export interface ZeroTrustAccessPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyRequireOidc {
    /**
     * The name of the OIDC claim.
     */
    claimName: string;
    /**
     * The OIDC claim value to look for.
     */
    claimValue: string;
    /**
     * The ID of your OIDC identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustDeviceCustomProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceCustomProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceCustomProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceCustomProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface ZeroTrustDeviceCustomProfileTargetTest {
    /**
     * The id of the DEX test targeting this policy.
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy.
     */
    name: string;
}

export interface ZeroTrustDeviceDefaultProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address?: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description?: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host?: string;
}

export interface ZeroTrustDeviceDefaultProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceDefaultProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
     */
    address?: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description?: string;
    /**
     * The domain name to include in the tunnel. If `host` is present, `address` must not be present.
     */
    host?: string;
}

export interface ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceDefaultProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode?: string;
    /**
     * The port number when used with proxy mode.
     */
    port?: number;
}

export interface ZeroTrustDeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256?: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface ZeroTrustDevicePostureIntegrationConfig {
    /**
     * If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `apiUrl`.
     */
    accessClientId?: string;
    /**
     * If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `apiUrl`.
     */
    accessClientSecret?: string;
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl?: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl?: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId?: string;
    /**
     * The Uptycs client secret.
     */
    clientKey?: string;
    /**
     * The Workspace One client secret provided in the Workspace One Admin Dashboard.
     */
    clientSecret?: string;
    /**
     * The Crowdstrike customer ID.
     */
    customerId?: string;
}

export interface ZeroTrustDevicePostureRuleInput {
    /**
     * The Number of active threats.
     */
    activeThreats?: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks?: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey?: boolean;
    /**
     * Common Name that is protected by the certificate.
     */
    cn?: string;
    /**
     * Compliance Status.
     * Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
     */
    complianceStatus?: string;
    /**
     * Posture Integration ID.
     */
    connectionId?: string;
    /**
     * Count Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    countOperator?: string;
    /**
     * Domain.
     */
    domain?: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen?: string;
    /**
     * Enabled.
     */
    enabled?: boolean;
    /**
     * Whether or not file exists.
     */
    exists?: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used.
     */
    extendedKeyUsages?: string[];
    /**
     * List ID.
     */
    id?: string;
    /**
     * Whether device is infected.
     */
    infected?: boolean;
    /**
     * Whether device is active.
     */
    isActive?: boolean;
    /**
     * The Number of Issues.
     */
    issueCount?: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen?: string;
    locations?: outputs.ZeroTrustDevicePostureRuleInputLocations;
    /**
     * Network status of device.
     * Available values: "connected", "disconnected", "disconnecting", "connecting".
     */
    networkStatus?: string;
    /**
     * Operating system.
     * Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
     */
    operatingSystem?: string;
    /**
     * Agent operational state.
     * Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
     */
    operationalState?: string;
    /**
     * Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    operator?: string;
    /**
     * Os Version.
     */
    os?: string;
    /**
     * Operating System Distribution Name (linux only).
     */
    osDistroName?: string;
    /**
     * Version of OS Distribution (linux only).
     */
    osDistroRevision?: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
     */
    osVersionExtra?: string;
    /**
     * Overall.
     */
    overall?: string;
    /**
     * File path.
     */
    path?: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll?: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     * Available values: "low", "medium", "high", "critical".
     */
    riskLevel?: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score?: number;
    /**
     * Score Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    scoreOperator?: string;
    /**
     * SensorConfig.
     */
    sensorConfig?: string;
    /**
     * SHA-256.
     */
    sha256?: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     * Available values: "online", "offline", "unknown".
     */
    state?: string;
    /**
     * List of certificate Subject Alternative Names.
     */
    subjectAlternativeNames?: string[];
    /**
     * Signing certificate thumbprint.
     */
    thumbprint?: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore?: number;
    /**
     * Version of OS.
     */
    version?: string;
    /**
     * Version Operator.
     * Available values: "<", "<=", ">", ">=", "==".
     */
    versionOperator?: string;
}

export interface ZeroTrustDevicePostureRuleInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths?: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores?: string[];
}

export interface ZeroTrustDevicePostureRuleMatch {
    /**
     * Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
     */
    platform?: string;
}

export interface ZeroTrustDexTestData {
    /**
     * The desired endpoint to test.
     */
    host: string;
    /**
     * The type of test.
     */
    kind: string;
    /**
     * The HTTP request method type.
     */
    method?: string;
}

export interface ZeroTrustDexTestTargetPolicy {
    /**
     * Whether the DEX rule is the account default
     */
    default: boolean;
    /**
     * The id of the DEX rule
     */
    id: string;
    /**
     * The name of the DEX rule
     */
    name: string;
}

export interface ZeroTrustDlpCustomEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface ZeroTrustDlpCustomEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation?: string;
}

export interface ZeroTrustDlpCustomEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface ZeroTrustDlpCustomProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpCustomProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpCustomProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpCustomProfileEntry {
    enabled: boolean;
    entryId?: string;
    name: string;
    pattern: outputs.ZeroTrustDlpCustomProfileEntryPattern;
}

export interface ZeroTrustDlpCustomProfileEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation?: string;
}

export interface ZeroTrustDlpCustomProfileSharedEntry {
    enabled: boolean;
    entryId: string;
    /**
     * Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
     */
    entryType: string;
}

export interface ZeroTrustDlpDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    uploadStatus: string;
}

export interface ZeroTrustDlpDatasetDataset {
    caseSensitive: boolean;
    columns: outputs.ZeroTrustDlpDatasetDatasetColumn[];
    createdAt: string;
    /**
     * The description of the dataset.
     */
    description: string;
    encodingVersion: number;
    id: string;
    name: string;
    numCells: number;
    secret: boolean;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    status: string;
    /**
     * When the dataset was last updated.
     */
    updatedAt: string;
    uploads: outputs.ZeroTrustDlpDatasetDatasetUpload[];
}

export interface ZeroTrustDlpDatasetDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    uploadStatus: string;
}

export interface ZeroTrustDlpDatasetDatasetUpload {
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    status: string;
    version: number;
}

export interface ZeroTrustDlpDatasetUpload {
    numCells: number;
    /**
     * Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
     */
    status: string;
    version: number;
}

export interface ZeroTrustDlpEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface ZeroTrustDlpEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation?: string;
}

export interface ZeroTrustDlpEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface ZeroTrustDlpIntegrationEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface ZeroTrustDlpIntegrationEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface ZeroTrustDlpIntegrationEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface ZeroTrustDlpPredefinedEntryConfidence {
    /**
     * Indicates whether this entry has AI remote service validation.
     */
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry has any form of validation that is not an AI remote service.
     */
    available: boolean;
}

export interface ZeroTrustDlpPredefinedEntryPattern {
    regex: string;
    /**
     * Available values: "luhn".
     *
     * @deprecated This attribute is deprecated.
     */
    validation: string;
}

export interface ZeroTrustDlpPredefinedEntryVariant {
    description: string;
    /**
     * Available values: "Intent", "Content".
     */
    topicType: string;
    /**
     * Available values: "PromptTopic".
     */
    type: string;
}

export interface ZeroTrustDlpPredefinedProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpPredefinedProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpPredefinedProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpPredefinedProfileEntry {
    enabled: boolean;
    id: string;
}

export interface ZeroTrustDnsLocationEndpoints {
    doh: outputs.ZeroTrustDnsLocationEndpointsDoh;
    dot: outputs.ZeroTrustDnsLocationEndpointsDot;
    ipv4: outputs.ZeroTrustDnsLocationEndpointsIpv4;
    ipv6: outputs.ZeroTrustDnsLocationEndpointsIpv6;
}

export interface ZeroTrustDnsLocationEndpointsDoh {
    /**
     * Indicate whether the DOH endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsDohNetwork[];
    /**
     * Specify whether the DOH endpoint requires user identity authentication.
     */
    requireToken: boolean;
}

export interface ZeroTrustDnsLocationEndpointsDohNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationEndpointsDot {
    /**
     * Indicate whether the DOT endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IP network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsDotNetwork[];
}

export interface ZeroTrustDnsLocationEndpointsDotNetwork {
    /**
     * Specify the IP address or IP CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationEndpointsIpv4 {
    /**
     * Indicate whether the IPv4 endpoint is enabled for this location.
     */
    enabled: boolean;
}

export interface ZeroTrustDnsLocationEndpointsIpv6 {
    /**
     * Indicate whether the IPV6 endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * Specify the list of allowed source IPv6 network ranges for this endpoint. When the list is empty, the endpoint allows all source IPs. The list takes effect only if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsIpv6Network[];
}

export interface ZeroTrustDnsLocationEndpointsIpv6Network {
    /**
     * Specify the IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationNetwork {
    /**
     * Specify the IPv4 address or IPv4 CIDR. Limit IPv4 CIDRs to a maximum of /24.
     */
    network: string;
}

export interface ZeroTrustGatewayLoggingSettingsByRuleType {
    /**
     * Configure logging settings for DNS firewall.
     */
    dns: outputs.ZeroTrustGatewayLoggingSettingsByRuleTypeDns;
    /**
     * Configure logging settings for HTTP/HTTPS firewall.
     */
    http: outputs.ZeroTrustGatewayLoggingSettingsByRuleTypeHttp;
    /**
     * Configure logging settings for Network firewall.
     */
    l4: outputs.ZeroTrustGatewayLoggingSettingsByRuleTypeL4;
}

export interface ZeroTrustGatewayLoggingSettingsByRuleTypeDns {
    /**
     * Specify whether to log all requests to this service.
     */
    logAll: boolean;
    /**
     * Specify whether to log only blocking requests to this service.
     */
    logBlocks: boolean;
}

export interface ZeroTrustGatewayLoggingSettingsByRuleTypeHttp {
    /**
     * Specify whether to log all requests to this service.
     */
    logAll: boolean;
    /**
     * Specify whether to log only blocking requests to this service.
     */
    logBlocks: boolean;
}

export interface ZeroTrustGatewayLoggingSettingsByRuleTypeL4 {
    /**
     * Specify whether to log all requests to this service.
     */
    logAll: boolean;
    /**
     * Specify whether to log only blocking requests to this service.
     */
    logBlocks: boolean;
}

export interface ZeroTrustGatewayPolicyExpiration {
    /**
     * Defines the default duration a policy active in minutes. Must set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration?: number;
    /**
     * Indicates whether the policy is expired.
     */
    expired: boolean;
    /**
     * Show the timestamp when the policy expires and stops applying.  The value must follow RFC 3339 and include a UTC offset.  The system accepts non-zero offsets but converts them to the equivalent UTC+00:00  value and returns timestamps with a trailing Z. Expiration policies ignore client  timezones and expire globally at the specified expiresAt time.
     */
    expiresAt: string;
}

export interface ZeroTrustGatewayPolicyRuleSettings {
    /**
     * Add custom headers to allowed requests as key-value pairs. Use header names as keys that map to arrays of header values. Settable only for `http` rules with the action set to `allow`.
     */
    addHeaders?: {[key: string]: string[]};
    /**
     * Set to enable MSP children to bypass this rule. Only parent MSP accounts can set this. this rule. Settable for all types of rules.
     */
    allowChildBypass: boolean;
    /**
     * Define the settings for the Audit SSH action. Settable only for `l4` rules with `auditSsh` action.
     */
    auditSsh?: outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh;
    /**
     * Configure browser isolation behavior. Settable only for `http` rules with the action set to `isolate`.
     */
    bisoAdminControls?: outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls;
    /**
     * Configure custom block page settings. If missing or null, use the account settings. Settable only for `http` rules with the action set to `block`.
     */
    blockPage?: outputs.ZeroTrustGatewayPolicyRuleSettingsBlockPage;
    /**
     * Enable the custom block page. Settable only for `dns` rules with action `block`.
     */
    blockPageEnabled: boolean;
    /**
     * Explain why the rule blocks the request. The custom block page shows this text (if enabled). Settable only for `dns`, `l4`, and `http` rules when the action set to `block`.
     */
    blockReason: string;
    /**
     * Set to enable MSP accounts to bypass their parent's rules. Only MSP child accounts can set this. Settable for all types of rules.
     */
    bypassParentRule?: boolean;
    /**
     * Configure session check behavior. Settable only for `l4` and `http` rules with the action set to `allow`.
     */
    checkSession?: outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession;
    /**
     * Configure custom resolvers to route queries that match the resolver policy. Unused with 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' settings. DNS queries get routed to the address closest to their origin. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    dnsResolvers?: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. Settable only for `egress` rules.
     */
    egress?: outputs.ZeroTrustGatewayPolicyRuleSettingsEgress;
    /**
     * Ignore category matches at CNAME domains in a response. When off, evaluate categories in this rule against all CNAME domain categories in the response. Settable only for `dns` and `dnsResolver` rules.
     */
    ignoreCnameCategoryMatches: boolean;
    /**
     * Specify whether to disable DNSSEC validation (for Allow actions) [INSECURE]. Settable only for `dns` rules.
     */
    insecureDisableDnssecValidation: boolean;
    /**
     * Enable IPs in DNS resolver category blocks. The system blocks only domain name categories unless you enable this setting. Settable only for `dns` and `dnsResolver` rules.
     */
    ipCategories: boolean;
    /**
     * Indicates whether to include IPs in DNS resolver indicator feed blocks. Default, indicator feeds block only domain names. Settable only for `dns` and `dnsResolver` rules.
     */
    ipIndicatorFeeds: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port. Settable only for `l4` rules with the action set to `l4Override`.
     */
    l4override?: outputs.ZeroTrustGatewayPolicyRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule matched. Settable for all types of rules with the action set to `block`.
     */
    notificationSettings?: outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings;
    /**
     * Defines a hostname for override, for the matching DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideHost: string;
    /**
     * Defines a an IP or set of IPs for overriding matched DNS queries. Settable only for `dns` rules with the action set to `override`.
     */
    overrideIps: string[];
    /**
     * Configure DLP payload logging. Settable only for `http` rules.
     */
    payloadLog?: outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog;
    /**
     * Configure settings that apply to quarantine rules. Settable only for `http` rules.
     */
    quarantine?: outputs.ZeroTrustGatewayPolicyRuleSettingsQuarantine;
    /**
     * Apply settings to redirect rules. Settable only for `http` rules with the action set to `redirect`.
     */
    redirect?: outputs.ZeroTrustGatewayPolicyRuleSettingsRedirect;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Not used when 'dns*resolvers' is specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsInternally?: outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot set when 'dns*resolvers' specified or 'resolve*dns_internally' is set. Only valid when a rule's action set to 'resolve'. Settable only for `dnsResolver` rules.
     */
    resolveDnsThroughCloudflare: boolean;
    /**
     * Configure behavior when an upstream certificate is invalid or an SSL error occurs. Settable only for `http` rules with the action set to `allow`.
     */
    untrustedCert?: outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert;
}

export interface ZeroTrustGatewayPolicyRuleSettingsAuditSsh {
    /**
     * Enable SSH command logging.
     */
    commandLogging?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls {
    /**
     * Configure copy behavior. If set to remote*only, users cannot copy isolated content from the remote browser to the local clipboard. If this field is absent, copying remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    copy?: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp?: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd?: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk?: boolean;
    /**
     * Configure download behavior. When set to remote*only, users can view downloads but cannot save them. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    download?: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp?: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du?: boolean;
    /**
     * Configure keyboard usage behavior. If this field is absent, keyboard usage remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    keyboard?: string;
    /**
     * Configure paste behavior. If set to remote*only, users cannot paste content from the local clipboard into isolated pages. If this field is absent, pasting remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled", "remote*only".
     */
    paste?: string;
    /**
     * Configure print behavior. Default, Printing is enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    printing?: string;
    /**
     * Configure upload behavior. If this field is absent, uploading remains enabled. Applies only when version == "v2".
     * Available values: "enabled", "disabled".
     */
    upload?: string;
    /**
     * Indicate which version of the browser isolation controls should apply.
     * Available values: "v1", "v2".
     */
    version: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsBlockPage {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsCheckSession {
    /**
     * Sets the required session freshness threshold. The API returns a normalized version of this value.
     */
    duration?: string;
    /**
     * Enable session enforcement.
     */
    enforce?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolvers {
    ipv4s?: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4[];
    ipv6s?: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4 {
    /**
     * Specify the IPv4 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6 {
    /**
     * Specify the IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Indicate whether to connect to this resolver over a private network. Must set when vnetId set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsEgress {
    /**
     * Specify the IPv4 address to use for egress.
     */
    ipv4?: string;
    /**
     * Specify the fallback IPv4 address to use for egress when the primary IPv4 fails. Set '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback?: string;
    /**
     * Specify the IPv6 range to use for egress.
     */
    ipv6?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsL4override {
    /**
     * Defines the IPv4 or IPv6 address.
     */
    ip?: string;
    /**
     * Defines a port number to use for TCP/UDP overrides.
     */
    port?: number;
}

export interface ZeroTrustGatewayPolicyRuleSettingsNotificationSettings {
    /**
     * Enable notification.
     */
    enabled?: boolean;
    /**
     * Indicates whether to pass the context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg?: string;
    /**
     * Defines an optional URL to direct users to additional information. If unset, the notification opens a block page.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsPayloadLog {
    /**
     * Enable DLP payload logging for this rule.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsQuarantine {
    /**
     * Specify the types of files to sandbox.
     */
    fileTypes?: string[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsRedirect {
    /**
     * Specify whether to pass the context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Specify whether to append the path and query parameters from the original request to target_uri.
     */
    preservePathAndQuery?: boolean;
    /**
     * Specify the URI to which the user is redirected.
     */
    targetUri: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally {
    /**
     * Specify the fallback behavior to apply when the internal DNS response code differs from 'NOERROR' or when the response data contains only CNAME records for 'A' or 'AAAA' queries.
     * Available values: "none", "publicDns".
     */
    fallback?: string;
    /**
     * Specify the internal DNS view identifier to pass to the internal DNS service.
     */
    viewId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsUntrustedCert {
    /**
     * Defines the action performed when an untrusted certificate seen. The default action an error with HTTP code 526.
     * Available values: "passThrough", "block", "error".
     */
    action?: string;
}

export interface ZeroTrustGatewayPolicySchedule {
    fri?: string;
    mon?: string;
    sat?: string;
    sun?: string;
    thu?: string;
    /**
     * Specify the time zone for rule evaluation. When a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway always uses the current time for that time zone. When this parameter is omitted, Gateway uses the time zone determined from the user's IP address. Colo time zone is used when the user's IP address does not resolve to a location.
     */
    timeZone?: string;
    tue?: string;
    wed?: string;
}

export interface ZeroTrustGatewaySettingsSettings {
    /**
     * Specify activity log settings.
     */
    activityLog?: outputs.ZeroTrustGatewaySettingsSettingsActivityLog;
    /**
     * Specify anti-virus settings.
     */
    antivirus?: outputs.ZeroTrustGatewaySettingsSettingsAntivirus;
    /**
     * Specify block page layout settings.
     */
    blockPage?: outputs.ZeroTrustGatewaySettingsSettingsBlockPage;
    /**
     * Specify the DLP inspection mode.
     */
    bodyScanning?: outputs.ZeroTrustGatewaySettingsSettingsBodyScanning;
    /**
     * Specify Clientless Browser Isolation settings.
     */
    browserIsolation?: outputs.ZeroTrustGatewaySettingsSettingsBrowserIsolation;
    /**
     * Specify certificate settings for Gateway TLS interception. If unset, the Cloudflare Root CA handles interception.
     */
    certificate?: outputs.ZeroTrustGatewaySettingsSettingsCertificate;
    /**
     * Specify custom certificate settings for BYO-PKI. This field is deprecated; use `certificate` instead.
     *
     * @deprecated This attribute is deprecated.
     */
    customCertificate?: outputs.ZeroTrustGatewaySettingsSettingsCustomCertificate;
    /**
     * Specify user email settings for the firewall policies. When this is enabled, we standardize the email addresses in the identity part of the rule, so that they match the extended email variants in the firewall policies. When this setting is turned off, the email addresses in the identity part of the rule will be matched exactly as provided. If your email has `.` or `+` modifiers, you should enable this setting.
     */
    extendedEmailMatching?: outputs.ZeroTrustGatewaySettingsSettingsExtendedEmailMatching;
    /**
     * Specify FIPS settings.
     */
    fips?: outputs.ZeroTrustGatewaySettingsSettingsFips;
    /**
     * Enable host selection in egress policies.
     */
    hostSelector?: outputs.ZeroTrustGatewaySettingsSettingsHostSelector;
    /**
     * Define the proxy inspection mode.
     */
    inspection?: outputs.ZeroTrustGatewaySettingsSettingsInspection;
    /**
     * Specify whether to detect protocols from the initial bytes of client traffic.
     */
    protocolDetection?: outputs.ZeroTrustGatewaySettingsSettingsProtocolDetection;
    /**
     * Specify whether to enable the sandbox.
     */
    sandbox?: outputs.ZeroTrustGatewaySettingsSettingsSandbox;
    /**
     * Specify whether to inspect encrypted HTTP traffic.
     */
    tlsDecrypt?: outputs.ZeroTrustGatewaySettingsSettingsTlsDecrypt;
}

export interface ZeroTrustGatewaySettingsSettingsActivityLog {
    /**
     * Specify whether to log activity.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsAntivirus {
    /**
     * Specify whether to enable anti-virus scanning on downloads.
     */
    enabledDownloadPhase: boolean;
    /**
     * Specify whether to enable anti-virus scanning on uploads.
     */
    enabledUploadPhase: boolean;
    /**
     * Specify whether to block requests for unscannable files.
     */
    failClosed: boolean;
    /**
     * Configure the message the user's device shows during an antivirus scan.
     */
    notificationSettings: outputs.ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings;
}

export interface ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings {
    /**
     * Specify whether to enable notifications.
     */
    enabled?: boolean;
    /**
     * Specify whether to include context information as query parameters.
     */
    includeContext?: boolean;
    /**
     * Specify the message to show in the notification.
     */
    msg?: string;
    /**
     * Specify a URL that directs users to more information. If unset, the notification opens a block page.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewaySettingsSettingsBlockPage {
    /**
     * Specify the block page background color in `#rrggbb` format when the mode is customized*block*page.
     */
    backgroundColor?: string;
    /**
     * Specify whether to enable the custom block page.
     */
    enabled?: boolean;
    /**
     * Specify the block page footer text when the mode is customized*block*page.
     */
    footerText?: string;
    /**
     * Specify the block page header text when the mode is customized*block*page.
     */
    headerText?: string;
    /**
     * Specify whether to append context to target*uri as query parameters. This applies only when the mode is redirect*uri.
     */
    includeContext?: boolean;
    /**
     * Specify the full URL to the logo file when the mode is customized*block*page.
     */
    logoPath?: string;
    /**
     * Specify the admin email for users to contact when the mode is customized*block*page.
     */
    mailtoAddress?: string;
    /**
     * Specify the subject line for emails created from the block page when the mode is customized*block*page.
     */
    mailtoSubject?: string;
    /**
     * Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
     * Available values: "", "customized*block*page", "redirectUri".
     */
    mode?: string;
    /**
     * Specify the block page title when the mode is customized*block*page.
     */
    name?: string;
    /**
     * Indicate that this setting was shared via the Orgs API and read only for the current account.
     */
    readOnly: boolean;
    /**
     * Indicate the account tag of the account that shared this setting.
     */
    sourceAccount: string;
    /**
     * Specify whether to suppress detailed information at the bottom of the block page when the mode is customized*block*page.
     */
    suppressFooter?: boolean;
    /**
     * Specify the URI to redirect users to when the mode is redirect_uri.
     */
    targetUri?: string;
    /**
     * Indicate the version number of the setting.
     */
    version: number;
}

export interface ZeroTrustGatewaySettingsSettingsBodyScanning {
    /**
     * Specify the inspection mode as either `deep` or `shallow`.
     * Available values: "deep", "shallow".
     */
    inspectionMode?: string;
}

export interface ZeroTrustGatewaySettingsSettingsBrowserIsolation {
    /**
     * Specify whether to enable non-identity onramp support for Browser Isolation.
     */
    nonIdentityEnabled?: boolean;
    /**
     * Specify whether to enable Clientless Browser Isolation.
     */
    urlBrowserIsolationEnabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsCertificate {
    /**
     * Specify the UUID of the certificate used for interception. Ensure the certificate is available at the edge(previously called 'active'). A nil UUID directs Cloudflare to use the Root CA.
     */
    id: string;
}

export interface ZeroTrustGatewaySettingsSettingsCustomCertificate {
    /**
     * Indicate the internal certificate status.
     */
    bindingStatus: string;
    /**
     * Specify whether to enable a custom certificate authority for signing Gateway traffic.
     */
    enabled: boolean;
    /**
     * Specify the UUID of the certificate (ID from MTLS certificate store).
     */
    id?: string;
    updatedAt: string;
}

export interface ZeroTrustGatewaySettingsSettingsExtendedEmailMatching {
    /**
     * Specify whether to match all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
     */
    enabled?: boolean;
    /**
     * Indicate that this setting was shared via the Orgs API and read only for the current account.
     */
    readOnly: boolean;
    /**
     * Indicate the account tag of the account that shared this setting.
     */
    sourceAccount: string;
    /**
     * Indicate the version number of the setting.
     */
    version: number;
}

export interface ZeroTrustGatewaySettingsSettingsFips {
    /**
     * Enforce cipher suites and TLS versions compliant with FIPS 140-2.
     */
    tls?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsHostSelector {
    /**
     * Specify whether to enable filtering via hosts for egress policies.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsInspection {
    /**
     * Define the proxy inspection mode.   1. static: Gateway applies static inspection to HTTP on TCP(80). With TLS decryption on, Gateway inspects HTTPS traffic on TCP(443) and UDP(443).   2. dynamic: Gateway applies protocol detection to inspect HTTP and HTTPS traffic on any port. TLS decryption must remain on to inspect HTTPS traffic.
     * Available values: "static", "dynamic".
     */
    mode?: string;
}

export interface ZeroTrustGatewaySettingsSettingsProtocolDetection {
    /**
     * Specify whether to detect protocols from the initial bytes of client traffic.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsSandbox {
    /**
     * Specify whether to enable the sandbox.
     */
    enabled?: boolean;
    /**
     * Specify the action to take when the system cannot scan the file.
     * Available values: "allow", "block".
     */
    fallbackAction?: string;
}

export interface ZeroTrustGatewaySettingsSettingsTlsDecrypt {
    /**
     * Specify whether to inspect encrypted HTTP traffic.
     */
    enabled?: boolean;
}

export interface ZeroTrustListItem {
    /**
     * Provide the list item description (optional).
     */
    description?: string;
    /**
     * Specify the item value.
     */
    value?: string;
}

export interface ZeroTrustLocalFallbackDomainDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustOrganizationCustomPages {
    /**
     * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
     */
    forbidden?: string;
    /**
     * The uid of the custom page to use when a user is denied access.
     */
    identityDenied?: string;
}

export interface ZeroTrustOrganizationLoginDesign {
    /**
     * The background color on your login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of your login page.
     */
    footerText?: string;
    /**
     * The text at the top of your login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on your login page.
     */
    logoPath?: string;
    /**
     * The text color on your login page.
     */
    textColor?: string;
}

export interface ZeroTrustRiskBehaviorBehaviors {
    enabled: boolean;
    /**
     * Available values: "low", "medium", "high".
     */
    riskLevel: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfig {
    /**
     * List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
     */
    ingresses?: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngress[];
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest?: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest;
    /**
     * Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
     */
    warpRouting: outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngress {
    /**
     * Public hostname for this service.
     */
    hostname?: string;
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest?: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest;
    /**
     * Requests with this path route to this public hostname.
     */
    path?: string;
    /**
     * Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
     */
    service: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access?: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout?: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader?: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout?: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive?: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout?: number;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required?: boolean;
    teamName: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access?: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout?: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader?: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout?: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive?: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout?: number;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required?: boolean;
    teamName: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigWarpRouting {
    enabled: boolean;
}

export interface ZeroTrustTunnelCloudflaredConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface ZeroTrustTunnelWarpConnectorConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface ZoneAccount {
    /**
     * Identifier
     */
    id?: string;
}

export interface ZoneCacheVariantsValue {
    /**
     * List of strings with the MIME types of all the variants that should be served for avif.
     */
    avifs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for bmp.
     */
    bmps?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for gif.
     */
    gifs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jp2.
     */
    jp2s?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpeg.
     */
    jpegs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpg2.
     */
    jpg2s?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpg.
     */
    jpgs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for png.
     */
    pngs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for tiff.
     */
    tiffs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for tif.
     */
    tifs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for webp.
     */
    webps?: string[];
}

export interface ZoneDnsSettingsInternalDns {
    /**
     * The ID of the zone to fallback to.
     */
    referenceZoneId?: string;
}

export interface ZoneDnsSettingsNameservers {
    /**
     * Configured nameserver set to be used for this zone
     */
    nsSet?: number;
    /**
     * Nameserver type
     * Available values: "cloudflare.standard", "custom.account", "custom.tenant", "custom.zone".
     */
    type?: string;
}

export interface ZoneDnsSettingsSoa {
    /**
     * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
     */
    expire?: number;
    /**
     * The time to live (TTL) for negative caching of records within the zone.
     */
    minTtl?: number;
    /**
     * The primary nameserver, which may be used for outbound zone transfers. If null, a Cloudflare-assigned value will be used.
     */
    mname?: string;
    /**
     * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
     */
    refresh?: number;
    /**
     * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
     */
    retry?: number;
    /**
     * The email address of the zone administrator, with the first label representing the local part of the email address.
     */
    rname?: string;
    /**
     * The time to live (TTL) of the SOA record itself.
     */
    ttl?: number;
}

export interface ZoneLockdownConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
     * Available values: "ip", "ipRange".
     */
    target?: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value?: string;
}

export interface ZoneMeta {
    /**
     * The zone is only configured for CDN.
     */
    cdnOnly: boolean;
    /**
     * Number of Custom Certificates the zone can have.
     */
    customCertificateQuota: number;
    /**
     * The zone is only configured for DNS.
     */
    dnsOnly: boolean;
    /**
     * The zone is setup with Foundation DNS.
     */
    foundationDns: boolean;
    /**
     * Number of Page Rules a zone can have.
     */
    pageRuleQuota: number;
    /**
     * The zone has been flagged for phishing.
     */
    phishingDetected: boolean;
    step: number;
}

export interface ZoneOwner {
    /**
     * Identifier
     */
    id: string;
    /**
     * Name of the owner.
     */
    name: string;
    /**
     * The type of owner.
     */
    type: string;
}

export interface ZonePlan {
    /**
     * States if the subscription can be activated.
     */
    canSubscribe: boolean;
    /**
     * The denomination of the customer.
     */
    currency: string;
    /**
     * If this Zone is managed by another company.
     */
    externallyManaged: boolean;
    /**
     * How often the customer is billed.
     */
    frequency: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * States if the subscription active.
     */
    isSubscribed: boolean;
    /**
     * If the legacy discount applies to this Zone.
     */
    legacyDiscount: boolean;
    /**
     * The legacy name of the plan.
     */
    legacyId: string;
    /**
     * Name of the owner.
     */
    name: string;
    /**
     * How much the customer is paying.
     */
    price: number;
}

export interface ZoneSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency?: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged?: boolean;
    /**
     * The ID of the rate plan.
     * Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partnersEnterprise".
     */
    id?: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract?: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName?: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope?: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets?: string[];
}

export interface ZoneTenant {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the Tenant account.
     */
    name: string;
}

export interface ZoneTenantUnit {
    /**
     * Identifier
     */
    id: string;
}

