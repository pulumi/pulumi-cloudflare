// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApplicationCorsHeader {
    /**
     * Value to determine whether all HTTP headers are exposed.
     */
    allowAllHeaders?: boolean;
    /**
     * Value to determine whether all methods are exposed.
     */
    allowAllMethods?: boolean;
    /**
     * Value to determine whether all origins are permitted to make CORS requests.
     */
    allowAllOrigins?: boolean;
    /**
     * Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
     */
    allowCredentials?: boolean;
    /**
     * List of HTTP headers to expose via CORS.
     */
    allowedHeaders?: string[];
    /**
     * List of methods to expose via CORS.
     */
    allowedMethods?: string[];
    /**
     * List of origins permitted to make CORS requests.
     */
    allowedOrigins?: string[];
    /**
     * The maximum time a preflight request will be cached.
     */
    maxAge?: number;
}

export interface AccessApplicationFooterLink {
    /**
     * The name of the footer link.
     */
    name?: string;
    /**
     * The URL of the footer link.
     */
    url?: string;
}

export interface AccessApplicationLandingPageDesign {
    /**
     * The button color of the landing page.
     */
    buttonColor?: string;
    /**
     * The button text color of the landing page.
     */
    buttonTextColor?: string;
    /**
     * The URL of the image to be displayed in the landing page.
     */
    imageUrl?: string;
    /**
     * The message of the landing page.
     */
    message?: string;
    /**
     * The title of the landing page.
     */
    title?: string;
}

export interface AccessApplicationSaasApp {
    /**
     * The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime?: string;
    /**
     * Allow PKCE flow without a client secret.
     */
    allowPkceWithoutClientSecret?: boolean;
    /**
     * The URL where this applications tile redirects users.
     */
    appLauncherUrl?: string;
    /**
     * **Modifying this attribute will force creation of a new resource.**
     */
    authType?: string;
    /**
     * The application client id.
     */
    clientId: string;
    /**
     * The application client secret, only returned on initial apply.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl?: string;
    /**
     * Custom attribute mapped from IDPs.
     */
    customAttributes?: outputs.AccessApplicationSaasAppCustomAttribute[];
    /**
     * Custom claim mapped from IDPs.
     */
    customClaims?: outputs.AccessApplicationSaasAppCustomClaim[];
    /**
     * The relay state used if not provided by the identity provider.
     */
    defaultRelayState?: string;
    /**
     * The OIDC flows supported by this application.
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
     */
    groupFilterRegex?: string;
    /**
     * Hybrid and Implicit Flow options.
     */
    hybridAndImplicitOptions?: outputs.AccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for the SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     */
    nameIdFormat?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata?: string;
    /**
     * The public certificate that will be used to verify identities.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
     */
    redirectUris?: string[];
    /**
     * Refresh token grant options.
     */
    refreshTokenOptions?: outputs.AccessApplicationSaasAppRefreshTokenOption[];
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata?: string;
    /**
     * Define the user information shared with access.
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId?: string;
    /**
     * The endpoint where the SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface AccessApplicationSaasAppCustomAttribute {
    /**
     * A friendly name for the attribute as provided to the SaaS app.
     */
    friendlyName?: string;
    /**
     * The name of the attribute as provided to the SaaS app.
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat?: string;
    /**
     * True if the attribute must be always present.
     */
    required?: boolean;
    source: outputs.AccessApplicationSaasAppCustomAttributeSource;
}

export interface AccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the attribute as provided by the IDP.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface AccessApplicationSaasAppCustomClaim {
    /**
     * The name of the attribute as provided to the SaaS app.
     */
    name?: string;
    /**
     * True if the attribute must be always present.
     */
    required?: boolean;
    /**
     * The scope of the claim.
     */
    scope?: string;
    source: outputs.AccessApplicationSaasAppCustomClaimSource;
}

export interface AccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the attribute as provided by the IDP.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface AccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If true, the authorization endpoint will return an access token.
     */
    returnAccessTokenFromAuthorizationEndpoint?: boolean;
    /**
     * If true, the authorization endpoint will return an id token.
     */
    returnIdTokenFromAuthorizationEndpoint?: boolean;
}

export interface AccessApplicationSaasAppRefreshTokenOption {
    /**
     * How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
     */
    lifetime?: string;
}

export interface AccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
     */
    authentication?: outputs.AccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete?: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled?: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings?: outputs.AccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface AccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    authorizationUrl?: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    clientId?: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    clientSecret?: string;
    /**
     * Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    password?: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    scopes?: string[];
    /**
     * Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    token?: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    tokenUrl?: string;
    /**
     * User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    user?: string;
}

export interface AccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled?: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter?: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations?: outputs.AccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata?: string;
}

export interface AccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
}

export interface AccessGroupExclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessGroupExcludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessGroupExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupExcludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupExcludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupExcludeOkta[];
    samls?: outputs.AccessGroupExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessGroupExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupInclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessGroupIncludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessGroupIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupIncludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupIncludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupIncludeOkta[];
    samls?: outputs.AccessGroupIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessGroupIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupRequire {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessGroupRequireAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessGroupRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupRequireExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupRequireGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupRequireOkta[];
    samls?: outputs.AccessGroupRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessGroupRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessIdentityProviderConfig {
    apiToken?: string;
    appsDomain?: string;
    attributes: string[];
    authUrl?: string;
    authorizationServerId?: string;
    centrifyAccount?: string;
    centrifyAppId?: string;
    certsUrl?: string;
    claims: string[];
    clientId?: string;
    clientSecret?: string;
    conditionalAccessEnabled?: boolean;
    directoryId?: string;
    emailAttributeName?: string;
    emailClaimName?: string;
    idpPublicCert?: string;
    issuerUrl?: string;
    oktaAccount?: string;
    oneloginAccount?: string;
    pingEnvId?: string;
    pkceEnabled?: boolean;
    redirectUrl: string;
    scopes: string[];
    signRequest?: boolean;
    ssoTargetUrl?: string;
    supportGroups?: boolean;
    tokenUrl?: string;
}

export interface AccessIdentityProviderScimConfig {
    enabled?: boolean;
    groupMemberDeprovision?: boolean;
    seatDeprovision?: boolean;
    secret: string;
    userDeprovision?: boolean;
}

export interface AccessMutualTlsHostnameSettingsSetting {
    /**
     * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
     */
    chinaNetwork?: boolean;
    /**
     * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
     */
    clientCertificateForwarding?: boolean;
    /**
     * The hostname that these settings apply to.
     */
    hostname: string;
}

export interface AccessOrganizationCustomPage {
    /**
     * The id of the forbidden page.
     */
    forbidden?: string;
    /**
     * The id of the identity denied page.
     */
    identityDenied?: string;
}

export interface AccessOrganizationLoginDesign {
    /**
     * The background color on the login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of the login page.
     */
    footerText?: string;
    /**
     * The text at the top of the login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on the login page.
     */
    logoPath?: string;
    /**
     * The text color on the login page.
     */
    textColor?: string;
}

export interface AccessPolicyApprovalGroup {
    /**
     * Number of approvals needed.
     */
    approvalsNeeded: number;
    /**
     * List of emails to request approval from.
     */
    emailAddresses?: string[];
    emailListUuid?: string;
}

export interface AccessPolicyExclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessPolicyExcludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessPolicyExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyExcludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyExcludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyExcludeOkta[];
    samls?: outputs.AccessPolicyExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessPolicyExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessPolicyExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessPolicyExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyInclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessPolicyIncludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessPolicyIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyIncludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyIncludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyIncludeOkta[];
    samls?: outputs.AccessPolicyIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessPolicyIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessPolicyIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessPolicyIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyRequire {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessPolicyRequireAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessPolicyRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common*name rules in a single policy.  Use in place of the singular common*name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyRequireExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyRequireGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyRequireOkta[];
    samls?: outputs.AccessPolicyRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessPolicyRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessPolicyRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessPolicyRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessRuleConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ip6`, `ipRange`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
     */
    target: string;
    /**
     * The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
     */
    value: string;
}

export interface AddressMapIp {
    /**
     * An IPv4 or IPv6 address.
     */
    ip: string;
}

export interface AddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete: boolean;
    /**
     * Identifier of the account or zone.
     */
    identifier: string;
    /**
     * The type of the membership.
     */
    kind: string;
}

export interface ApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic.
     */
    name?: string;
    /**
     * The type of characteristic. Available values: `header`, `cookie`.
     */
    type?: string;
}

export interface ApiTokenCondition {
    /**
     * Request IP related conditions.
     */
    requestIp?: outputs.ApiTokenConditionRequestIp;
}

export interface ApiTokenConditionRequestIp {
    /**
     * List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
     */
    ins?: string[];
    /**
     * List of IP addresses or CIDR notation where the token should not be used from.
     */
    notIns?: string[];
}

export interface ApiTokenPolicy {
    /**
     * Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
     */
    effect?: string;
    /**
     * List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
     */
    permissionGroups: string[];
    /**
     * Describes what operations against which resources are allowed or denied.
     */
    resources: {[key: string]: string};
}

export interface CertificatePackValidationError {
    message: string;
}

export interface CertificatePackValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: string;
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate?: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: string;
    /**
     * Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     */
    method?: string;
    /**
     * SSL/TLS settings for the certificate.
     */
    settings: outputs.CustomHostnameSslSetting[];
    status: string;
    /**
     * Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     */
    type?: string;
    validationErrors: outputs.CustomHostnameSslValidationError[];
    validationRecords: outputs.CustomHostnameSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: boolean;
}

export interface CustomHostnameSslSetting {
    /**
     * List of SSL/TLS ciphers to associate with this certificate.
     */
    ciphers?: string[];
    /**
     * Whether early hints should be supported. Available values: `on`, `off`.
     */
    earlyHints?: string;
    /**
     * Whether HTTP2 should be supported. Available values: `on`, `off`.
     */
    http2?: string;
    /**
     * Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
     */
    minTlsVersion?: string;
    /**
     * Whether TLSv1.3 should be supported. Available values: `on`, `off`.
     */
    tls13?: string;
}

export interface CustomHostnameSslValidationError {
    message: string;
}

export interface CustomHostnameSslValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomSslCustomSslOptions {
    /**
     * Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: string;
    /**
     * Certificate certificate and the intermediate(s).
     */
    certificate?: string;
    /**
     * Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highestSecurity`.
     */
    geoRestrictions?: string;
    /**
     * Certificate's private key.
     */
    privateKey?: string;
    /**
     * Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacyCustom`, `sniCustom`.
     */
    type?: string;
}

export interface CustomSslCustomSslPriority {
    /**
     * The ID of this resource.
     */
    id?: string;
    priority?: number;
}

export interface DeviceDexTestData {
    /**
     * The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
     */
    host: string;
    /**
     * The type of Device Dex Test. Available values: `http`, `traceroute`.
     */
    kind: string;
    /**
     * The http request method. Available values: `GET`.
     */
    method?: string;
}

export interface DeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface DevicePostureIntegrationConfig {
    /**
     * The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `apiUrl`.
     */
    accessClientId?: string;
    /**
     * The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `apiUrl`.
     */
    accessClientSecret?: string;
    /**
     * The third-party API's URL.
     */
    apiUrl?: string;
    /**
     * The third-party authorization API URL.
     */
    authUrl?: string;
    /**
     * The client identifier for authenticating API calls.
     */
    clientId?: string;
    /**
     * The client key for authenticating API calls.
     */
    clientKey?: string;
    /**
     * The client secret for authenticating API calls.
     */
    clientSecret?: string;
    /**
     * The customer identifier for authenticating API calls.
     */
    customerId?: string;
}

export interface DevicePostureRuleInput {
    /**
     * The number of active threats from SentinelOne.
     */
    activeThreats?: number;
    /**
     * The UUID of a Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * Specific volume(s) to check for encryption.
     */
    checkDisks?: string[];
    /**
     * The common name for a certificate.
     */
    cn?: string;
    /**
     * The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
     */
    complianceStatus?: string;
    /**
     * The workspace one connection id.
     */
    connectionId?: string;
    /**
     * The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    countOperator?: string;
    /**
     * The domain that the client must join.
     */
    domain?: string;
    /**
     * The datetime a device last seen in RFC 3339 format from Tanium.
     */
    eidLastSeen?: string;
    /**
     * True if the firewall must be enabled.
     */
    enabled: boolean;
    /**
     * Checks if the file should exist.
     */
    exists: boolean;
    /**
     * The Teams List id. Required for `serialNumber` and `uniqueClientId` rule types.
     */
    id?: string;
    /**
     * True if SentinelOne device is infected.
     */
    infected: boolean;
    /**
     * True if SentinelOne device is active.
     */
    isActive: boolean;
    /**
     * The number of issues for kolide.
     */
    issueCount?: string;
    /**
     * The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
     */
    lastSeen?: string;
    /**
     * The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
     */
    networkStatus?: string;
    /**
     * The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    operator?: string;
    /**
     * OS signal score from Crowdstrike. Value must be between 1 and 100.
     */
    os?: string;
    /**
     * The operating system excluding version information.
     */
    osDistroName?: string;
    /**
     * The operating system version excluding OS name information or release name.
     */
    osDistroRevision?: string;
    /**
     * Extra version value following the operating system semantic version.
     */
    osVersionExtra?: string;
    /**
     * Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
     */
    overall?: string;
    /**
     * The path to the file.
     */
    path?: string;
    /**
     * True if all drives must be encrypted.
     */
    requireAll: boolean;
    /**
     * The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
     */
    riskLevel?: string;
    /**
     * Checks if the application should be running.
     */
    running: boolean;
    /**
     * Sensor signal score from Crowdstrike. Value must be between 1 and 100.
     */
    sensorConfig?: string;
    /**
     * The sha256 hash of the file.
     */
    sha256?: string;
    /**
     * The hostâ€™s current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
     */
    state?: string;
    /**
     * The thumbprint of the file certificate.
     */
    thumbprint?: string;
    /**
     * The total score from Tanium.
     */
    totalScore?: number;
    /**
     * The operating system semantic version.
     */
    version?: string;
    /**
     * The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    versionOperator?: string;
}

export interface DevicePostureRuleMatch {
    /**
     * The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
     */
    platform?: string;
}

export interface DlpProfileContextAwareness {
    /**
     * Scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.DlpProfileContextAwarenessSkip;
}

export interface DlpProfileContextAwarenessSkip {
    /**
     * Return all matches, regardless of context analysis result, if the data is a file.
     */
    files: boolean;
}

export interface DlpProfileEntry {
    /**
     * Whether the entry is active. Defaults to `false`.
     */
    enabled?: boolean;
    /**
     * Unique entry identifier.
     */
    id: string;
    /**
     * Name of the entry to deploy.
     */
    name: string;
    pattern?: outputs.DlpProfileEntryPattern;
}

export interface DlpProfileEntryPattern {
    /**
     * The regex that defines the pattern.
     */
    regex: string;
    /**
     * The validation algorithm to apply with this pattern.
     */
    validation?: string;
}

export interface EmailRoutingCatchAllAction {
    /**
     * Type of supported action. Available values: `drop`, `forward`, `worker`.
     */
    type: string;
    /**
     * A list with items in the following form.
     */
    values: string[];
}

export interface EmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Available values: `all`.
     */
    type: string;
}

export interface EmailRoutingRuleAction {
    /**
     * Type of action. Available values: `forward`, `worker`, `drop`
     */
    type: string;
    /**
     * Value to match on. Required for `type` of `literal`.
     */
    values?: string[];
}

export interface EmailRoutingRuleMatcher {
    /**
     * Field to match on. Required for `type` of `literal`.
     */
    field?: string;
    /**
     * Type of matcher. Available values: `literal`, `all`
     */
    type: string;
    /**
     * Value to match on. Required for `type` of `literal`.
     */
    value?: string;
}

export interface FallbackDomainDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix?: string;
}

export interface GetAccountRolesRole {
    /**
     * Description of role's permissions.
     */
    description?: string;
    /**
     * Role identifier tag.
     */
    id?: string;
    /**
     * Role Name.
     */
    name?: string;
}

export interface GetAccountsAccount {
    /**
     * Whether 2FA is enforced on the account.
     */
    enforceTwofactor?: boolean;
    /**
     * Account ID.
     */
    id?: string;
    /**
     * Account name.
     */
    name?: string;
    /**
     * Account subscription type.
     */
    type?: string;
}

export interface GetDevicePostureRulesRule {
    description?: string;
    /**
     * Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
     */
    expiration?: string;
    /**
     * ID of the Device Posture Rule.
     */
    id: string;
    /**
     * Name of the device posture rule.
     */
    name?: string;
    /**
     * Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
     */
    schedule?: string;
    /**
     * The device posture rule type. Available values: `serialNumber`, `file`, `application`, `gateway`, `warp`, `domainJoined`, `osVersion`, `diskEncryption`, `firewall`, `clientCertificate`, `workspaceOne`, `uniqueClientId`, `crowdstrikeS2s`, `sentinelone`, `kolide`, `taniumS2s`, `intune`, `sentineloneS2s`
     */
    type: string;
}

export interface GetDevicesDevice {
    /**
     * When the device was created.
     */
    created?: string;
    /**
     * Whether the device has been deleted.
     */
    deleted?: boolean;
    /**
     * The type of the device.
     */
    deviceType?: string;
    /**
     * Device ID.
     */
    id?: string;
    /**
     * IPv4 or IPv6 address.
     */
    ip?: string;
    /**
     * The device's public key.
     */
    key?: string;
    /**
     * When the device was last seen.
     */
    lastSeen?: string;
    /**
     * The device's MAC address.
     */
    macAddress?: string;
    /**
     * The device manufacturer's name.
     */
    manufacturer?: string;
    /**
     * The device model name.
     */
    model?: string;
    /**
     * The device name.
     */
    name?: string;
    /**
     * The Linux distribution name.
     */
    osDistroName?: string;
    /**
     * The Linux distribution revision.
     */
    osDistroRevision?: string;
    /**
     * The operating system version.
     */
    osVersion?: string;
    /**
     * Extra version value following the operating system version.
     */
    osVersionExtra?: string;
    /**
     * When the device was revoked.
     */
    revokedAt?: string;
    /**
     * The device's serial number.
     */
    serialNumber?: string;
    /**
     * When the device was updated.
     */
    updated?: string;
    /**
     * User's email.
     */
    userEmail?: string;
    /**
     * User's ID.
     */
    userId?: string;
    /**
     * User's Name.
     */
    userName?: string;
    /**
     * The WARP client version.
     */
    version?: string;
}

export interface GetDlpDatasetsDataset {
    description: string;
    id: string;
    name: string;
    secret: boolean;
    status: string;
}

export interface GetListsList {
    /**
     * List description.
     */
    description?: string;
    /**
     * List identifier.
     */
    id?: string;
    /**
     * List kind.
     */
    kind?: string;
    /**
     * The list name to target for the resource.
     */
    name?: string;
    /**
     * Number of items in list.
     */
    numitems?: number;
}

export interface GetLoadBalancerPoolsFilter {
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name?: string;
}

export interface GetLoadBalancerPoolsPool {
    /**
     * List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
     */
    checkRegions: string[];
    /**
     * The RFC3339 timestamp of when the load balancer was created.
     */
    createdOn: string;
    /**
     * Brief description of the Load Balancer Pool intention.
     */
    description: string;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled: boolean;
    /**
     * ID for this load balancer pool.
     */
    id: string;
    /**
     * Latitude this pool is physically located at; used for proximity steering.
     */
    latitude: number;
    /**
     * Setting for controlling load shedding for this pool.
     */
    loadSheddings: outputs.GetLoadBalancerPoolsPoolLoadShedding[];
    /**
     * Longitude this pool is physically located at; used for proximity steering.
     */
    longitude: number;
    /**
     * Minimum number of origins that must be healthy for this pool to serve traffic.
     */
    minimumOrigins: number;
    /**
     * The RFC3339 timestamp of when the load balancer was last modified.
     */
    modifiedOn: string;
    /**
     * ID of the Monitor to use for health checking origins within this pool.
     */
    monitor: string;
    /**
     * Short name (tag) for the pool.
     */
    name: string;
    /**
     * Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
     */
    notificationEmail: string;
    /**
     * The list of origins within this pool.
     */
    origins: outputs.GetLoadBalancerPoolsPoolOrigin[];
}

export interface GetLoadBalancerPoolsPoolLoadShedding {
    /**
     * Percent of traffic to shed 0 - 100.
     */
    defaultPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`, `random`
     */
    defaultPolicy?: string;
    /**
     * Percent of session traffic to shed 0 - 100.
     */
    sessionPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`
     */
    sessionPolicy?: string;
}

export interface GetLoadBalancerPoolsPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
     */
    address: string;
    /**
     * Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks.
     */
    enabled?: boolean;
    /**
     * HTTP request headers.
     */
    headers?: outputs.GetLoadBalancerPoolsPoolOriginHeader[];
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId?: string;
    /**
     * The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="leastOutstandingRequests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="leastConnections"`, weight is used to scale the origin's open connections.
     */
    weight?: number;
}

export interface GetLoadBalancerPoolsPoolOriginHeader {
    /**
     * HTTP Header name.
     */
    header: string;
    /**
     * Values for the HTTP headers.
     */
    values: string[];
}

export interface GetRulesetsFilter {
    /**
     * The ID of the Ruleset to target.
     */
    id?: string;
    /**
     * Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
     */
    kind?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`.
     */
    phase?: string;
    /**
     * Version of the ruleset to filter on.
     */
    version?: string;
}

export interface GetRulesetsRuleset {
    /**
     * Brief summary of the ruleset and its intended use.
     */
    description?: string;
    /**
     * ID of the ruleset.
     */
    id: string;
    /**
     * Type of Ruleset. Available values: `custom`, `managed`, `root`, `zone`
     */
    kind: string;
    /**
     * Name of the ruleset.
     */
    name: string;
    /**
     * Point in the request/response lifecycle where the ruleset executes. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`
     */
    phase: string;
    /**
     * List of rules to apply to the ruleset.
     */
    rules?: outputs.GetRulesetsRulesetRule[];
    /**
     * Version of the ruleset.
     */
    version: string;
}

export interface GetRulesetsRulesetRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`
     */
    action?: string;
    /**
     * List of parameters that configure the behavior of the ruleset rule action.
     */
    actionParameters?: outputs.GetRulesetsRulesetRuleActionParameters;
    /**
     * Brief summary of the ruleset rule and its intended use.
     */
    description?: string;
    /**
     * Whether the rule is active.
     */
    enabled?: boolean;
    /**
     * List of parameters that configure exposed credential checks.
     */
    exposedCredentialCheck?: outputs.GetRulesetsRulesetRuleExposedCredentialCheck;
    /**
     * Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * The most recent update to this rule.
     */
    lastUpdated?: string;
    /**
     * List parameters to configure how the rule generates logs.
     */
    logging?: outputs.GetRulesetsRulesetRuleLogging;
    /**
     * List of parameters that configure HTTP rate limiting behaviour.
     */
    ratelimit?: outputs.GetRulesetsRulesetRuleRatelimit;
    /**
     * Rule reference.
     */
    ref: string;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface GetRulesetsRulesetRuleActionParameters {
    /**
     * Allows for the ability to support caching on non-standard ports.
     */
    additionalCacheablePorts?: number[];
    /**
     * Turn on or off Cloudflare Automatic HTTPS rewrites.
     */
    automaticHttpsRewrites?: boolean;
    /**
     * Indicate which file extensions to minify automatically.
     */
    autominifies?: outputs.GetRulesetsRulesetRuleActionParametersAutominify[];
    /**
     * Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
     */
    bic?: boolean;
    /**
     * List of browser TTL parameters to apply to the request.
     */
    browserTtl?: outputs.GetRulesetsRulesetRuleActionParametersBrowserTtl;
    /**
     * Whether to cache if expression matches.
     */
    cache?: boolean;
    /**
     * List of cache key parameters to apply to the request.
     */
    cacheKey?: outputs.GetRulesetsRulesetRuleActionParametersCacheKey;
    /**
     * Content of the custom error response
     */
    content?: string;
    /**
     * Content-Type of the custom error response
     */
    contentType?: string;
    /**
     * List of cookie values to include as part of custom fields logging.
     */
    cookieFields?: string[];
    /**
     * Turn off all active Cloudflare Apps.
     */
    disableApps?: boolean;
    /**
     * Turn off railgun feature of the Cloudflare Speed app.
     */
    disableRailgun?: boolean;
    /**
     * Turn off zaraz feature.
     */
    disableZaraz?: boolean;
    /**
     * List of edge TTL parameters to apply to the request.
     */
    edgeTtl?: outputs.GetRulesetsRulesetRuleActionParametersEdgeTtl;
    /**
     * Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
     */
    emailObfuscation?: boolean;
    /**
     * Use a list to lookup information for the action.
     */
    fromList?: outputs.GetRulesetsRulesetRuleActionParametersFromList;
    /**
     * Use a value to lookup information for the action.
     */
    fromValue?: outputs.GetRulesetsRulesetRuleActionParametersFromValue;
    /**
     * List of HTTP header modifications to perform in the ruleset rule.
     */
    headers?: outputs.GetRulesetsRulesetRuleActionParametersHeader[];
    /**
     * Host Header that request origin receives.
     */
    hostHeader?: string;
    /**
     * Turn on or off the hotlink protection feature.
     */
    hotlinkProtection?: boolean;
    /**
     * Identifier of the action parameter to modify.
     */
    id?: string;
    increment?: number;
    /**
     * List of properties to configure WAF payload logging.
     */
    matchedData?: outputs.GetRulesetsRulesetRuleActionParametersMatchedData;
    /**
     * Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
     */
    mirage?: boolean;
    /**
     * Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    opportunisticEncryption?: boolean;
    /**
     * List of properties to change request origin.
     */
    origin?: outputs.GetRulesetsRulesetRuleActionParametersOrigin;
    /**
     * Sets a more compliant mode for parsing Cache Control headers
     */
    originCacheControl?: boolean;
    /**
     * Pass-through error page for origin.
     */
    originErrorPagePassthru?: boolean;
    /**
     * List of override configurations to apply to the ruleset.
     */
    overrides?: outputs.GetRulesetsRulesetRuleActionParametersOverrides;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`
     */
    phases?: string[];
    /**
     * Apply options from the Polish feature of the Cloudflare Speed app.
     */
    polish?: string;
    /**
     * Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`
     */
    products?: string[];
    /**
     * Sets the timeout value for reading content from an origin server.
     */
    readTimeout?: number;
    /**
     * List of request headers to include as part of custom fields logging, in lowercase.
     */
    requestFields?: string[];
    /**
     * Respect strong ETags.
     */
    respectStrongEtags?: boolean;
    /**
     * List of response headers to include as part of custom fields logging, in lowercase.
     */
    responseFields?: string[];
    /**
     * List of parameters that configure the response given to end users
     */
    responses?: outputs.GetRulesetsRulesetRuleActionParametersResponse[];
    /**
     * Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
     */
    rocketLoader?: boolean;
    /**
     * Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`
     */
    rules?: {[key: string]: string};
    /**
     * Which ruleset ID to target.
     */
    ruleset?: string;
    /**
     * List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip
     */
    rulesets?: string[];
    /**
     * Control options for the Security Level feature from the Security app.
     */
    securityLevel?: string;
    /**
     * List of serve stale parameters to apply to the request.
     */
    serveStale?: outputs.GetRulesetsRulesetRuleActionParametersServeStale;
    /**
     * Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
     */
    serverSideExcludes?: boolean;
    /**
     * List of properties to manange Server Name Indication.
     */
    sni?: outputs.GetRulesetsRulesetRuleActionParametersSni;
    /**
     * Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    ssl?: string;
    /**
     * HTTP status code of the custom error response
     */
    statusCode?: number;
    /**
     * Turn on or off the SXG feature.
     */
    sxg?: boolean;
    /**
     * List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
     */
    uri?: outputs.GetRulesetsRulesetRuleActionParametersUri;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface GetRulesetsRulesetRuleActionParametersAutominify {
    /**
     * SSL minification.
     */
    css?: boolean;
    /**
     * HTML minification.
     */
    html?: boolean;
    /**
     * JS minification.
     */
    js?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersBrowserTtl {
    /**
     * Default browser TTL.
     */
    default?: number;
    /**
     * Mode of the browser TTL.
     */
    mode: string;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKey {
    /**
     * Cache by device type. Conflicts with "custom_key.user.device_type".
     */
    cacheByDeviceType?: boolean;
    /**
     * Cache deception armor.
     */
    cacheDeceptionArmor?: boolean;
    /**
     * Custom key parameters for the request.
     */
    customKey?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKey;
    /**
     * Ignore query strings order.
     */
    ignoreQueryStringsOrder?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * Cookie parameters for the custom key.
     */
    cookie?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie;
    /**
     * Header parameters for the custom key.
     */
    header?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader;
    /**
     * Host parameters for the custom key.
     */
    host?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost;
    /**
     * Query string parameters for the custom key.
     */
    queryString?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    /**
     * User parameters for the custom key.
     */
    user?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * List of cookies to check for presence in the custom key.
     */
    checkPresences?: string[];
    /**
     * List of cookies to include in the custom key.
     */
    includes?: string[];
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * List of headers to check for presence in the custom key.
     */
    checkPresences?: string[];
    /**
     * Exclude the origin header from the custom key.
     */
    excludeOrigin?: boolean;
    /**
     * List of headers to include in the custom key.
     */
    includes?: string[];
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Resolve hostname to IP address.
     */
    resolved?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * List of query string parameters to exclude from the custom key. Conflicts with "include".
     */
    excludes?: string[];
    /**
     * List of query string parameters to include in the custom key. Conflicts with "exclude".
     */
    includes?: string[];
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Add device type to the custom key. Conflicts with "cache_key.cache_by_device_type".
     */
    deviceType?: boolean;
    /**
     * Add geo data to the custom key.
     */
    geo?: boolean;
    /**
     * Add language data to the custom key.
     */
    lang?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersEdgeTtl {
    /**
     * Default edge TTL
     */
    default?: number;
    /**
     * Mode of the edge TTL.
     */
    mode: string;
    /**
     * Edge TTL for the status codes.
     */
    statusCodeTtls?: outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * Status code for which the edge TTL is applied. Conflicts with "statusCodeRange".
     */
    statusCode?: number;
    /**
     * Status code range for which the edge TTL is applied. Conflicts with "statusCode".
     */
    statusCodeRanges?: outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange[];
    /**
     * Status code edge TTL value.
     */
    value: number;
}

export interface GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * From status code.
     */
    from?: number;
    /**
     * To status code.
     */
    to?: number;
}

export interface GetRulesetsRulesetRuleActionParametersFromList {
    /**
     * Expression to use for the list lookup.
     */
    key: string;
    /**
     * Name of the list.
     */
    name: string;
}

export interface GetRulesetsRulesetRuleActionParametersFromValue {
    /**
     * Preserve query string for redirect URL.
     */
    preserveQueryString?: boolean;
    /**
     * Status code for redirect.
     */
    statusCode?: number;
    /**
     * Target URL for redirect.
     */
    targetUrl?: outputs.GetRulesetsRulesetRuleActionParametersFromValueTargetUrl;
}

export interface GetRulesetsRulesetRuleActionParametersFromValueTargetUrl {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `"value"`.
     */
    expression?: string;
    /**
     * Static value to provide as the HTTP request header value. Conflicts with `"expression"`.
     */
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersHeader {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions. Conflicts with `"value"`.
     */
    expression?: string;
    /**
     * Name of the HTTP request header to target.
     */
    name?: string;
    /**
     * Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`
     */
    operation?: string;
    /**
     * Static value to provide as the HTTP request header value. Conflicts with `"expression"`.
     */
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersMatchedData {
    /**
     * Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure)
     */
    publicKey?: string;
}

export interface GetRulesetsRulesetRuleActionParametersOrigin {
    /**
     * Origin Hostname where request is sent.
     */
    host?: string;
    /**
     * Origin Port where request is sent.
     */
    port?: number;
}

export interface GetRulesetsRulesetRuleActionParametersOverrides {
    /**
     * Action to perform in the rule-level override. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`
     */
    action?: string;
    /**
     * List of tag-based overrides.
     */
    categories?: outputs.GetRulesetsRulesetRuleActionParametersOverridesCategory[];
    /**
     * Defines if the current ruleset-level override enables or disables the ruleset.
     *
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * List of rule-based overrides.
     */
    rules?: outputs.GetRulesetsRulesetRuleActionParametersOverridesRule[];
    /**
     * Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`
     */
    sensitivityLevel?: string;
    /**
     * Defines if the current ruleset-level override enables or disables the ruleset. Available values: `enabled`, `disabled`
     */
    status?: string;
}

export interface GetRulesetsRulesetRuleActionParametersOverridesCategory {
    /**
     * Action to perform in the tag-level override. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`
     */
    action?: string;
    /**
     * Tag name to apply the ruleset rule override to.
     */
    category?: string;
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
     *
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag. Available values: `enabled`, `disabled`
     */
    status?: string;
}

export interface GetRulesetsRulesetRuleActionParametersOverridesRule {
    /**
     * Action to perform in the rule-level override. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`
     */
    action?: string;
    /**
     * Defines if the current rule-level override enables or disables the rule.
     *
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
    /**
     * Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
     */
    scoreThreshold?: number;
    /**
     * Sensitivity level for a ruleset rule override.
     */
    sensitivityLevel?: string;
    /**
     * Defines if the current rule-level override enables or disables the rule. Available values: `enabled`, `disabled`
     */
    status?: string;
}

export interface GetRulesetsRulesetRuleActionParametersResponse {
    /**
     * Body content to include in the response.
     */
    content?: string;
    /**
     * HTTP content type to send in the response.
     */
    contentType?: string;
    /**
     * HTTP status code to send in the response.
     */
    statusCode?: number;
}

export interface GetRulesetsRulesetRuleActionParametersServeStale {
    /**
     * Disable stale while updating.
     */
    disableStaleWhileUpdating?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersSni {
    /**
     * Value to define for SNI.
     */
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersUri {
    origin?: boolean;
    /**
     * URI path configuration when performing a URL rewrite.
     */
    path?: outputs.GetRulesetsRulesetRuleActionParametersUriPath;
    /**
     * Query string configuration when performing a URL rewrite.
     */
    query?: outputs.GetRulesetsRulesetRuleActionParametersUriQuery;
}

export interface GetRulesetsRulesetRuleActionParametersUriPath {
    /**
     * Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
     */
    expression?: string;
    /**
     * Static string value of the updated URI path or query string component.
     */
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersUriQuery {
    /**
     * Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions
     */
    expression?: string;
    /**
     * Static string value of the updated URI path or query string component.
     */
    value?: string;
}

export interface GetRulesetsRulesetRuleExposedCredentialCheck {
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    passwordExpression?: string;
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    usernameExpression?: string;
}

export interface GetRulesetsRulesetRuleLogging {
    /**
     * Override the default logging behavior when a rule is matched.
     *
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * Override the default logging behavior when a rule is matched. Available values: `enabled`, `disabled`
     */
    status?: string;
}

export interface GetRulesetsRulesetRuleRatelimit {
    /**
     * List of parameters that define how Cloudflare tracks the request rate for this rule.
     */
    characteristics?: string[];
    /**
     * Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    countingExpression?: string;
    /**
     * Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
     */
    mitigationTimeout?: number;
    /**
     * The period of time to consider (in seconds) when evaluating the request rate.
     */
    period?: number;
    /**
     * The number of requests over the period of time that will trigger the Rate Limiting rule.
     */
    requestsPerPeriod?: number;
    /**
     * Whether to include requests to origin within the Rate Limiting count.
     */
    requestsToOrigin?: boolean;
    /**
     * The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
     */
    scorePerPeriod?: number;
    /**
     * Name of HTTP header in the response, set by the origin server, with the score for the current request.
     */
    scoreResponseHeaderName?: string;
}

export interface GetZonesFilter {
    /**
     * The account identifier to target for the resource.
     */
    accountId?: string;
    /**
     * The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
     */
    lookupType?: string;
    /**
     * A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookupType`	are performed on the Cloudflare server side.
     */
    match?: string;
    /**
     * A string value to search for.
     */
    name?: string;
    /**
     * Paused status of the zone to lookup. Defaults to `false`.
     */
    paused?: boolean;
    /**
     * Status of the zone to lookup.
     */
    status?: string;
}

export interface GetZonesZone {
    /**
     * The zone ID.
     */
    id?: string;
    /**
     * Zone name.
     */
    name?: string;
}

export interface HealthcheckHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of string values for the header.
     */
    values: string[];
}

export interface HyperdriveConfigCaching {
    /**
     * Disable caching for this Hyperdrive configuration.
     */
    disabled: boolean;
}

export interface HyperdriveConfigOrigin {
    /**
     * The name of your origin database.
     */
    database: string;
    /**
     * The host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * The password of the Hyperdrive configuration.
     */
    password: string;
    /**
     * The port (default: 5432 for Postgres) of your origin database.
     */
    port: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     */
    scheme: string;
    /**
     * The user of your origin database.
     */
    user: string;
}

export interface ListItem {
    /**
     * An optional comment for the item.
     */
    comment?: string;
    value: outputs.ListItemValue;
}

export interface ListItemHostname {
    /**
     * The FQDN to match on.
     */
    urlHostname: string;
}

export interface ListItemRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url.
     */
    includeSubdomains?: boolean;
    /**
     * Whether the redirect target url should keep the query string of the request's url.
     */
    preservePathSuffix?: boolean;
    /**
     * Whether the redirect target url should keep the query string of the request's url.
     */
    preserveQueryString?: boolean;
    /**
     * The source url of the redirect.
     */
    sourceUrl: string;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: number;
    /**
     * Whether the redirect also matches subpaths of the source url.
     */
    subpathMatching?: boolean;
    /**
     * The target url of the redirect.
     */
    targetUrl: string;
}

export interface ListItemValue {
    asn?: number;
    hostnames?: outputs.ListItemValueHostname[];
    ip?: string;
    redirects?: outputs.ListItemValueRedirect[];
}

export interface ListItemValueHostname {
    /**
     * The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
     */
    urlHostname: string;
}

export interface ListItemValueRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
     */
    includeSubdomains?: string;
    /**
     * Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
     */
    preservePathSuffix?: string;
    /**
     * Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
     */
    preserveQueryString?: string;
    /**
     * The source url of the redirect.
     */
    sourceUrl: string;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: number;
    /**
     * Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
     */
    subpathMatching?: string;
    /**
     * The target url of the redirect.
     */
    targetUrl: string;
}

export interface LoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
     */
    failoverAcrossPools?: boolean;
}

export interface LoadBalancerCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: string[];
}

export interface LoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolverIp` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolverIp`. Defaults to `pop`.
     */
    mode?: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
     */
    preferEcs?: string;
}

export interface LoadBalancerMonitorHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of values for the header.
     */
    values: string[];
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * Percent of traffic to shed 0 - 100. Defaults to `0`.
     */
    defaultPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
     */
    defaultPolicy?: string;
    /**
     * Percent of session traffic to shed 0 - 100. Defaults to `0`.
     */
    sessionPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
     */
    sessionPolicy?: string;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
     */
    address: string;
    /**
     * Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * HTTP request headers.
     */
    headers?: outputs.LoadBalancerPoolOriginHeader[];
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId?: string;
    /**
     * The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="leastOutstandingRequests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="leastConnections"`, weight is used to scale the origin's open connections. Defaults to `1`.
     */
    weight?: number;
}

export interface LoadBalancerPoolOriginHeader {
    /**
     * HTTP Header name.
     */
    header: string;
    /**
     * Values for the HTTP headers.
     */
    values: string[];
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `leastOutstandingRequests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `leastConnections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `leastOutstandingRequests`, `leastConnections`. Defaults to `random`.
     */
    policy?: string;
}

export interface LoadBalancerPopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `poolWeights` map.
     */
    defaultWeight?: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRule {
    /**
     * The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
     */
    condition?: string;
    /**
     * A disabled rule will not be executed.
     */
    disabled?: boolean;
    /**
     * Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixedResponse` must be set.
     */
    fixedResponse?: outputs.LoadBalancerRuleFixedResponse;
    /**
     * Human readable name for this rule.
     */
    name: string;
    /**
     * The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixedResponse` must be set.
     */
    overrides?: outputs.LoadBalancerRuleOverride[];
    /**
     * Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
     */
    priority: number;
    /**
     * Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixedResponse` forces this field to `true`.
     */
    terminates: boolean;
}

export interface LoadBalancerRuleFixedResponse {
    /**
     * The value of the HTTP context-type header for this fixed response.
     */
    contentType?: string;
    /**
     * The value of the HTTP location header for this fixed response.
     */
    location?: string;
    /**
     * The text used as the html body for this fixed response.
     */
    messageBody?: string;
    /**
     * The HTTP status code used for this fixed response.
     */
    statusCode?: number;
}

export interface LoadBalancerRuleOverride {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     */
    adaptiveRoutings?: outputs.LoadBalancerRuleOverrideAdaptiveRouting[];
    /**
     * A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     */
    countryPools: outputs.LoadBalancerRuleOverrideCountryPool[];
    /**
     * A list of pool IDs ordered by their failover priority. Used whenever `popPools`/`countryPools`/`regionPools` are not defined.
     */
    defaultPools?: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool?: string;
    /**
     * Controls location-based steering for non-proxied requests.
     */
    locationStrategies?: outputs.LoadBalancerRuleOverrideLocationStrategy[];
    /**
     * A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     */
    popPools: outputs.LoadBalancerRuleOverridePopPool[];
    /**
     * Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="leastOutstandingRequests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="leastConnections"`, pool weights are used to scale each pool's open connections.
     */
    randomSteerings?: outputs.LoadBalancerRuleOverrideRandomSteering[];
    /**
     * A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     */
    regionPools: outputs.LoadBalancerRuleOverrideRegionPool[];
    /**
     * Configure attributes for session affinity.
     */
    sessionAffinity?: string;
    /**
     * Configure attributes for session affinity. Note that the property `drainDuration` is not currently supported as a rule override.
     */
    sessionAffinityAttributes?: outputs.LoadBalancerRuleOverrideSessionAffinityAttribute[];
    /**
     * Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `sessionAffinityTtl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     */
    sessionAffinityTtl?: number;
    /**
     * The method the load balancer uses to determine the route to your origin. Value `off` uses `defaultPoolIds`. Value `geo` uses `popPools`/`countryPools`/`regionPools`. For non-proxied requests, the `country` for `countryPools` is determined by `locationStrategy`. Value `random` selects a pool randomly. Value `dynamicLatency` uses round trip time to select the closest pool in `defaultPoolIds` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `locationStrategy` for non-proxied requests. Value `leastOutstandingRequests` selects a pool by taking into consideration `randomSteering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `leastConnections` selects a pool by taking into consideration `randomSteering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `popPools`/`countryPools`/`regionPools` otherwise `off`. Available values: `off`, `geo`, `dynamicLatency`, `random`, `proximity`, `leastOutstandingRequests`, `leastConnections`, `""` Defaults to `""`.
     */
    steeringPolicy?: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
     */
    ttl?: number;
}

export interface LoadBalancerRuleOverrideAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
     */
    failoverAcrossPools?: boolean;
}

export interface LoadBalancerRuleOverrideCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: string[];
}

export interface LoadBalancerRuleOverrideLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolverIp` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolverIp`.
     */
    mode?: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
     */
    preferEcs?: string;
}

export interface LoadBalancerRuleOverridePopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRuleOverrideRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `poolWeights` map.
     */
    defaultWeight?: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRuleOverrideRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRuleOverrideSessionAffinityAttribute {
    /**
     * Configures the HTTP header names to use when header session affinity is enabled.
     */
    headers?: string[];
    /**
     * Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
     */
    requireAllHeaders?: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
     */
    samesite?: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
     */
    secure?: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
     */
    zeroDowntimeFailover?: string;
}

export interface LoadBalancerSessionAffinityAttribute {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
     */
    drainDuration?: number;
    /**
     * Configures the HTTP header names to use when header session affinity is enabled.
     */
    headers?: string[];
    /**
     * Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
     */
    requireAllHeaders?: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
     */
    samesite?: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
     */
    secure?: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
     */
    zeroDowntimeFailover?: string;
}

export interface LogpushJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix?: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix?: string;
    /**
     * Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
     */
    cve20214428?: boolean;
    /**
     * String to join fields. This field be ignored when recordTemplate is set. Defaults to `,`.
     */
    fieldDelimiter?: string;
    /**
     * List of field names to be included in the Logpush output.
     */
    fieldNames?: string[];
    /**
     * Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
     */
    outputType?: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter?: string;
    /**
     * String to be prepended before each record. Defaults to `{`.
     */
    recordPrefix?: string;
    /**
     * String to be appended after each record. Defaults to `}
     * `.
     */
    recordSuffix?: string;
    /**
     * String to use as template for each record instead of the default comma-separated list.
     */
    recordTemplate?: string;
    /**
     * Specifies the sampling rate. Defaults to `1`.
     */
    sampleRate?: number;
    /**
     * Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
     */
    timestampFormat?: string;
}

export interface ManagedHeadersManagedRequestHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface ManagedHeadersManagedResponseHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface NotificationPolicyEmailIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
}

export interface NotificationPolicyFilters {
    /**
     * Targeted actions for alert.
     */
    actions?: string[];
    /**
     * Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
     */
    affectedComponents?: string[];
    /**
     * Filter on Points of Presence.
     */
    airportCodes?: string[];
    /**
     * Alert trigger preferences. Example: `slo`.
     */
    alertTriggerPreferences?: string[];
    /**
     * State of the pool to alert on.
     */
    enableds?: string[];
    /**
     * Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
     */
    environments?: string[];
    /**
     * Source configuration to alert on for pool or origin.
     */
    eventSources?: string[];
    /**
     * Stream event type to alert on.
     */
    eventTypes?: string[];
    /**
     * Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
     */
    events?: string[];
    /**
     * Alert grouping.
     */
    groupBies?: string[];
    /**
     * Identifier health check. Required when using `filters.0.status`.
     */
    healthCheckIds?: string[];
    /**
     * The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
     */
    incidentImpacts?: string[];
    /**
     * Stream input id to alert on.
     */
    inputIds?: string[];
    /**
     * A numerical limit. Example: `100`.
     */
    limits?: string[];
    /**
     * Megabits per second threshold for dos alert.
     */
    megabitsPerSeconds?: string[];
    /**
     * Health status to alert on for pool or origin.
     */
    newHealths?: string[];
    /**
     * Tunnel health status to alert on.
     */
    newStatuses?: string[];
    /**
     * Packets per second threshold for dos alert.
     */
    packetsPerSeconds?: string[];
    /**
     * Load balancer pool identifier.
     */
    poolIds?: string[];
    /**
     * Product name. Available values: `workerRequests`, `workerDurableObjectsRequests`, `workerDurableObjectsDuration`, `workerDurableObjectsDataTransfer`, `workerDurableObjectsStoredData`, `workerDurableObjectsStorageDeletes`, `workerDurableObjectsStorageWrites`, `workerDurableObjectsStorageReads`.
     */
    products?: string[];
    /**
     * Identifier of pages project.
     */
    projectIds?: string[];
    /**
     * Protocol to alert on for dos.
     */
    protocols?: string[];
    /**
     * Requests per second threshold for dos alert.
     */
    requestsPerSeconds?: string[];
    /**
     * Selectors for alert. Valid options depend on the alert type.
     */
    selectors?: string[];
    services?: string[];
    /**
     * A numerical limit. Example: `99.9`.
     */
    slos?: string[];
    /**
     * Status to alert on.
     */
    statuses?: string[];
    /**
     * Target host to alert on for dos.
     */
    targetHostnames?: string[];
    /**
     * Target ip to alert on for dos in CIDR notation.
     */
    targetIps?: string[];
    /**
     * Target domain to alert on.
     */
    targetZoneNames?: string[];
    /**
     * Tunnel IDs to alert on.
     */
    tunnelIds?: string[];
    /**
     * Tunnel Names to alert on.
     */
    tunnelNames?: string[];
    /**
     * Filter for alert.
     */
    wheres?: string[];
    /**
     * A list of zone identifiers.
     */
    zones?: string[];
}

export interface NotificationPolicyPagerdutyIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
}

export interface NotificationPolicyWebhooksIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    name?: string;
}

export interface PageRuleActions {
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    alwaysUseHttps?: boolean;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    automaticHttpsRewrites?: string;
    /**
     * The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
     */
    browserCacheTtl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    browserCheck?: string;
    /**
     * String value of cookie name to conditionally bypass cache the page.
     */
    bypassCacheOnCookie?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheByDeviceType?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheDeceptionArmor?: string;
    /**
     * Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
     */
    cacheKeyFields?: outputs.PageRuleActionsCacheKeyFields;
    /**
     * Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cacheEverything"`.
     */
    cacheLevel?: string;
    /**
     * String value of cookie name to conditionally cache the page.
     */
    cacheOnCookie?: string;
    /**
     * Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
     */
    cacheTtlByStatuses?: outputs.PageRuleActionsCacheTtlByStatus[];
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableApps?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disablePerformance?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableRailgun?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableSecurity?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableZaraz?: boolean;
    /**
     * The Time To Live for the edge cache.
     */
    edgeCacheTtl?: number;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    emailObfuscation?: string;
    /**
     * Whether origin Cache-Control action is `"on"` or `"off"`.
     */
    explicitCacheControl?: string;
    /**
     * The URL to forward to, and with what status. See below.
     */
    forwardingUrl?: outputs.PageRuleActionsForwardingUrl;
    /**
     * Value of the Host header to send.
     */
    hostHeaderOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    ipGeolocation?: string;
    /**
     * The configuration for HTML, CSS and JS minification. See below for full list of options.
     */
    minifies?: outputs.PageRuleActionsMinify[];
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    mirage?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    opportunisticEncryption?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    originErrorPagePassThru?: string;
    /**
     * Whether this action is `"off"`, `"lossless"` or `"lossy"`.
     */
    polish?: string;
    /**
     * Overridden origin server name.
     */
    resolveOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    respectStrongEtag?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    responseBuffering?: string;
    /**
     * Whether to set the rocket loader to `"on"`, `"off"`.
     */
    rocketLoader?: string;
    /**
     * Whether to set the security level to `"off"`, `"essentiallyOff"`, `"low"`, `"medium"`, `"high"`, or `"underAttack"`.
     */
    securityLevel?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    serverSideExclude?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    sortQueryStringForCache?: string;
    /**
     * Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"originPull"`.
     */
    ssl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    trueClientIpHeader?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    waf?: string;
}

export interface PageRuleActionsCacheKeyFields {
    /**
     * Controls what cookies go into Cache Key:
     */
    cookie?: outputs.PageRuleActionsCacheKeyFieldsCookie;
    /**
     * Controls what HTTP headers go into Cache Key:
     */
    header?: outputs.PageRuleActionsCacheKeyFieldsHeader;
    /**
     * Controls which Host header goes into Cache Key:
     */
    host: outputs.PageRuleActionsCacheKeyFieldsHost;
    /**
     * Controls which URL query string parameters go into the Cache Key.
     */
    queryString: outputs.PageRuleActionsCacheKeyFieldsQueryString;
    /**
     * Controls which end user-related features go into the Cache Key.
     */
    user: outputs.PageRuleActionsCacheKeyFieldsUser;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    /**
     * Check for presence of specified cookies, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Use values of specified cookies in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    /**
     * Check for presence of specified HTTP headers, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
     */
    excludes: string[];
    /**
     * Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHost {
    /**
     * `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
     */
    resolved?: boolean;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    /**
     * Exclude these query string parameters from Cache Key.
     */
    excludes: string[];
    /**
     * `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
     */
    ignore: boolean;
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsUser {
    /**
     * `true` - classifies a request as â€œmobileâ€, â€œdesktopâ€, or â€œtabletâ€ based on the User Agent; defaults to `false`.
     */
    deviceType: boolean;
    /**
     * `true` - includes the clientâ€™s country, derived from the IP address; defaults to `false`.
     */
    geo: boolean;
    /**
     * `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
     *
     * Example:
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as cloudflare from "@pulumi/cloudflare";
     *
     * // Unrealistic example with all features used
     * const foobar = new cloudflare.PageRule("foobar", {
     *     zoneId: cloudflareZoneId,
     *     target: `${cloudflareZone}/app/*`,
     *     priority: 1,
     *     actions: {
     *         cacheKeyFields: {
     *             cookie: {
     *                 checkPresences: ["wordpress_test_cookie"],
     *             },
     *             header: {
     *                 checkPresences: ["header_present"],
     *                 excludes: ["origin"],
     *                 includes: [
     *                     "api-key",
     *                     "dnt",
     *                 ],
     *             },
     *             host: {
     *                 resolved: true,
     *             },
     *             queryString: {
     *                 ignore: true,
     *             },
     *             user: {
     *                 deviceType: false,
     *                 geo: true,
     *                 lang: true,
     *             },
     *         },
     *     },
     * });
     * ```
     */
    lang: boolean;
}

export interface PageRuleActionsCacheTtlByStatus {
    /**
     * A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
     */
    codes: string;
    /**
     * Duration a resource lives in the Cloudflare cache.
     * - positive number - cache for specified duration in seconds
     */
    ttl: number;
}

export interface PageRuleActionsForwardingUrl {
    /**
     * The status code to use for the redirection.
     */
    statusCode: number;
    /**
     * The URL to which the page rule should forward.
     */
    url: string;
}

export interface PageRuleActionsMinify {
    /**
     * Whether CSS should be minified. Valid values are `"on"` or `"off"`.
     */
    css: string;
    /**
     * Whether HTML should be minified. Valid values are `"on"` or `"off"`.
     */
    html: string;
    /**
     * Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
     */
    js: string;
}

export interface PagesProjectBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching?: boolean;
    /**
     * Command used to build project.
     */
    buildCommand?: string;
    /**
     * Output directory of the build.
     */
    destinationDir?: string;
    /**
     * Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
     */
    rootDir?: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag?: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken?: string;
}

export interface PagesProjectDeploymentConfigs {
    /**
     * Configuration for preview deploys.
     */
    preview: outputs.PagesProjectDeploymentConfigsPreview;
    /**
     * Configuration for production deploys.
     */
    production: outputs.PagesProjectDeploymentConfigsProduction;
}

export interface PagesProjectDeploymentConfigsPreview {
    /**
     * Use latest compatibility date for Pages Functions. Defaults to `false`.
     */
    alwaysUseLatestCompatibilityDate?: boolean;
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 Databases used for Pages Functions. Defaults to `map[]`.
     */
    d1Databases?: {[key: string]: any};
    /**
     * Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
     */
    durableObjectNamespaces?: {[key: string]: any};
    /**
     * Environment variables for Pages Functions. Defaults to `map[]`.
     */
    environmentVariables?: {[key: string]: any};
    /**
     * Fail open used for Pages Functions. Defaults to `false`.
     */
    failOpen?: boolean;
    /**
     * KV namespaces used for Pages Functions. Defaults to `map[]`.
     */
    kvNamespaces?: {[key: string]: any};
    /**
     * Configuration for placement in the Cloudflare Pages project.
     */
    placement: outputs.PagesProjectDeploymentConfigsPreviewPlacement;
    /**
     * R2 Buckets used for Pages Functions. Defaults to `map[]`.
     */
    r2Buckets?: {[key: string]: any};
    /**
     * Encrypted environment variables for Pages Functions. Defaults to `map[]`.
     */
    secrets?: {[key: string]: any};
    /**
     * Services used for Pages Functions.
     */
    serviceBindings?: outputs.PagesProjectDeploymentConfigsPreviewServiceBinding[];
    /**
     * Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
     */
    usageModel?: string;
}

export interface PagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement Mode for the Pages Function.
     */
    mode: string;
}

export interface PagesProjectDeploymentConfigsPreviewServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface PagesProjectDeploymentConfigsProduction {
    /**
     * Use latest compatibility date for Pages Functions. Defaults to `false`.
     */
    alwaysUseLatestCompatibilityDate?: boolean;
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 Databases used for Pages Functions. Defaults to `map[]`.
     */
    d1Databases?: {[key: string]: any};
    /**
     * Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
     */
    durableObjectNamespaces?: {[key: string]: any};
    /**
     * Environment variables for Pages Functions. Defaults to `map[]`.
     */
    environmentVariables?: {[key: string]: any};
    /**
     * Fail open used for Pages Functions. Defaults to `false`.
     */
    failOpen?: boolean;
    /**
     * KV namespaces used for Pages Functions. Defaults to `map[]`.
     */
    kvNamespaces?: {[key: string]: any};
    /**
     * Configuration for placement in the Cloudflare Pages project.
     */
    placement: outputs.PagesProjectDeploymentConfigsProductionPlacement;
    /**
     * R2 Buckets used for Pages Functions. Defaults to `map[]`.
     */
    r2Buckets?: {[key: string]: any};
    /**
     * Encrypted environment variables for Pages Functions. Defaults to `map[]`.
     */
    secrets?: {[key: string]: any};
    /**
     * Services used for Pages Functions.
     */
    serviceBindings?: outputs.PagesProjectDeploymentConfigsProductionServiceBinding[];
    /**
     * Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
     */
    usageModel?: string;
}

export interface PagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement Mode for the Pages Function.
     */
    mode: string;
}

export interface PagesProjectDeploymentConfigsProductionServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface PagesProjectSource {
    /**
     * Configuration for the source of the Cloudflare Pages project.
     */
    config?: outputs.PagesProjectSourceConfig;
    /**
     * Project host type.
     */
    type?: string;
}

export interface PagesProjectSourceConfig {
    /**
     * Toggle deployments on this repo. Defaults to `true`.
     */
    deploymentsEnabled?: boolean;
    /**
     * Project owner username. **Modifying this attribute will force creation of a new resource.**
     */
    owner?: string;
    /**
     * Enable Pages to comment on Pull Requests. Defaults to `true`.
     */
    prCommentsEnabled?: boolean;
    /**
     * Branches will be excluded from automatic deployment.
     */
    previewBranchExcludes: string[];
    /**
     * Branches will be included for automatic deployment.
     */
    previewBranchIncludes: string[];
    /**
     * Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
     */
    previewDeploymentSetting?: string;
    /**
     * Project production branch name.
     */
    productionBranch: string;
    /**
     * Enable production deployments. Defaults to `true`.
     */
    productionDeploymentEnabled?: boolean;
    /**
     * Project repository name. **Modifying this attribute will force creation of a new resource.**
     */
    repoName?: string;
}

export interface RateLimitAction {
    /**
     * The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `jsChallenge`, `managedChallenge`.
     */
    mode: string;
    /**
     * Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
     */
    response?: outputs.RateLimitActionResponse;
    /**
     * The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
     */
    timeout?: number;
}

export interface RateLimitActionResponse {
    /**
     * The body to return, the content here should conform to the `contentType`.
     */
    body: string;
    /**
     * The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
     */
    contentType: string;
}

export interface RateLimitCorrelate {
    /**
     * If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
     */
    by?: string;
}

export interface RateLimitMatch {
    /**
     * Matches HTTP requests (from the client to Cloudflare).
     */
    request: outputs.RateLimitMatchRequest;
    /**
     * Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
     */
    response: outputs.RateLimitMatchResponse;
}

export interface RateLimitMatchRequest {
    /**
     * HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
     */
    methods: string[];
    /**
     * HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
     */
    schemes: string[];
    /**
     * The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
     */
    urlPattern: string;
}

export interface RateLimitMatchResponse {
    /**
     * List of HTTP headers maps to match the origin response on.
     */
    headers?: {[key: string]: string}[];
    /**
     * Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
     */
    originTraffic: boolean;
    /**
     * HTTP Status codes, can be one, many or indicate all by not providing this value.
     */
    statuses: number[];
}

export interface RecordData {
    algorithm?: number;
    altitude?: number;
    certificate?: string;
    content?: string;
    digest?: string;
    digestType?: number;
    fingerprint?: string;
    flags?: string;
    keyTag?: number;
    latDegrees?: number;
    latDirection?: string;
    latMinutes?: number;
    latSeconds?: number;
    longDegrees?: number;
    longDirection?: string;
    longMinutes?: number;
    longSeconds?: number;
    matchingType?: number;
    name?: string;
    order?: number;
    port?: number;
    precisionHorz?: number;
    precisionVert?: number;
    preference?: number;
    priority?: number;
    proto?: string;
    protocol?: number;
    publicKey?: string;
    regex?: string;
    replacement?: string;
    selector?: number;
    service?: string;
    size?: number;
    tag?: string;
    target?: string;
    type?: number;
    usage?: number;
    value?: string;
    weight?: number;
}

export interface RiskBehaviorBehavior {
    /**
     * Whether this risk behavior type is enabled.
     */
    enabled: boolean;
    /**
     * Name of this risk behavior type
     */
    name: string;
    /**
     * Risk level. Available values: `low`, `medium`, `high`
     */
    riskLevel: string;
}

export interface RulesetRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: string;
    /**
     * List of parameters that configure the behavior of the ruleset rule action.
     */
    actionParameters?: outputs.RulesetRuleActionParameters;
    /**
     * Brief summary of the ruleset rule and its intended use.
     */
    description: string;
    /**
     * Whether the rule is active.
     */
    enabled: boolean;
    /**
     * List of parameters that configure exposed credential checks.
     */
    exposedCredentialCheck?: outputs.RulesetRuleExposedCredentialCheck;
    /**
     * Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * The most recent update to this rule.
     */
    lastUpdated: string;
    /**
     * List parameters to configure how the rule generates logs. Only valid for skip action.
     */
    logging?: outputs.RulesetRuleLogging;
    /**
     * List of parameters that configure HTTP rate limiting behaviour.
     */
    ratelimit?: outputs.RulesetRuleRatelimit;
    /**
     * Rule reference.
     */
    ref: string;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface RulesetRuleActionParameters {
    /**
     * Specifies uncommon ports to allow cacheable assets to be served from.
     */
    additionalCacheablePorts?: number[];
    /**
     * Compression algorithms to use in order of preference.
     */
    algorithms?: outputs.RulesetRuleActionParametersAlgorithm[];
    /**
     * Turn on or off Cloudflare Automatic HTTPS rewrites.
     */
    automaticHttpsRewrites?: boolean;
    /**
     * Indicate which file extensions to minify automatically.
     */
    autominifies?: outputs.RulesetRuleActionParametersAutominify[];
    /**
     * Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
     */
    bic?: boolean;
    /**
     * List of browser TTL parameters to apply to the request.
     */
    browserTtl?: outputs.RulesetRuleActionParametersBrowserTtl;
    /**
     * Whether to cache if expression matches.
     */
    cache?: boolean;
    /**
     * List of cache key parameters to apply to the request.
     */
    cacheKey?: outputs.RulesetRuleActionParametersCacheKey;
    /**
     * Content of the custom error response.
     */
    content?: string;
    /**
     * Content-Type of the custom error response.
     */
    contentType?: string;
    /**
     * List of cookie values to include as part of custom fields logging.
     */
    cookieFields?: string[];
    /**
     * Turn off all active Cloudflare Apps.
     */
    disableApps?: boolean;
    /**
     * Turn off railgun feature of the Cloudflare Speed app.
     */
    disableRailgun?: boolean;
    /**
     * Turn off RUM feature.
     */
    disableRum?: boolean;
    /**
     * Turn off zaraz feature.
     */
    disableZaraz?: boolean;
    /**
     * List of edge TTL parameters to apply to the request.
     */
    edgeTtl?: outputs.RulesetRuleActionParametersEdgeTtl;
    /**
     * Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
     */
    emailObfuscation?: boolean;
    /**
     * Toggle fonts.
     */
    fonts?: boolean;
    /**
     * Use a list to lookup information for the action.
     */
    fromList?: outputs.RulesetRuleActionParametersFromList;
    /**
     * Use a value to lookup information for the action.
     */
    fromValue?: outputs.RulesetRuleActionParametersFromValue;
    /**
     * List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
     */
    headers?: outputs.RulesetRuleActionParametersHeader[];
    /**
     * Host Header that request origin receives.
     */
    hostHeader?: string;
    /**
     * Turn on or off the hotlink protection feature.
     */
    hotlinkProtection?: boolean;
    /**
     * Identifier of the action parameter to modify.
     */
    id?: string;
    increment?: number;
    /**
     * List of properties to configure WAF payload logging.
     */
    matchedData?: outputs.RulesetRuleActionParametersMatchedData;
    /**
     * Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
     */
    mirage?: boolean;
    /**
     * Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    opportunisticEncryption?: boolean;
    /**
     * List of properties to change request origin.
     */
    origin?: outputs.RulesetRuleActionParametersOrigin;
    /**
     * Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
     */
    originCacheControl?: boolean;
    /**
     * Pass-through error page for origin.
     */
    originErrorPagePassthru?: boolean;
    /**
     * List of override configurations to apply to the ruleset.
     */
    overrides?: outputs.RulesetRuleActionParametersOverrides;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`.
     */
    phases?: string[];
    /**
     * Apply options from the Polish feature of the Cloudflare Speed app.
     */
    polish?: string;
    /**
     * Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
     */
    products?: string[];
    /**
     * Specifies a maximum timeout for reading content from an origin server.
     */
    readTimeout?: number;
    /**
     * List of request headers to include as part of custom fields logging, in lowercase.
     */
    requestFields?: string[];
    /**
     * Respect strong ETags.
     */
    respectStrongEtags?: boolean;
    /**
     * List of response headers to include as part of custom fields logging, in lowercase.
     */
    responseFields?: string[];
    /**
     * List of parameters that configure the response given to end users.
     */
    responses?: outputs.RulesetRuleActionParametersResponse[];
    /**
     * Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
     */
    rocketLoader?: boolean;
    /**
     * Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
     */
    rules?: {[key: string]: string};
    /**
     * Which ruleset ID to target.
     */
    ruleset?: string;
    /**
     * List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
     */
    rulesets?: string[];
    /**
     * Control options for the Security Level feature from the Security app.
     */
    securityLevel?: string;
    /**
     * List of serve stale parameters to apply to the request.
     */
    serveStale?: outputs.RulesetRuleActionParametersServeStale;
    /**
     * Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
     */
    serverSideExcludes?: boolean;
    /**
     * List of properties to manange Server Name Indication.
     */
    sni?: outputs.RulesetRuleActionParametersSni;
    /**
     * Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    ssl?: string;
    /**
     * HTTP status code of the custom error response.
     */
    statusCode?: number;
    /**
     * Turn on or off the SXG feature.
     */
    sxg?: boolean;
    /**
     * List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
     */
    uri?: outputs.RulesetRuleActionParametersUri;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface RulesetRuleActionParametersAlgorithm {
    /**
     * Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
     */
    name: string;
}

export interface RulesetRuleActionParametersAutominify {
    /**
     * CSS minification.
     */
    css?: boolean;
    /**
     * HTML minification.
     */
    html?: boolean;
    /**
     * JS minification.
     */
    js?: boolean;
}

export interface RulesetRuleActionParametersBrowserTtl {
    /**
     * Default browser TTL. This value is required when overrideOrigin is set
     */
    default?: number;
    /**
     * Mode of the browser TTL. Available values: `overrideOrigin`, `respectOrigin`, `bypass`
     */
    mode: string;
}

export interface RulesetRuleActionParametersCacheKey {
    /**
     * Cache by device type.
     */
    cacheByDeviceType?: boolean;
    /**
     * Cache deception armor.
     */
    cacheDeceptionArmor?: boolean;
    /**
     * Custom key parameters for the request.
     */
    customKey?: outputs.RulesetRuleActionParametersCacheKeyCustomKey;
    /**
     * Ignore query strings order.
     */
    ignoreQueryStringsOrder?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * Cookie parameters for the custom key.
     */
    cookie?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie;
    /**
     * Header parameters for the custom key.
     */
    header?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader;
    /**
     * Host parameters for the custom key.
     */
    host?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost;
    /**
     * Query string parameters for the custom key.
     */
    queryString?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    /**
     * User parameters for the custom key.
     */
    user?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * List of cookies to check for presence in the custom key.
     */
    checkPresences?: string[];
    /**
     * List of cookies to include in the custom key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * List of headers to check for presence in the custom key.
     */
    checkPresences?: string[];
    /**
     * Exclude the origin header from the custom key.
     */
    excludeOrigin: boolean;
    /**
     * List of headers to include in the custom key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Resolve hostname to IP address.
     */
    resolved?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * List of query string parameters to exclude from the custom key.
     */
    excludes?: string[];
    /**
     * List of query string parameters to include in the custom key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Add device type to the custom key.
     */
    deviceType?: boolean;
    /**
     * Add geo data to the custom key.
     */
    geo?: boolean;
    /**
     * Add language data to the custom key.
     */
    lang?: boolean;
}

export interface RulesetRuleActionParametersEdgeTtl {
    /**
     * Default edge TTL.
     */
    default?: number;
    /**
     * Mode of the edge TTL. Available values: `overrideOrigin`, `respectOrigin`, `bypassByDefault`
     */
    mode: string;
    /**
     * Edge TTL for the status codes.
     */
    statusCodeTtls?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * Status code for which the edge TTL is applied.
     */
    statusCode?: number;
    /**
     * Status code range for which the edge TTL is applied.
     */
    statusCodeRanges?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange[];
    /**
     * Status code edge TTL value.
     */
    value?: number;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * From status code.
     */
    from?: number;
    /**
     * To status code.
     */
    to?: number;
}

export interface RulesetRuleActionParametersFromList {
    /**
     * Expression to use for the list lookup.
     */
    key?: string;
    /**
     * Name of the list.
     */
    name?: string;
}

export interface RulesetRuleActionParametersFromValue {
    /**
     * Preserve query string for redirect URL.
     */
    preserveQueryString?: boolean;
    /**
     * Status code for redirect.
     */
    statusCode?: number;
    /**
     * Target URL for redirect.
     */
    targetUrl?: outputs.RulesetRuleActionParametersFromValueTargetUrl;
}

export interface RulesetRuleActionParametersFromValueTargetUrl {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Static value to provide as the HTTP request header value.
     */
    value?: string;
}

export interface RulesetRuleActionParametersHeader {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Name of the HTTP request header to target.
     */
    name?: string;
    /**
     * Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
     */
    operation?: string;
    /**
     * Static value to provide as the HTTP request header value.
     */
    value?: string;
}

export interface RulesetRuleActionParametersMatchedData {
    /**
     * Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
     */
    publicKey?: string;
}

export interface RulesetRuleActionParametersOrigin {
    /**
     * Origin Hostname where request is sent.
     */
    host?: string;
    /**
     * Origin Port where request is sent.
     */
    port?: number;
}

export interface RulesetRuleActionParametersOverrides {
    /**
     * Action to perform in the rule-level override. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: string;
    /**
     * List of tag-based overrides.
     */
    categories?: outputs.RulesetRuleActionParametersOverridesCategory[];
    /**
     * Defines if the current ruleset-level override enables or disables the ruleset.
     */
    enabled?: boolean;
    /**
     * List of rule-based overrides.
     */
    rules?: outputs.RulesetRuleActionParametersOverridesRule[];
    /**
     * Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersOverridesCategory {
    /**
     * Action to perform in the tag-level override. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: string;
    /**
     * Tag name to apply the ruleset rule override to.
     */
    category?: string;
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
     */
    enabled?: boolean;
}

export interface RulesetRuleActionParametersOverridesRule {
    /**
     * Action to perform in the rule-level override. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: string;
    /**
     * Defines if the current rule-level override enables or disables the rule.
     */
    enabled?: boolean;
    /**
     * Rule ID to apply the override to.
     */
    id?: string;
    /**
     * Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
     */
    scoreThreshold?: number;
    /**
     * Sensitivity level for a ruleset rule override.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersResponse {
    /**
     * Body content to include in the response.
     */
    content?: string;
    /**
     * HTTP content type to send in the response.
     */
    contentType?: string;
    /**
     * HTTP status code to send in the response.
     */
    statusCode?: number;
}

export interface RulesetRuleActionParametersServeStale {
    /**
     * Disable stale while updating.
     */
    disableStaleWhileUpdating?: boolean;
}

export interface RulesetRuleActionParametersSni {
    /**
     * Value to define for SNI.
     */
    value?: string;
}

export interface RulesetRuleActionParametersUri {
    origin?: boolean;
    /**
     * URI path configuration when performing a URL rewrite.
     */
    path?: outputs.RulesetRuleActionParametersUriPath;
    /**
     * Query string configuration when performing a URL rewrite.
     */
    query?: outputs.RulesetRuleActionParametersUriQuery;
}

export interface RulesetRuleActionParametersUriPath {
    /**
     * Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Static string value of the updated URI path or query string component.
     */
    value?: string;
}

export interface RulesetRuleActionParametersUriQuery {
    /**
     * Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Static string value of the updated URI path or query string component.
     */
    value?: string;
}

export interface RulesetRuleExposedCredentialCheck {
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    passwordExpression?: string;
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    usernameExpression?: string;
}

export interface RulesetRuleLogging {
    /**
     * Override the default logging behavior when a rule is matched.
     */
    enabled?: boolean;
}

export interface RulesetRuleRatelimit {
    /**
     * List of parameters that define how Cloudflare tracks the request rate for this rule.
     */
    characteristics?: string[];
    /**
     * Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    countingExpression?: string;
    /**
     * Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
     */
    mitigationTimeout?: number;
    /**
     * The period of time to consider (in seconds) when evaluating the request rate.
     */
    period?: number;
    /**
     * The number of requests over the period of time that will trigger the Rate Limiting rule.
     */
    requestsPerPeriod?: number;
    /**
     * Whether to include requests to origin within the Rate Limiting count.
     */
    requestsToOrigin: boolean;
    /**
     * The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
     */
    scorePerPeriod?: number;
    /**
     * Name of HTTP header in the response, set by the origin server, with the score for the current request.
     */
    scoreResponseHeaderName?: string;
}

export interface SpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name: string;
    /**
     * The type of DNS record associated with the application.
     */
    type: string;
}

export interface SpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
     */
    connectivity?: string;
    /**
     * The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
     */
    ips?: string[];
    /**
     * The type of edge IP configuration specified. Available values: `dynamic`, `static`.
     */
    type: string;
}

export interface SpectrumApplicationOriginDns {
    /**
     * Fully qualified domain name of the origin.
     */
    name: string;
}

export interface SpectrumApplicationOriginPortRange {
    /**
     * Upper bound of the origin port range.
     */
    end: number;
    /**
     * Lower bound of the origin port range.
     */
    start: number;
}

export interface SplitTunnelTunnel {
    /**
     * The address for the tunnel.
     */
    address?: string;
    /**
     * A description for the tunnel.
     */
    description?: string;
    /**
     * The domain name for the tunnel.
     */
    host?: string;
}

export interface TeamsAccountAntivirus {
    /**
     * Scan on file download.
     */
    enabledDownloadPhase: boolean;
    /**
     * Scan on file upload.
     */
    enabledUploadPhase: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: boolean;
    /**
     * Set notifications for antivirus.
     */
    notificationSettings?: outputs.TeamsAccountAntivirusNotificationSettings;
}

export interface TeamsAccountAntivirusNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: boolean;
    /**
     * Notification content.
     */
    message?: string;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: string;
}

export interface TeamsAccountBlockPage {
    /**
     * Hex code of block page background color.
     */
    backgroundColor?: string;
    /**
     * Indicator of enablement.
     */
    enabled?: boolean;
    /**
     * Block page footer text.
     */
    footerText?: string;
    /**
     * Block page header text.
     */
    headerText?: string;
    /**
     * URL of block page logo.
     */
    logoPath?: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: string;
    /**
     * Name of block page configuration.
     */
    name?: string;
}

export interface TeamsAccountBodyScanning {
    /**
     * Body scanning inspection mode. Available values: `deep`, `shallow`.
     */
    inspectionMode: string;
}

export interface TeamsAccountCustomCertificate {
    /**
     * Whether TLS encryption should use a custom certificate.
     */
    enabled: boolean;
    /**
     * ID of custom certificate.
     */
    id: string;
    updatedAt: string;
}

export interface TeamsAccountExtendedEmailMatching {
    /**
     * Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
     */
    enabled: boolean;
}

export interface TeamsAccountFips {
    /**
     * Only allow FIPS-compliant TLS configuration.
     */
    tls?: boolean;
}

export interface TeamsAccountLogging {
    /**
     * Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
     */
    redactPii: boolean;
    /**
     * Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
     */
    settingsByRuleType: outputs.TeamsAccountLoggingSettingsByRuleType;
}

export interface TeamsAccountLoggingSettingsByRuleType {
    /**
     * Logging configuration for DNS requests.
     */
    dns: outputs.TeamsAccountLoggingSettingsByRuleTypeDns;
    /**
     * Logging configuration for HTTP requests.
     */
    http: outputs.TeamsAccountLoggingSettingsByRuleTypeHttp;
    /**
     * Logging configuration for layer 4 requests.
     */
    l4: outputs.TeamsAccountLoggingSettingsByRuleTypeL4;
}

export interface TeamsAccountLoggingSettingsByRuleTypeDns {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeHttp {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeL4 {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountPayloadLog {
    /**
     * Public key used to encrypt matched payloads.
     */
    publicKey: string;
}

export interface TeamsAccountProxy {
    /**
     * Whether root ca is enabled account wide for ZT clients.
     */
    rootCa: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for TCP traffic.
     */
    tcp: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for UDP traffic.
     */
    udp: boolean;
    /**
     * Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
     */
    virtualIp: boolean;
}

export interface TeamsAccountSshSessionLog {
    /**
     * Public key used to encrypt ssh session.
     */
    publicKey: string;
}

export interface TeamsLocationNetwork {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * CIDR notation representation of the network IP.
     */
    network: string;
}

export interface TeamsRuleRuleSettings {
    /**
     * Add custom headers to allowed requests in the form of key-value pairs.
     */
    addHeaders?: {[key: string]: string};
    /**
     * Allow parent MSP accounts to enable bypass their children's rules.
     */
    allowChildBypass?: boolean;
    /**
     * Settings for auditing SSH usage.
     */
    auditSsh?: outputs.TeamsRuleRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls?: outputs.TeamsRuleRuleSettingsBisoAdminControls;
    /**
     * Indicator of block page enablement.
     */
    blockPageEnabled?: boolean;
    /**
     * The displayed reason for a user being blocked.
     */
    blockPageReason?: string;
    /**
     * Allow child MSP accounts to bypass their parent's rule.
     */
    bypassParentRule?: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession?: outputs.TeamsRuleRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve*dns*through*cloudflare is set. DNS queries will route to the address closest to their origin.
     */
    dnsResolvers?: outputs.TeamsRuleRuleSettingsDnsResolvers;
    /**
     * Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
     */
    egress?: outputs.TeamsRuleRuleSettingsEgress;
    /**
     * Disable DNSSEC validation (must be Allow rule).
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Turns on IP category based filter on dns if the rule contains dns category checks.
     */
    ipCategories?: boolean;
    /**
     * Settings to forward layer 4 traffic.
     */
    l4override?: outputs.TeamsRuleRuleSettingsL4override;
    /**
     * Notification settings on a block rule.
     */
    notificationSettings?: outputs.TeamsRuleRuleSettingsNotificationSettings;
    /**
     * The host to override matching DNS queries with.
     */
    overrideHost?: string;
    /**
     * The IPs to override matching DNS queries with.
     */
    overrideIps?: string[];
    /**
     * Configure DLP Payload Logging settings for this rule.
     */
    payloadLog?: outputs.TeamsRuleRuleSettingsPayloadLog;
    /**
     * Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dnsResolvers` are specified.
     */
    resolveDnsThroughCloudflare?: boolean;
    /**
     * Configure untrusted certificate settings for this rule.
     */
    untrustedCert?: outputs.TeamsRuleRuleSettingsUntrustedCert;
}

export interface TeamsRuleRuleSettingsAuditSsh {
    /**
     * Log all SSH commands.
     */
    commandLogging: boolean;
}

export interface TeamsRuleRuleSettingsBisoAdminControls {
    /**
     * Disable copy-paste.
     */
    disableCopyPaste?: boolean;
    /**
     * Disable download.
     */
    disableDownload?: boolean;
    /**
     * Disable keyboard usage.
     */
    disableKeyboard?: boolean;
    /**
     * Disable printing.
     */
    disablePrinting?: boolean;
    /**
     * Disable upload.
     */
    disableUpload?: boolean;
}

export interface TeamsRuleRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: string;
    /**
     * Enable session enforcement for this rule.
     */
    enforce: boolean;
}

export interface TeamsRuleRuleSettingsDnsResolvers {
    /**
     * IPv4 resolvers.
     */
    ipv4s?: outputs.TeamsRuleRuleSettingsDnsResolversIpv4[];
    /**
     * IPv6 resolvers.
     */
    ipv6s?: outputs.TeamsRuleRuleSettingsDnsResolversIpv6[];
}

export interface TeamsRuleRuleSettingsDnsResolversIpv4 {
    /**
     * The IPv4 or IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for the upstream resolver. Defaults to `53`.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when `vnetId` is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface TeamsRuleRuleSettingsDnsResolversIpv6 {
    /**
     * The IPv4 or IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for the upstream resolver. Defaults to `53`.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when `vnetId` is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface TeamsRuleRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4: string;
    /**
     * The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
     */
    ipv4Fallback?: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6: string;
}

export interface TeamsRuleRuleSettingsL4override {
    /**
     * Override IP to forward traffic to.
     */
    ip: string;
    /**
     * Override Port to forward traffic to.
     */
    port: number;
}

export interface TeamsRuleRuleSettingsNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: boolean;
    /**
     * Notification content.
     */
    message?: string;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: string;
}

export interface TeamsRuleRuleSettingsPayloadLog {
    /**
     * Enable or disable DLP Payload Logging for this rule.
     */
    enabled: boolean;
}

export interface TeamsRuleRuleSettingsUntrustedCert {
    /**
     * Action to be taken when the SSL certificate of upstream is invalid. Available values: `passThrough`, `block`, `error`.
     */
    action?: string;
}

export interface TunnelConfigConfig {
    /**
     * Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
     */
    ingressRules: outputs.TunnelConfigConfigIngressRule[];
    originRequest?: outputs.TunnelConfigConfigOriginRequest;
    /**
     * If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
     */
    warpRouting?: outputs.TunnelConfigConfigWarpRouting;
}

export interface TunnelConfigConfigIngressRule {
    /**
     * Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
     */
    hostname?: string;
    originRequest?: outputs.TunnelConfigConfigIngressRuleOriginRequest;
    /**
     * Path of the incoming request. If the path matches, the request will be sent to the local service.
     */
    path?: string;
    /**
     * Name of the service to which the request will be sent.
     */
    service: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: outputs.TunnelConfigConfigIngressRuleOriginRequestAccess;
    /**
     * Runs as jump host.
     */
    bastionMode?: boolean;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: string;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: string;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule[];
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: string;
    /**
     * Disable the â€œhappy eyeballsâ€ algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: number;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: string;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: string[];
    /**
     * Whether the access rule is required.
     */
    required?: boolean;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: boolean;
    /**
     * Ports to use within the IP rule.
     */
    ports?: number[];
    /**
     * IP rule prefix.
     */
    prefix?: string;
}

export interface TunnelConfigConfigOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: outputs.TunnelConfigConfigOriginRequestAccess;
    /**
     * Runs as jump host.
     */
    bastionMode?: boolean;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: string;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: string;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: outputs.TunnelConfigConfigOriginRequestIpRule[];
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: string;
    /**
     * Disable the â€œhappy eyeballsâ€ algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: number;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: string;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: string;
}

export interface TunnelConfigConfigOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: string[];
    /**
     * Whether the access rule is required.
     */
    required?: boolean;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: string;
}

export interface TunnelConfigConfigOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: boolean;
    /**
     * Ports to use within the IP rule.
     */
    ports?: number[];
    /**
     * IP rule prefix.
     */
    prefix?: string;
}

export interface TunnelConfigConfigWarpRouting {
    /**
     * Whether WARP routing is enabled.
     */
    enabled?: boolean;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
     */
    value: string;
}

export interface WaitingRoomAdditionalRoute {
    /**
     * The additional host name for which the waiting room to be applied on (no wildcards).
     */
    host: string;
    /**
     * The path within the additional host to enable the waiting room on. Defaults to `/`.
     */
    path?: string;
}

export interface WaitingRoomRulesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `bypassWaitingRoom`.
     */
    action: string;
    /**
     * Brief summary of the waiting room rule and its intended use.
     */
    description?: string;
    /**
     * Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
     */
    status?: string;
    /**
     * Version of the waiting room rule.
     */
    version: string;
}

export interface WorkerScriptAnalyticsEngineBinding {
    /**
     * The name of the Analytics Engine dataset to write to.
     */
    dataset: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptD1DatabaseBinding {
    /**
     * Database ID of D1 database to use.
     */
    databaseId: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptKvNamespaceBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * ID of the KV namespace you want to use.
     */
    namespaceId: string;
}

export interface WorkerScriptPlacement {
    /**
     * The placement mode for the Worker. Available values: `smart`.
     */
    mode: string;
}

export interface WorkerScriptPlainTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The plain text you want to store.
     */
    text: string;
}

export interface WorkerScriptQueueBinding {
    /**
     * The name of the global variable for the binding in your Worker code.
     */
    binding: string;
    /**
     * Name of the queue you want to use.
     */
    queue: string;
}

export interface WorkerScriptR2BucketBinding {
    /**
     * The name of the Bucket to bind to.
     */
    bucketName: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptSecretTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The secret text you want to store.
     */
    text: string;
}

export interface WorkerScriptServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface WorkerScriptWebassemblyBinding {
    /**
     * The base64 encoded wasm module you want to store.
     */
    module: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface ZoneLockdownConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ipRange`.
     */
    target: string;
    /**
     * The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
     */
    value: string;
}

export interface ZoneSettingsOverrideInitialSetting {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    cacheLevel: string;
    challengeTtl: number;
    ciphers: string[];
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    fonts: string;
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    minTlsVersion: string;
    minify: outputs.ZoneSettingsOverrideInitialSettingMinify;
    mirage: string;
    /**
     * @deprecated Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.
     */
    mobileRedirect: outputs.ZoneSettingsOverrideInitialSettingMobileRedirect;
    nel: outputs.ZoneSettingsOverrideInitialSettingNel;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    originMaxHttpVersion: string;
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader: outputs.ZoneSettingsOverrideInitialSettingSecurityHeader;
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    ssl: string;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `minTlsVersion = "1.2"` instead.
     */
    tls12Only: string;
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideInitialSettingMinify {
    css: string;
    html: string;
    js: string;
}

export interface ZoneSettingsOverrideInitialSettingMobileRedirect {
    mobileSubdomain: string;
    status: string;
    stripUri: boolean;
}

export interface ZoneSettingsOverrideInitialSettingNel {
    enabled: boolean;
}

export interface ZoneSettingsOverrideInitialSettingSecurityHeader {
    enabled: boolean;
    includeSubdomains: boolean;
    maxAge: number;
    nosniff: boolean;
    preload: boolean;
}

export interface ZoneSettingsOverrideSettings {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    cacheLevel: string;
    challengeTtl: number;
    ciphers: string[];
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    fonts: string;
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    minTlsVersion: string;
    minify: outputs.ZoneSettingsOverrideSettingsMinify;
    mirage: string;
    /**
     * @deprecated Mobile redirects has been deprecated and disabled in favour of [Single Redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/) and are no longer configurable using the API. Refer to [Perform mobile redirects](https://developers.cloudflare.com/rules/url-forwarding/single-redirects/examples/#perform-mobile-redirects) for examples of performing mobile redirects with Single Redirects.
     */
    mobileRedirect: outputs.ZoneSettingsOverrideSettingsMobileRedirect;
    nel: outputs.ZoneSettingsOverrideSettingsNel;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    originMaxHttpVersion: string;
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader: outputs.ZoneSettingsOverrideSettingsSecurityHeader;
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    ssl: string;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `minTlsVersion = "1.2"` instead.
     */
    tls12Only: string;
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideSettingsMinify {
    css: string;
    html: string;
    js: string;
}

export interface ZoneSettingsOverrideSettingsMobileRedirect {
    mobileSubdomain: string;
    status: string;
    stripUri: boolean;
}

export interface ZoneSettingsOverrideSettingsNel {
    enabled: boolean;
}

export interface ZoneSettingsOverrideSettingsSecurityHeader {
    enabled: boolean;
    includeSubdomains: boolean;
    maxAge: number;
    nosniff: boolean;
    preload: boolean;
}

