// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApplicationCorsHeader {
    /**
     * Value to determine whether all HTTP headers are exposed.
     */
    allowAllHeaders?: boolean;
    /**
     * Value to determine whether all methods are exposed.
     */
    allowAllMethods?: boolean;
    /**
     * Value to determine whether all origins are permitted to make CORS requests.
     */
    allowAllOrigins?: boolean;
    /**
     * Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
     */
    allowCredentials?: boolean;
    /**
     * List of HTTP headers to expose via CORS.
     */
    allowedHeaders?: string[];
    /**
     * List of methods to expose via CORS.
     */
    allowedMethods?: string[];
    /**
     * List of origins permitted to make CORS requests.
     */
    allowedOrigins?: string[];
    /**
     * The maximum time a preflight request will be cached.
     */
    maxAge?: number;
}

export interface AccessApplicationSaasApp {
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: string;
    /**
     * The format of the name identifier sent to the SaaS application. Defaults to `email`.
     */
    nameIdFormat?: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: string;
}

export interface AccessGroupExclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessGroupExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupExcludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupExcludeGsuite[];
    ipLists?: string[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupExcludeOkta[];
    samls?: outputs.AccessGroupExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupExcludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessGroupExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupInclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessGroupIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupIncludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupIncludeGsuite[];
    ipLists?: string[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupIncludeOkta[];
    samls?: outputs.AccessGroupIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupIncludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessGroupIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupRequire {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessGroupRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessGroupRequireExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessGroupRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupRequireGsuite[];
    ipLists?: string[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupRequireOkta[];
    samls?: outputs.AccessGroupRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupRequireAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessGroupRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessIdentityProviderConfig {
    apiToken?: string;
    appsDomain?: string;
    attributes: string[];
    authUrl?: string;
    centrifyAccount?: string;
    centrifyAppId?: string;
    certsUrl?: string;
    claims: string[];
    clientId?: string;
    clientSecret?: string;
    directoryId?: string;
    emailAttributeName?: string;
    idpPublicCert?: string;
    issuerUrl?: string;
    oktaAccount?: string;
    oneloginAccount?: string;
    pkceEnabled?: boolean;
    redirectUrl: string;
    scopes: string[];
    signRequest?: boolean;
    ssoTargetUrl?: string;
    supportGroups?: boolean;
    tokenUrl?: string;
}

export interface AccessIdentityProviderScimConfig {
    enabled?: boolean;
    groupMemberDeprovision?: boolean;
    seatDeprovision?: boolean;
    secret: string;
    userDeprovision?: boolean;
}

export interface AccessOrganizationLoginDesign {
    /**
     * The background color on the login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of the login page.
     */
    footerText?: string;
    /**
     * The text at the top of the login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on the login page.
     */
    logoPath?: string;
    /**
     * The text color on the login page.
     */
    textColor?: string;
}

export interface AccessPolicyApprovalGroup {
    /**
     * Number of approvals needed.
     */
    approvalsNeeded: number;
    /**
     * List of emails to request approval from.
     */
    emailAddresses?: string[];
    emailListUuid?: string;
}

export interface AccessPolicyExclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessPolicyExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyExcludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyExcludeGsuite[];
    ipLists?: string[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyExcludeOkta[];
    samls?: outputs.AccessPolicyExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyExcludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessPolicyExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyExcludeGithub {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    name?: string;
    teams?: string[];
}

export interface AccessPolicyExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyExcludeOkta {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    names?: string[];
}

export interface AccessPolicyExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyInclude {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessPolicyIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyIncludeExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyIncludeGsuite[];
    ipLists?: string[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyIncludeOkta[];
    samls?: outputs.AccessPolicyIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyIncludeAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessPolicyIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyIncludeGithub {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    name?: string;
    teams?: string[];
}

export interface AccessPolicyIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyIncludeOkta {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    names?: string[];
}

export interface AccessPolicyIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyRequire {
    anyValidServiceToken?: boolean;
    authMethod?: string;
    azures?: outputs.AccessPolicyRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    devicePostures?: string[];
    emailDomains?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluation?: outputs.AccessPolicyRequireExternalEvaluation;
    geos?: string[];
    githubs?: outputs.AccessPolicyRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyRequireGsuite[];
    ipLists?: string[];
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyRequireOkta[];
    samls?: outputs.AccessPolicyRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyRequireAzure {
    identityProviderId?: string;
    /**
     * The ID of this resource.
     */
    ids?: string[];
}

export interface AccessPolicyRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyRequireGithub {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    name?: string;
    teams?: string[];
}

export interface AccessPolicyRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyRequireOkta {
    identityProviderId?: string;
    /**
     * Friendly name of the Access Policy.
     */
    names?: string[];
}

export interface AccessPolicyRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessRuleConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ip6`, `ipRange`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
     */
    target: string;
    /**
     * The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
     */
    value: string;
}

export interface AddressMapIp {
    /**
     * An IPv4 or IPv6 address.
     */
    ip: string;
}

export interface AddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete: boolean;
    /**
     * Identifier of the account or zone.
     */
    identifier: string;
    /**
     * The type of the membership.
     */
    kind: string;
}

export interface ApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic.
     */
    name?: string;
    /**
     * The type of characteristic. Available values: `header`, `cookie`.
     */
    type?: string;
}

export interface ApiTokenCondition {
    /**
     * Request IP related conditions.
     */
    requestIp?: outputs.ApiTokenConditionRequestIp;
}

export interface ApiTokenConditionRequestIp {
    ins?: string[];
    notIns?: string[];
}

export interface ApiTokenPolicy {
    /**
     * Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
     */
    effect?: string;
    /**
     * List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
     */
    permissionGroups: string[];
    /**
     * Describes what operations against which resources are allowed or denied.
     */
    resources: {[key: string]: string};
}

export interface CertificatePackValidationError {
    message: string;
}

export interface CertificatePackValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomHostnameSsl {
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate?: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: string;
    /**
     * Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     */
    method?: string;
    /**
     * SSL/TLS settings for the certificate.
     */
    settings: outputs.CustomHostnameSslSetting[];
    /**
     * Status of the certificate.
     */
    status: string;
    /**
     * Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     */
    type?: string;
    validationErrors: outputs.CustomHostnameSslValidationError[];
    validationRecords: outputs.CustomHostnameSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: boolean;
}

export interface CustomHostnameSslSetting {
    ciphers?: string[];
    earlyHints?: string;
    http2?: string;
    minTlsVersion?: string;
    tls13?: string;
}

export interface CustomHostnameSslValidationError {
    message: string;
}

export interface CustomHostnameSslValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomSslCustomSslOptions {
    /**
     * Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: string;
    /**
     * Certificate certificate and the intermediate(s).
     */
    certificate?: string;
    /**
     * Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highestSecurity`.
     */
    geoRestrictions?: string;
    /**
     * Certificate's private key.
     */
    privateKey?: string;
    /**
     * Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacyCustom`, `sniCustom`.
     */
    type?: string;
}

export interface CustomSslCustomSslPriority {
    /**
     * The ID of this resource.
     */
    id?: string;
    priority?: number;
}

export interface DeviceDexTestData {
    /**
     * The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
     */
    host: string;
    /**
     * The type of Device Dex Test. Available values: `http`, `traceroute`.
     */
    kind: string;
    /**
     * The http request method. Available values: `GET`.
     */
    method?: string;
}

export interface DeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface DevicePostureIntegrationConfig {
    /**
     * The third-party API's URL.
     */
    apiUrl?: string;
    /**
     * The third-party authorization API URL.
     */
    authUrl?: string;
    /**
     * The client identifier for authenticating API calls.
     */
    clientId?: string;
    /**
     * The client key for authenticating API calls.
     */
    clientKey?: string;
    /**
     * The client secret for authenticating API calls.
     */
    clientSecret?: string;
    /**
     * The customer identifier for authenticating API calls.
     */
    customerId?: string;
}

export interface DevicePostureRuleInput {
    /**
     * Specific volume(s) to check for encryption.
     */
    checkDisks?: string[];
    /**
     * The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
     */
    complianceStatus?: string;
    /**
     * The workspace one connection id.
     */
    connectionId?: string;
    /**
     * The domain that the client must join.
     */
    domain?: string;
    /**
     * True if the firewall must be enabled.
     */
    enabled: boolean;
    /**
     * Checks if the file should exist.
     */
    exists: boolean;
    /**
     * The Teams List id.
     */
    id?: string;
    /**
     * The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    operator?: string;
    /**
     * OS signal score from Crowdstrike. Value must be between 1 and 100.
     */
    os?: string;
    /**
     * The operating system excluding version information.
     */
    osDistroName?: string;
    /**
     * The operating system version excluding OS name information or release name.
     */
    osDistroRevision?: string;
    /**
     * Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
     */
    overall?: string;
    /**
     * The path to the file.
     */
    path?: string;
    /**
     * True if all drives must be encrypted.
     */
    requireAll: boolean;
    /**
     * Checks if the application should be running.
     */
    running: boolean;
    /**
     * Sensor signal score from Crowdstrike. Value must be between 1 and 100.
     */
    sensorConfig?: string;
    /**
     * The sha256 hash of the file.
     */
    sha256?: string;
    /**
     * The thumbprint of the file certificate.
     */
    thumbprint?: string;
    /**
     * The operating system semantic version.
     */
    version?: string;
    /**
     * The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    versionOperator?: string;
}

export interface DevicePostureRuleMatch {
    /**
     * The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
     */
    platform?: string;
}

export interface DlpProfileEntry {
    /**
     * Whether the entry is active. Defaults to `false`.
     */
    enabled?: boolean;
    /**
     * Unique entry identifier.
     */
    id: string;
    /**
     * Name of the entry to deploy.
     */
    name: string;
    pattern?: outputs.DlpProfileEntryPattern;
}

export interface DlpProfileEntryPattern {
    regex: string;
    validation?: string;
}

export interface EmailRoutingCatchAllAction {
    /**
     * Type of supported action. Available values: `drop`, `forward`, `worker`.
     */
    type: string;
    /**
     * A list with items in the following form.
     */
    values: string[];
}

export interface EmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Available values: `all`.
     */
    type: string;
}

export interface EmailRoutingRuleAction {
    /**
     * Type of supported action.
     */
    type: string;
    /**
     * An array with items in the following form.
     */
    values: string[];
}

export interface EmailRoutingRuleMatcher {
    /**
     * Field for type matcher.
     */
    field?: string;
    /**
     * Type of matcher.
     */
    type: string;
    /**
     * Value for matcher.
     */
    value?: string;
}

export interface FallbackDomainDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix?: string;
}

export interface GetAccountRolesRole {
    description?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    name?: string;
}

export interface GetAccountsAccount {
    enforceTwofactor?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
    /**
     * The account name to target for the resource.
     */
    name?: string;
    type?: string;
}

export interface GetDevicesDevice {
    created?: string;
    deleted?: boolean;
    deviceType?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    ip?: string;
    key?: string;
    lastSeen?: string;
    macAddress?: string;
    manufacturer?: string;
    model?: string;
    name?: string;
    osDistroName?: string;
    osDistroRevision?: string;
    osVersion?: string;
    revokedAt?: string;
    serialNumber?: string;
    updated?: string;
    userEmail?: string;
    userId?: string;
    userName?: string;
    version?: string;
}

export interface GetListsList {
    description?: string;
    /**
     * The ID of this resource.
     */
    id?: string;
    kind?: string;
    name?: string;
    numitems?: number;
}

export interface GetLoadBalancerPoolsFilter {
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name?: string;
}

export interface GetLoadBalancerPoolsPool {
    /**
     * List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
     */
    checkRegions: string[];
    /**
     * The RFC3339 timestamp of when the load balancer was created.
     */
    createdOn: string;
    /**
     * Brief description of the Load Balancer Pool intention.
     */
    description: string;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled: boolean;
    /**
     * ID for this load balancer pool.
     */
    id: string;
    /**
     * Latitude this pool is physically located at; used for proximity steering.
     */
    latitude: number;
    /**
     * Setting for controlling load shedding for this pool.
     */
    loadSheddings: outputs.GetLoadBalancerPoolsPoolLoadShedding[];
    /**
     * Longitude this pool is physically located at; used for proximity steering.
     */
    longitude: number;
    /**
     * Minimum number of origins that must be healthy for this pool to serve traffic.
     */
    minimumOrigins: number;
    /**
     * The RFC3339 timestamp of when the load balancer was last modified.
     */
    modifiedOn: string;
    /**
     * ID of the Monitor to use for health checking origins within this pool.
     */
    monitor: string;
    /**
     * Short name (tag) for the pool.
     */
    name: string;
    /**
     * Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
     */
    notificationEmail: string;
    /**
     * The list of origins within this pool.
     */
    origins: outputs.GetLoadBalancerPoolsPoolOrigin[];
}

export interface GetLoadBalancerPoolsPoolLoadShedding {
    defaultPercent?: number;
    defaultPolicy?: string;
    sessionPercent?: number;
    sessionPolicy?: string;
}

export interface GetLoadBalancerPoolsPoolOrigin {
    address: string;
    enabled?: boolean;
    headers?: outputs.GetLoadBalancerPoolsPoolOriginHeader[];
    name: string;
    weight?: number;
}

export interface GetLoadBalancerPoolsPoolOriginHeader {
    header: string;
    values: string[];
}

export interface GetRulesetsFilter {
    /**
     * The ID of the Ruleset to target.
     */
    id?: string;
    /**
     * Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `schema`, `zone`.
     */
    kind?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpCustomErrors`, `httpLogCustomFields`, `httpRequestCacheSettings`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestLateTransformManaged`, `httpRequestMain`, `httpRequestOrigin`, `httpRequestDynamicRedirect`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestTransform`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `httpResponseHeadersTransformManaged`, `httpResponseCompression`, `magicTransit`, `httpRatelimit`, `httpRequestSbfm`, `httpConfigSettings`.
     */
    phase?: string;
    /**
     * Version of the ruleset to filter on.
     */
    version?: string;
}

export interface GetRulesetsRuleset {
    description?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    kind: string;
    name: string;
    phase: string;
    rules?: outputs.GetRulesetsRulesetRule[];
    version: string;
}

export interface GetRulesetsRulesetRule {
    action?: string;
    actionParameters?: outputs.GetRulesetsRulesetRuleActionParameters;
    description?: string;
    enabled?: boolean;
    exposedCredentialCheck?: outputs.GetRulesetsRulesetRuleExposedCredentialCheck;
    expression: string;
    /**
     * The ID of this resource.
     */
    id: string;
    lastUpdated?: string;
    logging?: outputs.GetRulesetsRulesetRuleLogging;
    ratelimit?: outputs.GetRulesetsRulesetRuleRatelimit;
    ref: string;
    version: string;
}

export interface GetRulesetsRulesetRuleActionParameters {
    automaticHttpsRewrites?: boolean;
    autominifies?: outputs.GetRulesetsRulesetRuleActionParametersAutominify[];
    bic?: boolean;
    browserTtl?: outputs.GetRulesetsRulesetRuleActionParametersBrowserTtl;
    cache?: boolean;
    cacheKey?: outputs.GetRulesetsRulesetRuleActionParametersCacheKey;
    content?: string;
    contentType?: string;
    cookieFields?: string[];
    disableApps?: boolean;
    disableRailgun?: boolean;
    disableZaraz?: boolean;
    edgeTtl?: outputs.GetRulesetsRulesetRuleActionParametersEdgeTtl;
    emailObfuscation?: boolean;
    fromList?: outputs.GetRulesetsRulesetRuleActionParametersFromList;
    fromValue?: outputs.GetRulesetsRulesetRuleActionParametersFromValue;
    headers?: outputs.GetRulesetsRulesetRuleActionParametersHeader[];
    hostHeader?: string;
    hotlinkProtection?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
    increment?: number;
    matchedData?: outputs.GetRulesetsRulesetRuleActionParametersMatchedData;
    mirage?: boolean;
    opportunisticEncryption?: boolean;
    origin?: outputs.GetRulesetsRulesetRuleActionParametersOrigin;
    originErrorPagePassthru?: boolean;
    overrides?: outputs.GetRulesetsRulesetRuleActionParametersOverrides;
    phases?: string[];
    polish?: string;
    products?: string[];
    requestFields?: string[];
    respectStrongEtags?: boolean;
    responseFields?: string[];
    responses?: outputs.GetRulesetsRulesetRuleActionParametersResponse[];
    rocketLoader?: boolean;
    rules?: {[key: string]: string};
    ruleset?: string;
    rulesets?: string[];
    securityLevel?: string;
    serveStale?: outputs.GetRulesetsRulesetRuleActionParametersServeStale;
    serverSideExcludes?: boolean;
    sni?: outputs.GetRulesetsRulesetRuleActionParametersSni;
    ssl?: string;
    statusCode?: number;
    sxg?: boolean;
    uri?: outputs.GetRulesetsRulesetRuleActionParametersUri;
    version: string;
}

export interface GetRulesetsRulesetRuleActionParametersAutominify {
    css?: boolean;
    html?: boolean;
    js?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersBrowserTtl {
    default?: number;
    mode: string;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKey {
    cacheByDeviceType?: boolean;
    cacheDeceptionArmor?: boolean;
    customKey?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKey;
    ignoreQueryStringsOrder?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKey {
    cookie?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie;
    header?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader;
    host?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost;
    queryString?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    user?: outputs.GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyCookie {
    checkPresences?: string[];
    includes?: string[];
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHeader {
    checkPresences?: string[];
    excludeOrigin?: boolean;
    includes?: string[];
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyHost {
    resolved?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    excludes?: string[];
    includes?: string[];
}

export interface GetRulesetsRulesetRuleActionParametersCacheKeyCustomKeyUser {
    deviceType?: boolean;
    geo?: boolean;
    lang?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersEdgeTtl {
    default?: number;
    mode: string;
    statusCodeTtls?: outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    statusCode?: number;
    statusCodeRanges?: outputs.GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange[];
    value: number;
}

export interface GetRulesetsRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    from?: number;
    to?: number;
}

export interface GetRulesetsRulesetRuleActionParametersFromList {
    key: string;
    name: string;
}

export interface GetRulesetsRulesetRuleActionParametersFromValue {
    preserveQueryString?: boolean;
    statusCode?: number;
    targetUrl?: outputs.GetRulesetsRulesetRuleActionParametersFromValueTargetUrl;
}

export interface GetRulesetsRulesetRuleActionParametersFromValueTargetUrl {
    expression?: string;
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersHeader {
    expression?: string;
    name?: string;
    operation?: string;
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersMatchedData {
    publicKey?: string;
}

export interface GetRulesetsRulesetRuleActionParametersOrigin {
    host?: string;
    port?: number;
}

export interface GetRulesetsRulesetRuleActionParametersOverrides {
    action?: string;
    categories?: outputs.GetRulesetsRulesetRuleActionParametersOverridesCategory[];
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    rules?: outputs.GetRulesetsRulesetRuleActionParametersOverridesRule[];
    sensitivityLevel?: string;
    status?: string;
}

export interface GetRulesetsRulesetRuleActionParametersOverridesCategory {
    action?: string;
    category?: string;
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    status?: string;
}

export interface GetRulesetsRulesetRuleActionParametersOverridesRule {
    action?: string;
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
    scoreThreshold?: number;
    sensitivityLevel?: string;
    status?: string;
}

export interface GetRulesetsRulesetRuleActionParametersResponse {
    content?: string;
    contentType?: string;
    statusCode?: number;
}

export interface GetRulesetsRulesetRuleActionParametersServeStale {
    disableStaleWhileUpdating?: boolean;
}

export interface GetRulesetsRulesetRuleActionParametersSni {
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersUri {
    origin?: boolean;
    path?: outputs.GetRulesetsRulesetRuleActionParametersUriPath;
    query?: outputs.GetRulesetsRulesetRuleActionParametersUriQuery;
}

export interface GetRulesetsRulesetRuleActionParametersUriPath {
    expression?: string;
    value?: string;
}

export interface GetRulesetsRulesetRuleActionParametersUriQuery {
    expression?: string;
    value?: string;
}

export interface GetRulesetsRulesetRuleExposedCredentialCheck {
    passwordExpression?: string;
    usernameExpression?: string;
}

export interface GetRulesetsRulesetRuleLogging {
    /**
     * @deprecated Use `status` instead. Continuing to use `enabled` will result in an inconsistent state for your Ruleset configuration.
     */
    enabled?: boolean;
    status?: string;
}

export interface GetRulesetsRulesetRuleRatelimit {
    characteristics?: string[];
    countingExpression?: string;
    mitigationTimeout?: number;
    period?: number;
    requestsPerPeriod?: number;
    requestsToOrigin?: boolean;
    scorePerPeriod?: number;
    scoreResponseHeaderName?: string;
}

export interface GetZonesFilter {
    /**
     * The account identifier to target for the resource.
     */
    accountId?: string;
    /**
     * The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
     */
    lookupType?: string;
    /**
     * A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookupType`	are performed on the Cloudflare server side.
     */
    match?: string;
    /**
     * A string value to search for.
     */
    name?: string;
    /**
     * Paused status of the zone to lookup. Defaults to `false`.
     */
    paused?: boolean;
    /**
     * Status of the zone to lookup.
     */
    status?: string;
}

export interface GetZonesZone {
    /**
     * The ID of this resource.
     */
    id?: string;
    name?: string;
}

export interface HealthcheckHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of string values for the header.
     */
    values: string[];
}

export interface ListItem {
    /**
     * An optional comment for the item.
     */
    comment?: string;
    value: outputs.ListItemValue;
}

export interface ListItemHostname {
    /**
     * The FQDN to match on.
     */
    urlHostname: string;
}

export interface ListItemRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
     */
    includeSubdomains?: string;
    /**
     * Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
     */
    preservePathSuffix?: string;
    /**
     * Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
     */
    preserveQueryString?: string;
    /**
     * The source url of the redirect.
     */
    sourceUrl: string;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: number;
    /**
     * Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
     */
    subpathMatching?: string;
    /**
     * The target url of the redirect.
     */
    targetUrl: string;
}

export interface ListItemValue {
    asn?: number;
    hostnames?: outputs.ListItemValueHostname[];
    ip?: string;
    redirects?: outputs.ListItemValueRedirect[];
}

export interface ListItemValueHostname {
    urlHostname: string;
}

export interface ListItemValueRedirect {
    includeSubdomains?: string;
    preservePathSuffix?: string;
    preserveQueryString?: string;
    sourceUrl: string;
    statusCode?: number;
    subpathMatching?: string;
    targetUrl: string;
}

export interface LoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
     */
    failoverAcrossPools?: boolean;
}

export interface LoadBalancerCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: string[];
}

export interface LoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolverIp` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolverIp`. Defaults to `pop`.
     */
    mode?: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
     */
    preferEcs?: string;
}

export interface LoadBalancerMonitorHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of values for the header.
     */
    values: string[];
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * Percent of traffic to shed 0 - 100. Defaults to `0`.
     */
    defaultPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
     */
    defaultPolicy?: string;
    /**
     * Percent of session traffic to shed 0 - 100. Defaults to `0`.
     */
    sessionPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
     */
    sessionPolicy?: string;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
     */
    address: string;
    /**
     * Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * HTTP request headers.
     */
    headers?: outputs.LoadBalancerPoolOriginHeader[];
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. Defaults to `1`.
     */
    weight?: number;
}

export interface LoadBalancerPoolOriginHeader {
    header: string;
    values: string[];
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * Origin steering policy to be used. Available values: `""`, `hash`, `random`. Defaults to `random`.
     */
    policy?: string;
}

export interface LoadBalancerPopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `poolWeights` map.
     */
    defaultWeight?: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRule {
    /**
     * The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
     */
    condition?: string;
    /**
     * A disabled rule will not be executed.
     */
    disabled?: boolean;
    /**
     * Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixedResponse` must be set.
     */
    fixedResponse?: outputs.LoadBalancerRuleFixedResponse;
    /**
     * Human readable name for this rule.
     */
    name: string;
    /**
     * The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixedResponse` must be set.
     */
    overrides?: outputs.LoadBalancerRuleOverride[];
    /**
     * Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
     */
    priority: number;
    /**
     * Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixedResponse` forces this field to `true`.
     */
    terminates: boolean;
}

export interface LoadBalancerRuleFixedResponse {
    contentType?: string;
    location?: string;
    messageBody?: string;
    statusCode?: number;
}

export interface LoadBalancerRuleOverride {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     */
    adaptiveRoutings?: outputs.LoadBalancerRuleOverrideAdaptiveRouting[];
    /**
     * A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     */
    countryPools: outputs.LoadBalancerRuleOverrideCountryPool[];
    defaultPools?: string[];
    fallbackPool?: string;
    /**
     * Controls location-based steering for non-proxied requests.
     */
    locationStrategies?: outputs.LoadBalancerRuleOverrideLocationStrategy[];
    /**
     * A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     */
    popPools: outputs.LoadBalancerRuleOverridePopPool[];
    /**
     * Configures pool weights for random steering. When the `steering_policy="random"`, a random pool is selected with probability proportional to these pool weights.
     */
    randomSteerings?: outputs.LoadBalancerRuleOverrideRandomSteering[];
    /**
     * A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     */
    regionPools: outputs.LoadBalancerRuleOverrideRegionPool[];
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `none` or `""` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ipCookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `""`, `none`, `cookie`, `ipCookie`. Defaults to `none`.
     */
    sessionAffinity?: string;
    /**
     * Configure cookie attributes for session affinity cookie.
     */
    sessionAffinityAttributes?: outputs.LoadBalancerRuleOverrideSessionAffinityAttribute[];
    /**
     * Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `sessionAffinityTtl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     */
    sessionAffinityTtl?: number;
    /**
     * The method the load balancer uses to determine the route to your origin. Value `off` uses `defaultPoolIds`. Value `geo` uses `popPools`/`countryPools`/`regionPools`. For non-proxied requests, the `country` for `countryPools` is determined by `locationStrategy`. Value `random` selects a pool randomly. Value `dynamicLatency` uses round trip time to select the closest pool in `defaultPoolIds` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `locationStrategy` for non-proxied requests. Value `""` maps to `geo` if you use `popPools`/`countryPools`/`regionPools` otherwise `off`. Available values: `off`, `geo`, `dynamicLatency`, `random`, `proximity`, `""` Defaults to `""`.
     */
    steeringPolicy?: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
     */
    ttl?: number;
}

export interface LoadBalancerRuleOverrideAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
     */
    failoverAcrossPools?: boolean;
}

export interface LoadBalancerRuleOverrideCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: string[];
}

export interface LoadBalancerRuleOverrideLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolverIp` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolverIp`. Defaults to `pop`.
     */
    mode?: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
     */
    preferEcs?: string;
}

export interface LoadBalancerRuleOverridePopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRuleOverrideRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `poolWeights` map.
     */
    defaultWeight?: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRuleOverrideRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRuleOverrideSessionAffinityAttribute {
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
     */
    samesite?: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
     */
    secure?: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
     */
    zeroDowntimeFailover?: string;
}

export interface LoadBalancerSessionAffinityAttribute {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
     */
    drainDuration?: number;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
     */
    samesite?: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
     */
    secure?: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
     */
    zeroDowntimeFailover?: string;
}

export interface ManagedHeadersManagedRequestHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface ManagedHeadersManagedResponseHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface NotificationPolicyEmailIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the notification policy.
     */
    name?: string;
}

export interface NotificationPolicyFilters {
    /**
     * State of the pool to alert on.
     */
    enableds?: string[];
    /**
     * Source configuration to alert on for pool or origin.
     */
    eventSources?: string[];
    /**
     * Stream event type to alert on.
     */
    eventTypes?: string[];
    /**
     * Identifier health check. Required when using `filters.0.status`.
     */
    healthCheckIds?: string[];
    /**
     * Stream input id to alert on.
     */
    inputIds?: string[];
    /**
     * A numerical limit. Example: `100`.
     */
    limits?: string[];
    /**
     * Megabits per second threshold for dos alert.
     */
    megabitsPerSeconds?: string[];
    /**
     * Health status to alert on for pool or origin.
     */
    newHealths?: string[];
    /**
     * Packets per second threshold for dos alert.
     */
    packetsPerSeconds?: string[];
    /**
     * Load balancer pool identifier.
     */
    poolIds?: string[];
    /**
     * Product name. Available values: `workerRequests`, `workerDurableObjectsRequests`, `workerDurableObjectsDuration`, `workerDurableObjectsDataTransfer`, `workerDurableObjectsStoredData`, `workerDurableObjectsStorageDeletes`, `workerDurableObjectsStorageWrites`, `workerDurableObjectsStorageReads`.
     */
    products?: string[];
    /**
     * Protocol to alert on for dos.
     */
    protocols?: string[];
    /**
     * Requests per second threshold for dos alert.
     */
    requestsPerSeconds?: string[];
    services?: string[];
    /**
     * A numerical limit. Example: `99.9`.
     */
    slos?: string[];
    /**
     * Status to alert on.
     */
    statuses?: string[];
    /**
     * Target host to alert on for dos.
     */
    targetHostnames?: string[];
    /**
     * Target domain to alert on.
     */
    targetZoneNames?: string[];
    /**
     * A list of zone identifiers.
     */
    zones?: string[];
}

export interface NotificationPolicyPagerdutyIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the notification policy.
     */
    name?: string;
}

export interface NotificationPolicyWebhooksIntegration {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * The name of the notification policy.
     */
    name?: string;
}

export interface PageRuleActions {
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    alwaysUseHttps?: boolean;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    automaticHttpsRewrites?: string;
    /**
     * The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
     */
    browserCacheTtl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    browserCheck?: string;
    /**
     * String value of cookie name to conditionally bypass cache the page.
     */
    bypassCacheOnCookie?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheByDeviceType?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheDeceptionArmor?: string;
    /**
     * Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
     */
    cacheKeyFields?: outputs.PageRuleActionsCacheKeyFields;
    /**
     * Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cacheEverything"`.
     */
    cacheLevel?: string;
    /**
     * String value of cookie name to conditionally cache the page.
     */
    cacheOnCookie?: string;
    /**
     * Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
     */
    cacheTtlByStatuses?: outputs.PageRuleActionsCacheTtlByStatus[];
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableApps?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disablePerformance?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableRailgun?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableSecurity?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableZaraz?: boolean;
    /**
     * The Time To Live for the edge cache.
     */
    edgeCacheTtl?: number;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    emailObfuscation?: string;
    /**
     * Whether origin Cache-Control action is `"on"` or `"off"`.
     */
    explicitCacheControl?: string;
    /**
     * The URL to forward to, and with what status. See below.
     */
    forwardingUrl?: outputs.PageRuleActionsForwardingUrl;
    /**
     * Value of the Host header to send.
     */
    hostHeaderOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    ipGeolocation?: string;
    /**
     * The configuration for HTML, CSS and JS minification. See below for full list of options.
     */
    minifies?: outputs.PageRuleActionsMinify[];
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    mirage?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    opportunisticEncryption?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    originErrorPagePassThru?: string;
    /**
     * Whether this action is `"off"`, `"lossless"` or `"lossy"`.
     */
    polish?: string;
    /**
     * Overridden origin server name.
     */
    resolveOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    respectStrongEtag?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    responseBuffering?: string;
    /**
     * Whether to set the rocket loader to `"on"`, `"off"`.
     */
    rocketLoader?: string;
    /**
     * Whether to set the security level to `"off"`, `"essentiallyOff"`, `"low"`, `"medium"`, `"high"`, or `"underAttack"`.
     */
    securityLevel?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    serverSideExclude?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    sortQueryStringForCache?: string;
    /**
     * Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"originPull"`.
     */
    ssl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    trueClientIpHeader?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    waf?: string;
}

export interface PageRuleActionsCacheKeyFields {
    /**
     * Controls what cookies go into Cache Key:
     */
    cookie?: outputs.PageRuleActionsCacheKeyFieldsCookie;
    /**
     * Controls what HTTP headers go into Cache Key:
     */
    header?: outputs.PageRuleActionsCacheKeyFieldsHeader;
    /**
     * Controls which Host header goes into Cache Key:
     */
    host: outputs.PageRuleActionsCacheKeyFieldsHost;
    /**
     * Controls which URL query string parameters go into the Cache Key.
     */
    queryString: outputs.PageRuleActionsCacheKeyFieldsQueryString;
    /**
     * Controls which end user-related features go into the Cache Key.
     */
    user: outputs.PageRuleActionsCacheKeyFieldsUser;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    /**
     * Check for presence of specified cookies, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Use values of specified cookies in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    /**
     * Check for presence of specified cookies, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
     */
    excludes: string[];
    /**
     * Use values of specified cookies in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHost {
    /**
     * `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
     */
    resolved?: boolean;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    /**
     * Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
     */
    excludes: string[];
    /**
     * `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
     */
    ignore: boolean;
    /**
     * Use values of specified cookies in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsUser {
    /**
     * `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
     */
    deviceType: boolean;
    /**
     * `true` - includes the client’s country, derived from the IP address; defaults to `false`.
     */
    geo: boolean;
    /**
     * `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
     *
     * Example:
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as cloudflare from "@pulumi/cloudflare";
     *
     * // Unrealistic example with all features used
     * const foobar = new cloudflare.PageRule("foobar", {
     *     zoneId: _var.cloudflare_zone_id,
     *     target: `${_var.cloudflare_zone}/app/*`,
     *     priority: 1,
     *     actions: {
     *         cacheKeyFields: {
     *             cookie: {
     *                 checkPresences: ["wordpress_test_cookie"],
     *             },
     *             header: {
     *                 checkPresences: ["header_present"],
     *                 excludes: ["origin"],
     *                 includes: [
     *                     "api-key",
     *                     "dnt",
     *                 ],
     *             },
     *             host: {
     *                 resolved: true,
     *             },
     *             queryString: {
     *                 ignore: true,
     *             },
     *             user: {
     *                 deviceType: false,
     *                 geo: true,
     *                 lang: true,
     *             },
     *         },
     *     },
     * });
     * ```
     */
    lang: boolean;
}

export interface PageRuleActionsCacheTtlByStatus {
    /**
     * A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
     */
    codes: string;
    /**
     * Duration a resource lives in the Cloudflare cache.
     * - positive number - cache for specified duration in seconds
     */
    ttl: number;
}

export interface PageRuleActionsForwardingUrl {
    /**
     * The status code to use for the redirection.
     */
    statusCode: number;
    /**
     * The URL to which the page rule should forward.
     */
    url: string;
}

export interface PageRuleActionsMinify {
    /**
     * Whether CSS should be minified. Valid values are `"on"` or `"off"`.
     */
    css: string;
    /**
     * Whether HTML should be minified. Valid values are `"on"` or `"off"`.
     */
    html: string;
    /**
     * Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
     */
    js: string;
}

export interface PagesProjectBuildConfig {
    /**
     * Command used to build project.
     */
    buildCommand?: string;
    /**
     * Output directory of the build.
     */
    destinationDir?: string;
    /**
     * Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
     */
    rootDir?: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag?: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken?: string;
}

export interface PagesProjectDeploymentConfigs {
    /**
     * Configuration for preview deploys.
     */
    preview: outputs.PagesProjectDeploymentConfigsPreview;
    /**
     * Configuration for production deploys.
     */
    production: outputs.PagesProjectDeploymentConfigsProduction;
}

export interface PagesProjectDeploymentConfigsPreview {
    alwaysUseLatestCompatibilityDate?: boolean;
    compatibilityDate: string;
    compatibilityFlags: string[];
    d1Databases?: {[key: string]: any};
    durableObjectNamespaces?: {[key: string]: any};
    environmentVariables?: {[key: string]: any};
    failOpen?: boolean;
    kvNamespaces?: {[key: string]: any};
    r2Buckets?: {[key: string]: any};
    secrets?: {[key: string]: any};
    serviceBindings?: outputs.PagesProjectDeploymentConfigsPreviewServiceBinding[];
    usageModel?: string;
}

export interface PagesProjectDeploymentConfigsPreviewServiceBinding {
    environment?: string;
    /**
     * Name of the project. **Modifying this attribute will force creation of a new resource.**
     */
    name: string;
    service: string;
}

export interface PagesProjectDeploymentConfigsProduction {
    alwaysUseLatestCompatibilityDate?: boolean;
    compatibilityDate: string;
    compatibilityFlags: string[];
    d1Databases?: {[key: string]: any};
    durableObjectNamespaces?: {[key: string]: any};
    environmentVariables?: {[key: string]: any};
    failOpen?: boolean;
    kvNamespaces?: {[key: string]: any};
    r2Buckets?: {[key: string]: any};
    secrets?: {[key: string]: any};
    serviceBindings?: outputs.PagesProjectDeploymentConfigsProductionServiceBinding[];
    usageModel?: string;
}

export interface PagesProjectDeploymentConfigsProductionServiceBinding {
    environment?: string;
    /**
     * Name of the project. **Modifying this attribute will force creation of a new resource.**
     */
    name: string;
    service: string;
}

export interface PagesProjectSource {
    /**
     * Configuration for the source of the Cloudflare Pages project.
     */
    config?: outputs.PagesProjectSourceConfig;
    /**
     * Project host type.
     */
    type?: string;
}

export interface PagesProjectSourceConfig {
    deploymentsEnabled?: boolean;
    owner?: string;
    prCommentsEnabled?: boolean;
    previewBranchExcludes?: string[];
    previewBranchIncludes?: string[];
    previewDeploymentSetting?: string;
    /**
     * The name of the branch that is used for the production environment.
     */
    productionBranch: string;
    productionDeploymentEnabled?: boolean;
    repoName?: string;
}

export interface RateLimitAction {
    /**
     * The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `jsChallenge`, `managedChallenge`.
     */
    mode: string;
    /**
     * Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
     */
    response?: outputs.RateLimitActionResponse;
    /**
     * The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
     */
    timeout?: number;
}

export interface RateLimitActionResponse {
    body: string;
    contentType: string;
}

export interface RateLimitCorrelate {
    /**
     * If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
     */
    by?: string;
}

export interface RateLimitMatch {
    /**
     * Matches HTTP requests (from the client to Cloudflare).
     */
    request: outputs.RateLimitMatchRequest;
    /**
     * Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
     */
    response: outputs.RateLimitMatchResponse;
}

export interface RateLimitMatchRequest {
    methods: string[];
    schemes: string[];
    urlPattern: string;
}

export interface RateLimitMatchResponse {
    headers?: {[key: string]: string}[];
    originTraffic: boolean;
    statuses: number[];
}

export interface RecordData {
    algorithm?: number;
    altitude?: number;
    certificate?: string;
    content?: string;
    digest?: string;
    digestType?: number;
    fingerprint?: string;
    flags?: string;
    keyTag?: number;
    latDegrees?: number;
    latDirection?: string;
    latMinutes?: number;
    latSeconds?: number;
    longDegrees?: number;
    longDirection?: string;
    longMinutes?: number;
    longSeconds?: number;
    matchingType?: number;
    /**
     * The name of the record. **Modifying this attribute will force creation of a new resource.**
     */
    name?: string;
    order?: number;
    port?: number;
    precisionHorz?: number;
    precisionVert?: number;
    preference?: number;
    /**
     * The priority of the record.
     */
    priority?: number;
    proto?: string;
    protocol?: number;
    publicKey?: string;
    regex?: string;
    replacement?: string;
    selector?: number;
    service?: string;
    size?: number;
    tag?: string;
    target?: string;
    /**
     * The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`. **Modifying this attribute will force creation of a new resource.**
     */
    type?: number;
    usage?: number;
    /**
     * The value of the record. Conflicts with `data`.
     */
    value?: string;
    weight?: number;
}

export interface RulesetRule {
    /**
     * Action to perform in the ruleset rule. Available values: `allow`, `block`, `challenge`, `ddosDynamic`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `setCacheSettings`, `setConfig`, `serveError`, `skip`, `compressResponse`.
     */
    action?: string;
    /**
     * List of parameters that configure the behavior of the ruleset rule action.
     */
    actionParameters?: outputs.RulesetRuleActionParameters;
    /**
     * Brief summary of the ruleset rule and its intended use.
     */
    description: string;
    /**
     * Whether the rule is active.
     */
    enabled: boolean;
    /**
     * List of parameters that configure exposed credential checks.
     */
    exposedCredentialCheck?: outputs.RulesetRuleExposedCredentialCheck;
    /**
     * Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * The most recent update to this rule.
     */
    lastUpdated: string;
    /**
     * List parameters to configure how the rule generates logs.
     */
    logging?: outputs.RulesetRuleLogging;
    /**
     * List of parameters that configure HTTP rate limiting behaviour.
     */
    ratelimit?: outputs.RulesetRuleRatelimit;
    /**
     * Rule reference.
     */
    ref?: string;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface RulesetRuleActionParameters {
    algorithms?: outputs.RulesetRuleActionParametersAlgorithm[];
    automaticHttpsRewrites?: boolean;
    autominifies?: outputs.RulesetRuleActionParametersAutominify[];
    bic?: boolean;
    browserTtl?: outputs.RulesetRuleActionParametersBrowserTtl;
    cache?: boolean;
    cacheKey?: outputs.RulesetRuleActionParametersCacheKey;
    content?: string;
    contentType?: string;
    cookieFields?: string[];
    disableApps?: boolean;
    disableRailgun?: boolean;
    disableZaraz?: boolean;
    edgeTtl?: outputs.RulesetRuleActionParametersEdgeTtl;
    emailObfuscation?: boolean;
    fromList?: outputs.RulesetRuleActionParametersFromList;
    fromValue?: outputs.RulesetRuleActionParametersFromValue;
    headers?: outputs.RulesetRuleActionParametersHeader[];
    hostHeader?: string;
    hotlinkProtection?: boolean;
    /**
     * The identifier of this resource.
     */
    id?: string;
    increment?: number;
    matchedData?: outputs.RulesetRuleActionParametersMatchedData;
    mirage?: boolean;
    opportunisticEncryption?: boolean;
    origin?: outputs.RulesetRuleActionParametersOrigin;
    originErrorPagePassthru?: boolean;
    overrides?: outputs.RulesetRuleActionParametersOverrides;
    phases?: string[];
    polish?: string;
    products?: string[];
    requestFields?: string[];
    respectStrongEtags?: boolean;
    responseFields?: string[];
    responses?: outputs.RulesetRuleActionParametersResponse[];
    rocketLoader?: boolean;
    /**
     * List of rules to apply to the ruleset.
     */
    rules?: {[key: string]: string};
    ruleset?: string;
    rulesets?: string[];
    securityLevel?: string;
    serveStale?: outputs.RulesetRuleActionParametersServeStale;
    serverSideExcludes?: boolean;
    sni?: outputs.RulesetRuleActionParametersSni;
    ssl?: string;
    statusCode?: number;
    sxg?: boolean;
    uri?: outputs.RulesetRuleActionParametersUri;
    version: string;
}

export interface RulesetRuleActionParametersAlgorithm {
    /**
     * Name of the ruleset.
     */
    name: string;
}

export interface RulesetRuleActionParametersAutominify {
    css?: boolean;
    html?: boolean;
    js?: boolean;
}

export interface RulesetRuleActionParametersBrowserTtl {
    default?: number;
    mode: string;
}

export interface RulesetRuleActionParametersCacheKey {
    cacheByDeviceType?: boolean;
    cacheDeceptionArmor?: boolean;
    customKey?: outputs.RulesetRuleActionParametersCacheKeyCustomKey;
    ignoreQueryStringsOrder?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKey {
    cookie?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie;
    header?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader;
    host?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost;
    queryString?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    user?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyCookie {
    checkPresences?: string[];
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHeader {
    checkPresences?: string[];
    excludeOrigin?: boolean;
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHost {
    resolved?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    excludes?: string[];
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyUser {
    deviceType?: boolean;
    geo?: boolean;
    lang?: boolean;
}

export interface RulesetRuleActionParametersEdgeTtl {
    default?: number;
    mode: string;
    statusCodeTtls?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    statusCode?: number;
    statusCodeRanges?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange[];
    value?: number;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    from?: number;
    to?: number;
}

export interface RulesetRuleActionParametersFromList {
    key?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
}

export interface RulesetRuleActionParametersFromValue {
    preserveQueryString?: boolean;
    statusCode?: number;
    targetUrl?: outputs.RulesetRuleActionParametersFromValueTargetUrl;
}

export interface RulesetRuleActionParametersFromValueTargetUrl {
    expression?: string;
    value?: string;
}

export interface RulesetRuleActionParametersHeader {
    expression?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
    operation?: string;
    value?: string;
}

export interface RulesetRuleActionParametersMatchedData {
    publicKey?: string;
}

export interface RulesetRuleActionParametersOrigin {
    host?: string;
    port?: number;
}

export interface RulesetRuleActionParametersOverrides {
    action?: string;
    categories?: outputs.RulesetRuleActionParametersOverridesCategory[];
    enabled?: boolean;
    /**
     * List of rules to apply to the ruleset.
     */
    rules?: outputs.RulesetRuleActionParametersOverridesRule[];
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersOverridesCategory {
    action?: string;
    category?: string;
    enabled?: boolean;
}

export interface RulesetRuleActionParametersOverridesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `allow`, `block`, `challenge`, `ddosDynamic`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `setCacheSettings`, `setConfig`, `serveError`, `skip`, `compressResponse`.
     */
    action?: string;
    /**
     * Whether the rule is active.
     */
    enabled?: boolean;
    /**
     * Unique rule identifier.
     */
    id?: string;
    scoreThreshold?: number;
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersResponse {
    content?: string;
    contentType?: string;
    statusCode?: number;
}

export interface RulesetRuleActionParametersServeStale {
    disableStaleWhileUpdating?: boolean;
}

export interface RulesetRuleActionParametersSni {
    value?: string;
}

export interface RulesetRuleActionParametersUri {
    origin?: boolean;
    path?: outputs.RulesetRuleActionParametersUriPath;
    query?: outputs.RulesetRuleActionParametersUriQuery;
}

export interface RulesetRuleActionParametersUriPath {
    expression?: string;
    value?: string;
}

export interface RulesetRuleActionParametersUriQuery {
    expression?: string;
    value?: string;
}

export interface RulesetRuleExposedCredentialCheck {
    passwordExpression?: string;
    usernameExpression?: string;
}

export interface RulesetRuleLogging {
    enabled?: boolean;
}

export interface RulesetRuleRatelimit {
    characteristics?: string[];
    countingExpression?: string;
    mitigationTimeout?: number;
    period?: number;
    requestsPerPeriod?: number;
    requestsToOrigin?: boolean;
    scorePerPeriod?: number;
    scoreResponseHeaderName?: string;
}

export interface SpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name: string;
    /**
     * The type of DNS record associated with the application.
     */
    type: string;
}

export interface SpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
     */
    connectivity?: string;
    /**
     * The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
     */
    ips?: string[];
    /**
     * The type of edge IP configuration specified. Available values: `dynamic`, `static`.
     */
    type: string;
}

export interface SpectrumApplicationOriginDns {
    /**
     * Fully qualified domain name of the origin.
     */
    name: string;
}

export interface SpectrumApplicationOriginPortRange {
    /**
     * Upper bound of the origin port range.
     */
    end: number;
    /**
     * Lower bound of the origin port range.
     */
    start: number;
}

export interface SplitTunnelTunnel {
    /**
     * The address for the tunnel.
     */
    address?: string;
    /**
     * A description for the tunnel.
     */
    description?: string;
    /**
     * The domain name for the tunnel.
     */
    host?: string;
}

export interface TeamsAccountAntivirus {
    /**
     * Scan on file download.
     */
    enabledDownloadPhase: boolean;
    /**
     * Scan on file upload.
     */
    enabledUploadPhase: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: boolean;
}

export interface TeamsAccountBlockPage {
    /**
     * Hex code of block page background color.
     */
    backgroundColor?: string;
    /**
     * Indicator of enablement.
     */
    enabled?: boolean;
    /**
     * Block page footer text.
     */
    footerText?: string;
    /**
     * Block page header text.
     */
    headerText?: string;
    /**
     * URL of block page logo.
     */
    logoPath?: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: string;
    /**
     * Name of block page configuration.
     */
    name?: string;
}

export interface TeamsAccountFips {
    /**
     * Only allow FIPS-compliant TLS configuration.
     */
    tls?: boolean;
}

export interface TeamsAccountLogging {
    /**
     * Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
     */
    redactPii: boolean;
    /**
     * Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
     */
    settingsByRuleType: outputs.TeamsAccountLoggingSettingsByRuleType;
}

export interface TeamsAccountLoggingSettingsByRuleType {
    dns: outputs.TeamsAccountLoggingSettingsByRuleTypeDns;
    http: outputs.TeamsAccountLoggingSettingsByRuleTypeHttp;
    l4: outputs.TeamsAccountLoggingSettingsByRuleTypeL4;
}

export interface TeamsAccountLoggingSettingsByRuleTypeDns {
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeHttp {
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeL4 {
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountPayloadLog {
    /**
     * Public key used to encrypt matched payloads.
     */
    publicKey: string;
}

export interface TeamsAccountProxy {
    /**
     * Whether gateway proxy is enabled on gateway devices for TCP traffic.
     */
    tcp: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for UDP traffic.
     */
    udp: boolean;
}

export interface TeamsLocationNetwork {
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * CIDR notation representation of the network IP.
     */
    network: string;
}

export interface TeamsRuleRuleSettings {
    /**
     * Add custom headers to allowed requests in the form of key-value pairs.
     */
    addHeaders?: {[key: string]: string};
    /**
     * Allow parent MSP accounts to enable bypass their children's rules.
     */
    allowChildBypass?: boolean;
    /**
     * Settings for auditing SSH usage.
     */
    auditSsh?: outputs.TeamsRuleRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls?: outputs.TeamsRuleRuleSettingsBisoAdminControls;
    /**
     * Indicator of block page enablement.
     */
    blockPageEnabled?: boolean;
    /**
     * The displayed reason for a user being blocked.
     */
    blockPageReason?: string;
    /**
     * Allow child MSP accounts to bypass their parent's rule.
     */
    bypassParentRule?: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession?: outputs.TeamsRuleRuleSettingsCheckSession;
    /**
     * Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
     */
    egress?: outputs.TeamsRuleRuleSettingsEgress;
    /**
     * Disable DNSSEC validation (must be Allow rule).
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Turns on IP category based filter on dns if the rule contains dns category checks.
     */
    ipCategories?: boolean;
    /**
     * Settings to forward layer 4 traffic.
     */
    l4override?: outputs.TeamsRuleRuleSettingsL4override;
    /**
     * The host to override matching DNS queries with.
     */
    overrideHost?: string;
    /**
     * The IPs to override matching DNS queries with.
     */
    overrideIps?: string[];
    /**
     * Configure DLP Payload Logging settings for this rule.
     */
    payloadLog?: outputs.TeamsRuleRuleSettingsPayloadLog;
    /**
     * Configure untrusted certificate settings for this rule.
     */
    untrustedCert?: outputs.TeamsRuleRuleSettingsUntrustedCert;
}

export interface TeamsRuleRuleSettingsAuditSsh {
    commandLogging: boolean;
}

export interface TeamsRuleRuleSettingsBisoAdminControls {
    disableCopyPaste?: boolean;
    disableDownload?: boolean;
    disableKeyboard?: boolean;
    disablePrinting?: boolean;
    disableUpload?: boolean;
}

export interface TeamsRuleRuleSettingsCheckSession {
    duration: string;
    enforce: boolean;
}

export interface TeamsRuleRuleSettingsEgress {
    ipv4: string;
    ipv4Fallback?: string;
    ipv6: string;
}

export interface TeamsRuleRuleSettingsL4override {
    ip: string;
    port: number;
}

export interface TeamsRuleRuleSettingsPayloadLog {
    /**
     * Indicator of rule enablement.
     */
    enabled: boolean;
}

export interface TeamsRuleRuleSettingsUntrustedCert {
    /**
     * The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4Override`, `egress`, `auditSsh`.
     */
    action?: string;
}

export interface TunnelConfigConfig {
    /**
     * Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
     */
    ingressRules: outputs.TunnelConfigConfigIngressRule[];
    originRequest?: outputs.TunnelConfigConfigOriginRequest;
    /**
     * If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
     */
    warpRouting?: outputs.TunnelConfigConfigWarpRouting;
}

export interface TunnelConfigConfigIngressRule {
    hostname?: string;
    originRequest?: outputs.TunnelConfigConfigIngressRuleOriginRequest;
    path?: string;
    service: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequest {
    access?: outputs.TunnelConfigConfigIngressRuleOriginRequestAccess;
    bastionMode?: boolean;
    caPool?: string;
    connectTimeout?: string;
    disableChunkedEncoding?: boolean;
    http2Origin?: boolean;
    httpHostHeader?: string;
    ipRules?: outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule[];
    keepAliveConnections?: number;
    keepAliveTimeout?: string;
    noHappyEyeballs?: boolean;
    noTlsVerify?: boolean;
    originServerName?: string;
    proxyAddress?: string;
    proxyPort?: number;
    proxyType?: string;
    tcpKeepAlive?: string;
    tlsTimeout?: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequestAccess {
    audTags?: string[];
    required?: boolean;
    teamName?: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequestIpRule {
    allow?: boolean;
    ports?: number[];
    prefix?: string;
}

export interface TunnelConfigConfigOriginRequest {
    access?: outputs.TunnelConfigConfigOriginRequestAccess;
    bastionMode?: boolean;
    caPool?: string;
    connectTimeout?: string;
    disableChunkedEncoding?: boolean;
    http2Origin?: boolean;
    httpHostHeader?: string;
    ipRules?: outputs.TunnelConfigConfigOriginRequestIpRule[];
    keepAliveConnections?: number;
    keepAliveTimeout?: string;
    noHappyEyeballs?: boolean;
    noTlsVerify?: boolean;
    originServerName?: string;
    proxyAddress?: string;
    proxyPort?: number;
    proxyType?: string;
    tcpKeepAlive?: string;
    tlsTimeout?: string;
}

export interface TunnelConfigConfigOriginRequestAccess {
    audTags?: string[];
    required?: boolean;
    teamName?: string;
}

export interface TunnelConfigConfigOriginRequestIpRule {
    allow?: boolean;
    ports?: number[];
    prefix?: string;
}

export interface TunnelConfigConfigWarpRouting {
    enabled?: boolean;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
     */
    value: string;
}

export interface WaitingRoomRulesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `bypassWaitingRoom`.
     */
    action: string;
    /**
     * Brief summary of the waiting room rule and its intended use.
     */
    description?: string;
    /**
     * Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
     */
    status?: string;
    /**
     * Version of the waiting room rule.
     */
    version: string;
}

export interface WorkerScriptAnalyticsEngineBinding {
    /**
     * The name of the Analytics Engine dataset to write to.
     */
    dataset: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptKvNamespaceBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * ID of the KV namespace you want to use.
     */
    namespaceId: string;
}

export interface WorkerScriptPlainTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The plain text you want to store.
     */
    text: string;
}

export interface WorkerScriptQueueBinding {
    /**
     * The name of the global variable for the binding in your Worker code.
     */
    binding: string;
    /**
     * Name of the queue you want to use.
     */
    queue: string;
}

export interface WorkerScriptR2BucketBinding {
    /**
     * The name of the Bucket to bind to.
     */
    bucketName: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptSecretTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The secret text you want to store.
     */
    text: string;
}

export interface WorkerScriptServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface WorkerScriptWebassemblyBinding {
    /**
     * The base64 encoded wasm module you want to store.
     */
    module: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface ZoneLockdownConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ipRange`.
     */
    target: string;
    /**
     * The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
     */
    value: string;
}

export interface ZoneSettingsOverrideInitialSetting {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    cacheLevel: string;
    challengeTtl: number;
    ciphers: string[];
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    minTlsVersion: string;
    minify: outputs.ZoneSettingsOverrideInitialSettingMinify;
    mirage: string;
    mobileRedirect: outputs.ZoneSettingsOverrideInitialSettingMobileRedirect;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    originMaxHttpVersion: string;
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader: outputs.ZoneSettingsOverrideInitialSettingSecurityHeader;
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    ssl: string;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `min_tls_version = "1.2"` instead.
     */
    tls12Only: string;
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideInitialSettingMinify {
    css: string;
    html: string;
    js: string;
}

export interface ZoneSettingsOverrideInitialSettingMobileRedirect {
    mobileSubdomain: string;
    status: string;
    stripUri: boolean;
}

export interface ZoneSettingsOverrideInitialSettingSecurityHeader {
    enabled: boolean;
    includeSubdomains: boolean;
    maxAge: number;
    nosniff: boolean;
    preload: boolean;
}

export interface ZoneSettingsOverrideSettings {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    cacheLevel: string;
    challengeTtl: number;
    ciphers: string[];
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    minTlsVersion: string;
    minify: outputs.ZoneSettingsOverrideSettingsMinify;
    mirage: string;
    mobileRedirect: outputs.ZoneSettingsOverrideSettingsMobileRedirect;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    originMaxHttpVersion: string;
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader: outputs.ZoneSettingsOverrideSettingsSecurityHeader;
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    ssl: string;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `min_tls_version = "1.2"` instead.
     */
    tls12Only: string;
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideSettingsMinify {
    css: string;
    html: string;
    js: string;
}

export interface ZoneSettingsOverrideSettingsMobileRedirect {
    mobileSubdomain: string;
    status: string;
    stripUri: boolean;
}

export interface ZoneSettingsOverrideSettingsSecurityHeader {
    enabled: boolean;
    includeSubdomains: boolean;
    maxAge: number;
    nosniff: boolean;
    preload: boolean;
}

