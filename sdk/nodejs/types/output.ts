// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessRuleConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     */
    target?: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value?: string;
}

export interface AccessRuleScope {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The scope of the rule.
     */
    type: string;
}

export interface AccountMemberPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    access: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.AccountMemberPolicyPermissionGroup[];
    /**
     * A list of resource groups that the policy applies to.
     */
    resourceGroups: outputs.AccountMemberPolicyResourceGroup[];
}

export interface AccountMemberPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
}

export interface AccountMemberPolicyResourceGroup {
    /**
     * Identifier of the group.
     */
    id: string;
}

export interface AccountMemberUser {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
     */
    twoFactorAuthenticationEnabled: boolean;
}

export interface AccountSettings {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     */
    abuseContactEmail?: string;
    /**
     * Specifies the default nameservers to be used for new zones added to this account.
     */
    defaultNameservers: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     */
    enforceTwofactor: boolean;
    /**
     * Indicates whether new zones should use the account-level custom
     * nameservers by default.
     *
     * Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
     */
    useAccountCustomNsByDefault: boolean;
}

export interface AccountSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency?: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged?: boolean;
    /**
     * The ID of the rate plan.
     */
    id?: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract?: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName?: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope?: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets?: string[];
}

export interface AccountTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.AccountTokenConditionRequestIp;
}

export interface AccountTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins?: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns?: string[];
}

export interface AccountTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.AccountTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface AccountTokenPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta?: outputs.AccountTokenPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface AccountTokenPolicyPermissionGroupMeta {
    key?: string;
    value?: string;
}

export interface AccountUnit {
    /**
     * Tenant unit ID
     */
    id?: string;
}

export interface AddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete: boolean;
    createdAt: string;
    /**
     * The identifier for the membership (eg. a zone or account tag).
     */
    identifier?: string;
    /**
     * The type of the membership.
     */
    kind?: string;
}

export interface ApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic field, i.e., the header or cookie name.
     */
    name: string;
    /**
     * The type of characteristic.
     */
    type: string;
}

export interface ApiShieldError {
    code: number;
    message: string;
}

export interface ApiShieldMessage {
    code: number;
    message: string;
}

export interface ApiShieldOperationFeatures {
    /**
     * API Routing settings on endpoint.
     */
    apiRouting: outputs.ApiShieldOperationFeaturesApiRouting;
    confidenceIntervals: outputs.ApiShieldOperationFeaturesConfidenceIntervals;
    parameterSchemas: outputs.ApiShieldOperationFeaturesParameterSchemas;
    schemaInfo: outputs.ApiShieldOperationFeaturesSchemaInfo;
    thresholds: outputs.ApiShieldOperationFeaturesThresholds;
}

export interface ApiShieldOperationFeaturesApiRouting {
    lastUpdated: string;
    /**
     * Target route.
     */
    route: string;
}

export interface ApiShieldOperationFeaturesConfidenceIntervals {
    lastUpdated: string;
    suggestedThreshold: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold {
    confidenceIntervals: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals;
    /**
     * Suggested threshold.
     */
    mean: number;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals {
    /**
     * Upper and lower bound for percentile estimate
     */
    p90: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90;
    /**
     * Upper and lower bound for percentile estimate
     */
    p95: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95;
    /**
     * Upper and lower bound for percentile estimate
     */
    p99: outputs.ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface ApiShieldOperationFeaturesParameterSchemas {
    lastUpdated: string;
    /**
     * An operation schema object containing a response.
     */
    parameterSchemas: outputs.ApiShieldOperationFeaturesParameterSchemasParameterSchemas;
}

export interface ApiShieldOperationFeaturesParameterSchemasParameterSchemas {
    /**
     * An array containing the learned parameter schemas.
     */
    parameters: string[];
    /**
     * An empty response object. This field is required to yield a valid operation schema.
     */
    responses: string;
}

export interface ApiShieldOperationFeaturesSchemaInfo {
    /**
     * Schema active on endpoint.
     */
    activeSchema: outputs.ApiShieldOperationFeaturesSchemaInfoActiveSchema;
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     */
    learnedAvailable: boolean;
    /**
     * Action taken on requests failing validation.
     */
    mitigationAction: string;
}

export interface ApiShieldOperationFeaturesSchemaInfoActiveSchema {
    createdAt: string;
    /**
     * UUID
     */
    id: string;
    /**
     * True if schema is Cloudflare-provided.
     */
    isLearned: boolean;
    /**
     * Schema file name.
     */
    name: string;
}

export interface ApiShieldOperationFeaturesThresholds {
    /**
     * The total number of auth-ids seen across this calculation.
     */
    authIdTokens: number;
    /**
     * The number of data points used for the threshold suggestion calculation.
     */
    dataPoints: number;
    lastUpdated: string;
    /**
     * The p50 quantile of requests (in period_seconds).
     */
    p50: number;
    /**
     * The p90 quantile of requests (in period_seconds).
     */
    p90: number;
    /**
     * The p99 quantile of requests (in period_seconds).
     */
    p99: number;
    /**
     * The period over which this threshold is suggested.
     */
    periodSeconds: number;
    /**
     * The estimated number of requests covered by these calculations.
     */
    requests: number;
    /**
     * The suggested threshold in requests done by the same auth*id or period*seconds.
     */
    suggestedThreshold: number;
}

export interface ApiShieldSchemaSchema {
    createdAt: string;
    /**
     * Kind of schema
     */
    kind: string;
    /**
     * Name of the schema
     */
    name: string;
    /**
     * UUID
     */
    schemaId: string;
    /**
     * Source of the schema
     */
    source: string;
    /**
     * Flag whether schema is enabled for validation.
     */
    validationEnabled: boolean;
}

export interface ApiShieldSchemaUploadDetails {
    /**
     * Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
     */
    warnings: outputs.ApiShieldSchemaUploadDetailsWarning[];
}

export interface ApiShieldSchemaUploadDetailsWarning {
    /**
     * Code that identifies the event that occurred.
     */
    code: number;
    /**
     * JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
     */
    locations: string[];
    /**
     * Diagnostic message that describes the event.
     */
    message: string;
}

export interface ApiTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.ApiTokenConditionRequestIp;
}

export interface ApiTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins?: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns?: string[];
}

export interface ApiTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.ApiTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface ApiTokenPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta?: outputs.ApiTokenPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface ApiTokenPolicyPermissionGroupMeta {
    key?: string;
    value?: string;
}

export interface AuthenticatedOriginPullsConfig {
    /**
     * Certificate identifier tag.
     */
    certId?: string;
    /**
     * Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
     */
    enabled?: boolean;
    /**
     * The hostname on the origin for which the client certificate uploaded will be used.
     */
    hostname?: string;
}

export interface BotManagementStaleZoneConfiguration {
    /**
     * Indicates that the zone's Bot Fight Mode is turned on.
     */
    fightMode: boolean;
    /**
     * Indicates that the zone's wordpress optimization for SBFM is turned on.
     */
    optimizeWordpress: boolean;
    /**
     * Indicates that the zone's definitely automated requests are being blocked or challenged.
     */
    sbfmDefinitelyAutomated: string;
    /**
     * Indicates that the zone's likely automated requests are being blocked or challenged.
     */
    sbfmLikelyAutomated: string;
    /**
     * Indicates that the zone's static resource protection is turned on.
     */
    sbfmStaticResourceProtection: string;
    /**
     * Indicates that the zone's verified bot requests are being blocked.
     */
    sbfmVerifiedBots: string;
    /**
     * Indicates that the zone's session score tracking is disabled.
     */
    suppressSessionScore: boolean;
}

<<<<<<< HEAD
=======
export interface CloudConnectorRulesParameters {
    /**
     * Host to perform Cloud Connection to
     */
    host: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface CloudConnectorRulesRule {
    /**
     * Cloud Provider type
     */
    cloudProvider?: string;
    description?: string;
    enabled?: boolean;
    expression?: string;
    id?: string;
    /**
     * Parameters of Cloud Connector Rule
     */
    parameters?: outputs.CloudConnectorRulesRuleParameters;
}

export interface CloudConnectorRulesRuleParameters {
    /**
     * Host to perform Cloud Connection to
     */
    host?: string;
}

export interface ContentScanningExpressionBody {
    /**
     * Ruleset expression to use in matching content objects
     */
    payload: string;
}

export interface CustomHostnameOwnershipVerification {
    /**
     * DNS Name for record.
     */
    name: string;
    /**
     * DNS Record type.
     */
    type: string;
    /**
     * Content for the record.
     */
    value: string;
}

export interface CustomHostnameOwnershipVerificationHttp {
    /**
     * Token to be served.
     */
    httpBody: string;
    /**
     * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
     */
    httpUrl: string;
}

export interface CustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     */
    bundleMethod: string;
    /**
     * The Certificate Authority that will issue the certificate
     */
    certificateAuthority: string;
    /**
     * Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
     */
    cloudflareBranding?: boolean;
    /**
<<<<<<< HEAD
=======
     * Array of custom certificate and key pairs (1 or 2 pairs allowed)
     */
    customCertBundles?: outputs.CustomHostnameSslCustomCertBundle[];
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * If a custom uploaded certificate is used.
     */
    customCertificate?: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: string;
    /**
     * Domain control validation (DCV) method used for this hostname.
     */
    method?: string;
    /**
     * SSL specific settings.
     */
    settings?: outputs.CustomHostnameSslSettings;
    /**
     * Level of validation to be used for this hostname. Domain validation (dv) must be used.
     */
    type?: string;
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: boolean;
}

<<<<<<< HEAD
export interface CustomHostnameSslSettings {
    /**
=======
export interface CustomHostnameSslCustomCertBundle {
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey: string;
}

export interface CustomHostnameSslSettings {
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers?: string[];
    /**
     * Whether or not Early Hints is enabled.
     */
    earlyHints?: string;
    /**
     * Whether or not HTTP2 is enabled.
     */
    http2?: string;
    /**
     * The minimum TLS version supported.
     */
    minTlsVersion?: string;
    /**
     * Whether or not TLS 1.3 is enabled.
     */
    tls13?: string;
}

export interface CustomSslGeoRestrictions {
    label?: string;
}

export interface CustomSslKeylessServer {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.CustomSslKeylessServerTunnel;
}

export interface CustomSslKeylessServerTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface DnsFirewallAttackMitigation {
    /**
     * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
     */
    enabled?: boolean;
    /**
     * Only mitigate attacks when upstream servers seem unhealthy
     */
    onlyWhenUpstreamUnhealthy: boolean;
}

export interface DnsRecordData {
    /**
     * Algorithm.
     */
    algorithm?: number;
    /**
     * Altitude of location in meters.
     */
    altitude?: number;
    /**
     * Certificate.
     */
    certificate?: string;
    /**
     * Digest.
     */
    digest?: string;
    /**
     * Digest Type.
     */
    digestType?: number;
    /**
     * fingerprint.
     */
    fingerprint?: string;
    /**
     * Flags for the CAA record.
     */
<<<<<<< HEAD
    flags?: any;
=======
    flags?: number;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Key Tag.
     */
    keyTag?: number;
    /**
     * Degrees of latitude.
     */
    latDegrees?: number;
    /**
     * Latitude direction.
     */
    latDirection?: string;
    /**
     * Minutes of latitude.
     */
    latMinutes: number;
    /**
     * Seconds of latitude.
     */
    latSeconds: number;
    /**
     * Degrees of longitude.
     */
    longDegrees?: number;
    /**
     * Longitude direction.
     */
    longDirection?: string;
    /**
     * Minutes of longitude.
     */
    longMinutes: number;
    /**
     * Seconds of longitude.
     */
    longSeconds: number;
    /**
     * Matching Type.
     */
    matchingType?: number;
    /**
     * Order.
     */
    order?: number;
    /**
     * The port of the service.
     */
    port?: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz: number;
    /**
     * Vertical precision of location.
     */
    precisionVert: number;
    /**
     * Preference.
     */
    preference?: number;
    /**
     * priority.
     */
    priority?: number;
    /**
     * Protocol.
     */
    protocol?: number;
    /**
     * Public Key.
     */
    publicKey?: string;
    /**
     * Regex.
     */
    regex?: string;
    /**
     * Replacement.
     */
    replacement?: string;
    /**
     * Selector.
     */
    selector?: number;
    /**
     * Service.
     */
    service?: string;
    /**
     * Size of location in meters.
     */
    size: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag?: string;
    /**
     * target.
     */
    target?: string;
    /**
     * Type.
     */
    type?: number;
    /**
     * Usage.
     */
    usage?: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value?: string;
    /**
     * The record weight.
     */
    weight?: number;
}

export interface DnsRecordSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

<<<<<<< HEAD
=======
export interface DnsSettingsZoneDefaults {
    /**
     * Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
     */
    flattenAllCnames?: boolean;
    /**
     * Whether to enable Foundation DNS Advanced Nameservers on the zone.
     */
    foundationDns?: boolean;
    /**
     * Settings for this internal zone.
     */
    internalDns: outputs.DnsSettingsZoneDefaultsInternalDns;
    /**
     * Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
     */
    multiProvider?: boolean;
    /**
     * Settings determining the nameservers through which the zone should be available.
     */
    nameservers: outputs.DnsSettingsZoneDefaultsNameservers;
    /**
     * The time to live (TTL) of the zone's nameserver (NS) records.
     */
    nsTtl?: number;
    /**
     * Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
     */
    secondaryOverrides?: boolean;
    /**
     * Components of the zone's SOA record.
     */
    soa: outputs.DnsSettingsZoneDefaultsSoa;
    /**
     * Whether the zone mode is a regular or CDN/DNS only zone.
     */
    zoneMode?: string;
}

export interface DnsSettingsZoneDefaultsInternalDns {
    /**
     * The ID of the zone to fallback to.
     */
    referenceZoneId?: string;
}

export interface DnsSettingsZoneDefaultsNameservers {
    /**
     * Nameserver type
     */
    type: string;
}

export interface DnsSettingsZoneDefaultsSoa {
    /**
     * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
     */
    expire: number;
    /**
     * The time to live (TTL) for negative caching of records within the zone.
     */
    minTtl: number;
    /**
     * The primary nameserver, which may be used for outbound zone transfers.
     */
    mname: string;
    /**
     * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
     */
    refresh: number;
    /**
     * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
     */
    retry: number;
    /**
     * The email address of the zone administrator, with the first label representing the local part of the email address.
     */
    rname: string;
    /**
     * The time to live (TTL) of the SOA record itself.
     */
    ttl: number;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface EmailRoutingCatchAllAction {
    /**
     * Type of action for catch-all rule.
     */
    type: string;
    values?: string[];
}

export interface EmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Default is 'all'.
     */
    type: string;
}

export interface EmailRoutingDnsError {
    code: number;
    message: string;
}

export interface EmailRoutingDnsMessage {
    code: number;
    message: string;
}

export interface EmailRoutingDnsResult {
    /**
     * DNS record content.
     */
    content: string;
    errors: outputs.EmailRoutingDnsResultError[];
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    records: outputs.EmailRoutingDnsResultRecord[];
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     */
    type: string;
}

export interface EmailRoutingDnsResultError {
    code: string;
    /**
     * List of records needed to enable an Email Routing zone.
     */
    missing: outputs.EmailRoutingDnsResultErrorMissing;
}

export interface EmailRoutingDnsResultErrorMissing {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     */
    type: string;
}

export interface EmailRoutingDnsResultInfo {
    /**
     * Total number of results for the requested service
     */
    count: number;
    /**
     * Current page within paginated list of results
     */
    page: number;
    /**
     * Number of results per page of results
     */
    perPage: number;
    /**
     * Total results available without any search parameters
     */
    totalCount: number;
}

export interface EmailRoutingDnsResultRecord {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     */
    type: string;
}

export interface EmailRoutingRuleAction {
    /**
     * Type of supported action.
     */
    type: string;
    values: string[];
}

export interface EmailRoutingRuleMatcher {
    /**
     * Field for type matcher.
     */
    field: string;
    /**
     * Type of matcher.
     */
    type: string;
    /**
     * Value for matcher.
     */
    value: string;
}

export interface EmailSecurityTrustedDomainsBody {
    comments?: string;
    /**
     * Select to prevent recently registered domains from triggering a
     * Suspicious or Malicious disposition.
     */
    isRecent: boolean;
    isRegex: boolean;
    /**
     * Select for partner or other approved domains that have similar
     * spelling to your connected domains. Prevents listed domains from
     * triggering a Spoof disposition.
     */
    isSimilarity: boolean;
    pattern: string;
}

export interface FirewallRuleAction {
    /**
     * The action to perform.
     */
    mode?: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response?: outputs.FirewallRuleActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout?: number;
}

export interface FirewallRuleActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body?: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType?: string;
}

export interface FirewallRuleFilter {
    /**
     * An informative summary of the filter.
     */
    description?: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression?: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused?: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref?: string;
}

export interface GetAccessRuleConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetAccessRuleFilter {
    configuration?: outputs.GetAccessRuleFilterConfiguration;
    /**
     * The direction used to sort returned rules.
     */
    direction?: string;
    /**
     * When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
     */
    match: string;
    /**
     * The action to apply to a matched request.
     */
    mode?: string;
    /**
     * The string to search for in the notes of existing IP Access rules.
     * Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
     */
    notes?: string;
    /**
     * The field used to sort returned rules.
     */
    order?: string;
}

export interface GetAccessRuleFilterConfiguration {
    /**
     * The target to search in existing rules.
     */
    target?: string;
    /**
     * The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
     * Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
     */
    value?: string;
}

export interface GetAccessRuleScope {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The scope of the rule.
     */
    type: string;
}

export interface GetAccessRulesConfiguration {
    /**
     * The target to search in existing rules.
     */
    target?: string;
    /**
     * The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
     * Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
     */
    value?: string;
}

export interface GetAccessRulesResult {
    /**
     * The available actions that a rule can apply to a matched request.
     */
    allowedModes: string[];
    /**
     * The rule configuration.
     */
    configuration: outputs.GetAccessRulesResultConfiguration;
    /**
     * The timestamp of when the rule was created.
     */
    createdOn: string;
    /**
     * The unique identifier of the IP Access rule.
     */
    id: string;
    /**
     * The action to apply to a matched request.
     */
    mode: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    modifiedOn: string;
    /**
     * An informative summary of the rule, typically used as a reminder or explanation.
     */
    notes: string;
    /**
     * All zones owned by the user will have the rule applied.
     */
    scope: outputs.GetAccessRulesResultScope;
}

export interface GetAccessRulesResultConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetAccessRulesResultScope {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The scope of the rule.
     */
    type: string;
}

export interface GetAccountFilter {
    /**
     * Direction to order results.
     */
    direction?: string;
    /**
     * Name of the account.
     */
    name?: string;
}

export interface GetAccountMemberFilter {
    /**
     * Direction to order results.
     */
    direction?: string;
    /**
     * Field to order results by.
     */
    order?: string;
    /**
     * A member's status in the account.
     */
    status?: string;
}

export interface GetAccountMemberPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    access: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountMemberPolicyPermissionGroup[];
    /**
     * A list of resource groups that the policy applies to.
     */
    resourceGroups: outputs.GetAccountMemberPolicyResourceGroup[];
}

export interface GetAccountMemberPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountMemberPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetAccountMemberPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMemberPolicyResourceGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the resource group.
     */
    meta: outputs.GetAccountMemberPolicyResourceGroupMeta;
    /**
     * Name of the resource group.
     */
    name: string;
    /**
     * The scope associated to the resource group
     */
    scopes: outputs.GetAccountMemberPolicyResourceGroupScope[];
}

export interface GetAccountMemberPolicyResourceGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMemberPolicyResourceGroupScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetAccountMemberPolicyResourceGroupScopeObject[];
}

export interface GetAccountMemberPolicyResourceGroupScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetAccountMemberRole {
    /**
     * Description of role's permissions.
     */
    description: string;
    /**
     * Role identifier tag.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
    permissions: outputs.GetAccountMemberRolePermissions;
}

export interface GetAccountMemberRolePermissions {
    analytics: outputs.GetAccountMemberRolePermissionsAnalytics;
    billing: outputs.GetAccountMemberRolePermissionsBilling;
    cachePurge: outputs.GetAccountMemberRolePermissionsCachePurge;
    dns: outputs.GetAccountMemberRolePermissionsDns;
    dnsRecords: outputs.GetAccountMemberRolePermissionsDnsRecords;
    lb: outputs.GetAccountMemberRolePermissionsLb;
    logs: outputs.GetAccountMemberRolePermissionsLogs;
    organization: outputs.GetAccountMemberRolePermissionsOrganization;
    ssl: outputs.GetAccountMemberRolePermissionsSsl;
    waf: outputs.GetAccountMemberRolePermissionsWaf;
    zoneSettings: outputs.GetAccountMemberRolePermissionsZoneSettings;
    zones: outputs.GetAccountMemberRolePermissionsZones;
}

export interface GetAccountMemberRolePermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberRolePermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountMemberUser {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
     */
    twoFactorAuthenticationEnabled: boolean;
}

export interface GetAccountMembersResult {
    /**
     * Membership identifier tag.
     */
    id: string;
    /**
     * Access policy for the membership
     */
    policies: outputs.GetAccountMembersResultPolicy[];
    /**
     * Roles assigned to this Member.
     */
    roles: outputs.GetAccountMembersResultRole[];
    /**
     * A member's status in the account.
     */
    status: string;
    /**
     * Details of the user associated to the membership.
     */
    user: outputs.GetAccountMembersResultUser;
}

export interface GetAccountMembersResultPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    access: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountMembersResultPolicyPermissionGroup[];
    /**
     * A list of resource groups that the policy applies to.
     */
    resourceGroups: outputs.GetAccountMembersResultPolicyResourceGroup[];
}

export interface GetAccountMembersResultPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountMembersResultPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetAccountMembersResultPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMembersResultPolicyResourceGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the resource group.
     */
    meta: outputs.GetAccountMembersResultPolicyResourceGroupMeta;
    /**
     * Name of the resource group.
     */
    name: string;
    /**
     * The scope associated to the resource group
     */
    scopes: outputs.GetAccountMembersResultPolicyResourceGroupScope[];
}

export interface GetAccountMembersResultPolicyResourceGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountMembersResultPolicyResourceGroupScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetAccountMembersResultPolicyResourceGroupScopeObject[];
}

export interface GetAccountMembersResultPolicyResourceGroupScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetAccountMembersResultRole {
    /**
     * Description of role's permissions.
     */
    description: string;
    /**
     * Role identifier tag.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
    permissions: outputs.GetAccountMembersResultRolePermissions;
}

export interface GetAccountMembersResultRolePermissions {
    analytics: outputs.GetAccountMembersResultRolePermissionsAnalytics;
    billing: outputs.GetAccountMembersResultRolePermissionsBilling;
    cachePurge: outputs.GetAccountMembersResultRolePermissionsCachePurge;
    dns: outputs.GetAccountMembersResultRolePermissionsDns;
    dnsRecords: outputs.GetAccountMembersResultRolePermissionsDnsRecords;
    lb: outputs.GetAccountMembersResultRolePermissionsLb;
    logs: outputs.GetAccountMembersResultRolePermissionsLogs;
    organization: outputs.GetAccountMembersResultRolePermissionsOrganization;
    ssl: outputs.GetAccountMembersResultRolePermissionsSsl;
    waf: outputs.GetAccountMembersResultRolePermissionsWaf;
    zoneSettings: outputs.GetAccountMembersResultRolePermissionsZoneSettings;
    zones: outputs.GetAccountMembersResultRolePermissionsZones;
}

export interface GetAccountMembersResultRolePermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultRolePermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountMembersResultUser {
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
     */
    twoFactorAuthenticationEnabled: boolean;
}

export interface GetAccountRolePermissions {
    analytics: outputs.GetAccountRolePermissionsAnalytics;
    billing: outputs.GetAccountRolePermissionsBilling;
    cachePurge: outputs.GetAccountRolePermissionsCachePurge;
    dns: outputs.GetAccountRolePermissionsDns;
    dnsRecords: outputs.GetAccountRolePermissionsDnsRecords;
    lb: outputs.GetAccountRolePermissionsLb;
    logs: outputs.GetAccountRolePermissionsLogs;
    organization: outputs.GetAccountRolePermissionsOrganization;
    ssl: outputs.GetAccountRolePermissionsSsl;
    waf: outputs.GetAccountRolePermissionsWaf;
    zoneSettings: outputs.GetAccountRolePermissionsZoneSettings;
    zones: outputs.GetAccountRolePermissionsZones;
}

export interface GetAccountRolePermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolePermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResult {
    /**
     * Description of role's permissions.
     */
    description: string;
    /**
     * Role identifier tag.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
    permissions: outputs.GetAccountRolesResultPermissions;
}

export interface GetAccountRolesResultPermissions {
    analytics: outputs.GetAccountRolesResultPermissionsAnalytics;
    billing: outputs.GetAccountRolesResultPermissionsBilling;
    cachePurge: outputs.GetAccountRolesResultPermissionsCachePurge;
    dns: outputs.GetAccountRolesResultPermissionsDns;
    dnsRecords: outputs.GetAccountRolesResultPermissionsDnsRecords;
    lb: outputs.GetAccountRolesResultPermissionsLb;
    logs: outputs.GetAccountRolesResultPermissionsLogs;
    organization: outputs.GetAccountRolesResultPermissionsOrganization;
    ssl: outputs.GetAccountRolesResultPermissionsSsl;
    waf: outputs.GetAccountRolesResultPermissionsWaf;
    zoneSettings: outputs.GetAccountRolesResultPermissionsZoneSettings;
    zones: outputs.GetAccountRolesResultPermissionsZones;
}

export interface GetAccountRolesResultPermissionsAnalytics {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsBilling {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsCachePurge {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsDns {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsDnsRecords {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsLb {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsLogs {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsOrganization {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsSsl {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsWaf {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsZoneSettings {
    read: boolean;
    write: boolean;
}

export interface GetAccountRolesResultPermissionsZones {
    read: boolean;
    write: boolean;
}

export interface GetAccountSettings {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     */
    abuseContactEmail: string;
    /**
     * Specifies the default nameservers to be used for new zones added to this account.
     */
    defaultNameservers: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     */
    enforceTwofactor: boolean;
    /**
     * Indicates whether new zones should use the account-level custom
     * nameservers by default.
     *
     * Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
     */
    useAccountCustomNsByDefault: boolean;
}

<<<<<<< HEAD
=======
export interface GetAccountSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged: boolean;
    /**
     * The ID of the rate plan.
     */
    id: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets: string[];
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetAccountTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetAccountTokenConditionRequestIp;
}

export interface GetAccountTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetAccountTokenFilter {
    /**
     * Direction to order results.
     */
    direction?: string;
}

export interface GetAccountTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetAccountTokenPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountTokenPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetAccountTokenPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountTokensResult {
    condition: outputs.GetAccountTokensResultCondition;
    /**
     * The expiration time on or after which the JWT MUST NOT be accepted for processing.
     */
    expiresOn: string;
    /**
     * Token identifier tag.
     */
    id: string;
    /**
     * The time on which the token was created.
     */
    issuedOn: string;
    /**
     * Last time the token was used.
     */
    lastUsedOn: string;
    /**
     * Last time the token was modified.
     */
    modifiedOn: string;
    /**
     * Token name.
     */
    name: string;
    /**
     * The time before which the token MUST NOT be accepted for processing.
     */
    notBefore: string;
    /**
     * List of access policies assigned to the token.
     */
    policies: outputs.GetAccountTokensResultPolicy[];
    /**
     * Status of the token.
     */
    status: string;
}

export interface GetAccountTokensResultCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetAccountTokensResultConditionRequestIp;
}

export interface GetAccountTokensResultConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetAccountTokensResultPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetAccountTokensResultPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetAccountTokensResultPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetAccountTokensResultPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetAccountTokensResultPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAccountsResult {
    /**
     * Timestamp for the creation of the account
     */
    createdOn: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * Account name
     */
    name: string;
    /**
     * Account settings
     */
    settings: outputs.GetAccountsResultSettings;
}

export interface GetAccountsResultSettings {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     */
    abuseContactEmail: string;
    /**
     * Specifies the default nameservers to be used for new zones added to this account.
     */
    defaultNameservers: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     */
    enforceTwofactor: boolean;
    /**
     * Indicates whether new zones should use the account-level custom
     * nameservers by default.
     *
     * Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
     */
    useAccountCustomNsByDefault: boolean;
}

export interface GetAddressMapIp {
    createdAt: string;
    /**
     * An IPv4 or IPv6 address.
     */
    ip: string;
}

export interface GetAddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete: boolean;
    createdAt: string;
    /**
     * The identifier for the membership (eg. a zone or account tag).
     */
    identifier: string;
    /**
     * The type of the membership.
     */
    kind: string;
}

export interface GetAddressMapsResult {
    /**
     * If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
     */
    canDelete: boolean;
    /**
     * If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
     */
    canModifyIps: boolean;
    createdAt: string;
    /**
     * If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
     */
    defaultSni: string;
    /**
     * An optional description field which may be used to describe the types of IPs or zones on the map.
     */
    description: string;
    /**
     * Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
     */
    enabled: boolean;
    /**
     * Identifier of an Address Map.
     */
    id: string;
    modifiedAt: string;
}

export interface GetApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic field, i.e., the header or cookie name.
     */
    name: string;
    /**
     * The type of characteristic.
     */
    type: string;
}

export interface GetApiShieldDiscoveryOperationsResult {
    /**
     * The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
     */
    endpoint: string;
    features: outputs.GetApiShieldDiscoveryOperationsResultFeatures;
    /**
     * RFC3986-compliant host.
     */
    host: string;
    /**
     * UUID
     */
    id: string;
    lastUpdated: string;
    /**
     * The HTTP method used to access the endpoint.
     */
    method: string;
    /**
     * API discovery engine(s) that discovered this operation
     */
    origins: string[];
    /**
     * State of operation in API Discovery
     *   * `review` - Operation is not saved into API Shield Endpoint Management
     *   * `saved` - Operation is saved into API Shield Endpoint Management
     *   * `ignored` - Operation is marked as ignored
     */
    state: string;
}

export interface GetApiShieldDiscoveryOperationsResultFeatures {
    trafficStats: outputs.GetApiShieldDiscoveryOperationsResultFeaturesTrafficStats;
}

export interface GetApiShieldDiscoveryOperationsResultFeaturesTrafficStats {
    lastUpdated: string;
    /**
     * The period in seconds these statistics were computed over
     */
    periodSeconds: number;
    /**
     * The average number of requests seen during this period
     */
    requests: number;
}

export interface GetApiShieldOperationFeatures {
    /**
     * API Routing settings on endpoint.
     */
    apiRouting: outputs.GetApiShieldOperationFeaturesApiRouting;
    confidenceIntervals: outputs.GetApiShieldOperationFeaturesConfidenceIntervals;
    parameterSchemas: outputs.GetApiShieldOperationFeaturesParameterSchemas;
    schemaInfo: outputs.GetApiShieldOperationFeaturesSchemaInfo;
    thresholds: outputs.GetApiShieldOperationFeaturesThresholds;
}

export interface GetApiShieldOperationFeaturesApiRouting {
    lastUpdated: string;
    /**
     * Target route.
     */
    route: string;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervals {
    lastUpdated: string;
    suggestedThreshold: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThreshold {
    confidenceIntervals: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals;
    /**
     * Suggested threshold.
     */
    mean: number;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals {
    /**
     * Upper and lower bound for percentile estimate
     */
    p90: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90;
    /**
     * Upper and lower bound for percentile estimate
     */
    p95: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95;
    /**
     * Upper and lower bound for percentile estimate
     */
    p99: outputs.GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationFeaturesParameterSchemas {
    lastUpdated: string;
    /**
     * An operation schema object containing a response.
     */
    parameterSchemas: outputs.GetApiShieldOperationFeaturesParameterSchemasParameterSchemas;
}

export interface GetApiShieldOperationFeaturesParameterSchemasParameterSchemas {
    /**
     * An array containing the learned parameter schemas.
     */
    parameters: string[];
    /**
     * An empty response object. This field is required to yield a valid operation schema.
     */
    responses: string;
}

export interface GetApiShieldOperationFeaturesSchemaInfo {
    /**
     * Schema active on endpoint.
     */
    activeSchema: outputs.GetApiShieldOperationFeaturesSchemaInfoActiveSchema;
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     */
    learnedAvailable: boolean;
    /**
     * Action taken on requests failing validation.
     */
    mitigationAction: string;
}

export interface GetApiShieldOperationFeaturesSchemaInfoActiveSchema {
    createdAt: string;
    /**
     * UUID
     */
    id: string;
    /**
     * True if schema is Cloudflare-provided.
     */
    isLearned: boolean;
    /**
     * Schema file name.
     */
    name: string;
}

export interface GetApiShieldOperationFeaturesThresholds {
    /**
     * The total number of auth-ids seen across this calculation.
     */
    authIdTokens: number;
    /**
     * The number of data points used for the threshold suggestion calculation.
     */
    dataPoints: number;
    lastUpdated: string;
    /**
     * The p50 quantile of requests (in period_seconds).
     */
    p50: number;
    /**
     * The p90 quantile of requests (in period_seconds).
     */
    p90: number;
    /**
     * The p99 quantile of requests (in period_seconds).
     */
    p99: number;
    /**
     * The period over which this threshold is suggested.
     */
    periodSeconds: number;
    /**
     * The estimated number of requests covered by these calculations.
     */
    requests: number;
    /**
     * The suggested threshold in requests done by the same auth*id or period*seconds.
     */
    suggestedThreshold: number;
}

export interface GetApiShieldOperationFilter {
    /**
     * Direction to order results.
     */
    direction?: string;
    /**
     * Filter results to only include endpoints containing this pattern.
     */
    endpoint?: string;
    /**
     * Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
     */
    features?: string[];
    /**
     * Filter results to only include the specified hosts.
     */
    hosts?: string[];
    /**
     * Filter results to only include the specified HTTP methods.
     */
    methods?: string[];
    /**
     * Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
     */
    order?: string;
}

export interface GetApiShieldOperationsResult {
    /**
     * The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
     */
    endpoint: string;
    features: outputs.GetApiShieldOperationsResultFeatures;
    /**
     * RFC3986-compliant host.
     */
    host: string;
    lastUpdated: string;
    /**
     * The HTTP method used to access the endpoint.
     */
    method: string;
    /**
     * UUID
     */
    operationId: string;
}

export interface GetApiShieldOperationsResultFeatures {
    /**
     * API Routing settings on endpoint.
     */
    apiRouting: outputs.GetApiShieldOperationsResultFeaturesApiRouting;
    confidenceIntervals: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervals;
    parameterSchemas: outputs.GetApiShieldOperationsResultFeaturesParameterSchemas;
    schemaInfo: outputs.GetApiShieldOperationsResultFeaturesSchemaInfo;
    thresholds: outputs.GetApiShieldOperationsResultFeaturesThresholds;
}

export interface GetApiShieldOperationsResultFeaturesApiRouting {
    lastUpdated: string;
    /**
     * Target route.
     */
    route: string;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervals {
    lastUpdated: string;
    suggestedThreshold: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThreshold;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThreshold {
    confidenceIntervals: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals;
    /**
     * Suggested threshold.
     */
    mean: number;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervals {
    /**
     * Upper and lower bound for percentile estimate
     */
    p90: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90;
    /**
     * Upper and lower bound for percentile estimate
     */
    p95: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95;
    /**
     * Upper and lower bound for percentile estimate
     */
    p99: outputs.GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationsResultFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99 {
    /**
     * Lower bound for percentile estimate
     */
    lower: number;
    /**
     * Upper bound for percentile estimate
     */
    upper: number;
}

export interface GetApiShieldOperationsResultFeaturesParameterSchemas {
    lastUpdated: string;
    /**
     * An operation schema object containing a response.
     */
    parameterSchemas: outputs.GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemas;
}

export interface GetApiShieldOperationsResultFeaturesParameterSchemasParameterSchemas {
    /**
     * An array containing the learned parameter schemas.
     */
    parameters: string[];
    /**
     * An empty response object. This field is required to yield a valid operation schema.
     */
    responses: string;
}

export interface GetApiShieldOperationsResultFeaturesSchemaInfo {
    /**
     * Schema active on endpoint.
     */
    activeSchema: outputs.GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchema;
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     */
    learnedAvailable: boolean;
    /**
     * Action taken on requests failing validation.
     */
    mitigationAction: string;
}

export interface GetApiShieldOperationsResultFeaturesSchemaInfoActiveSchema {
    createdAt: string;
    /**
     * UUID
     */
    id: string;
    /**
     * True if schema is Cloudflare-provided.
     */
    isLearned: boolean;
    /**
     * Schema file name.
     */
    name: string;
}

export interface GetApiShieldOperationsResultFeaturesThresholds {
    /**
     * The total number of auth-ids seen across this calculation.
     */
    authIdTokens: number;
    /**
     * The number of data points used for the threshold suggestion calculation.
     */
    dataPoints: number;
    lastUpdated: string;
    /**
     * The p50 quantile of requests (in period_seconds).
     */
    p50: number;
    /**
     * The p90 quantile of requests (in period_seconds).
     */
    p90: number;
    /**
     * The p99 quantile of requests (in period_seconds).
     */
    p99: number;
    /**
     * The period over which this threshold is suggested.
     */
    periodSeconds: number;
    /**
     * The estimated number of requests covered by these calculations.
     */
    requests: number;
    /**
     * The suggested threshold in requests done by the same auth*id or period*seconds.
     */
    suggestedThreshold: number;
}

export interface GetApiShieldSchemasResult {
    createdAt: string;
    /**
     * Kind of schema
     */
    kind: string;
    /**
     * Name of the schema
     */
    name: string;
    /**
     * UUID
     */
    schemaId: string;
    /**
     * Source of the schema
     */
    source: string;
    /**
     * Flag whether schema is enabled for validation.
     */
    validationEnabled: boolean;
}

export interface GetApiTokenCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetApiTokenConditionRequestIp;
}

export interface GetApiTokenConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetApiTokenFilter {
    /**
     * Direction to order results.
     */
    direction?: string;
}

export interface GetApiTokenPermissionsGroupsListResult {
<<<<<<< HEAD
=======
    /**
     * Public ID.
     */
    id: string;
    /**
     * Permission Group Name
     */
    name: string;
    /**
     * Resources to which the Permission Group is scoped
     */
    scopes: string[];
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface GetApiTokenPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetApiTokenPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetApiTokenPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetApiTokenPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetApiTokenPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetApiTokensResult {
    condition: outputs.GetApiTokensResultCondition;
    /**
     * The expiration time on or after which the JWT MUST NOT be accepted for processing.
     */
    expiresOn: string;
    /**
     * Token identifier tag.
     */
    id: string;
    /**
     * The time on which the token was created.
     */
    issuedOn: string;
    /**
     * Last time the token was used.
     */
    lastUsedOn: string;
    /**
     * Last time the token was modified.
     */
    modifiedOn: string;
    /**
     * Token name.
     */
    name: string;
    /**
     * The time before which the token MUST NOT be accepted for processing.
     */
    notBefore: string;
    /**
     * List of access policies assigned to the token.
     */
    policies: outputs.GetApiTokensResultPolicy[];
    /**
     * Status of the token.
     */
    status: string;
}

export interface GetApiTokensResultCondition {
    /**
     * Client IP restrictions.
     */
    requestIp: outputs.GetApiTokensResultConditionRequestIp;
}

export interface GetApiTokensResultConditionRequestIp {
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    ins: string[];
    /**
     * List of IPv4/IPv6 CIDR addresses.
     */
    notIns: string[];
}

export interface GetApiTokensResultPolicy {
    /**
     * Allow or deny operations against the resources.
     */
    effect: string;
    /**
     * Policy identifier.
     */
    id: string;
    /**
     * A set of permission groups that are specified to the policy.
     */
    permissionGroups: outputs.GetApiTokensResultPolicyPermissionGroup[];
    /**
     * A list of resource names that the policy applies to.
     */
    resources: {[key: string]: string};
}

export interface GetApiTokensResultPolicyPermissionGroup {
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetApiTokensResultPolicyPermissionGroupMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetApiTokensResultPolicyPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetAuthenticatedOriginPullsCertificatesResult {
    /**
     * The zone's leaf certificate.
     */
    certificate: string;
    /**
     * Indicates whether zone-level authenticated origin pulls is enabled.
     */
    enabled: boolean;
    /**
     * When the certificate from the authority expires.
     */
    expiresOn: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    issuer: string;
    /**
     * The zone's private key.
     */
    privateKey: string;
    /**
     * The type of hash used for the certificate.
     */
    signature: string;
    /**
     * Status of the certificate activation.
     */
    status: string;
    /**
     * This is the time the certificate was uploaded.
     */
    uploadedOn: string;
}

export interface GetBotManagementStaleZoneConfiguration {
    /**
     * Indicates that the zone's Bot Fight Mode is turned on.
     */
    fightMode: boolean;
    /**
     * Indicates that the zone's wordpress optimization for SBFM is turned on.
     */
    optimizeWordpress: boolean;
    /**
     * Indicates that the zone's definitely automated requests are being blocked or challenged.
     */
    sbfmDefinitelyAutomated: string;
    /**
     * Indicates that the zone's likely automated requests are being blocked or challenged.
     */
    sbfmLikelyAutomated: string;
    /**
     * Indicates that the zone's static resource protection is turned on.
     */
    sbfmStaticResourceProtection: string;
    /**
     * Indicates that the zone's verified bot requests are being blocked.
     */
    sbfmVerifiedBots: string;
    /**
     * Indicates that the zone's session score tracking is disabled.
     */
    suppressSessionScore: boolean;
}

export interface GetByoIpPrefixesResult {
    /**
     * Identifier of a Cloudflare account.
     */
    accountId: string;
    /**
     * Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled.
     */
    advertised: boolean;
    /**
     * Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled.
     */
    advertisedModifiedAt: string;
    /**
     * Approval state of the prefix (P = pending, V = active).
     */
    approved: string;
    /**
     * Autonomous System Number (ASN) the prefix will be advertised under.
     */
    asn: number;
    /**
     * IP Prefix in Classless Inter-Domain Routing format.
     */
    cidr: string;
    createdAt: string;
    /**
     * Description of the prefix.
     */
    description: string;
    /**
     * Identifier of an IP Prefix.
     */
    id: string;
    /**
     * Identifier for the uploaded LOA document.
     */
    loaDocumentId: string;
    modifiedAt: string;
    /**
     * Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled.
     */
    onDemandEnabled: boolean;
    /**
     * Whether advertisement status of the prefix is locked, meaning it cannot be changed.
     */
    onDemandLocked: boolean;
}

export interface GetCallsSfuAppsResult {
    /**
     * The date and time the item was created.
     */
    created: string;
    /**
     * The date and time the item was last modified.
     */
    modified: string;
    /**
     * A short description of Calls app, not shown to end users.
     */
    name: string;
    /**
     * A Cloudflare-generated unique identifier for a item.
     */
    uid: string;
}

export interface GetCallsTurnAppsResult {
    /**
     * The date and time the item was created.
     */
    created: string;
    /**
     * The date and time the item was last modified.
     */
    modified: string;
    /**
     * A short description of Calls app, not shown to end users.
     */
    name: string;
    /**
     * A Cloudflare-generated unique identifier for a item.
     */
    uid: string;
}

export interface GetCertificatePacksResult {
}

export interface GetCloudConnectorRulesListResult {
    /**
     * Cloud Provider type
     */
    cloudProvider: string;
    description: string;
    enabled: boolean;
    expression: string;
    id: string;
    /**
     * Parameters of Cloud Connector Rule
     */
    parameters: outputs.GetCloudConnectorRulesListResultParameters;
}

export interface GetCloudConnectorRulesListResultParameters {
    /**
     * Host to perform Cloud Connection to
     */
    host: string;
}

export interface GetCloudforceOneRequestsResult {
    /**
     * Request completion time
     */
    completed: string;
    /**
     * Request creation time
     */
    created: string;
    /**
     * UUID
     */
    id: string;
    /**
     * Tokens for the request messages
     */
    messageTokens: number;
    priority: string;
    /**
     * Readable Request ID
     */
    readableId: string;
    /**
     * Requested information from request
     */
    request: string;
    /**
     * Request Status
     */
    status: string;
    /**
     * Brief description of the request
     */
    summary: string;
    /**
     * The CISA defined Traffic Light Protocol (TLP)
     */
    tlp: string;
    /**
     * Tokens for the request
     */
    tokens: number;
    /**
     * Request last updated time
     */
    updated: string;
}

export interface GetContentScanningExpressionsResult {
    /**
     * The unique ID for this custom scan expression
     */
    id: string;
    /**
     * Ruleset expression to use in matching content objects
     */
    payload: string;
}

export interface GetCustomHostnameFilter {
    /**
     * Direction to order hostnames.
     */
    direction?: string;
    /**
     * Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
     */
    hostname?: string;
    /**
     * Hostname ID to match against. This ID was generated and returned during the initial customHostname creation. This parameter cannot be used with the 'hostname' parameter.
     */
    id?: string;
    /**
     * Field to order hostnames by.
     */
    order: string;
    /**
     * Whether to filter hostnames based on if they have SSL enabled.
     */
    ssl?: number;
}

export interface GetCustomHostnameOwnershipVerification {
    /**
     * DNS Name for record.
     */
    name: string;
    /**
     * DNS Record type.
     */
    type: string;
    /**
     * Content for the record.
     */
    value: string;
}

export interface GetCustomHostnameOwnershipVerificationHttp {
    /**
     * Token to be served.
     */
    httpBody: string;
    /**
     * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
     */
    httpUrl: string;
}

export interface GetCustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     */
    bundleMethod: string;
    /**
     * The Certificate Authority that will issue the certificate
     */
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate: string;
    /**
     * The identifier for the Custom CSR that was used.
     */
    customCsrId: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey: string;
    /**
     * The time the custom certificate expires on.
     */
    expiresOn: string;
    /**
     * A list of Hostnames on a custom uploaded certificate.
     */
    hosts: string[];
    /**
     * Custom hostname SSL identifier tag.
     */
    id: string;
    /**
     * The issuer on a custom uploaded certificate.
     */
    issuer: string;
    /**
     * Domain control validation (DCV) method used for this hostname.
     */
    method: string;
    /**
     * The serial number on a custom uploaded certificate.
     */
    serialNumber: string;
    settings: outputs.GetCustomHostnameSslSettings;
    /**
     * The signature on a custom uploaded certificate.
     */
    signature: string;
    /**
     * Status of the hostname's SSL certificates.
     */
    status: string;
    /**
     * Level of validation to be used for this hostname. Domain validation (dv) must be used.
     */
    type: string;
    /**
     * The time the custom certificate was uploaded.
     */
    uploadedOn: string;
    /**
     * Domain validation errors that have been received by the certificate authority (CA).
     */
    validationErrors: outputs.GetCustomHostnameSslValidationError[];
    validationRecords: outputs.GetCustomHostnameSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard: boolean;
}

export interface GetCustomHostnameSslSettings {
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers: string[];
    /**
     * Whether or not Early Hints is enabled.
     */
    earlyHints: string;
    /**
     * Whether or not HTTP2 is enabled.
     */
    http2: string;
    /**
     * The minimum TLS version supported.
     */
    minTlsVersion: string;
    /**
     * Whether or not TLS 1.3 is enabled.
     */
    tls13: string;
}

export interface GetCustomHostnameSslValidationError {
    /**
     * A domain validation error.
     */
    message: string;
}

export interface GetCustomHostnameSslValidationRecord {
    /**
     * The set of email addresses that the certificate authority (CA) will use to complete domain validation.
     */
    emails: string[];
    /**
     * The content that the certificate authority (CA) will expect to find at the httpUrl during the domain validation.
     */
    httpBody: string;
    /**
     * The url that will be checked during domain validation.
     */
    httpUrl: string;
    /**
     * The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
     */
    txtName: string;
    /**
     * The TXT record that the certificate authority (CA) will check during domain validation.
     */
    txtValue: string;
}

export interface GetCustomHostnamesResult {
    /**
     * This is the time the hostname was created.
     */
    createdAt: string;
    /**
     * Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
     */
    customMetadata: {[key: string]: string};
    /**
     * a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
     */
    customOriginServer: string;
    /**
     * A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request*host*header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
     */
    customOriginSni: string;
    /**
     * The custom hostname that will point to your hostname via CNAME.
     */
    hostname: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * This is a record which can be placed to activate a hostname.
     */
    ownershipVerification: outputs.GetCustomHostnamesResultOwnershipVerification;
    /**
     * This presents the token to be served by the given http url to activate a hostname.
     */
    ownershipVerificationHttp: outputs.GetCustomHostnamesResultOwnershipVerificationHttp;
    ssl: outputs.GetCustomHostnamesResultSsl;
    /**
     * Status of the hostname's activation.
     */
    status: string;
    /**
     * These are errors that were encountered while trying to activate a hostname.
     */
    verificationErrors: string[];
}

export interface GetCustomHostnamesResultOwnershipVerification {
    /**
     * DNS Name for record.
     */
    name: string;
    /**
     * DNS Record type.
     */
    type: string;
    /**
     * Content for the record.
     */
    value: string;
}

export interface GetCustomHostnamesResultOwnershipVerificationHttp {
    /**
     * Token to be served.
     */
    httpBody: string;
    /**
     * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
     */
    httpUrl: string;
}

export interface GetCustomHostnamesResultSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     */
    bundleMethod: string;
    /**
     * The Certificate Authority that will issue the certificate
     */
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate: string;
    /**
     * The identifier for the Custom CSR that was used.
     */
    customCsrId: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey: string;
    /**
     * The time the custom certificate expires on.
     */
    expiresOn: string;
    /**
     * A list of Hostnames on a custom uploaded certificate.
     */
    hosts: string[];
    /**
     * Custom hostname SSL identifier tag.
     */
    id: string;
    /**
     * The issuer on a custom uploaded certificate.
     */
    issuer: string;
    /**
     * Domain control validation (DCV) method used for this hostname.
     */
    method: string;
    /**
     * The serial number on a custom uploaded certificate.
     */
    serialNumber: string;
    settings: outputs.GetCustomHostnamesResultSslSettings;
    /**
     * The signature on a custom uploaded certificate.
     */
    signature: string;
    /**
     * Status of the hostname's SSL certificates.
     */
    status: string;
    /**
     * Level of validation to be used for this hostname. Domain validation (dv) must be used.
     */
    type: string;
    /**
     * The time the custom certificate was uploaded.
     */
    uploadedOn: string;
    /**
     * Domain validation errors that have been received by the certificate authority (CA).
     */
    validationErrors: outputs.GetCustomHostnamesResultSslValidationError[];
    validationRecords: outputs.GetCustomHostnamesResultSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard: boolean;
}

export interface GetCustomHostnamesResultSslSettings {
    /**
     * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
     */
    ciphers: string[];
    /**
     * Whether or not Early Hints is enabled.
     */
    earlyHints: string;
    /**
     * Whether or not HTTP2 is enabled.
     */
    http2: string;
    /**
     * The minimum TLS version supported.
     */
    minTlsVersion: string;
    /**
     * Whether or not TLS 1.3 is enabled.
     */
    tls13: string;
}

export interface GetCustomHostnamesResultSslValidationError {
    /**
     * A domain validation error.
     */
    message: string;
}

export interface GetCustomHostnamesResultSslValidationRecord {
    /**
     * The set of email addresses that the certificate authority (CA) will use to complete domain validation.
     */
    emails: string[];
    /**
     * The content that the certificate authority (CA) will expect to find at the httpUrl during the domain validation.
     */
    httpBody: string;
    /**
     * The url that will be checked during domain validation.
     */
    httpUrl: string;
    /**
     * The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
     */
    txtName: string;
    /**
     * The TXT record that the certificate authority (CA) will check during domain validation.
     */
    txtValue: string;
}

export interface GetCustomSslFilter {
    /**
     * Whether to match all search requirements or at least one (any).
     */
    match: string;
    /**
     * Status of the zone's custom SSL.
     */
    status?: string;
}

export interface GetCustomSslGeoRestrictions {
    label: string;
}

export interface GetCustomSslKeylessServer {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.GetCustomSslKeylessServerTunnel;
}

export interface GetCustomSslKeylessServerTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetCustomSslsResult {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     */
    bundleMethod: string;
    /**
     * When the certificate from the authority expires.
     */
    expiresOn: string;
    /**
     * Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
     */
    geoRestrictions: outputs.GetCustomSslsResultGeoRestrictions;
    hosts: string[];
    /**
     * Identifier
     */
    id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    issuer: string;
    keylessServer: outputs.GetCustomSslsResultKeylessServer;
    /**
     * When the certificate was last modified.
     */
    modifiedOn: string;
    /**
     * Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
     */
    policy: string;
    /**
     * The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy*custom' certificates, but 'legacy*custom' certificates will always supercede 'sni_custom' certificates.
     */
    priority: number;
    /**
     * The type of hash used for the certificate.
     */
    signature: string;
    /**
     * Status of the zone's custom SSL.
     */
    status: string;
    /**
     * When the certificate was uploaded to Cloudflare.
     */
    uploadedOn: string;
    /**
     * Identifier
     */
    zoneId: string;
}

export interface GetCustomSslsResultGeoRestrictions {
    label: string;
}

export interface GetCustomSslsResultKeylessServer {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.GetCustomSslsResultKeylessServerTunnel;
}

export interface GetCustomSslsResultKeylessServerTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetD1DatabaseFilter {
    /**
     * a database name to search for.
     */
    name?: string;
}

export interface GetD1DatabasesResult {
    /**
     * Specifies the timestamp the resource was created as an ISO8601 string.
     */
    createdAt: string;
<<<<<<< HEAD
    name: string;
=======
    /**
     * D1 database name.
     */
    name: string;
    /**
     * D1 database identifier (UUID).
     */
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    uuid: string;
    version: string;
}

export interface GetDnsFirewallAttackMitigation {
    /**
     * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
     */
    enabled: boolean;
    /**
     * Only mitigate attacks when upstream servers seem unhealthy
     */
    onlyWhenUpstreamUnhealthy: boolean;
}

export interface GetDnsFirewallsResult {
    /**
     * Attack mitigation settings
     */
    attackMitigation: outputs.GetDnsFirewallsResultAttackMitigation;
    /**
     * Whether to refuse to answer queries for the ANY type
     */
    deprecateAnyRequests: boolean;
    dnsFirewallIps: string[];
    /**
     * Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     */
    ecsFallback: boolean;
    /**
     * Identifier
     */
    id: string;
    /**
     * Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
     */
    maximumCacheTtl: number;
    /**
     * Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
     */
    minimumCacheTtl: number;
    /**
     * Last modification of DNS Firewall cluster
     */
    modifiedOn: string;
    /**
     * DNS Firewall cluster name
     */
    name: string;
    /**
     * Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
     */
    negativeCacheTtl: number;
    /**
     * Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
     */
    ratelimit: number;
    /**
     * Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
     */
    retries: number;
    upstreamIps: string[];
}

export interface GetDnsFirewallsResultAttackMitigation {
    /**
     * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
     */
    enabled: boolean;
    /**
     * Only mitigate attacks when upstream servers seem unhealthy
     */
    onlyWhenUpstreamUnhealthy: boolean;
}

export interface GetDnsRecordData {
    /**
     * Algorithm.
     */
    algorithm: number;
    /**
     * Altitude of location in meters.
     */
    altitude: number;
    /**
     * Certificate.
     */
    certificate: string;
    /**
     * Digest.
     */
    digest: string;
    /**
     * Digest Type.
     */
    digestType: number;
    /**
     * fingerprint.
     */
    fingerprint: string;
    /**
     * Flags for the CAA record.
     */
    flags: any;
    /**
     * Key Tag.
     */
    keyTag: number;
    /**
     * Degrees of latitude.
     */
    latDegrees: number;
    /**
     * Latitude direction.
     */
    latDirection: string;
    /**
     * Minutes of latitude.
     */
    latMinutes: number;
    /**
     * Seconds of latitude.
     */
    latSeconds: number;
    /**
     * Degrees of longitude.
     */
    longDegrees: number;
    /**
     * Longitude direction.
     */
    longDirection: string;
    /**
     * Minutes of longitude.
     */
    longMinutes: number;
    /**
     * Seconds of longitude.
     */
    longSeconds: number;
    /**
     * Matching Type.
     */
    matchingType: number;
    /**
     * Order.
     */
    order: number;
    /**
     * The port of the service.
     */
    port: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz: number;
    /**
     * Vertical precision of location.
     */
    precisionVert: number;
    /**
     * Preference.
     */
    preference: number;
    /**
     * priority.
     */
    priority: number;
    /**
     * Protocol.
     */
    protocol: number;
    /**
     * Public Key.
     */
    publicKey: string;
    /**
     * Regex.
     */
    regex: string;
    /**
     * Replacement.
     */
    replacement: string;
    /**
     * Selector.
     */
    selector: number;
    /**
     * Service.
     */
    service: string;
    /**
     * Size of location in meters.
     */
    size: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag: string;
    /**
     * target.
     */
    target: string;
    /**
     * Type.
     */
    type: number;
    /**
     * Usage.
     */
    usage: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value: string;
    /**
     * The record weight.
     */
    weight: number;
}

export interface GetDnsRecordFilter {
    comment?: outputs.GetDnsRecordFilterComment;
    content?: outputs.GetDnsRecordFilterContent;
    /**
     * Direction to order DNS records in.
     */
    direction: string;
    /**
     * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
     */
    match: string;
    name?: outputs.GetDnsRecordFilterName;
    /**
     * Field to order DNS records by.
     */
    order: string;
    /**
     * Whether the record is receiving the performance and security benefits of Cloudflare.
     */
    proxied: boolean;
    /**
     * Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
     */
    search?: string;
    tag?: outputs.GetDnsRecordFilterTag;
    /**
     * Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
     */
    tagMatch: string;
    /**
     * Record type.
     */
    type?: string;
}

export interface GetDnsRecordFilterComment {
    /**
     * If this parameter is present, only records *without* a comment are returned.
     */
    absent?: string;
    /**
     * Substring of the DNS record comment. Comment filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record comment. Comment filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record comment. Comment filters are case-insensitive.
     */
    exact?: string;
    /**
     * If this parameter is present, only records *with* a comment are returned.
     */
    present?: string;
    /**
     * Prefix of the DNS record comment. Comment filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordFilterContent {
    /**
     * Substring of the DNS record content. Content filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record content. Content filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record content. Content filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record content. Content filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordFilterName {
    /**
     * Substring of the DNS record name. Name filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record name. Name filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record name. Name filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record name. Name filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordFilterTag {
    /**
     * Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
     */
    absent?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
     */
    contains?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
     */
    endswith?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
     */
    exact?: string;
    /**
     * Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
     */
    present?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface GetDnsRecordsComment {
    /**
     * If this parameter is present, only records *without* a comment are returned.
     */
    absent?: string;
    /**
     * Substring of the DNS record comment. Comment filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record comment. Comment filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record comment. Comment filters are case-insensitive.
     */
    exact?: string;
    /**
     * If this parameter is present, only records *with* a comment are returned.
     */
    present?: string;
    /**
     * Prefix of the DNS record comment. Comment filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordsContent {
    /**
     * Substring of the DNS record content. Content filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record content. Content filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record content. Content filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record content. Content filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordsName {
    /**
     * Substring of the DNS record name. Name filters are case-insensitive.
     */
    contains?: string;
    /**
     * Suffix of the DNS record name. Name filters are case-insensitive.
     */
    endswith?: string;
    /**
     * Exact value of the DNS record name. Name filters are case-insensitive.
     */
    exact?: string;
    /**
     * Prefix of the DNS record name. Name filters are case-insensitive.
     */
    startswith?: string;
}

export interface GetDnsRecordsResult {
    /**
     * Comments or notes about the DNS record. This field has no effect on DNS responses.
     */
    comment: string;
    /**
     * When the record comment was last modified. Omitted if there is no comment.
     */
    commentModifiedOn: string;
    /**
     * A valid IPv4 address.
     */
    content: string;
    /**
     * When the record was created.
     */
    createdOn: string;
    /**
     * Components of a CAA record.
     */
    data: outputs.GetDnsRecordsResultData;
    /**
     * Identifier
     */
    id: string;
    /**
     * Extra Cloudflare-specific information about the record.
     */
    meta: string;
    /**
     * When the record was last modified.
     */
    modifiedOn: string;
    /**
     * DNS record name (or @ for the zone apex) in Punycode.
     */
    name: string;
    /**
     * Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Whether the record can be proxied by Cloudflare or not.
     */
    proxiable: boolean;
    /**
     * Whether the record is receiving the performance and security benefits of Cloudflare.
     */
    proxied: boolean;
    /**
     * Settings for the DNS record.
     */
    settings: outputs.GetDnsRecordsResultSettings;
    /**
     * Custom tags for the DNS record. This field has no effect on DNS responses.
     */
    tags: string[];
    /**
     * When the record tags were last modified. Omitted if there are no tags.
     */
    tagsModifiedOn: string;
    /**
     * Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
     */
    ttl: number;
    /**
     * Record type.
     */
    type: string;
}

export interface GetDnsRecordsResultData {
    /**
     * Algorithm.
     */
    algorithm: number;
    /**
     * Altitude of location in meters.
     */
    altitude: number;
    /**
     * Certificate.
     */
    certificate: string;
    /**
     * Digest.
     */
    digest: string;
    /**
     * Digest Type.
     */
    digestType: number;
    /**
     * fingerprint.
     */
    fingerprint: string;
    /**
     * Flags for the CAA record.
     */
    flags: any;
    /**
     * Key Tag.
     */
    keyTag: number;
    /**
     * Degrees of latitude.
     */
    latDegrees: number;
    /**
     * Latitude direction.
     */
    latDirection: string;
    /**
     * Minutes of latitude.
     */
    latMinutes: number;
    /**
     * Seconds of latitude.
     */
    latSeconds: number;
    /**
     * Degrees of longitude.
     */
    longDegrees: number;
    /**
     * Longitude direction.
     */
    longDirection: string;
    /**
     * Minutes of longitude.
     */
    longMinutes: number;
    /**
     * Seconds of longitude.
     */
    longSeconds: number;
    /**
     * Matching Type.
     */
    matchingType: number;
    /**
     * Order.
     */
    order: number;
    /**
     * The port of the service.
     */
    port: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz: number;
    /**
     * Vertical precision of location.
     */
    precisionVert: number;
    /**
     * Preference.
     */
    preference: number;
    /**
     * priority.
     */
    priority: number;
    /**
     * Protocol.
     */
    protocol: number;
    /**
     * Public Key.
     */
    publicKey: string;
    /**
     * Regex.
     */
    regex: string;
    /**
     * Replacement.
     */
    replacement: string;
    /**
     * Selector.
     */
    selector: number;
    /**
     * Service.
     */
    service: string;
    /**
     * Size of location in meters.
     */
    size: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag: string;
    /**
     * target.
     */
    target: string;
    /**
     * Type.
     */
    type: number;
    /**
     * Usage.
     */
    usage: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value: string;
    /**
     * The record weight.
     */
    weight: number;
}

export interface GetDnsRecordsResultSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface GetDnsRecordsTag {
    /**
     * Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
     */
    absent?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
     */
    contains?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
     */
    endswith?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
     */
    exact?: string;
    /**
     * Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
     */
    present?: string;
    /**
     * A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
     */
    startswith?: string;
}

<<<<<<< HEAD
=======
export interface GetDnsSettingsInternalViewFilter {
    /**
     * Direction to order DNS views in.
     */
    direction: string;
    /**
     * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
     */
    match: string;
    name?: outputs.GetDnsSettingsInternalViewFilterName;
    /**
     * Field to order DNS views by.
     */
    order?: string;
    /**
     * A zone ID that exists in the zones list for the view.
     */
    zoneId?: string;
    /**
     * A zone name that exists in the zones list for the view.
     */
    zoneName?: string;
}

export interface GetDnsSettingsInternalViewFilterName {
    /**
     * Substring of the DNS view name.
     */
    contains?: string;
    /**
     * Suffix of the DNS view name.
     */
    endswith?: string;
    /**
     * Exact value of the DNS view name.
     */
    exact?: string;
    /**
     * Prefix of the DNS view name.
     */
    startswith?: string;
}

export interface GetDnsSettingsInternalViewsName {
    /**
     * Substring of the DNS view name.
     */
    contains?: string;
    /**
     * Suffix of the DNS view name.
     */
    endswith?: string;
    /**
     * Exact value of the DNS view name.
     */
    exact?: string;
    /**
     * Prefix of the DNS view name.
     */
    startswith?: string;
}

export interface GetDnsSettingsInternalViewsResult {
    /**
     * When the view was created.
     */
    createdTime: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * When the view was last modified.
     */
    modifiedTime: string;
    /**
     * The name of the view.
     */
    name: string;
    /**
     * The list of zones linked to this view.
     */
    zones: string[];
}

export interface GetDnsSettingsZoneDefaults {
    /**
     * Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
     */
    flattenAllCnames: boolean;
    /**
     * Whether to enable Foundation DNS Advanced Nameservers on the zone.
     */
    foundationDns: boolean;
    /**
     * Settings for this internal zone.
     */
    internalDns: outputs.GetDnsSettingsZoneDefaultsInternalDns;
    /**
     * Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
     */
    multiProvider: boolean;
    /**
     * Settings determining the nameservers through which the zone should be available.
     */
    nameservers: outputs.GetDnsSettingsZoneDefaultsNameservers;
    /**
     * The time to live (TTL) of the zone's nameserver (NS) records.
     */
    nsTtl: number;
    /**
     * Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
     */
    secondaryOverrides: boolean;
    /**
     * Components of the zone's SOA record.
     */
    soa: outputs.GetDnsSettingsZoneDefaultsSoa;
    /**
     * Whether the zone mode is a regular or CDN/DNS only zone.
     */
    zoneMode: string;
}

export interface GetDnsSettingsZoneDefaultsInternalDns {
    /**
     * The ID of the zone to fallback to.
     */
    referenceZoneId: string;
}

export interface GetDnsSettingsZoneDefaultsNameservers {
    /**
     * Nameserver type
     */
    type: string;
}

export interface GetDnsSettingsZoneDefaultsSoa {
    /**
     * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
     */
    expire: number;
    /**
     * The time to live (TTL) for negative caching of records within the zone.
     */
    minTtl: number;
    /**
     * The primary nameserver, which may be used for outbound zone transfers.
     */
    mname: string;
    /**
     * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
     */
    refresh: number;
    /**
     * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
     */
    retry: number;
    /**
     * The email address of the zone administrator, with the first label representing the local part of the email address.
     */
    rname: string;
    /**
     * The time to live (TTL) of the SOA record itself.
     */
    ttl: number;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetDnsZoneTransfersAclsResult {
    id: string;
    /**
     * Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
     */
    ipRange: string;
    /**
     * The name of the acl.
     */
    name: string;
}

export interface GetDnsZoneTransfersPeersResult {
    id: string;
    /**
     * IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to.
     */
    ip: string;
    /**
     * Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones.
     */
    ixfrEnable: boolean;
    /**
     * The name of the peer.
     */
    name: string;
    /**
     * DNS port of primary or secondary nameserver, depending on what zone this peer is linked to.
     */
    port: number;
    /**
     * TSIG authentication will be used for zone transfer if configured.
     */
    tsigId: string;
}

export interface GetDnsZoneTransfersTsigsResult {
    /**
     * TSIG algorithm.
     */
    algo: string;
    id: string;
    /**
     * TSIG key name.
     */
    name: string;
    /**
     * TSIG secret.
     */
    secret: string;
}

export interface GetEmailRoutingAddressFilter {
    /**
     * Sorts results in an ascending or descending order.
     */
    direction: string;
    /**
     * Filter by verified destination addresses.
     */
    verified: boolean;
}

export interface GetEmailRoutingAddressesResult {
    /**
     * The date and time the destination address has been created.
     */
    created: string;
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Destination address identifier.
     */
    id: string;
    /**
     * The date and time the destination address was last modified.
     */
    modified: string;
    /**
     * Destination address tag. (Deprecated, replaced by destination address identifier)
     */
    tag: string;
    /**
     * The date and time the destination address has been verified. Null means not verified yet.
     */
    verified: string;
}

export interface GetEmailRoutingCatchAllAction {
    /**
     * Type of action for catch-all rule.
     */
    type: string;
    values: string[];
}

export interface GetEmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Default is 'all'.
     */
    type: string;
}

export interface GetEmailRoutingDnsError {
    code: number;
    message: string;
}

export interface GetEmailRoutingDnsMessage {
    code: number;
    message: string;
}

export interface GetEmailRoutingDnsResult {
    /**
     * DNS record content.
     */
    content: string;
    errors: outputs.GetEmailRoutingDnsResultError[];
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    records: outputs.GetEmailRoutingDnsResultRecord[];
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     */
    type: string;
}

export interface GetEmailRoutingDnsResultError {
    code: string;
    /**
     * List of records needed to enable an Email Routing zone.
     */
    missing: outputs.GetEmailRoutingDnsResultErrorMissing;
}

export interface GetEmailRoutingDnsResultErrorMissing {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     */
    type: string;
}

export interface GetEmailRoutingDnsResultInfo {
    /**
     * Total number of results for the requested service
     */
    count: number;
    /**
     * Current page within paginated list of results
     */
    page: number;
    /**
     * Number of results per page of results
     */
    perPage: number;
    /**
     * Total results available without any search parameters
     */
    totalCount: number;
}

export interface GetEmailRoutingDnsResultRecord {
    /**
     * DNS record content.
     */
    content: string;
    /**
     * DNS record name (or @ for the zone apex).
     */
    name: string;
    /**
     * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
     */
    priority: number;
    /**
     * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
     */
    ttl: number;
    /**
     * DNS record type.
     */
    type: string;
}

export interface GetEmailRoutingRuleAction {
    /**
     * Type of supported action.
     */
    type: string;
    values: string[];
}

export interface GetEmailRoutingRuleFilter {
    /**
     * Filter by enabled routing rules.
     */
    enabled?: boolean;
}

export interface GetEmailRoutingRuleMatcher {
    /**
     * Field for type matcher.
     */
    field: string;
    /**
     * Type of matcher.
     */
    type: string;
    /**
     * Value for matcher.
     */
    value: string;
}

export interface GetEmailRoutingRulesResult {
    /**
     * List actions patterns.
     */
    actions: outputs.GetEmailRoutingRulesResultAction[];
    /**
     * Routing rule status.
     */
    enabled: boolean;
    /**
     * Routing rule identifier.
     */
    id: string;
    /**
     * Matching patterns to forward to your actions.
     */
    matchers: outputs.GetEmailRoutingRulesResultMatcher[];
    /**
     * Routing rule name.
     */
    name: string;
    /**
     * Priority of the routing rule.
     */
    priority: number;
    /**
     * Routing rule tag. (Deprecated, replaced by routing rule identifier)
     */
    tag: string;
}

export interface GetEmailRoutingRulesResultAction {
    /**
     * Type of supported action.
     */
    type: string;
    values: string[];
}

export interface GetEmailRoutingRulesResultMatcher {
    /**
     * Field for type matcher.
     */
    field: string;
    /**
     * Type of matcher.
     */
    type: string;
    /**
     * Value for matcher.
     */
    value: string;
}

export interface GetEmailSecurityBlockSenderFilter {
    /**
     * The sorting direction.
     */
    direction?: string;
    /**
     * The field to sort by.
     */
    order?: string;
    patternType?: string;
    /**
     * Allows searching in multiple properties of a record simultaneously.
     * This parameter is intended for human users, not automation. Its exact
     * behavior is intentionally left unspecified and is subject to change
     * in the future.
     */
    search?: string;
}

export interface GetEmailSecurityBlockSendersResult {
    comments: string;
    createdAt: string;
    /**
     * The unique identifier for the allow policy.
     */
    id: number;
    isRegex: boolean;
    lastModified: string;
    pattern: string;
    patternType: string;
}

export interface GetEmailSecurityImpersonationRegistriesResult {
    comments: string;
    createdAt: string;
    directoryId: number;
    directoryNodeId: number;
    email: string;
    externalDirectoryNodeId: string;
    id: number;
    isEmailRegex: boolean;
    lastModified: string;
    name: string;
    provenance: string;
}

export interface GetEmailSecurityImpersonationRegistryFilter {
    /**
     * The sorting direction.
     */
    direction?: string;
    /**
     * The field to sort by.
     */
    order?: string;
    provenance?: string;
    /**
     * Allows searching in multiple properties of a record simultaneously.
     * This parameter is intended for human users, not automation. Its exact
     * behavior is intentionally left unspecified and is subject to change
     * in the future.
     */
    search?: string;
}

export interface GetEmailSecurityTrustedDomainsFilter {
    /**
     * The sorting direction.
     */
    direction?: string;
    isRecent?: boolean;
    isSimilarity?: boolean;
    /**
     * The field to sort by.
     */
    order?: string;
    /**
     * Allows searching in multiple properties of a record simultaneously.
     * This parameter is intended for human users, not automation. Its exact
     * behavior is intentionally left unspecified and is subject to change
     * in the future.
     */
    search?: string;
}

export interface GetEmailSecurityTrustedDomainsListResult {
    comments: string;
    createdAt: string;
    /**
     * The unique identifier for the trusted domain.
     */
    id: number;
    /**
     * Select to prevent recently registered domains from triggering a
     * Suspicious or Malicious disposition.
     */
    isRecent: boolean;
    isRegex: boolean;
    /**
     * Select for partner or other approved domains that have similar
     * spelling to your connected domains. Prevents listed domains from
     * triggering a Spoof disposition.
     */
    isSimilarity: boolean;
    lastModified: string;
    pattern: string;
}

<<<<<<< HEAD
export interface GetFiltersResult {
    /**
     * An informative summary of the filter.
     */
    description: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref: string;
}

export interface GetFirewallRuleFilter {
    /**
     * When true, indicates that the firewall rule was deleted.
     */
    deleted: boolean;
=======
export interface GetFilterFilter {
    /**
     * A case-insensitive string to find in the description.
     */
    description?: string;
    /**
     * A case-insensitive string to find in the expression.
     */
    expression?: string;
    /**
     * The unique identifier of the filter.
     */
    id?: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused?: boolean;
    /**
     * The filter ref (a short reference tag) to search for. Must be an exact match.
     */
    ref?: string;
}

export interface GetFiltersResult {
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * An informative summary of the filter.
     */
    description: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref: string;
}

export interface GetFirewallRulesResult {
    /**
     * The action to apply to a matched request. The `log` action is only available on an Enterprise plan.
     */
    action: string;
    /**
     * An informative summary of the firewall rule.
     */
    description: string;
    filter: outputs.GetFirewallRulesResultFilter;
    /**
     * The unique identifier of the firewall rule.
     */
    id: string;
    /**
     * When true, indicates that the firewall rule is currently paused.
     */
    paused: boolean;
    /**
     * The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority.
     */
    priority: number;
    products: string[];
    /**
     * A short reference tag. Allows you to select related firewall rules.
     */
    ref: string;
}

export interface GetFirewallRulesResultFilter {
    /**
     * When true, indicates that the firewall rule was deleted.
     */
    deleted: boolean;
    /**
     * An informative summary of the filter.
     */
    description: string;
    /**
     * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
     */
    expression: string;
    /**
     * The unique identifier of the filter.
     */
    id: string;
    /**
     * When true, indicates that the filter is currently paused.
     */
    paused: boolean;
    /**
     * A short reference tag. Allows you to select related filters.
     */
    ref: string;
}

export interface GetHealthcheckHttpConfig {
    /**
     * Do not validate the certificate when the health check uses HTTPS.
     */
    allowInsecure: boolean;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
     */
    expectedBody: string;
    /**
     * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
     */
    expectedCodes: string[];
    /**
     * Follow redirects if the origin returns a 3xx status code.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
     */
    header: {[key: string]: string[]};
    /**
     * The HTTP method to use for the health check.
     */
    method: string;
    /**
     * The endpoint path to health check against.
     */
    path: string;
    /**
     * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
     */
    port: number;
}

export interface GetHealthcheckTcpConfig {
    /**
     * The TCP connection method to use for the health check.
     */
    method: string;
    /**
     * Port number to connect to for the health check. Defaults to 80.
     */
    port: number;
}

export interface GetHealthchecksResult {
    /**
     * The hostname or IP address of the origin server to run health checks on.
     */
    address: string;
    /**
     * A list of regions from which to run health checks. Null means Cloudflare will pick a default region.
     */
    checkRegions: string[];
    /**
     * The number of consecutive fails required from a health check before changing the health to unhealthy.
     */
    consecutiveFails: number;
    /**
     * The number of consecutive successes required from a health check before changing the health to healthy.
     */
    consecutiveSuccesses: number;
    createdOn: string;
    /**
     * A human-readable description of the health check.
     */
    description: string;
    /**
     * The current failure reason if status is unhealthy.
     */
    failureReason: string;
    /**
     * Parameters specific to an HTTP or HTTPS health check.
     */
    httpConfig: outputs.GetHealthchecksResultHttpConfig;
    /**
     * Identifier
     */
    id: string;
    /**
     * The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations.
     */
    interval: number;
    modifiedOn: string;
    /**
     * A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: string;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    retries: number;
    /**
     * The current status of the origin server according to the health check.
     */
    status: string;
    /**
     * If suspended, no health checks are sent to the origin.
     */
    suspended: boolean;
    /**
     * Parameters specific to TCP health check.
     */
    tcpConfig: outputs.GetHealthchecksResultTcpConfig;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    timeout: number;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'.
     */
    type: string;
}

export interface GetHealthchecksResultHttpConfig {
    /**
     * Do not validate the certificate when the health check uses HTTPS.
     */
    allowInsecure: boolean;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
     */
    expectedBody: string;
    /**
     * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
     */
    expectedCodes: string[];
    /**
     * Follow redirects if the origin returns a 3xx status code.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
     */
    header: {[key: string]: string[]};
    /**
     * The HTTP method to use for the health check.
     */
    method: string;
    /**
     * The endpoint path to health check against.
     */
    path: string;
    /**
     * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
     */
    port: number;
}

export interface GetHealthchecksResultTcpConfig {
    /**
     * The TCP connection method to use for the health check.
     */
    method: string;
    /**
     * Port number to connect to for the health check. Defaults to 80.
     */
    port: number;
}

export interface GetHyperdriveConfigCaching {
    /**
     * When set to true, disables the caching of SQL responses. (Default: false)
     */
    disabled: boolean;
    /**
     * When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
     */
    maxAge: number;
    /**
     * When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
     */
    staleWhileRevalidate: number;
}

export interface GetHyperdriveConfigOrigin {
    /**
     * The Client ID of the Access token to use when connecting to the origin database.
     */
    accessClientId: string;
    /**
     * The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
     */
    accessClientSecret: string;
    /**
     * The name of your origin database.
     */
    database: string;
    /**
     * The host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * The password required to access your origin database. This value is write-only and never returned by the API.
     */
    password: string;
    /**
     * The port (default: 5432 for Postgres) of your origin database.
     */
    port: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     */
    scheme: string;
    /**
     * The user of your origin database.
     */
    user: string;
}

export interface GetHyperdriveConfigsResult {
    caching: outputs.GetHyperdriveConfigsResultCaching;
    /**
     * When the Hyperdrive configuration was created.
     */
    createdOn: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * When the Hyperdrive configuration was last modified.
     */
    modifiedOn: string;
    name: string;
    origin: outputs.GetHyperdriveConfigsResultOrigin;
}

export interface GetHyperdriveConfigsResultCaching {
    /**
     * When set to true, disables the caching of SQL responses. (Default: false)
     */
    disabled: boolean;
    /**
     * When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
     */
    maxAge: number;
    /**
     * When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
     */
    staleWhileRevalidate: number;
}

export interface GetHyperdriveConfigsResultOrigin {
    /**
     * The Client ID of the Access token to use when connecting to the origin database.
     */
    accessClientId: string;
    /**
     * The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
     */
    accessClientSecret: string;
    /**
     * The name of your origin database.
     */
    database: string;
    /**
     * The host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * The password required to access your origin database. This value is write-only and never returned by the API.
     */
    password: string;
    /**
     * The port (default: 5432 for Postgres) of your origin database.
     */
    port: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     */
    scheme: string;
    /**
     * The user of your origin database.
     */
    user: string;
}

export interface GetImageVariantVariant {
    id: string;
    /**
     * Indicates whether the variant can access an image without a signature, regardless of image access control.
     */
    neverRequireSignedUrls: boolean;
    /**
     * Allows you to define image resizing sizes for different use cases.
     */
    options: outputs.GetImageVariantVariantOptions;
}

export interface GetImageVariantVariantOptions {
    /**
     * The fit property describes how the width and height dimensions should be interpreted.
     */
    fit: string;
    /**
     * Maximum height in image pixels.
     */
    height: number;
    /**
     * What EXIF data should be preserved in the output image.
     */
    metadata: string;
    /**
     * Maximum width in image pixels.
     */
    width: number;
}

export interface GetImagesResult {
    images: outputs.GetImagesResultImage[];
}

export interface GetImagesResultImage {
    /**
     * Image file name.
     */
    filename: string;
    /**
     * Image unique identifier.
     */
    id: string;
    /**
     * User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes.
     */
    meta: string;
    /**
     * Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image.
     */
    requireSignedUrls: boolean;
    /**
     * When the media item was uploaded.
     */
    uploaded: string;
    /**
     * Object specifying available variants for an image.
     */
    variants: string[];
}

export interface GetKeylessCertificateTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetKeylessCertificatesResult {
    /**
     * When the Keyless SSL was created.
     */
    createdOn: string;
    /**
     * Whether or not the Keyless SSL is on or off.
     */
    enabled: boolean;
    /**
     * The keyless SSL name.
     */
    host: string;
    /**
     * Keyless certificate identifier tag.
     */
    id: string;
    /**
     * When the Keyless SSL was last modified.
     */
    modifiedOn: string;
    /**
     * The keyless SSL name.
     */
    name: string;
    /**
     * Available permissions for the Keyless SSL for the current user requesting the item.
     */
    permissions: string[];
    /**
     * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
     */
    port: number;
    /**
     * Status of the Keyless SSL.
     */
    status: string;
    /**
     * Configuration for using Keyless SSL through a Cloudflare Tunnel
     */
    tunnel: outputs.GetKeylessCertificatesResultTunnel;
}

export interface GetKeylessCertificatesResultTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface GetLeakedCredentialCheckRulesResult {
    /**
     * The unique ID for this custom detection
     */
    id: string;
    /**
     * The ruleset expression to use in matching the password in a request
     */
    password: string;
    /**
     * The ruleset expression to use in matching the username in a request
     */
    username: string;
}

export interface GetListItemHostname {
    urlHostname: string;
}

export interface GetListItemRedirect {
    includeSubdomains: boolean;
    preservePathSuffix: boolean;
    preserveQueryString: boolean;
    sourceUrl: string;
    statusCode: number;
    subpathMatching: boolean;
    targetUrl: string;
}

export interface GetListItemsResult {
    /**
     * A non-negative 32 bit integer
     */
    asn: number;
    /**
     * An informative summary of the list item.
     */
    comment: string;
    /**
     * The RFC 3339 timestamp of when the item was created.
     */
    createdOn: string;
    /**
     * Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
     */
    hostname: outputs.GetListItemsResultHostname;
    /**
     * The unique ID of the list.
     */
    id: string;
    /**
     * An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64.
     */
    ip: string;
    /**
     * The RFC 3339 timestamp of when the item was last modified.
     */
    modifiedOn: string;
    /**
     * The definition of the redirect.
     */
    redirect: outputs.GetListItemsResultRedirect;
}

export interface GetListItemsResultHostname {
    urlHostname: string;
}

export interface GetListItemsResultRedirect {
    includeSubdomains: boolean;
    preservePathSuffix: boolean;
    preserveQueryString: boolean;
    sourceUrl: string;
    statusCode: number;
    subpathMatching: boolean;
    targetUrl: string;
}

export interface GetListsResult {
    /**
     * The RFC 3339 timestamp of when the list was created.
     */
    createdOn: string;
    /**
     * An informative summary of the list.
     */
    description: string;
    /**
     * The unique ID of the list.
     */
    id: string;
    /**
     * The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects).
     */
    kind: string;
    /**
     * The RFC 3339 timestamp of when the list was last modified.
     */
    modifiedOn: string;
    /**
     * An informative name for the list. Use this name in filter and rule expressions.
     */
    name: string;
    /**
     * The number of items in the list.
     */
    numItems: number;
    /**
     * The number of [filters](https://www.terraform.io/operations/filters-list-filters) referencing the list.
     */
    numReferencingFilters: number;
}

export interface GetLoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancerMonitorsResult {
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     */
    allowInsecure: boolean;
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     */
    consecutiveDown: number;
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     */
    consecutiveUp: number;
    createdOn: string;
    /**
     * Object description.
     */
    description: string;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedBody: string;
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedCodes: string;
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     */
    header: {[key: string]: string[]};
    id: string;
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     */
    interval: number;
    /**
     * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
     */
    method: string;
    modifiedOn: string;
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     */
    path: string;
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     */
    port: number;
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     */
    probeZone: string;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    retries: number;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    timeout: number;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
     */
    type: string;
}

export interface GetLoadBalancerPoolFilter {
    /**
     * The ID of the Monitor to use for checking the health of origins within this pool.
     */
    monitor?: string;
}

export interface GetLoadBalancerPoolLoadShedding {
    /**
     * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
     */
    defaultPercent: number;
    /**
     * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
     */
    defaultPolicy: string;
    /**
     * The percent of existing sessions to shed from the pool, according to the session policy.
     */
    sessionPercent: number;
    /**
     * Only the hash policy is supported for existing sessions (to avoid exponential decay).
     */
    sessionPolicy: string;
}

export interface GetLoadBalancerPoolNotificationFilter {
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    origin: outputs.GetLoadBalancerPoolNotificationFilterOrigin;
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    pool: outputs.GetLoadBalancerPoolNotificationFilterPool;
}

export interface GetLoadBalancerPoolNotificationFilterOrigin {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolNotificationFilterPool {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
     */
    address: string;
    /**
     * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled: boolean;
    /**
     * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
     */
    header: outputs.GetLoadBalancerPoolOriginHeader;
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId: string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     */
    weight: number;
}

export interface GetLoadBalancerPoolOriginHeader {
    /**
     * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
     */
    hosts: string[];
}

export interface GetLoadBalancerPoolOriginSteering {
    /**
     * The type of origin steering policy to use.
     */
    policy: string;
}

export interface GetLoadBalancerPoolsResult {
    /**
     * A list of regions from which to run health checks. Null means every Cloudflare data center.
     */
    checkRegions: string[];
    createdOn: string;
    /**
     * A human-readable description of the pool.
     */
    description: string;
    /**
     * This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any).
     */
    enabled: boolean;
    id: string;
    /**
     * The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set.
     */
    latitude: number;
    /**
     * Configures load shedding policies and percentages for the pool.
     */
    loadShedding: outputs.GetLoadBalancerPoolsResultLoadShedding;
    /**
     * The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set.
     */
    longitude: number;
    /**
     * The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool.
     */
    minimumOrigins: number;
    modifiedOn: string;
    /**
     * The ID of the Monitor to use for checking the health of origins within this pool.
     */
    monitor: string;
    /**
     * A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed.
     */
    name: string;
    /**
     * List of networks where Load Balancer or Pool is enabled.
     */
    networks: string[];
    /**
     * This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
     */
    notificationEmail: string;
    /**
     * Filter pool and origin health notifications by resource type or health status. Use null to reset.
     */
    notificationFilter: outputs.GetLoadBalancerPoolsResultNotificationFilter;
    /**
     * Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity.
     */
    originSteering: outputs.GetLoadBalancerPoolsResultOriginSteering;
    /**
     * The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
     */
    origins: outputs.GetLoadBalancerPoolsResultOrigin[];
}

export interface GetLoadBalancerPoolsResultLoadShedding {
    /**
     * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
     */
    defaultPercent: number;
    /**
     * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
     */
    defaultPolicy: string;
    /**
     * The percent of existing sessions to shed from the pool, according to the session policy.
     */
    sessionPercent: number;
    /**
     * Only the hash policy is supported for existing sessions (to avoid exponential decay).
     */
    sessionPolicy: string;
}

export interface GetLoadBalancerPoolsResultNotificationFilter {
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    origin: outputs.GetLoadBalancerPoolsResultNotificationFilterOrigin;
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    pool: outputs.GetLoadBalancerPoolsResultNotificationFilterPool;
}

export interface GetLoadBalancerPoolsResultNotificationFilterOrigin {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolsResultNotificationFilterPool {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy: boolean;
}

export interface GetLoadBalancerPoolsResultOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
     */
    address: string;
    /**
     * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled: boolean;
    /**
     * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
     */
    header: outputs.GetLoadBalancerPoolsResultOriginHeader;
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId: string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     */
    weight: number;
}

export interface GetLoadBalancerPoolsResultOriginHeader {
    /**
     * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
     */
    hosts: string[];
}

export interface GetLoadBalancerPoolsResultOriginSteering {
    /**
     * The type of origin steering policy to use.
     */
    policy: string;
}

export interface GetLoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancerRule {
    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixedResponse in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     */
    condition: string;
    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     */
    disabled: boolean;
    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     */
    fixedResponse: outputs.GetLoadBalancerRuleFixedResponse;
    /**
     * Name of this rule. Only used for human readability.
     */
    name: string;
    /**
     * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
     */
    overrides: outputs.GetLoadBalancerRuleOverrides;
    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     */
    priority: number;
    /**
     * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
     */
    terminates: boolean;
}

export interface GetLoadBalancerRuleFixedResponse {
    /**
     * The http 'Content-Type' header to include in the response.
     */
    contentType: string;
    /**
     * The http 'Location' header to include in the response.
     */
    location: string;
    /**
     * Text to include as the http body.
     */
    messageBody: string;
    /**
     * The http status code to respond with.
     */
    statusCode: number;
}

export interface GetLoadBalancerRuleOverrides {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.GetLoadBalancerRuleOverridesAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.GetLoadBalancerRuleOverridesLocationStrategy;
    /**
     * (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.GetLoadBalancerRuleOverridesRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.GetLoadBalancerRuleOverridesSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are:
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface GetLoadBalancerRuleOverridesAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancerRuleOverridesLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancerRuleOverridesRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancerRuleOverridesSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
     */
    zeroDowntimeFailover: string;
}

export interface GetLoadBalancerSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
     */
    zeroDowntimeFailover: string;
}

export interface GetLoadBalancersResult {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.GetLoadBalancersResultAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    createdOn: string;
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools: string[];
    /**
     * Object description.
     */
    description: string;
    /**
     * Whether to enable (the default) this load balancer.
     */
    enabled: boolean;
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool: string;
    id: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.GetLoadBalancersResultLocationStrategy;
    modifiedOn: string;
    /**
     * The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used.
     */
    name: string;
    /**
     * List of networks where Load Balancer or Pool is enabled.
     */
    networks: string[];
    /**
     * (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Whether the hostname should be gray clouded (false) or orange clouded (true).
     */
    proxied: boolean;
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.GetLoadBalancersResultRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * BETA Field Not General Access: A list of rules for this load balancer to execute.
     */
    rules: outputs.GetLoadBalancersResultRule[];
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.GetLoadBalancersResultSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are:
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface GetLoadBalancersResultAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancersResultLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancersResultRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancersResultRule {
    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixedResponse in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     */
    condition: string;
    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     */
    disabled: boolean;
    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     */
    fixedResponse: outputs.GetLoadBalancersResultRuleFixedResponse;
    /**
     * Name of this rule. Only used for human readability.
     */
    name: string;
    /**
     * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
     */
    overrides: outputs.GetLoadBalancersResultRuleOverrides;
    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     */
    priority: number;
    /**
     * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
     */
    terminates: boolean;
}

export interface GetLoadBalancersResultRuleFixedResponse {
    /**
     * The http 'Content-Type' header to include in the response.
     */
    contentType: string;
    /**
     * The http 'Location' header to include in the response.
     */
    location: string;
    /**
     * Text to include as the http body.
     */
    messageBody: string;
    /**
     * The http status code to respond with.
     */
    statusCode: number;
}

export interface GetLoadBalancersResultRuleOverrides {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.GetLoadBalancersResultRuleOverridesAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.GetLoadBalancersResultRuleOverridesLocationStrategy;
    /**
     * (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.GetLoadBalancersResultRuleOverridesRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.GetLoadBalancersResultRuleOverridesSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are:
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface GetLoadBalancersResultRuleOverridesAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface GetLoadBalancersResultRuleOverridesLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface GetLoadBalancersResultRuleOverridesRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights: {[key: string]: number};
}

export interface GetLoadBalancersResultRuleOverridesSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
     */
    zeroDowntimeFailover: string;
}

export interface GetLoadBalancersResultSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
     */
    zeroDowntimeFailover: string;
}

<<<<<<< HEAD
=======
export interface GetLogpushDatasetJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve20214428: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     */
    timestampFormat: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetLogpushJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve20214428: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     */
    timestampFormat: string;
}

export interface GetLogpushJobsResult {
    /**
     * Name of the dataset. A list of supported datasets can be found on the [Developer Docs](https://developers.cloudflare.com/logs/reference/log-fields/).
     */
    dataset: string;
    /**
     * Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included.
     */
    destinationConf: string;
    /**
     * Flag that indicates if the job is enabled.
     */
    enabled: boolean;
    /**
     * If not null, the job is currently failing. Failures are usually repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error*message and last*error are set to null.
     */
    errorMessage: string;
    /**
     * This field is deprecated. Please use `max_upload_*` parameters instead. The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files.
     */
    frequency: string;
    /**
     * Unique id of the job.
     */
    id: number;
    /**
     * The kind parameter (optional) is used to differentiate between Logpush and Edge Log Delivery jobs. Currently, Edge Log Delivery is only supported for the `httpRequests` dataset.
     */
    kind: string;
    /**
     * Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty.
     */
    lastComplete: string;
    /**
     * Records the last time the job failed. If not null, the job is currently failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the errorMessage field.
     */
    lastError: string;
    /**
     * This field is deprecated. Use `outputOptions` instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately.
     */
    logpullOptions: string;
    /**
     * The maximum uncompressed file size of a batch of logs. This setting value must be between `5 MB` and `1 GB`, or `0` to disable it. Note that you cannot set a minimum file size; this means that log files may be much smaller than this batch size. This parameter is not available for jobs with `edge` as its kind.
     */
    maxUploadBytes: number;
    /**
     * The maximum interval in seconds for log batches. This setting must be between 30 and 300 seconds (5 minutes), or `0` to disable it. Note that you cannot specify a minimum interval for log batches; this means that log files may be sent in shorter intervals than this. This parameter is only used for jobs with `edge` as its kind.
     */
    maxUploadIntervalSeconds: number;
    /**
     * The maximum number of log lines per batch. This setting must be between 1000 and 1,000,000 lines, or `0` to disable it. Note that you cannot specify a minimum number of log lines per batch; this means that log files may contain many fewer lines than this. This parameter is not available for jobs with `edge` as its kind.
     */
    maxUploadRecords: number;
    /**
     * Optional human readable job name. Not unique. Cloudflare suggests that you set this to a meaningful string, like the domain name, to make it easier to identify your job.
     */
    name: string;
    /**
     * The structured replacement for `logpullOptions`. When including this field, the `logpullOption` field will be ignored.
     */
    outputOptions: outputs.GetLogpushJobsResultOutputOptions;
}

export interface GetLogpushJobsResultOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve20214428: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     */
    timestampFormat: string;
}

export interface GetMagicNetworkMonitoringConfigurationWarpDevice {
    /**
     * Unique identifier for the warp device.
     */
    id: string;
    /**
     * Name of the warp device.
     */
    name: string;
    /**
     * IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
     */
    routerIp: string;
}

export interface GetMagicNetworkMonitoringRulesResult {
    /**
     * Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit.
     */
    automaticAdvertisement: boolean;
    /**
     * The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
     */
    bandwidthThreshold: number;
    /**
     * The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"]. The format is AhBmCsDmsEusFns where A, B, C, D, E and F durations are optional; however at least one unit must be provided.
     */
    duration: string;
    /**
     * The id of the rule. Must be unique.
     */
    id: string;
    /**
     * The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters.
     */
    name: string;
    /**
     * The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
     */
    packetThreshold: number;
    prefixes: string[];
}

export interface GetMagicTransitConnectorDevice {
    id: string;
    serialNumber: string;
}

export interface GetMagicTransitConnectorsResult {
    activated: boolean;
    device: outputs.GetMagicTransitConnectorsResultDevice;
    id: string;
    interruptWindowDurationHours: number;
    interruptWindowHourOfDay: number;
    lastHeartbeat: string;
    lastSeenVersion: string;
    lastUpdated: string;
    notes: string;
    timezone: string;
}

export interface GetMagicTransitConnectorsResultDevice {
    id: string;
    serialNumber: string;
}

export interface GetMagicTransitSiteAclLan1 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteAclLan2 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteAclsResult {
    /**
     * Description for the ACL.
     */
    description: string;
    /**
     * The desired forwarding action for this ACL policy. If set to "false", the policy will forward traffic to Cloudflare. If set to "true", the policy will forward traffic locally on the Magic Connector. If not included in request, will default to false.
     */
    forwardLocally: boolean;
    /**
     * Identifier
     */
    id: string;
    lan1: outputs.GetMagicTransitSiteAclsResultLan1;
    lan2: outputs.GetMagicTransitSiteAclsResultLan2;
    /**
     * The name of the ACL.
     */
    name: string;
    protocols: string[];
    /**
     * The desired traffic direction for this ACL policy. If set to "false", the policy will allow bidirectional traffic. If set to "true", the policy will only allow traffic in one direction. If not included in request, will default to false.
     */
    unidirectional: boolean;
}

export interface GetMagicTransitSiteAclsResultLan1 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteAclsResultLan2 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets: string[];
}

export interface GetMagicTransitSiteFilter {
    /**
     * Identifier
     */
<<<<<<< HEAD
    connectorIdentifier?: string;
=======
    connectorid?: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface GetMagicTransitSiteLanNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLanRoutedSubnet {
    nat: outputs.GetMagicTransitSiteLanRoutedSubnetNat;
    /**
     * A valid IPv4 address.
     */
    nextHop: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    prefix: string;
}

export interface GetMagicTransitSiteLanRoutedSubnetNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    dhcpRelay: outputs.GetMagicTransitSiteLanStaticAddressingDhcpRelay;
    dhcpServer: outputs.GetMagicTransitSiteLanStaticAddressingDhcpServer;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    virtualAddress: string;
}

export interface GetMagicTransitSiteLanStaticAddressingDhcpRelay {
    /**
     * List of DHCP server IPs.
     */
    serverAddresses: string[];
}

export interface GetMagicTransitSiteLanStaticAddressingDhcpServer {
    /**
     * A valid IPv4 address.
     */
    dhcpPoolEnd: string;
    /**
     * A valid IPv4 address.
     */
    dhcpPoolStart: string;
    /**
     * A valid IPv4 address.
     */
    dnsServer: string;
<<<<<<< HEAD
=======
    dnsServers: string[];
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Mapping of MAC addresses to IP addresses
     */
    reservations: {[key: string]: string};
}

export interface GetMagicTransitSiteLansResult {
    /**
     * mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
     */
    haLink: boolean;
    /**
     * Identifier
     */
    id: string;
    name: string;
    nat: outputs.GetMagicTransitSiteLansResultNat;
    physport: number;
    routedSubnets: outputs.GetMagicTransitSiteLansResultRoutedSubnet[];
    /**
     * Identifier
     */
    siteId: string;
    /**
     * If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static*address is required along with secondary and virtual address.
     */
    staticAddressing: outputs.GetMagicTransitSiteLansResultStaticAddressing;
    /**
     * VLAN port number.
     */
    vlanTag: number;
}

export interface GetMagicTransitSiteLansResultNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLansResultRoutedSubnet {
    nat: outputs.GetMagicTransitSiteLansResultRoutedSubnetNat;
    /**
     * A valid IPv4 address.
     */
    nextHop: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    prefix: string;
}

export interface GetMagicTransitSiteLansResultRoutedSubnetNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix: string;
}

export interface GetMagicTransitSiteLansResultStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    dhcpRelay: outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpRelay;
    dhcpServer: outputs.GetMagicTransitSiteLansResultStaticAddressingDhcpServer;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    virtualAddress: string;
}

export interface GetMagicTransitSiteLansResultStaticAddressingDhcpRelay {
    /**
     * List of DHCP server IPs.
     */
    serverAddresses: string[];
}

export interface GetMagicTransitSiteLansResultStaticAddressingDhcpServer {
    /**
     * A valid IPv4 address.
     */
    dhcpPoolEnd: string;
    /**
     * A valid IPv4 address.
     */
    dhcpPoolStart: string;
    /**
     * A valid IPv4 address.
     */
    dnsServer: string;
<<<<<<< HEAD
=======
    dnsServers: string[];
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Mapping of MAC addresses to IP addresses
     */
    reservations: {[key: string]: string};
}

export interface GetMagicTransitSiteLocation {
    /**
     * Latitude
     */
    lat: string;
    /**
     * Longitude
     */
    lon: string;
}

export interface GetMagicTransitSiteWanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    /**
     * A valid IPv4 address.
     */
    gatewayAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
}

export interface GetMagicTransitSiteWansResult {
    /**
     * Magic WAN health check rate for tunnels created on this link. The default value is `mid`.
     */
    healthCheckRate: string;
    /**
     * Identifier
     */
    id: string;
    name: string;
    physport: number;
    /**
     * Priority of WAN for traffic loadbalancing.
     */
    priority: number;
    /**
     * Identifier
     */
    siteId: string;
    /**
     * (optional) if omitted, use DHCP. Submit secondary*address when site is in high availability mode.
     */
    staticAddressing: outputs.GetMagicTransitSiteWansResultStaticAddressing;
    /**
     * VLAN port number.
     */
    vlanTag: number;
}

export interface GetMagicTransitSiteWansResultStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    /**
     * A valid IPv4 address.
     */
    gatewayAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress: string;
}

export interface GetMagicTransitSitesResult {
    /**
     * Magic Connector identifier tag.
     */
    connectorId: string;
    description: string;
    /**
     * Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
     */
    haMode: boolean;
    /**
     * Identifier
     */
    id: string;
    /**
     * Location of site in latitude and longitude.
     */
    location: outputs.GetMagicTransitSitesResultLocation;
    /**
     * The name of the site.
     */
    name: string;
    /**
     * Magic Connector identifier tag. Used when high availability mode is on.
     */
    secondaryConnectorId: string;
}

export interface GetMagicTransitSitesResultLocation {
    /**
     * Latitude
     */
    lat: string;
    /**
     * Longitude
     */
    lon: string;
}

export interface GetMagicWanGreTunnelGreTunnel {
    /**
     * The IP address assigned to the Cloudflare side of the GRE tunnel.
     */
    cloudflareGreEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the GRE tunnel.
     */
    customerGreEndpoint: string;
    /**
     * An optional description of the GRE tunnel.
     */
    description: string;
    healthCheck: outputs.GetMagicWanGreTunnelGreTunnelHealthCheck;
    /**
     * Tunnel identifier tag.
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
     */
    mtu: number;
    /**
     * The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
     */
    name: string;
    /**
     * Time To Live (TTL) in number of hops of the GRE tunnel.
     */
    ttl: number;
}

export interface GetMagicWanGreTunnelGreTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.GetMagicWanGreTunnelGreTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface GetMagicWanGreTunnelGreTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnel {
    /**
     * When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
     */
    allowNullCipher: boolean;
    /**
     * The IP address assigned to the Cloudflare side of the IPsec tunnel.
     */
    cloudflareEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
     */
    customerEndpoint: string;
    /**
     * An optional description forthe IPsec tunnel.
     */
    description: string;
    healthCheck: outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheck;
    /**
     * Tunnel identifier tag.
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * The name of the IPsec tunnel. The name cannot share a name with other tunnels.
     */
    name: string;
    /**
     * The PSK metadata that includes when the PSK was generated.
     */
    pskMetadata: outputs.GetMagicWanIpsecTunnelIpsecTunnelPskMetadata;
    /**
     * If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
     */
    replayProtection: boolean;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface GetMagicWanIpsecTunnelIpsecTunnelPskMetadata {
    /**
     * The date and time the tunnel was last modified.
     */
    lastGeneratedOn: string;
}

export interface GetMagicWanStaticRouteRoute {
    /**
     * When the route was created.
     */
    createdOn: string;
    /**
     * An optional human provided description of the static route.
     */
    description: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * When the route was last modified.
     */
    modifiedOn: string;
    /**
     * The next-hop IP Address for the static route.
     */
    nexthop: string;
    /**
     * IP Prefix in Classless Inter-Domain Routing format.
     */
    prefix: string;
    /**
     * Priority of the static route.
     */
    priority: number;
    /**
     * Used only for ECMP routes.
     */
    scope: outputs.GetMagicWanStaticRouteRouteScope;
    /**
     * Optional weight of the ECMP scope - if provided.
     */
    weight: number;
}

export interface GetMagicWanStaticRouteRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions: string[];
}

export interface GetManagedTransformsManagedRequestHeader {
    /**
     * The Managed Transforms that this Managed Transform conflicts with.
     */
    conflictsWiths: string[];
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
     */
    hasConflict: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface GetManagedTransformsManagedResponseHeader {
    /**
     * The Managed Transforms that this Managed Transform conflicts with.
     */
    conflictsWiths: string[];
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
     */
    hasConflict: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface GetMtlsCertificatesResult {
    /**
     * Indicates whether the certificate is a CA or leaf certificate.
     */
    ca: boolean;
    /**
     * The uploaded root CA certificate.
     */
    certificates: string;
    /**
     * When the certificate expires.
     */
    expiresOn: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    issuer: string;
    /**
     * Optional unique name for the certificate. Only used for human readability.
     */
    name: string;
    /**
     * The certificate serial number.
     */
    serialNumber: string;
    /**
     * The type of hash used for the certificate.
     */
    signature: string;
    /**
     * This is the time the certificate was uploaded.
     */
    uploadedOn: string;
}

export interface GetNotificationPoliciesResult {
    /**
     * Optional specification of how often to re-alert from the same incident, not support on all alert types.
     */
    alertInterval: string;
    /**
     * Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values.
     */
    alertType: string;
    created: string;
    /**
     * Optional description for the Notification policy.
     */
    description: string;
    /**
     * Whether or not the Notification policy is enabled.
     */
    enabled: boolean;
    /**
     * Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details.
     */
    filters: outputs.GetNotificationPoliciesResultFilters;
    /**
     * The unique identifier of a notification policy
     */
    id: string;
    /**
     * List of IDs that will be used when dispatching a notification. IDs for email type will be the email address.
     */
    mechanisms: outputs.GetNotificationPoliciesResultMechanisms;
    modified: string;
    /**
     * Name of the policy.
     */
    name: string;
}

export interface GetNotificationPoliciesResultFilters {
    /**
     * Usage depends on specific alert type
     */
    actions: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedAsns: string[];
    /**
     * Used for configuring incident_alert
     */
    affectedComponents: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedLocations: string[];
    /**
     * Used for configuring maintenance*event*notification
     */
    airportCodes: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferences: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferencesValues: string[];
    /**
     * Used for configuring load*balancing*pool*enablement*alert
     */
    enableds: string[];
    /**
     * Used for configuring pages*event*alert
     */
    environments: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    eventSources: string[];
    /**
     * Usage depends on specific alert type
     */
    eventTypes: string[];
    /**
     * Used for configuring pages*event*alert
     */
    events: string[];
    /**
     * Usage depends on specific alert type
     */
    groupBies: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    healthCheckIds: string[];
    /**
     * Used for configuring incident_alert
     */
    incidentImpacts: string[];
    /**
     * Used for configuring stream*live*notifications
     */
    inputIds: string[];
    /**
     * Used for configuring security*insights*alert
     */
    insightClasses: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    limits: string[];
    /**
     * Used for configuring logo*match*alert
     */
    logoTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    megabitsPerSeconds: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    newHealths: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    newStatuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    packetsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    poolIds: string[];
    /**
     * Usage depends on specific alert type
     */
    popNames: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    products: string[];
    /**
     * Used for configuring pages*event*alert
     */
    projectIds: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    protocols: string[];
    /**
     * Usage depends on specific alert type
     */
    queryTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    requestsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    selectors: string[];
    /**
     * Used for configuring clickhouse*alert*fw*ent*anomaly
     */
    services: string[];
    /**
     * Usage depends on specific alert type
     */
    slos: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    statuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetHostnames: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    targetIps: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetZoneNames: string[];
    /**
     * Used for configuring traffic*anomalies*alert
     */
    trafficExclusions: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    tunnelIds: string[];
    /**
     * Usage depends on specific alert type
     */
    tunnelNames: string[];
    /**
     * Usage depends on specific alert type
     */
    wheres: string[];
    /**
     * Usage depends on specific alert type
     */
    zones: string[];
}

export interface GetNotificationPoliciesResultMechanisms {
    emails: outputs.GetNotificationPoliciesResultMechanismsEmail[];
    pagerduties: outputs.GetNotificationPoliciesResultMechanismsPagerduty[];
    webhooks: outputs.GetNotificationPoliciesResultMechanismsWebhook[];
}

export interface GetNotificationPoliciesResultMechanismsEmail {
    /**
     * The email address
     */
    id: string;
}

export interface GetNotificationPoliciesResultMechanismsPagerduty {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPoliciesResultMechanismsWebhook {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPolicyFilters {
    /**
     * Usage depends on specific alert type
     */
    actions: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedAsns: string[];
    /**
     * Used for configuring incident_alert
     */
    affectedComponents: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedLocations: string[];
    /**
     * Used for configuring maintenance*event*notification
     */
    airportCodes: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferences: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferencesValues: string[];
    /**
     * Used for configuring load*balancing*pool*enablement*alert
     */
    enableds: string[];
    /**
     * Used for configuring pages*event*alert
     */
    environments: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    eventSources: string[];
    /**
     * Usage depends on specific alert type
     */
    eventTypes: string[];
    /**
     * Used for configuring pages*event*alert
     */
    events: string[];
    /**
     * Usage depends on specific alert type
     */
    groupBies: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    healthCheckIds: string[];
    /**
     * Used for configuring incident_alert
     */
    incidentImpacts: string[];
    /**
     * Used for configuring stream*live*notifications
     */
    inputIds: string[];
    /**
     * Used for configuring security*insights*alert
     */
    insightClasses: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    limits: string[];
    /**
     * Used for configuring logo*match*alert
     */
    logoTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    megabitsPerSeconds: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    newHealths: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    newStatuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    packetsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    poolIds: string[];
    /**
     * Usage depends on specific alert type
     */
    popNames: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    products: string[];
    /**
     * Used for configuring pages*event*alert
     */
    projectIds: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    protocols: string[];
    /**
     * Usage depends on specific alert type
     */
    queryTags: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    requestsPerSeconds: string[];
    /**
     * Usage depends on specific alert type
     */
    selectors: string[];
    /**
     * Used for configuring clickhouse*alert*fw*ent*anomaly
     */
    services: string[];
    /**
     * Usage depends on specific alert type
     */
    slos: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    statuses: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetHostnames: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    targetIps: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetZoneNames: string[];
    /**
     * Used for configuring traffic*anomalies*alert
     */
    trafficExclusions: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    tunnelIds: string[];
    /**
     * Usage depends on specific alert type
     */
    tunnelNames: string[];
    /**
     * Usage depends on specific alert type
     */
    wheres: string[];
    /**
     * Usage depends on specific alert type
     */
    zones: string[];
}

export interface GetNotificationPolicyMechanisms {
    emails: outputs.GetNotificationPolicyMechanismsEmail[];
    pagerduties: outputs.GetNotificationPolicyMechanismsPagerduty[];
    webhooks: outputs.GetNotificationPolicyMechanismsWebhook[];
}

export interface GetNotificationPolicyMechanismsEmail {
    /**
     * The email address
     */
    id: string;
}

export interface GetNotificationPolicyMechanismsPagerduty {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPolicyMechanismsWebhook {
    /**
     * UUID
     */
    id: string;
}

export interface GetNotificationPolicyWebhooksListResult {
    /**
     * Timestamp of when the webhook destination was created.
     */
    createdAt: string;
    /**
     * The unique identifier of a webhook
     */
    id: string;
    /**
     * Timestamp of the last time an attempt to dispatch a notification to this webhook failed.
     */
    lastFailure: string;
    /**
     * Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook.
     */
    lastSuccess: string;
    /**
     * The name of the webhook destination. This will be included in the request body when you receive a webhook notification.
     */
    name: string;
    /**
     * Optional secret that will be passed in the `cf-webhook-auth` header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body.
     */
    secret: string;
    /**
     * Type of webhook endpoint.
     */
    type: string;
    /**
     * The POST endpoint to call when dispatching a notification.
     */
    url: string;
}

export interface GetOriginCaCertificateFilter {
    /**
     * Identifier
     */
    zoneId?: string;
}

export interface GetOriginCaCertificatesResult {
    /**
     * The Origin CA certificate. Will be newline-encoded.
     */
    certificate: string;
    /**
     * The Certificate Signing Request (CSR). Must be newline-encoded.
     */
    csr: string;
    /**
     * When the certificate will expire.
     */
    expiresOn: string;
    /**
     * Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate.
     */
    hostnames: string[];
    /**
     * Identifier
     */
    id: string;
    /**
     * Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers).
     */
    requestType: string;
    /**
     * The number of days for which the certificate should be valid.
     */
    requestedValidity: number;
}

export interface GetPageShieldConnectionsListResult {
    addedAt: string;
    domainReportedMalicious: boolean;
    firstPageUrl: string;
    firstSeenAt: string;
    host: string;
    /**
     * Identifier
     */
    id: string;
    lastSeenAt: string;
    maliciousDomainCategories: string[];
    maliciousUrlCategories: string[];
    pageUrls: string[];
    url: string;
    urlContainsCdnCgiPath: boolean;
    urlReportedMalicious: boolean;
}

export interface GetPageShieldCookiesListResult {
    domainAttribute: string;
    expiresAttribute: string;
    firstSeenAt: string;
    host: string;
    httpOnlyAttribute: boolean;
    /**
     * Identifier
     */
    id: string;
    lastSeenAt: string;
    maxAgeAttribute: number;
    name: string;
    pageUrls: string[];
    pathAttribute: string;
    sameSiteAttribute: string;
    secureAttribute: boolean;
    type: string;
}

export interface GetPageShieldPoliciesResult {
    /**
     * The action to take if the expression matches
     */
    action: string;
    /**
     * A description for the policy
     */
    description: string;
    /**
     * Whether the policy is enabled
     */
    enabled: boolean;
    /**
     * The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax
     */
    expression: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The policy which will be applied
     */
    value: string;
}

export interface GetPageShieldScriptsListResult {
    addedAt: string;
    /**
     * The cryptomining score of the JavaScript content.
     */
    cryptominingScore: number;
    /**
     * The dataflow score of the JavaScript content.
     */
    dataflowScore: number;
    domainReportedMalicious: boolean;
    /**
     * The timestamp of when the script was last fetched.
     */
    fetchedAt: string;
    firstPageUrl: string;
    firstSeenAt: string;
    /**
     * The computed hash of the analyzed script.
     */
    hash: string;
    host: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * The integrity score of the JavaScript content.
     */
    jsIntegrityScore: number;
    lastSeenAt: string;
    /**
     * The magecart score of the JavaScript content.
     */
    magecartScore: number;
    maliciousDomainCategories: string[];
    maliciousUrlCategories: string[];
    /**
     * The malware score of the JavaScript content.
     */
    malwareScore: number;
    /**
     * The obfuscation score of the JavaScript content.
     */
    obfuscationScore: number;
    pageUrls: string[];
    url: string;
    urlContainsCdnCgiPath: boolean;
    urlReportedMalicious: boolean;
}

export interface GetPageShieldScriptsVersion {
    /**
     * The cryptomining score of the JavaScript content.
     */
    cryptominingScore: number;
    /**
     * The dataflow score of the JavaScript content.
     */
    dataflowScore: number;
    /**
     * The timestamp of when the script was last fetched.
     */
    fetchedAt: string;
    /**
     * The computed hash of the analyzed script.
     */
    hash: string;
    /**
     * The integrity score of the JavaScript content.
     */
    jsIntegrityScore: number;
    /**
     * The magecart score of the JavaScript content.
     */
    magecartScore: number;
    /**
     * The malware score of the JavaScript content.
     */
    malwareScore: number;
    /**
     * The obfuscation score of the JavaScript content.
     */
    obfuscationScore: number;
}

export interface GetPagesDomainValidationData {
    errorMessage: string;
    method: string;
    status: string;
    txtName: string;
    txtValue: string;
}

export interface GetPagesDomainVerificationData {
    errorMessage: string;
    status: string;
}

export interface GetPagesDomainsResult {
    certificateAuthority: string;
    createdOn: string;
    domainId: string;
    id: string;
    name: string;
    status: string;
    validationData: outputs.GetPagesDomainsResultValidationData;
    verificationData: outputs.GetPagesDomainsResultVerificationData;
    zoneTag: string;
}

export interface GetPagesDomainsResultValidationData {
    errorMessage: string;
    method: string;
    status: string;
    txtName: string;
    txtValue: string;
}

export interface GetPagesDomainsResultVerificationData {
    errorMessage: string;
    status: string;
}

export interface GetPagesProjectBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectCanonicalDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.GetPagesProjectCanonicalDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.GetPagesProjectCanonicalDeploymentDeploymentTrigger;
    /**
     * A dict of env variables to build this deploy.
     */
    envVars: {[key: string]: outputs.GetPagesProjectCanonicalDeploymentEnvVars};
    /**
     * Type of deploy.
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.GetPagesProjectCanonicalDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.GetPagesProjectCanonicalDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.GetPagesProjectCanonicalDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface GetPagesProjectCanonicalDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectCanonicalDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     */
    type: string;
}

export interface GetPagesProjectCanonicalDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface GetPagesProjectCanonicalDeploymentEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectCanonicalDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface GetPagesProjectCanonicalDeploymentSource {
    config: outputs.GetPagesProjectCanonicalDeploymentSourceConfig;
    type: string;
}

export interface GetPagesProjectCanonicalDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectCanonicalDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface GetPagesProjectDeploymentConfigs {
    /**
     * Configs for preview deploys.
     */
    preview: outputs.GetPagesProjectDeploymentConfigsPreview;
    /**
     * Configs for production deploys.
     */
    production: outputs.GetPagesProjectDeploymentConfigsProduction;
}

export interface GetPagesProjectDeploymentConfigsPreview {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewD1Databases};
    /**
     * Durabble Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespaces};
    /**
     * Environment variables for build configs.
     */
    envVars: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement: outputs.GetPagesProjectDeploymentConfigsPreviewPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsPreviewVectorizeBindings};
}

export interface GetPagesProjectDeploymentConfigsPreviewAiBindings {
    projectId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewBrowsers {
}

export interface GetPagesProjectDeploymentConfigsPreviewD1Databases {
    /**
     * UUID of the D1 database.
     */
    id: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewDurableObjectNamespaces {
    /**
     * ID of the Durabble Object namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewHyperdriveBindings {
    id: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewMtlsCertificates {
    certificateId: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement mode.
     */
    mode: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewQueueProducers {
    /**
     * Name of the Queue.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction: string;
    /**
     * Name of the R2 bucket.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint: string;
    /**
     * The Service environment.
     */
    environment: string;
    /**
     * The Service name.
     */
    service: string;
}

export interface GetPagesProjectDeploymentConfigsPreviewVectorizeBindings {
    indexName: string;
}

export interface GetPagesProjectDeploymentConfigsProduction {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionD1Databases};
    /**
     * Durabble Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionDurableObjectNamespaces};
    /**
     * Environment variables for build configs.
     */
    envVars: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement: outputs.GetPagesProjectDeploymentConfigsProductionPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings: {[key: string]: outputs.GetPagesProjectDeploymentConfigsProductionVectorizeBindings};
}

export interface GetPagesProjectDeploymentConfigsProductionAiBindings {
    projectId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset: string;
}

export interface GetPagesProjectDeploymentConfigsProductionBrowsers {
}

export interface GetPagesProjectDeploymentConfigsProductionD1Databases {
    /**
     * UUID of the D1 database.
     */
    id: string;
}

export interface GetPagesProjectDeploymentConfigsProductionDurableObjectNamespaces {
    /**
     * ID of the Durabble Object namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectDeploymentConfigsProductionHyperdriveBindings {
    id: string;
}

export interface GetPagesProjectDeploymentConfigsProductionKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionMtlsCertificates {
    certificateId: string;
}

export interface GetPagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement mode.
     */
    mode: string;
}

export interface GetPagesProjectDeploymentConfigsProductionQueueProducers {
    /**
     * Name of the Queue.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsProductionR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction: string;
    /**
     * Name of the R2 bucket.
     */
    name: string;
}

export interface GetPagesProjectDeploymentConfigsProductionServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint: string;
    /**
     * The Service environment.
     */
    environment: string;
    /**
     * The Service name.
     */
    service: string;
}

export interface GetPagesProjectDeploymentConfigsProductionVectorizeBindings {
    indexName: string;
}

export interface GetPagesProjectLatestDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.GetPagesProjectLatestDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.GetPagesProjectLatestDeploymentDeploymentTrigger;
    /**
     * A dict of env variables to build this deploy.
     */
    envVars: {[key: string]: outputs.GetPagesProjectLatestDeploymentEnvVars};
    /**
     * Type of deploy.
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.GetPagesProjectLatestDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.GetPagesProjectLatestDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.GetPagesProjectLatestDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface GetPagesProjectLatestDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectLatestDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.GetPagesProjectLatestDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     */
    type: string;
}

export interface GetPagesProjectLatestDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface GetPagesProjectLatestDeploymentEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectLatestDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface GetPagesProjectLatestDeploymentSource {
    config: outputs.GetPagesProjectLatestDeploymentSourceConfig;
    type: string;
}

export interface GetPagesProjectLatestDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectLatestDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface GetPagesProjectSource {
    config: outputs.GetPagesProjectSourceConfig;
    type: string;
}

export interface GetPagesProjectSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectsResult {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.GetPagesProjectsResultBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.GetPagesProjectsResultDeploymentTrigger;
    /**
     * A dict of env variables to build this deploy.
     */
    envVars: {[key: string]: outputs.GetPagesProjectsResultEnvVars};
    /**
     * Type of deploy.
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.GetPagesProjectsResultLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.GetPagesProjectsResultSource;
    /**
     * List of past stages.
     */
    stages: outputs.GetPagesProjectsResultStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface GetPagesProjectsResultBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface GetPagesProjectsResultDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.GetPagesProjectsResultDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     */
    type: string;
}

export interface GetPagesProjectsResultDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface GetPagesProjectsResultEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface GetPagesProjectsResultLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface GetPagesProjectsResultSource {
    config: outputs.GetPagesProjectsResultSourceConfig;
    type: string;
}

export interface GetPagesProjectsResultSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface GetPagesProjectsResultStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface GetPermissionGroupMeta {
    key: string;
    value: string;
}

export interface GetPermissionGroupsResult {
<<<<<<< HEAD
=======
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the permission group.
     */
    meta: outputs.GetPermissionGroupsResultMeta;
    /**
     * Name of the group.
     */
    name: string;
}

export interface GetPermissionGroupsResultMeta {
    key: string;
    value: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface GetQueueConsumer {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.GetQueueConsumerSettings;
    type: string;
}

export interface GetQueueConsumerSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency: number;
    /**
     * The maximum number of retries
     */
    maxRetries: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs: number;
}

export interface GetQueueProducer {
    bucketName: string;
    script: string;
    type: string;
}

export interface GetQueueSettings {
    /**
     * Number of seconds to delay delivery of all messages to consumers.
     */
    deliveryDelay: number;
    /**
     * Number of seconds after which an unconsumed message will be delayed.
     */
    messageRetentionPeriod: number;
}

export interface GetQueuesResult {
    consumers: outputs.GetQueuesResultConsumer[];
    consumersTotalCount: number;
    createdOn: string;
    modifiedOn: string;
    producers: outputs.GetQueuesResultProducer[];
    producersTotalCount: number;
    queueId: string;
    queueName: string;
    settings: outputs.GetQueuesResultSettings;
}

export interface GetQueuesResultConsumer {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.GetQueuesResultConsumerSettings;
    type: string;
}

export interface GetQueuesResultConsumerSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency: number;
    /**
     * The maximum number of retries
     */
    maxRetries: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs: number;
}

export interface GetQueuesResultProducer {
    bucketName: string;
    script: string;
    type: string;
}

export interface GetQueuesResultSettings {
    /**
     * Number of seconds to delay delivery of all messages to consumers.
     */
    deliveryDelay: number;
    /**
     * Number of seconds after which an unconsumed message will be delayed.
     */
    messageRetentionPeriod: number;
}

<<<<<<< HEAD
=======
export interface GetR2BucketCorsRule {
    /**
     * Object specifying allowed origins, methods and headers for this CORS rule.
     */
    allowed: outputs.GetR2BucketCorsRuleAllowed;
    /**
     * Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
     */
    exposeHeaders: string[];
    /**
     * Identifier for this rule
     */
    id: string;
    /**
     * Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
     */
    maxAgeSeconds: number;
}

export interface GetR2BucketCorsRuleAllowed {
    /**
     * Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
     */
    headers: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
     */
    methods: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
     */
    origins: string[];
}

export interface GetR2BucketEventNotificationQueue {
    /**
     * Queue ID
     */
    queueId: string;
    /**
     * Name of the queue
     */
    queueName: string;
    rules: outputs.GetR2BucketEventNotificationQueueRule[];
}

export interface GetR2BucketEventNotificationQueueRule {
    /**
     * Array of R2 object actions that will trigger notifications
     */
    actions: string[];
    /**
     * Timestamp when the rule was created
     */
    createdAt: string;
    /**
     * A description that can be used to identify the event notification rule after creation
     */
    description: string;
    /**
     * Notifications will be sent only for objects with this prefix
     */
    prefix: string;
    /**
     * Rule ID
     */
    ruleId: string;
    /**
     * Notifications will be sent only for objects with this suffix
     */
    suffix: string;
}

export interface GetR2BucketLifecycleRule {
    /**
     * Transition to abort ongoing multipart uploads
     */
    abortMultipartUploadsTransition: outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransition;
    /**
     * Conditions that apply to all transitions of this rule
     */
    conditions: outputs.GetR2BucketLifecycleRuleConditions;
    /**
     * Transition to delete objects
     */
    deleteObjectsTransition: outputs.GetR2BucketLifecycleRuleDeleteObjectsTransition;
    /**
     * Whether or not this rule is in effect
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule
     */
    id: string;
    /**
     * Transitions to change the storage class of objects
     */
    storageClassTransitions: outputs.GetR2BucketLifecycleRuleStorageClassTransition[];
}

export interface GetR2BucketLifecycleRuleAbortMultipartUploadsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds
     */
    condition: outputs.GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition;
}

export interface GetR2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition {
    maxAge: number;
    type: string;
}

export interface GetR2BucketLifecycleRuleConditions {
    /**
     * Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
     */
    prefix: string;
}

export interface GetR2BucketLifecycleRuleDeleteObjectsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds
     */
    condition: outputs.GetR2BucketLifecycleRuleDeleteObjectsTransitionCondition;
}

export interface GetR2BucketLifecycleRuleDeleteObjectsTransitionCondition {
    date: string;
    maxAge: number;
    type: string;
}

export interface GetR2BucketLifecycleRuleStorageClassTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds
     */
    condition: outputs.GetR2BucketLifecycleRuleStorageClassTransitionCondition;
    storageClass: string;
}

export interface GetR2BucketLifecycleRuleStorageClassTransitionCondition {
    date: string;
    maxAge: number;
    type: string;
}

export interface GetR2BucketLockRule {
    /**
     * Condition to apply a lock rule to an object for how long in seconds
     */
    condition: outputs.GetR2BucketLockRuleCondition;
    /**
     * Whether or not this rule is in effect
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule
     */
    id: string;
    /**
     * Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
     */
    prefix: string;
}

export interface GetR2BucketLockRuleCondition {
    date: string;
    maxAgeSeconds: number;
    type: string;
}

export interface GetR2BucketSippyDestination {
    /**
     * ID of the Cloudflare API token used when writing objects to this
     * bucket
     */
    accessKeyId: string;
    account: string;
    /**
     * Name of the bucket on the provider
     */
    bucket: string;
    provider: string;
}

export interface GetR2BucketSippySource {
    /**
     * Name of the bucket on the provider
     */
    bucket: string;
    provider: string;
    /**
     * Region where the bucket resides (AWS only)
     */
    region: string;
}

export interface GetR2CustomDomainStatus {
    /**
     * Ownership status of the domain
     */
    ownership: string;
    /**
     * SSL certificate status
     */
    ssl: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetRateLimitAction {
    /**
     * The action to perform.
     */
    mode: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response: outputs.GetRateLimitActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout: number;
}

export interface GetRateLimitActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType: string;
}

export interface GetRateLimitBypass {
    name: string;
    /**
     * The URL to bypass.
     */
    value: string;
}

export interface GetRateLimitMatch {
    headers: outputs.GetRateLimitMatchHeader[];
    request: outputs.GetRateLimitMatchRequest;
    response: outputs.GetRateLimitMatchResponse;
}

export interface GetRateLimitMatchHeader {
    /**
     * The name of the response header to match.
     */
    name: string;
    /**
     * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
     */
    op: string;
    /**
     * The value of the response header, which must match exactly.
     */
    value: string;
}

export interface GetRateLimitMatchRequest {
    /**
     * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
     */
    methods: string[];
    /**
     * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
     */
    schemes: string[];
    /**
     * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
     */
    url: string;
}

export interface GetRateLimitMatchResponse {
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
     */
    originTraffic: boolean;
}

export interface GetRateLimitsResult {
    /**
     * The action to perform when the threshold of matched traffic within the configured period is exceeded.
     */
    action: outputs.GetRateLimitsResultAction;
    /**
     * Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
     */
    bypasses: outputs.GetRateLimitsResultBypass[];
    /**
     * An informative summary of the rate limit. This value is sanitized and any tags will be removed.
     */
    description: string;
    /**
     * When true, indicates that the rate limit is currently disabled.
     */
    disabled: boolean;
    /**
     * The unique identifier of the rate limit.
     */
    id: string;
    /**
     * Determines which traffic the rate limit counts towards the threshold.
     */
    match: outputs.GetRateLimitsResultMatch;
    /**
     * The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
     */
    period: number;
    /**
     * The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
     */
    threshold: number;
}

export interface GetRateLimitsResultAction {
    /**
     * The action to perform.
     */
    mode: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response: outputs.GetRateLimitsResultActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout: number;
}

export interface GetRateLimitsResultActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType: string;
}

export interface GetRateLimitsResultBypass {
    name: string;
    /**
     * The URL to bypass.
     */
    value: string;
}

export interface GetRateLimitsResultMatch {
    headers: outputs.GetRateLimitsResultMatchHeader[];
    request: outputs.GetRateLimitsResultMatchRequest;
    response: outputs.GetRateLimitsResultMatchResponse;
}

export interface GetRateLimitsResultMatchHeader {
    /**
     * The name of the response header to match.
     */
    name: string;
    /**
     * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
     */
    op: string;
    /**
     * The value of the response header, which must match exactly.
     */
    value: string;
}

export interface GetRateLimitsResultMatchRequest {
    /**
     * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
     */
    methods: string[];
    /**
     * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
     */
    schemes: string[];
    /**
     * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
     */
    url: string;
}

export interface GetRateLimitsResultMatchResponse {
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
     */
    originTraffic: boolean;
}

export interface GetRegionalHostnamesResult {
    /**
     * When the regional hostname was created
     */
    createdOn: string;
    /**
     * DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g `*.example.com`
     */
    hostname: string;
    /**
     * Identifying key for the region
     */
    regionKey: string;
}

export interface GetRegistrarDomainsResult {
    /**
     * Shows if a domain is available for transferring into Cloudflare Registrar.
     */
    available: boolean;
    /**
     * Indicates if the domain can be registered as a new domain.
     */
    canRegister: boolean;
    /**
     * Shows time of creation.
     */
    createdAt: string;
    /**
     * Shows name of current registrar.
     */
    currentRegistrar: string;
    /**
     * Shows when domain name registration expires.
     */
    expiresAt: string;
    /**
     * Domain identifier.
     */
    id: string;
    /**
     * Shows whether a registrar lock is in place for a domain.
     */
    locked: boolean;
    /**
     * Shows contact information for domain registrant.
     */
    registrantContact: outputs.GetRegistrarDomainsResultRegistrantContact;
    /**
     * A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en).
     */
    registryStatuses: string;
    /**
     * Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs.
     */
    supportedTld: boolean;
    /**
     * Statuses for domain transfers into Cloudflare Registrar.
     */
    transferIn: outputs.GetRegistrarDomainsResultTransferIn;
    /**
     * Last updated.
     */
    updatedAt: string;
}

export interface GetRegistrarDomainsResultRegistrantContact {
    /**
     * Address.
     */
    address: string;
    /**
     * Optional address line for unit, floor, suite, etc.
     */
    address2: string;
    /**
     * City.
     */
    city: string;
    /**
     * The country in which the user lives.
     */
    country: string;
    /**
     * The contact email address of the user.
     */
    email: string;
    /**
     * Contact fax number.
     */
    fax: string;
    /**
     * User's first name
     */
    firstName: string;
    /**
     * Contact Identifier.
     */
    id: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * Name of organization.
     */
    organization: string;
    /**
     * User's telephone number
     */
    phone: string;
    /**
     * State.
     */
    state: string;
    /**
     * The zipcode or postal code where the user lives.
     */
    zip: string;
}

export interface GetRegistrarDomainsResultTransferIn {
    /**
     * Form of authorization has been accepted by the registrant.
     */
    acceptFoa: string;
    /**
     * Shows transfer status with the registry.
     */
    approveTransfer: string;
    /**
     * Indicates if cancellation is still possible.
     */
    canCancelTransfer: boolean;
    /**
     * Privacy guards are disabled at the foreign registrar.
     */
    disablePrivacy: string;
    /**
     * Auth code has been entered and verified.
     */
    enterAuthCode: string;
    /**
     * Domain is unlocked at the foreign registrar.
     */
    unlockDomain: string;
}

export interface GetResourceGroupMeta {
    key: string;
    value: string;
}

export interface GetResourceGroupScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetResourceGroupScopeObject[];
}

export interface GetResourceGroupScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
}

export interface GetResourceGroupsResult {
<<<<<<< HEAD
=======
    /**
     * Identifier of the group.
     */
    id: string;
    /**
     * Attributes associated to the resource group.
     */
    meta: outputs.GetResourceGroupsResultMeta;
    /**
     * Name of the resource group.
     */
    name: string;
    /**
     * The scope associated to the resource group
     */
    scopes: outputs.GetResourceGroupsResultScope[];
}

export interface GetResourceGroupsResultMeta {
    key: string;
    value: string;
}

export interface GetResourceGroupsResultScope {
    /**
     * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
     */
    key: string;
    /**
     * A list of scope objects for additional context.
     */
    objects: outputs.GetResourceGroupsResultScopeObject[];
}

export interface GetResourceGroupsResultScopeObject {
    /**
     * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
     */
    key: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface GetRulesetRule {
    /**
     * The action to perform when the rule matches.
     */
    action: string;
    /**
     * The parameters configuring the rule's action.
     */
    actionParameters: outputs.GetRulesetRuleActionParameters;
    /**
     * The categories of the rule.
     */
    categories: string[];
    /**
     * An informative description of the rule.
     */
    description: string;
    /**
     * Whether the rule should be executed.
     */
    enabled: boolean;
    /**
     * Configure checks for exposed credentials.
     */
    exposedCredentialCheck: outputs.GetRulesetRuleExposedCredentialCheck;
    /**
     * The expression defining which traffic will match the rule.
     */
    expression: string;
    /**
     * The unique ID of the rule.
     */
    id: string;
    /**
     * An object configuring the rule's logging behavior.
     */
    logging: outputs.GetRulesetRuleLogging;
    /**
     * An object configuring the rule's ratelimit behavior.
     */
    ratelimit: outputs.GetRulesetRuleRatelimit;
    /**
     * The reference of the rule (the rule ID by default).
     */
    ref: string;
}

export interface GetRulesetRuleActionParameters {
    /**
     * List of additional ports that caching can be enabled on.
     */
    additionalCacheablePorts: number[];
    /**
     * Custom order for compression algorithms.
     */
    algorithms: outputs.GetRulesetRuleActionParametersAlgorithm[];
    /**
     * Turn on or off Automatic HTTPS Rewrites.
     */
    automaticHttpsRewrites: boolean;
    /**
     * Select which file extensions to minify automatically.
     */
    autominify: outputs.GetRulesetRuleActionParametersAutominify;
    /**
     * Turn on or off Browser Integrity Check.
     */
    bic: boolean;
    /**
     * Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
     */
    browserTtl: outputs.GetRulesetRuleActionParametersBrowserTtl;
    /**
     * Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
     */
    cache: boolean;
    /**
     * Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
     */
    cacheKey: outputs.GetRulesetRuleActionParametersCacheKey;
    /**
     * Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
     */
    cacheReserve: outputs.GetRulesetRuleActionParametersCacheReserve;
    /**
     * Error response content.
     */
    content: string;
    /**
     * Content-type header to set with the response.
     */
    contentType: string;
    /**
     * The cookie fields to log.
     */
    cookieFields: outputs.GetRulesetRuleActionParametersCookieField[];
    /**
     * Turn off all active Cloudflare Apps.
     */
    disableApps: boolean;
    /**
     * Turn off Real User Monitoring (RUM).
     */
    disableRum: boolean;
    /**
     * Turn off Zaraz.
     */
    disableZaraz: boolean;
    /**
     * TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
     */
    edgeTtl: outputs.GetRulesetRuleActionParametersEdgeTtl;
    /**
     * Turn on or off Email Obfuscation.
     */
    emailObfuscation: boolean;
    /**
     * Turn on or off Cloudflare Fonts.
     */
    fonts: boolean;
    /**
     * Serve a redirect based on a bulk list lookup.
     */
    fromList: outputs.GetRulesetRuleActionParametersFromList;
    /**
     * Serve a redirect based on the request properties.
     */
    fromValue: outputs.GetRulesetRuleActionParametersFromValue;
    /**
     * Map of request headers to modify.
     */
    headers: {[key: string]: outputs.GetRulesetRuleActionParametersHeaders};
    /**
     * Rewrite the HTTP Host header.
     */
    hostHeader: string;
    /**
     * Turn on or off the Hotlink Protection.
     */
    hotlinkProtection: boolean;
    /**
     * The ID of the ruleset to execute.
     */
    id: string;
    /**
     * Increment contains the delta to change the score and can be either positive or negative.
     */
    increment: number;
    /**
     * The configuration to use for matched data logging.
     */
    matchedData: outputs.GetRulesetRuleActionParametersMatchedData;
    /**
     * Turn on or off Mirage.
     */
    mirage: boolean;
    /**
     * Turn on or off Opportunistic Encryption.
     */
    opportunisticEncryption: boolean;
    /**
     * Override the IP/TCP destination.
     */
    origin: outputs.GetRulesetRuleActionParametersOrigin;
    /**
     * When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
     */
    originCacheControl: boolean;
    /**
     * Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
     */
    originErrorPagePassthru: boolean;
    /**
     * A set of overrides to apply to the target ruleset.
     */
    overrides: outputs.GetRulesetRuleActionParametersOverrides;
    /**
     * A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
     */
    phases: string[];
    /**
     * Configure the Polish level.
     */
    polish: string;
    /**
     * A list of legacy security products to skip the execution of.
     */
    products: string[];
    /**
     * Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
     */
    readTimeout: number;
    /**
     * The request fields to log.
     */
    requestFields: outputs.GetRulesetRuleActionParametersRequestField[];
    /**
     * Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
     */
    respectStrongEtags: boolean;
    /**
     * The response to show when the block is applied.
     */
    response: outputs.GetRulesetRuleActionParametersResponse;
    /**
     * The response fields to log.
     */
    responseFields: outputs.GetRulesetRuleActionParametersResponseField[];
    /**
     * Turn on or off Rocket Loader
     */
    rocketLoader: boolean;
    /**
     * A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
     */
    rules: {[key: string]: string[]};
    /**
     * A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
     */
    ruleset: string;
    /**
     * A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
     */
    rulesets: string[];
    /**
     * Configure the Security Level.
     */
    securityLevel: string;
    /**
     * Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
     */
    serveStale: outputs.GetRulesetRuleActionParametersServeStale;
    /**
     * Turn on or off Server Side Excludes.
     */
    serverSideExcludes: boolean;
    /**
     * Override the Server Name Indication (SNI).
     */
    sni: outputs.GetRulesetRuleActionParametersSni;
    /**
     * Configure the SSL level.
     */
    ssl: string;
    /**
     * The status code to use for the error.
     */
    statusCode: number;
    /**
     * Turn on or off Signed Exchanges (SXG).
     */
    sxg: boolean;
    /**
     * URI to rewrite the request to.
     */
    uri: outputs.GetRulesetRuleActionParametersUri;
}

export interface GetRulesetRuleActionParametersAlgorithm {
    /**
     * Name of compression algorithm to enable.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersAutominify {
    /**
     * Minify CSS files.
     */
    css: boolean;
    /**
     * Minify HTML files.
     */
    html: boolean;
    /**
     * Minify JS files.
     */
    js: boolean;
}

export interface GetRulesetRuleActionParametersBrowserTtl {
    /**
     * The TTL (in seconds) if you choose overrideOrigin mode.
     */
    default: number;
    /**
     * Determines which browser ttl mode to use.
     */
    mode: string;
}

export interface GetRulesetRuleActionParametersCacheKey {
    /**
     * Separate cached content based on the visitor’s device type
     */
    cacheByDeviceType: boolean;
    /**
     * Protect from web cache deception attacks while allowing static assets to be cached
     */
    cacheDeceptionArmor: boolean;
    /**
     * Customize which components of the request are included or excluded from the cache key.
     */
    customKey: outputs.GetRulesetRuleActionParametersCacheKeyCustomKey;
    /**
     * Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
     */
    ignoreQueryStringsOrder: boolean;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * The cookies to include in building the cache key.
     */
    cookie: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyCookie;
    /**
     * The header names and values to include in building the cache key.
     */
    header: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHeader;
    /**
     * Whether to use the original host or the resolved host in the cache key.
     */
    host: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyHost;
    /**
     * Use the presence of parameters in the query string to build the cache key.
     */
    queryString: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    /**
     * Characteristics of the request user agent used in building the cache key.
     */
    user: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
     */
    checkPresences: string[];
    /**
     * Include these cookies' names and their values.
     */
    includes: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * Checks for the presence of these header names. The presence of these headers is used in building the cache key.
     */
    checkPresences: string[];
    /**
     * For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
     */
    contains: {[key: string]: string[]};
    /**
     * Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
     */
    excludeOrigin: boolean;
    /**
     * Include these headers' names and their values.
     */
    includes: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
     */
    resolved: boolean;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
     */
    exclude: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude;
    /**
     * A list of query string parameters used to build the cache key.
     */
    include: outputs.GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude;
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude {
    /**
     * Determines whether to exclude all query string parameters from the cache key.
     */
    all: boolean;
    lists: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude {
    /**
     * Determines whether to include all query string parameters in the cache key.
     */
    all: boolean;
    lists: string[];
}

export interface GetRulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Use the user agent's device type in the cache key.
     */
    deviceType: boolean;
    /**
     * Use the user agents's country in the cache key.
     */
    geo: boolean;
    /**
     * Use the user agent's language in the cache key.
     */
    lang: boolean;
}

export interface GetRulesetRuleActionParametersCacheReserve {
    /**
     * Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
     */
    eligible: boolean;
    /**
     * The minimum file size eligible for store in cache reserve.
     */
    minimumFileSize: number;
}

export interface GetRulesetRuleActionParametersCookieField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersEdgeTtl {
    /**
     * The TTL (in seconds) if you choose overrideOrigin mode.
     */
    default: number;
    /**
     * edge ttl options
     */
    mode: string;
    /**
     * List of single status codes, or status code ranges to apply the selected mode
     */
    statusCodeTtls: outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface GetRulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * The range of status codes used to apply the selected mode.
     */
    statusCodeRange: outputs.GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange;
    /**
     * Set the ttl for responses with this specific status code
     */
    statusCodeValue: number;
    /**
     * Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
     */
    value: number;
}

export interface GetRulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * response status code lower bound
     */
    from: number;
    /**
     * response status code upper bound
     */
    to: number;
}

export interface GetRulesetRuleActionParametersFromList {
    /**
     * Expression that evaluates to the list lookup key.
     */
    key: string;
    /**
     * The name of the list to match against.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersFromValue {
    /**
     * Keep the query string of the original request.
     */
    preserveQueryString: boolean;
    /**
     * The status code to be used for the redirect.
     */
    statusCode: number;
    /**
     * The URL to redirect the request to.
     */
    targetUrl: outputs.GetRulesetRuleActionParametersFromValueTargetUrl;
}

export interface GetRulesetRuleActionParametersFromValueTargetUrl {
    /**
     * An expression to evaluate to get the URL to redirect the request to.
     */
    expression: string;
    /**
     * The URL to redirect the request to.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersHeaders {
    /**
     * Expression for the header value.
     */
    expression: string;
    operation: string;
    /**
     * Static value for the header.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersMatchedData {
    /**
     * The public key to encrypt matched data logs with.
     */
    publicKey: string;
}

export interface GetRulesetRuleActionParametersOrigin {
    /**
     * Override the resolved hostname.
     */
    host: string;
    /**
     * Override the destination port.
     */
    port: number;
}

export interface GetRulesetRuleActionParametersOverrides {
    /**
     * An action to override all rules with. This option has lower precedence than rule and category overrides.
     */
    action: string;
    /**
     * A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
     */
    categories: outputs.GetRulesetRuleActionParametersOverridesCategory[];
    /**
     * Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
     */
    enabled: boolean;
    /**
     * A list of rule-level overrides. This option has the highest precedence.
     */
    rules: outputs.GetRulesetRuleActionParametersOverridesRule[];
    /**
     * A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
     */
    sensitivityLevel: string;
}

export interface GetRulesetRuleActionParametersOverridesCategory {
    /**
     * The action to override rules in the category with.
     */
    action: string;
    /**
     * The name of the category to override.
     */
    category: string;
    /**
     * Whether to enable execution of rules in the category.
     */
    enabled: boolean;
    /**
     * The sensitivity level to use for rules in the category.
     */
    sensitivityLevel: string;
}

export interface GetRulesetRuleActionParametersOverridesRule {
    /**
     * The action to override the rule with.
     */
    action: string;
    /**
     * Whether to enable execution of the rule.
     */
    enabled: boolean;
    /**
     * The ID of the rule to override.
     */
    id: string;
    /**
     * The score threshold to use for the rule.
     */
    scoreThreshold: number;
    /**
     * The sensitivity level to use for the rule.
     */
    sensitivityLevel: string;
}

export interface GetRulesetRuleActionParametersRequestField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersResponse {
    /**
     * The content to return.
     */
    content: string;
    /**
     * The type of the content to return.
     */
    contentType: string;
    /**
     * The status code to return.
     */
    statusCode: number;
}

export interface GetRulesetRuleActionParametersResponseField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface GetRulesetRuleActionParametersServeStale {
    /**
     * Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
     */
    disableStaleWhileUpdating: boolean;
}

export interface GetRulesetRuleActionParametersSni {
    /**
     * The SNI override.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersUri {
    /**
     * Path portion rewrite.
     */
    path: outputs.GetRulesetRuleActionParametersUriPath;
    /**
     * Query portion rewrite.
     */
    query: outputs.GetRulesetRuleActionParametersUriQuery;
}

export interface GetRulesetRuleActionParametersUriPath {
    /**
     * Expression to evaluate for the replacement value.
     */
    expression: string;
    /**
     * Predefined replacement value.
     */
    value: string;
}

export interface GetRulesetRuleActionParametersUriQuery {
    /**
     * Expression to evaluate for the replacement value.
     */
    expression: string;
    /**
     * Predefined replacement value.
     */
    value: string;
}

export interface GetRulesetRuleExposedCredentialCheck {
    /**
     * Expression that selects the password used in the credentials check.
     */
    passwordExpression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     */
    usernameExpression: string;
}

export interface GetRulesetRuleLogging {
    /**
     * Whether to generate a log when the rule matches.
     */
    enabled: boolean;
}

export interface GetRulesetRuleRatelimit {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     */
    countingExpression: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     */
    mitigationTimeout: number;
    /**
     * Period in seconds over which the counter is being incremented.
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     */
    requestsPerPeriod: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     */
    requestsToOrigin: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     */
    scorePerPeriod: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     */
    scoreResponseHeaderName: string;
}

export interface GetRulesetsResult {
    /**
     * An informative description of the ruleset.
     */
    description: string;
    /**
     * The unique ID of the ruleset.
     */
    id: string;
    /**
     * The kind of the ruleset.
     */
    kind: string;
    /**
     * The human-readable name of the ruleset.
     */
    name: string;
    /**
     * The phase of the ruleset.
     */
    phase: string;
}

export interface GetSnippetRulesListResult {
    description: string;
    enabled: boolean;
    expression: string;
    /**
     * Snippet identifying name
     */
    snippetName: string;
}

export interface GetSnippetsListResult {
    /**
     * Creation time of the snippet
     */
    createdOn: string;
    /**
     * Modification time of the snippet
     */
    modifiedOn: string;
    /**
     * Snippet identifying name
     */
    snippetName: string;
}

export interface GetSpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name: string;
    /**
     * The type of DNS record associated with the application.
     */
    type: string;
}

export interface GetSpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs.
     */
    connectivity: string;
    /**
     * The array of customer owned IPs we broadcast via anycast for this hostname and application.
     */
    ips: string[];
    /**
     * The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
     */
    type: string;
}

export interface GetSpectrumApplicationOriginDns {
    /**
     * The name of the DNS record associated with the origin.
     */
    name: string;
    /**
     * The TTL of our resolution of your DNS record in seconds.
     */
    ttl: number;
    /**
     * The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
     */
    type: string;
}

export interface GetSpectrumApplicationsResult {
}

export interface GetStreamInput {
    /**
     * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
     */
    height: number;
    /**
     * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
     */
    width: number;
}

export interface GetStreamLiveInputRecording {
    /**
     * Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
     */
    allowedOrigins: string[];
    /**
     * Disables reporting the number of live viewers when this property is set to `true`.
     */
    hideLiveViewerCount: boolean;
    /**
     * Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
     */
    mode: string;
    /**
     * Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
     */
    requireSignedUrls: boolean;
    /**
     * Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
     */
    timeoutSeconds: number;
}

export interface GetStreamLiveInputRtmps {
    /**
     * The secret key to use when streaming via RTMPS to a live input.
     */
    streamKey: string;
    /**
     * The RTMPS URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface GetStreamLiveInputRtmpsPlayback {
    /**
     * The secret key to use for playback via RTMPS.
     */
    streamKey: string;
    /**
     * The URL used to play live video over RTMPS.
     */
    url: string;
}

export interface GetStreamLiveInputSrt {
    /**
     * The secret key to use when streaming via SRT to a live input.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use when streaming via SRT.
     */
    streamId: string;
    /**
     * The SRT URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface GetStreamLiveInputSrtPlayback {
    /**
     * The secret key to use for playback via SRT.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use for playback via SRT.
     */
    streamId: string;
    /**
     * The URL used to play live video over SRT.
     */
    url: string;
}

export interface GetStreamLiveInputWebRtc {
    /**
     * The WebRTC URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface GetStreamLiveInputWebRtcPlayback {
    /**
     * The URL used to play live video over WebRTC.
     */
    url: string;
}

export interface GetStreamPlayback {
    /**
     * DASH Media Presentation Description for the video.
     */
    dash: string;
    /**
     * The HLS manifest for the video.
     */
    hls: string;
}

export interface GetStreamStatus {
    /**
     * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
     */
    errorReasonCode: string;
    /**
     * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
     */
    errorReasonText: string;
    /**
     * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
     */
    pctComplete: string;
    /**
     * Specifies the processing status for all quality levels for a video.
     */
    state: string;
}

export interface GetStreamWatermark {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface GetStreamWatermarksResult {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface GetStreamsResult {
    /**
     * Lists the origins allowed to display the video. Enter allowed origin domains in an array and use `*` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin.
     */
    allowedOrigins: string[];
    /**
     * The date and time the media item was created.
     */
    created: string;
    /**
     * A user-defined identifier for the media creator.
     */
    creator: string;
    /**
     * The duration of the video in seconds. A value of `-1` means the duration is unknown. The duration becomes available after the upload and before the video is ready.
     */
    duration: number;
    input: outputs.GetStreamsResultInput;
    /**
     * The live input ID used to upload a video with Stream Live.
     */
    liveInput: string;
    /**
     * The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of `-1` means the value is unknown.
     */
    maxDurationSeconds: number;
    /**
     * A user modifiable key-value store used to reference other systems of record for managing videos.
     */
    meta: string;
    /**
     * The date and time the media item was last modified.
     */
    modified: string;
    playback: outputs.GetStreamsResultPlayback;
    /**
     * The video's preview page URI. This field is omitted until encoding is complete.
     */
    preview: string;
    /**
     * Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
     */
    readyToStream: boolean;
    /**
     * Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
     */
    readyToStreamAt: string;
    /**
     * Indicates whether the video can be a accessed using the UID. When set to `true`, a signed token must be generated with a signing key to view the video.
     */
    requireSignedUrls: boolean;
    /**
     * Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a `null` value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time.
     */
    scheduledDeletion: string;
    /**
     * The size of the media item in bytes.
     */
    size: number;
    /**
     * Specifies a detailed status for a video. If the `state` is `inprogress` or `error`, the `step` field returns `encoding` or `manifest`. If the `state` is `inprogress`, `pctComplete` returns a number between 0 and 100 to indicate the approximate percent of completion. If the `state` is `error`, `errorReasonCode` and `errorReasonText` provide additional details.
     */
    status: outputs.GetStreamsResultStatus;
    /**
     * The media item's thumbnail URI. This field is omitted until encoding is complete.
     */
    thumbnail: string;
    /**
     * The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video.
     */
    thumbnailTimestampPct: number;
    /**
     * A Cloudflare-generated unique identifier for a media item.
     */
    uid: string;
    /**
     * The date and time when the video upload URL is no longer valid for direct user uploads.
     */
    uploadExpiry: string;
    /**
     * The date and time the media item was uploaded.
     */
    uploaded: string;
    watermark: outputs.GetStreamsResultWatermark;
}

export interface GetStreamsResultInput {
    /**
     * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
     */
    height: number;
    /**
     * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
     */
    width: number;
}

export interface GetStreamsResultPlayback {
    /**
     * DASH Media Presentation Description for the video.
     */
    dash: string;
    /**
     * The HLS manifest for the video.
     */
    hls: string;
}

export interface GetStreamsResultStatus {
    /**
     * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
     */
    errorReasonCode: string;
    /**
     * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
     */
    errorReasonText: string;
    /**
     * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
     */
    pctComplete: string;
    /**
     * Specifies the processing status for all quality levels for a video.
     */
    state: string;
}

export interface GetStreamsResultWatermark {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface GetTurnstileWidgetFilter {
    /**
     * Direction to order widgets.
     */
    direction?: string;
    /**
     * Field to order widgets by.
     */
    order?: string;
}

export interface GetTurnstileWidgetsResult {
    /**
     * If bot*fight*mode is set to `true`, Cloudflare issues computationally
     * expensive challenges in response to malicious bots (ENT only).
     */
    botFightMode: boolean;
    /**
     * If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
     * this setting can determine the clearance level to be set
     */
    clearanceLevel: string;
    /**
     * When the widget was created.
     */
    createdOn: string;
    domains: string[];
    /**
     * Return the Ephemeral ID in /siteverify (ENT only).
     */
    ephemeralId: boolean;
    /**
     * Widget Mode
     */
    mode: string;
    /**
     * When the widget was modified.
     */
    modifiedOn: string;
    /**
     * Human readable widget name. Not unique. Cloudflare suggests that you
     * set this to a meaningful string to make it easier to identify your
     * widget, and where it is used.
     */
    name: string;
    /**
     * Do not show any Cloudflare branding on the widget (ENT only).
     */
    offlabel: boolean;
    /**
     * Region where this widget can be used.
     */
    region: string;
    /**
     * Widget item identifier tag.
     */
    sitekey: string;
}

export interface GetUserAgentBlockingRulesResult {
    /**
     * The configuration object for the current rule.
     */
    configuration: outputs.GetUserAgentBlockingRulesResultConfiguration;
    /**
     * An informative summary of the rule.
     */
    description: string;
    /**
     * The unique identifier of the User Agent Blocking rule.
     */
    id: string;
    /**
     * The action to apply to a matched request.
     */
    mode: string;
    /**
     * When true, indicates that the rule is currently paused.
     */
    paused: boolean;
}

export interface GetUserAgentBlockingRulesResultConfiguration {
    /**
     * The configuration target for this rule. You must set the target to `ua` for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received `User-Agent` HTTP header value.
     */
    value: string;
}

export interface GetWaitingRoomAdditionalRoute {
    /**
     * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
     */
    host: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
}

export interface GetWaitingRoomCookieAttributes {
    /**
     * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
     */
    samesite: string;
    /**
     * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
     */
    secure: string;
}

export interface GetWaitingRoomEventsResult {
    createdOn: string;
    /**
     * If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
     */
    customPageHtml: string;
    /**
     * A note that you can use to add more details about the event.
     */
    description: string;
    /**
     * If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
     */
    disableSessionRenewal: boolean;
    /**
     * An ISO 8601 timestamp that marks the end of the event.
     */
    eventEndTime: string;
    /**
     * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
     */
    eventStartTime: string;
    id: string;
    modifiedOn: string;
    /**
     * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: string;
    /**
     * If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
     */
    newUsersPerMinute: number;
    /**
     * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
     */
    prequeueStartTime: string;
    /**
     * If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
     */
    queueingMethod: string;
    /**
     * If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
     */
    sessionDuration: number;
    /**
     * If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     */
    shuffleAtEventStart: boolean;
    /**
     * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     */
    suspended: boolean;
    /**
     * If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
     */
    totalActiveUsers: number;
}

export interface GetWaitingRoomsResult {
    /**
     * Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms.
     */
    additionalRoutes: outputs.GetWaitingRoomsResultAdditionalRoute[];
    /**
     * Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position.
     */
    cookieAttributes: outputs.GetWaitingRoomsResultCookieAttributes;
    /**
     * Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(_*cf*waitingroom). If `cookieSuffix` is "abcd", the cookie name will be `__cf_waitingroom_abcd`. This field is required if using `additionalRoutes`.
     */
    cookieSuffix: string;
    createdOn: string;
    /**
     * Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom*page*html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:
     */
    customPageHtml: string;
    /**
     * The language of the default page template. If no defaultTemplateLanguage is provided, then `en-US` (English) will be used.
     */
    defaultTemplateLanguage: string;
    /**
     * A note that you can use to add more details about the waiting room.
     */
    description: string;
    /**
     * Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If `true`, an accepted user will have sessionDuration minutes to browse the site. After that, they will have to go through the waiting room again. If `false`, a user's session cookie will be automatically renewed on every request.
     */
    disableSessionRenewal: boolean;
    /**
     * A list of enabled origin commands.
     */
    enabledOriginCommands: string[];
    /**
     * The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique.
     */
    host: string;
    id: string;
    /**
     * Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:
     * 1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).
     * 2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.
     * 3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.
     * 4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).
     * 5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.
     * 6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).
     * 7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.
     * 8. `queueIsFull`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
     * 9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.
     * 10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.
     * 11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time — it will always be **zero**.
     * 12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.
     * 13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.
     * 14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.
     * 15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.
     * 16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.
     * 17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties `prequeueStartTime`, `eventStartTime`, and `eventEndTime` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.
     * 18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.
     * 19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.
     * 20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.
     * 21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.
     * 22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.
     * 23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.
     *
     * An example cURL to a waiting room could be:
     *
     * 	curl -X GET "https://example.com/waitingroom" \
     * 		-H "Accept: application/json"
     *
     * If `jsonResponseEnabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:
     *
     * 	{
     * 		"cfWaitingRoom": {
     * 			"inWaitingRoom": true,
     * 			"waitTimeKnown": true,
     * 			"waitTime": 10,
     * 			"waitTime25Percentile": 0,
     * 			"waitTime50Percentile": 0,
     * 			"waitTime75Percentile": 0,
     * 			"waitTimeFormatted": "10 minutes",
     * 			"queueIsFull": false,
     * 			"queueAll": false,
     * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
     * 			"refreshIntervalSeconds": 20,
     * 			"queueingMethod": "fifo",
     * 			"isFIFOQueue": true,
     * 			"isRandomQueue": false,
     * 			"isPassthroughQueue": false,
     * 			"isRejectQueue": false,
     * 			"isEventActive": false,
     * 			"isEventPrequeueing": false,
     * 			"timeUntilEventStart": 0,
     * 			"timeUntilEventStartFormatted": "unavailable",
     * 			"timeUntilEventEnd": 0,
     * 			"timeUntilEventEndFormatted": "unavailable",
     * 			"shuffleAtEventStart": false
     * 		}
     * 	}
     *
     * If `jsonResponseEnabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:
     *
     * 	{
     * 		"cfWaitingRoom": {
     * 			"inWaitingRoom": true,
     * 			"waitTimeKnown": true,
     * 			"waitTime": 10,
     * 			"waitTime25Percentile": 5,
     * 			"waitTime50Percentile": 10,
     * 			"waitTime75Percentile": 15,
     * 			"waitTimeFormatted": "5 minutes to 15 minutes",
     * 			"queueIsFull": false,
     * 			"queueAll": false,
     * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
     * 			"refreshIntervalSeconds": 20,
     * 			"queueingMethod": "random",
     * 			"isFIFOQueue": false,
     * 			"isRandomQueue": true,
     * 			"isPassthroughQueue": false,
     * 			"isRejectQueue": false,
     * 			"isEventActive": true,
     * 			"isEventPrequeueing": false,
     * 			"timeUntilEventStart": 0,
     * 			"timeUntilEventStartFormatted": "unavailable",
     * 			"timeUntilEventEnd": 15,
     * 			"timeUntilEventEndFormatted": "15 minutes",
     * 			"shuffleAtEventStart": true
     * 		}
     * 	}.
     */
    jsonResponseEnabled: boolean;
    modifiedOn: string;
    /**
     * A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: string;
    /**
     * Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world.
     */
    newUsersPerMinute: number;
    /**
     * An ISO 8601 timestamp that marks when the next event will begin queueing.
     */
    nextEventPrequeueStartTime: string;
    /**
     * An ISO 8601 timestamp that marks when the next event will start.
     */
    nextEventStartTime: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
    /**
     * If queueAll is `true`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable.
     */
    queueAll: boolean;
    /**
     * Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if `queueAll` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:
     * 1. `fifo` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.
     * 2. `random`: Random queue where customers gain access randomly, regardless of arrival time.
     * 3. `passthrough`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with `suspended`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.
     * 4. `reject`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses `reject`, and its events override this with `fifo`, `random`, or `passthrough`. When this queueing method is enabled and neither `queueAll` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**.
     */
    queueingMethod: string;
    /**
     * HTTP status code returned to a user while in the queue.
     */
    queueingStatusCode: number;
    /**
     * Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route.
     */
    sessionDuration: number;
    /**
     * Suspends or allows traffic going to the waiting room. If set to `true`, the traffic will not go to the waiting room.
     */
    suspended: boolean;
    /**
     * Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world.
     */
    totalActiveUsers: number;
    /**
     * Which action to take when a bot is detected using Turnstile. `log` will
     * have no impact on queueing behavior, simply keeping track of how many
     * bots are detected in Waiting Room Analytics. `infiniteQueue` will send
     * bots to a false queueing state, where they will never reach your
     * origin. `infiniteQueue` requires Advanced Waiting Room.
     */
    turnstileAction: string;
    /**
     * Which Turnstile widget type to use for detecting bot traffic. See
     * [the Turnstile documentation](https://developers.cloudflare.com/turnstile/concepts/widget/#widget-types)
     * for the definitions of these widget types. Set to `off` to disable the
     * Turnstile integration entirely. Setting this to anything other than
     * `off` or `invisible` requires Advanced Waiting Room.
     */
    turnstileMode: string;
}

export interface GetWaitingRoomsResultAdditionalRoute {
    /**
     * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
     */
    host: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
}

export interface GetWaitingRoomsResultCookieAttributes {
    /**
     * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
     */
    samesite: string;
    /**
     * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
     */
    secure: string;
}

export interface GetWeb3HostnamesResult {
    createdOn: string;
    /**
     * An optional description of the hostname.
     */
    description: string;
    /**
     * DNSLink value used if the target is ipfs.
     */
    dnslink: string;
    /**
     * Identifier
     */
    id: string;
    modifiedOn: string;
    /**
     * The hostname that will point to the target gateway via CNAME.
     */
    name: string;
    /**
     * Status of the hostname's activation.
     */
    status: string;
    /**
     * Target gateway of the hostname.
     */
    target: string;
}

export interface GetWebAnalyticsSiteFilter {
    /**
     * The property used to sort the list of results.
     */
    orderBy?: string;
}

export interface GetWebAnalyticsSiteRule {
    created: string;
    /**
     * The hostname the rule will be applied to.
     */
    host: string;
    /**
     * The Web Analytics rule identifier.
     */
    id: string;
    /**
     * Whether the rule includes or excludes traffic from being measured.
     */
    inclusive: boolean;
    /**
     * Whether the rule is paused or not.
     */
    isPaused: boolean;
    /**
     * The paths the rule will be applied to.
     */
    paths: string[];
    priority: number;
}

export interface GetWebAnalyticsSiteRuleset {
    /**
     * Whether the ruleset is enabled.
     */
    enabled: boolean;
    /**
     * The Web Analytics ruleset identifier.
     */
    id: string;
    zoneName: string;
    /**
     * The zone identifier.
     */
    zoneTag: string;
}

export interface GetWebAnalyticsSitesResult {
    /**
     * If enabled, the JavaScript snippet is automatically injected for orange-clouded sites.
     */
    autoInstall: boolean;
    created: string;
    /**
     * A list of rules.
     */
    rules: outputs.GetWebAnalyticsSitesResultRule[];
    ruleset: outputs.GetWebAnalyticsSitesResultRuleset;
    /**
     * The Web Analytics site identifier.
     */
    siteTag: string;
    /**
     * The Web Analytics site token.
     */
    siteToken: string;
    /**
     * Encoded JavaScript snippet.
     */
    snippet: string;
}

export interface GetWebAnalyticsSitesResultRule {
    created: string;
    /**
     * The hostname the rule will be applied to.
     */
    host: string;
    /**
     * The Web Analytics rule identifier.
     */
    id: string;
    /**
     * Whether the rule includes or excludes traffic from being measured.
     */
    inclusive: boolean;
    /**
     * Whether the rule is paused or not.
     */
    isPaused: boolean;
    /**
     * The paths the rule will be applied to.
     */
    paths: string[];
    priority: number;
}

export interface GetWebAnalyticsSitesResultRuleset {
    /**
     * Whether the ruleset is enabled.
     */
    enabled: boolean;
    /**
     * The Web Analytics ruleset identifier.
     */
    id: string;
    zoneName: string;
    /**
     * The zone identifier.
     */
    zoneTag: string;
}

export interface GetWorkersCronTriggerSchedule {
    createdOn: string;
    cron: string;
    modifiedOn: string;
}

export interface GetWorkersCustomDomainFilter {
    /**
     * Worker environment associated with the zone and hostname.
     */
    environment?: string;
    /**
     * Hostname of the Worker Domain.
     */
    hostname?: string;
    /**
     * Worker service associated with the zone and hostname.
     */
    service?: string;
    /**
     * Identifier of the zone.
     */
    zoneId?: string;
    /**
     * Name of the zone.
     */
    zoneName?: string;
}

export interface GetWorkersCustomDomainsResult {
    /**
     * Worker environment associated with the zone and hostname.
     */
    environment: string;
    /**
     * Hostname of the Worker Domain.
     */
    hostname: string;
    /**
     * Identifer of the Worker Domain.
     */
    id: string;
    /**
     * Worker service associated with the zone and hostname.
     */
    service: string;
    /**
     * Identifier of the zone.
     */
    zoneId: string;
    /**
     * Name of the zone.
     */
    zoneName: string;
}

export interface GetWorkersDeploymentDeployment {
    annotations: outputs.GetWorkersDeploymentDeploymentAnnotations;
    authorEmail: string;
    createdOn: string;
    id: string;
    source: string;
    strategy: string;
    versions: outputs.GetWorkersDeploymentDeploymentVersion[];
}

export interface GetWorkersDeploymentDeploymentAnnotations {
    /**
     * Human-readable message about the deployment. Truncated to 100 bytes.
     */
    workersMessage: string;
}

export interface GetWorkersDeploymentDeploymentVersion {
    percentage: number;
    versionId: string;
}

export interface GetWorkersForPlatformsDispatchNamespacesResult {
    /**
     * Identifier
     */
    createdBy: string;
    /**
     * When the script was created.
     */
    createdOn: string;
    /**
     * Identifier
     */
    modifiedBy: string;
    /**
     * When the script was last modified.
     */
    modifiedOn: string;
    /**
     * API Resource UUID tag.
     */
    namespaceId: string;
    /**
     * Name of the Workers for Platforms dispatch namespace.
     */
    namespaceName: string;
    /**
     * The current number of scripts in this Dispatch Namespace
     */
    scriptCount: number;
}

export interface GetWorkersKvNamespaceFilter {
    /**
     * Direction to order namespaces.
     */
    direction?: string;
    /**
     * Field to order results by.
     */
    order?: string;
}

export interface GetWorkersKvNamespacesResult {
    /**
     * Namespace identifier tag.
     */
    id: string;
    /**
     * True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?".
     */
    supportsUrlEncoding: boolean;
    /**
     * A human-readable string name for a Namespace.
     */
    title: string;
}

<<<<<<< HEAD
=======
export interface GetWorkersRoutesResult {
    /**
     * Identifier
     */
    id: string;
    pattern: string;
    /**
     * Name of the script, used in URLs and route configuration.
     */
    script: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetWorkersScriptsResult {
    /**
     * When the script was created.
     */
    createdOn: string;
    /**
     * Hashed script content, can be used in a If-None-Match header when updating.
     */
    etag: string;
    /**
     * Whether a Worker contains assets.
     */
    hasAssets: boolean;
    /**
     * Whether a Worker contains modules.
     */
    hasModules: boolean;
    /**
     * The id of the script in the Workers system. Usually the script name.
     */
    id: string;
    /**
     * Whether Logpush is turned on for the Worker.
     */
    logpush: boolean;
    /**
     * When the script was last modified.
     */
    modifiedOn: string;
    /**
     * Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    placement: outputs.GetWorkersScriptsResultPlacement;
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    placementMode: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    placementStatus: string;
    /**
     * List of Workers that will consume logs from the attached Worker.
     */
    tailConsumers: outputs.GetWorkersScriptsResultTailConsumer[];
    /**
     * Usage model for the Worker invocations.
     */
    usageModel: string;
}

export interface GetWorkersScriptsResultPlacement {
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    mode: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    status: string;
}

export interface GetWorkersScriptsResultTailConsumer {
    /**
     * Optional environment if the Worker utilizes one.
     */
    environment: string;
    /**
     * Optional dispatch namespace the script belongs to.
     */
    namespace: string;
    /**
     * Name of Worker that is to be the consumer.
     */
    service: string;
}

export interface GetWorkersSecretsResult {
    /**
     * The name of this secret, this is what will be used to access it inside the Worker.
     */
    name: string;
    /**
     * The type of secret.
     */
    type: string;
}

export interface GetZeroTrustAccessApplicationCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge: number;
}

export interface GetZeroTrustAccessApplicationDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     */
    l4Protocol: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange: string;
    type: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId: string;
}

export interface GetZeroTrustAccessApplicationFilter {
    /**
     * The aud of the app.
     */
    aud?: string;
    /**
     * The domain of the app.
     */
    domain?: string;
    /**
     * The name of the app.
     */
    name?: string;
    /**
     * Search for apps by other listed query parameters.
     */
    search?: string;
}

export interface GetZeroTrustAccessApplicationFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface GetZeroTrustAccessApplicationLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl: string;
    /**
     * The message shown on the landing page.
     */
    message: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface GetZeroTrustAccessApplicationPolicy {
    /**
     * Administrators who can approve a temporary authentication request.
     */
    approvalGroups: outputs.GetZeroTrustAccessApplicationPolicyApprovalGroup[];
    /**
     * Requires the user to request access from an administrator at the start of each session.
     */
    approvalRequired: boolean;
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules: outputs.GetZeroTrustAccessApplicationPolicyConnectionRules;
    createdAt: string;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     */
    decision: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessApplicationPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessApplicationPolicyInclude[];
    /**
     * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
     */
    isolationRequired: boolean;
    /**
     * The name of the Access policy.
     */
    name: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence: number;
    /**
     * A custom message that will appear on the purpose justification screen.
     */
    purposeJustificationPrompt: string;
    /**
     * Require users to enter a justification when they log in to the application.
     */
    purposeJustificationRequired: boolean;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessApplicationPolicyRequire[];
    /**
     * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessApplicationPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh: outputs.GetZeroTrustAccessApplicationPolicyConnectionRulesSsh;
}

export interface GetZeroTrustAccessApplicationPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface GetZeroTrustAccessApplicationPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationPolicyExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationPolicyExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationPolicyExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationPolicyExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationPolicyExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationPolicyExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationPolicyExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationPolicyExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationPolicyExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationPolicyExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationPolicyExcludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationPolicyExcludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationPolicyExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessApplicationPolicyExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessApplicationPolicyExcludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationPolicyExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationPolicyExcludeServiceToken;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeCertificate {
}

export interface GetZeroTrustAccessApplicationPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeEveryone {
}

export interface GetZeroTrustAccessApplicationPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessApplicationPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessApplicationPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationPolicyIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationPolicyIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationPolicyIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationPolicyIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationPolicyIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationPolicyIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationPolicyIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationPolicyIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationPolicyIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationPolicyIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationPolicyIncludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationPolicyIncludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationPolicyIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessApplicationPolicyIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessApplicationPolicyIncludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationPolicyIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationPolicyIncludeServiceToken;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeCertificate {
}

export interface GetZeroTrustAccessApplicationPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeEveryone {
}

export interface GetZeroTrustAccessApplicationPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessApplicationPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessApplicationPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationPolicyRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationPolicyRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationPolicyRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationPolicyRequireCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationPolicyRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationPolicyRequireDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationPolicyRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationPolicyRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationPolicyRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationPolicyRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationPolicyRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationPolicyRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationPolicyRequireGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationPolicyRequireGsuite;
    ip: outputs.GetZeroTrustAccessApplicationPolicyRequireIp;
    ipList: outputs.GetZeroTrustAccessApplicationPolicyRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessApplicationPolicyRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessApplicationPolicyRequireOkta;
    saml: outputs.GetZeroTrustAccessApplicationPolicyRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationPolicyRequireServiceToken;
}

export interface GetZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireCertificate {
}

export interface GetZeroTrustAccessApplicationPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireEveryone {
}

export interface GetZeroTrustAccessApplicationPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessApplicationPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessApplicationPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: string;
    createdAt: string;
    customAttributes: outputs.GetZeroTrustAccessApplicationSaasAppCustomAttribute[];
    customClaims: outputs.GetZeroTrustAccessApplicationSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex: string;
    hybridAndImplicitOptions: outputs.GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     */
    nameIdFormat: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris: string[];
    refreshTokenOptions: outputs.GetZeroTrustAccessApplicationSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName: string;
    /**
     * The name of the attribute.
     */
    name: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required: boolean;
    source: outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSource;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
<<<<<<< HEAD
    nameByIdp: {[key: string]: string};
}

export interface GetZeroTrustAccessApplicationSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name: string;
    /**
     * If the claim is required when building an OIDC token.
     */
=======
    nameByIdps: outputs.GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp[];
}

export interface GetZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName: string;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name: string;
    /**
     * If the claim is required when building an OIDC token.
     */
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    required: boolean;
    /**
     * The scope of the claim.
     */
    scope: string;
    source: outputs.GetZeroTrustAccessApplicationSaasAppCustomClaimSource;
}

export interface GetZeroTrustAccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp: {[key: string]: string};
}

export interface GetZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint: boolean;
}

export interface GetZeroTrustAccessApplicationSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime: string;
}

export interface GetZeroTrustAccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication: outputs.GetZeroTrustAccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings: outputs.GetZeroTrustAccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface GetZeroTrustAccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user: string;
}

export interface GetZeroTrustAccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations: outputs.GetZeroTrustAccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     */
    strictness: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata: string;
}

export interface GetZeroTrustAccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update: boolean;
}

export interface GetZeroTrustAccessApplicationTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface GetZeroTrustAccessApplicationsResult {
    /**
     * When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
     */
    allowAuthenticateViaWarp: boolean;
    /**
     * The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account.
     */
    allowedIdps: string[];
    /**
     * The image URL of the logo shown in the App Launcher header.
     */
    appLauncherLogoUrl: string;
    /**
     * Displays the application in the App Launcher.
     */
    appLauncherVisible: boolean;
    /**
     * Audience tag.
     */
    aud: string;
    /**
     * When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps.
     */
    autoRedirectToIdentity: boolean;
    /**
     * The background color of the App Launcher page.
     */
    bgColor: string;
    corsHeaders: outputs.GetZeroTrustAccessApplicationsResultCorsHeaders;
    createdAt: string;
    /**
     * The custom error message shown to a user when they are denied access to the application.
     */
    customDenyMessage: string;
    /**
     * The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules.
     */
    customDenyUrl: string;
    /**
     * The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules.
     */
    customNonIdentityDenyUrl: string;
    /**
     * The custom pages that will be displayed when applicable for this application
     */
    customPages: string[];
    /**
     * List of destinations secured by Access. This supersedes `selfHostedDomains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `selfHostedDomains` will be ignored.
     */
    destinations: outputs.GetZeroTrustAccessApplicationsResultDestination[];
    /**
     * The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher.
     */
    domain: string;
    /**
     * Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks.
     */
    enableBindingCookie: boolean;
    /**
     * The links in the App Launcher footer.
     */
    footerLinks: outputs.GetZeroTrustAccessApplicationsResultFooterLink[];
    /**
     * The background color of the App Launcher header.
     */
    headerBgColor: string;
    /**
     * Enables the HttpOnly cookie attribute, which increases security against XSS attacks.
     */
    httpOnlyCookieAttribute: boolean;
    /**
     * UUID
     */
    id: string;
    /**
     * The design of the App Launcher landing page shown to users when they log in.
     */
    landingPageDesign: outputs.GetZeroTrustAccessApplicationsResultLandingPageDesign;
    /**
     * The image URL for the logo shown in the App Launcher dashboard.
     */
    logoUrl: string;
    /**
     * The name of the application.
     */
    name: string;
    /**
     * Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if corsHeaders is set.
     */
    optionsPreflightBypass: boolean;
    /**
     * Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default
     */
    pathCookieAttribute: boolean;
    policies: outputs.GetZeroTrustAccessApplicationsResultPolicy[];
    saasApp: outputs.GetZeroTrustAccessApplicationsResultSaasApp;
    /**
     * Sets the SameSite cookie setting, which provides increased security against CSRF attacks.
     */
    sameSiteCookieAttribute: string;
    /**
     * Configuration for provisioning to this application via SCIM. This is currently in closed beta.
     */
    scimConfig: outputs.GetZeroTrustAccessApplicationsResultScimConfig;
    /**
     * List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until **November 21, 2025.** If `destinations` are provided, then `selfHostedDomains` will be ignored.
     */
    selfHostedDomains: string[];
    /**
     * Returns a 401 status code when the request is blocked by a Service Auth policy.
     */
    serviceAuth401Redirect: boolean;
    /**
     * The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    /**
     * Determines when to skip the App Launcher landing page.
     */
    skipAppLauncherLoginPage: boolean;
    /**
     * Enables automatic authentication through cloudflared.
     */
    skipInterstitial: boolean;
    /**
     * The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard.
     */
    tags: string[];
    targetCriterias: outputs.GetZeroTrustAccessApplicationsResultTargetCriteria[];
    /**
     * The application type.
     */
    type: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationsResultCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge: number;
}

export interface GetZeroTrustAccessApplicationsResultDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     */
    l4Protocol: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange: string;
    type: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId: string;
}

export interface GetZeroTrustAccessApplicationsResultFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface GetZeroTrustAccessApplicationsResultLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl: string;
    /**
     * The message shown on the landing page.
     */
    message: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicy {
    /**
     * Administrators who can approve a temporary authentication request.
     */
    approvalGroups: outputs.GetZeroTrustAccessApplicationsResultPolicyApprovalGroup[];
    /**
     * Requires the user to request access from an administrator at the start of each session.
     */
    approvalRequired: boolean;
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules: outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRules;
    createdAt: string;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     */
    decision: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessApplicationsResultPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessApplicationsResultPolicyInclude[];
    /**
     * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
     */
    isolationRequired: boolean;
    /**
     * The name of the Access policy.
     */
    name: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence: number;
    /**
     * A custom message that will appear on the purpose justification screen.
     */
    purposeJustificationPrompt: string;
    /**
     * Require users to enter a justification when they log in to the application.
     */
    purposeJustificationRequired: boolean;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessApplicationsResultPolicyRequire[];
    /**
     * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh: outputs.GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSsh;
}

export interface GetZeroTrustAccessApplicationsResultPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface GetZeroTrustAccessApplicationsResultPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyExcludeServiceToken;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeCertificate {
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeEveryone {
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
export interface GetZeroTrustAccessApplicationsResultPolicyExcludeOkta {
    /**
=======
export interface GetZeroTrustAccessApplicationsResultPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeOkta {
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeGsuite;
    ip: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIp;
    ipList: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeOkta;
    saml: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyIncludeServiceToken;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeCertificate {
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeEveryone {
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessApplicationsResultPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessApplicationsResultPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCertificate;
    commonName: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireDevicePosture;
    email: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGroup;
    gsuite: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireGsuite;
    ip: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIp;
    ipList: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireOkta;
    saml: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessApplicationsResultPolicyRequireServiceToken;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireCertificate {
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireEveryone {
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessApplicationsResultPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessApplicationsResultPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessApplicationsResultPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessApplicationsResultSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: string;
    createdAt: string;
    customAttributes: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttribute[];
    customClaims: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex: string;
    hybridAndImplicitOptions: outputs.GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     */
    nameIdFormat: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris: string[];
    refreshTokenOptions: outputs.GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName: string;
    /**
     * The name of the attribute.
     */
    name: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required: boolean;
    source: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSource;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
<<<<<<< HEAD
    nameByIdp: {[key: string]: string};
=======
    nameByIdps: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdp[];
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name: string;
    /**
     * If the claim is required when building an OIDC token.
     */
    required: boolean;
    /**
     * The scope of the claim.
     */
    scope: string;
    source: outputs.GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSource;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp: {[key: string]: string};
}

export interface GetZeroTrustAccessApplicationsResultSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint: boolean;
}

export interface GetZeroTrustAccessApplicationsResultSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication: outputs.GetZeroTrustAccessApplicationsResultScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings: outputs.GetZeroTrustAccessApplicationsResultScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations: outputs.GetZeroTrustAccessApplicationsResultScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     */
    strictness: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata: string;
}

export interface GetZeroTrustAccessApplicationsResultScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update: boolean;
}

export interface GetZeroTrustAccessApplicationsResultTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface GetZeroTrustAccessCustomPagesResult {
    /**
     * Number of apps the custom page is assigned to.
     */
    appCount: number;
    createdAt: string;
    /**
     * Custom page name.
     */
    name: string;
    /**
     * Custom page type.
     */
    type: string;
    /**
     * UUID
     */
    uid: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessGroupExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupExcludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupExcludeIp;
    ipList: outputs.GetZeroTrustAccessGroupExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupExcludeOkta;
    saml: outputs.GetZeroTrustAccessGroupExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupExcludeServiceToken;
}

export interface GetZeroTrustAccessGroupExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeCertificate {
}

export interface GetZeroTrustAccessGroupExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupExcludeEveryone {
}

export interface GetZeroTrustAccessGroupExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupFilter {
    /**
     * The name of the group.
     */
    name?: string;
    /**
     * Search for groups by other listed query parameters.
     */
    search?: string;
}

export interface GetZeroTrustAccessGroupInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupIncludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupIncludeIp;
    ipList: outputs.GetZeroTrustAccessGroupIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupIncludeOkta;
    saml: outputs.GetZeroTrustAccessGroupIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupIncludeServiceToken;
}

export interface GetZeroTrustAccessGroupIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeCertificate {
}

export interface GetZeroTrustAccessGroupIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIncludeEveryone {
}

export interface GetZeroTrustAccessGroupIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupIsDefault {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupIsDefaultAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupIsDefaultAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupIsDefaultAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupIsDefaultAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupIsDefaultCertificate;
    commonName: outputs.GetZeroTrustAccessGroupIsDefaultCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupIsDefaultDevicePosture;
    email: outputs.GetZeroTrustAccessGroupIsDefaultEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupIsDefaultEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupIsDefaultEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupIsDefaultEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupIsDefaultExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupIsDefaultGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupIsDefaultGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupIsDefaultGroup;
    gsuite: outputs.GetZeroTrustAccessGroupIsDefaultGsuite;
    ip: outputs.GetZeroTrustAccessGroupIsDefaultIp;
    ipList: outputs.GetZeroTrustAccessGroupIsDefaultIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupIsDefaultLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupIsDefaultOkta;
    saml: outputs.GetZeroTrustAccessGroupIsDefaultSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupIsDefaultServiceToken;
}

export interface GetZeroTrustAccessGroupIsDefaultAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupIsDefaultAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupIsDefaultAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultCertificate {
}

export interface GetZeroTrustAccessGroupIsDefaultCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupIsDefaultDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIsDefaultEveryone {
}

export interface GetZeroTrustAccessGroupIsDefaultExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupIsDefaultGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupIsDefaultIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupIsDefaultLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupIsDefaultOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupIsDefaultSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupIsDefaultServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupRequireCertificate;
    commonName: outputs.GetZeroTrustAccessGroupRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupRequireDevicePosture;
    email: outputs.GetZeroTrustAccessGroupRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupRequireGroup;
    gsuite: outputs.GetZeroTrustAccessGroupRequireGsuite;
    ip: outputs.GetZeroTrustAccessGroupRequireIp;
    ipList: outputs.GetZeroTrustAccessGroupRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupRequireOkta;
    saml: outputs.GetZeroTrustAccessGroupRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupRequireServiceToken;
}

export interface GetZeroTrustAccessGroupRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireCertificate {
}

export interface GetZeroTrustAccessGroupRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupRequireEveryone {
}

export interface GetZeroTrustAccessGroupRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResult {
    createdAt: string;
    /**
     * Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessGroupsResultExclude[];
    /**
     * UUID
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessGroupsResultInclude[];
    /**
     * Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
     */
    isDefaults: outputs.GetZeroTrustAccessGroupsResultIsDefault[];
    /**
     * The name of the Access group.
     */
    name: string;
    /**
     * Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessGroupsResultRequire[];
    updatedAt: string;
}

export interface GetZeroTrustAccessGroupsResultExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultExcludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultExcludeIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupsResultExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupsResultExcludeOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultExcludeServiceToken;
}

export interface GetZeroTrustAccessGroupsResultExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeCertificate {
}

export interface GetZeroTrustAccessGroupsResultExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeEveryone {
}

export interface GetZeroTrustAccessGroupsResultExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupsResultExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupsResultExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResultInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultIncludeGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultIncludeIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupsResultIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupsResultIncludeOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultIncludeServiceToken;
}

export interface GetZeroTrustAccessGroupsResultIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeCertificate {
}

export interface GetZeroTrustAccessGroupsResultIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeEveryone {
}

export interface GetZeroTrustAccessGroupsResultIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupsResultIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupsResultIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefault {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultIsDefaultAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultIsDefaultAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultIsDefaultCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultIsDefaultCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultIsDefaultDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultIsDefaultEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultIsDefaultEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultIsDefaultEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultIsDefaultGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultIsDefaultGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultIsDefaultGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultIsDefaultGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultIsDefaultIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultIsDefaultIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupsResultIsDefaultLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupsResultIsDefaultOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultIsDefaultSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultIsDefaultServiceToken;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultCertificate {
}

export interface GetZeroTrustAccessGroupsResultIsDefaultCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultEveryone {
}

export interface GetZeroTrustAccessGroupsResultIsDefaultExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupsResultIsDefaultLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupsResultIsDefaultOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultIsDefaultServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessGroupsResultRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessGroupsResultRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessGroupsResultRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessGroupsResultRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessGroupsResultRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessGroupsResultRequireCertificate;
    commonName: outputs.GetZeroTrustAccessGroupsResultRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessGroupsResultRequireDevicePosture;
    email: outputs.GetZeroTrustAccessGroupsResultRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessGroupsResultRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessGroupsResultRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessGroupsResultRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessGroupsResultRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessGroupsResultRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessGroupsResultRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessGroupsResultRequireGroup;
    gsuite: outputs.GetZeroTrustAccessGroupsResultRequireGsuite;
    ip: outputs.GetZeroTrustAccessGroupsResultRequireIp;
    ipList: outputs.GetZeroTrustAccessGroupsResultRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessGroupsResultRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessGroupsResultRequireOkta;
    saml: outputs.GetZeroTrustAccessGroupsResultRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessGroupsResultRequireServiceToken;
}

export interface GetZeroTrustAccessGroupsResultRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessGroupsResultRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessGroupsResultRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireCertificate {
}

export interface GetZeroTrustAccessGroupsResultRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessGroupsResultRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultRequireEveryone {
}

export interface GetZeroTrustAccessGroupsResultRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessGroupsResultRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessGroupsResultRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessGroupsResultRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessGroupsResultRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessGroupsResultRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessGroupsResultRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessIdentityProviderConfig {
    /**
     * Your companies TLD
     */
    appsDomain: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId: string;
    /**
     * Your centrify account url
     */
    centrifyAccount: string;
    /**
     * Your centrify app id
     */
    centrifyAppId: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl: string;
    /**
     * Custom claims
     */
    claims: string[];
    /**
     * Your OAuth Client ID
     */
    clientId: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes: outputs.GetZeroTrustAccessIdentityProviderConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl: string;
    /**
     * Your okta account url
     */
    oktaAccount: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     */
    prompt: string;
    redirectUrl: string;
    /**
     * OAuth scopes
     */
    scopes: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl: string;
}

export interface GetZeroTrustAccessIdentityProviderConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName: string;
}

export interface GetZeroTrustAccessIdentityProviderFilter {
    /**
     * Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
     */
    scimEnabled?: string;
}

export interface GetZeroTrustAccessIdentityProviderScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "noAction" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     */
    identityUpdateBehavior: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision: boolean;
}

export interface GetZeroTrustAccessIdentityProvidersResult {
    /**
     * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
     */
    config: outputs.GetZeroTrustAccessIdentityProvidersResultConfig;
    /**
     * UUID
     */
    id: string;
    /**
     * The name of the identity provider, shown to users on the login page.
     */
    name: string;
    /**
     * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
     */
    scimConfig: outputs.GetZeroTrustAccessIdentityProvidersResultScimConfig;
    /**
     * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
     */
    type: string;
}

export interface GetZeroTrustAccessIdentityProvidersResultConfig {
    /**
     * Your companies TLD
     */
    appsDomain: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId: string;
    /**
     * Your centrify account url
     */
    centrifyAccount: string;
    /**
     * Your centrify app id
     */
    centrifyAppId: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl: string;
    /**
     * Custom claims
     */
    claims: string[];
    /**
     * Your OAuth Client ID
     */
    clientId: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes: outputs.GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl: string;
    /**
     * Your okta account url
     */
    oktaAccount: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     */
    prompt: string;
    /**
     * OAuth scopes
     */
    scopes: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl: string;
}

export interface GetZeroTrustAccessIdentityProvidersResultConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName: string;
}

export interface GetZeroTrustAccessIdentityProvidersResultScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "noAction" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     */
    identityUpdateBehavior: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision: boolean;
}

export interface GetZeroTrustAccessInfrastructureTargetFilter {
    /**
     * Date and time at which the target was created after (inclusive)
     */
    createdAfter?: string;
    /**
     * Date and time at which the target was created before (inclusive)
     */
    createdBefore?: string;
    /**
     * The sorting direction.
     */
    direction?: string;
    /**
     * Hostname of a target
     */
    hostname?: string;
    /**
     * Partial match to the hostname of a target
     */
    hostnameContains?: string;
    /**
<<<<<<< HEAD
=======
     * Filters for targets whose IP addresses look like the specified string.
     * Supports `*` as a wildcard character
     */
    ipLike?: string;
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * IPv4 address of the target
     */
    ipV4?: string;
    /**
     * IPv6 address of the target
     */
    ipV6?: string;
    /**
     * Filters for targets that have any of the following IP addresses. Specify
     * `ips` multiple times in query parameter to build list of candidates.
     */
    ips?: string[];
    /**
<<<<<<< HEAD
=======
     * Defines an IPv4 filter range's ending value (inclusive). Requires
     * `ipv4Start` to be specified as well.
     */
    ipv4End?: string;
    /**
     * Defines an IPv4 filter range's starting value (inclusive). Requires
     * `ipv4End` to be specified as well.
     */
    ipv4Start?: string;
    /**
     * Defines an IPv6 filter range's ending value (inclusive). Requires
     * `ipv6Start` to be specified as well.
     */
    ipv6End?: string;
    /**
     * Defines an IPv6 filter range's starting value (inclusive). Requires
     * `ipv6End` to be specified as well.
     */
    ipv6Start?: string;
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * Date and time at which the target was modified after (inclusive)
     */
    modifiedAfter?: string;
    /**
     * Date and time at which the target was modified before (inclusive)
     */
    modifiedBefore?: string;
    /**
     * The field to sort by.
     */
    order?: string;
    /**
<<<<<<< HEAD
=======
     * Filters for targets that have any of the following UUIDs. Specify
     * `targetIds` multiple times in query parameter to build list of
     * candidates.
     */
    targetIds?: string[];
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * Private virtual network identifier of the target
     */
    virtualNetworkId?: string;
}

export interface GetZeroTrustAccessInfrastructureTargetIp {
    /**
     * The target's IPv4 address
     */
    ipv4: outputs.GetZeroTrustAccessInfrastructureTargetIpIpv4;
    /**
     * The target's IPv6 address
     */
    ipv6: outputs.GetZeroTrustAccessInfrastructureTargetIpIpv6;
}

export interface GetZeroTrustAccessInfrastructureTargetIpIpv4 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessInfrastructureTargetIpIpv6 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessInfrastructureTargetsResult {
    /**
     * Date and time at which the target was created
     */
    createdAt: string;
    /**
     * A non-unique field that refers to a target
     */
    hostname: string;
    /**
     * Target identifier
     */
    id: string;
    /**
     * The IPv4/IPv6 address that identifies where to reach a target
     */
    ip: outputs.GetZeroTrustAccessInfrastructureTargetsResultIp;
    /**
     * Date and time at which the target was modified
     */
    modifiedAt: string;
}

export interface GetZeroTrustAccessInfrastructureTargetsResultIp {
    /**
     * The target's IPv4 address
     */
    ipv4: outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv4;
    /**
     * The target's IPv6 address
     */
    ipv6: outputs.GetZeroTrustAccessInfrastructureTargetsResultIpIpv6;
}

export interface GetZeroTrustAccessInfrastructureTargetsResultIpIpv4 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessInfrastructureTargetsResultIpIpv6 {
    /**
     * IP address of the target
     */
    ipAddr: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId: string;
}

export interface GetZeroTrustAccessMtlsCertificatesResult {
    /**
     * The hostnames of the applications that will use this certificate.
     */
    associatedHostnames: string[];
    createdAt: string;
    expiresOn: string;
    /**
     * The MD5 fingerprint of the certificate.
     */
    fingerprint: string;
    /**
     * The ID of the application that will use this certificate.
     */
    id: string;
    /**
     * The name of the certificate.
     */
    name: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessPoliciesResult {
    /**
     * Number of access applications currently using this policy.
     */
    appCount: number;
    /**
     * Administrators who can approve a temporary authentication request.
     */
    approvalGroups: outputs.GetZeroTrustAccessPoliciesResultApprovalGroup[];
    /**
     * Requires the user to request access from an administrator at the start of each session.
     */
    approvalRequired: boolean;
    createdAt: string;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     */
    decision: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.GetZeroTrustAccessPoliciesResultExclude[];
    /**
     * The UUID of the policy
     */
    id: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.GetZeroTrustAccessPoliciesResultInclude[];
    /**
     * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
     */
    isolationRequired: boolean;
    /**
     * The name of the Access policy.
     */
    name: string;
    /**
     * A custom message that will appear on the purpose justification screen.
     */
    purposeJustificationPrompt: string;
    /**
     * Require users to enter a justification when they log in to the application.
     */
    purposeJustificationRequired: boolean;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.GetZeroTrustAccessPoliciesResultRequire[];
    reusable: boolean;
    /**
     * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
     */
    sessionDuration: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessPoliciesResultApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessPoliciesResultExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPoliciesResultExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPoliciesResultExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPoliciesResultExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPoliciesResultExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessPoliciesResultExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPoliciesResultExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessPoliciesResultExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPoliciesResultExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPoliciesResultExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPoliciesResultExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPoliciesResultExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPoliciesResultExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPoliciesResultExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPoliciesResultExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessPoliciesResultExcludeGsuite;
    ip: outputs.GetZeroTrustAccessPoliciesResultExcludeIp;
    ipList: outputs.GetZeroTrustAccessPoliciesResultExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessPoliciesResultExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessPoliciesResultExcludeOkta;
    saml: outputs.GetZeroTrustAccessPoliciesResultExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPoliciesResultExcludeServiceToken;
}

export interface GetZeroTrustAccessPoliciesResultExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPoliciesResultExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeCertificate {
}

export interface GetZeroTrustAccessPoliciesResultExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeEveryone {
}

export interface GetZeroTrustAccessPoliciesResultExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessPoliciesResultExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessPoliciesResultExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPoliciesResultInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPoliciesResultIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPoliciesResultIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPoliciesResultIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPoliciesResultIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessPoliciesResultIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPoliciesResultIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessPoliciesResultIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPoliciesResultIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPoliciesResultIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPoliciesResultIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPoliciesResultIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPoliciesResultIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPoliciesResultIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPoliciesResultIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessPoliciesResultIncludeGsuite;
    ip: outputs.GetZeroTrustAccessPoliciesResultIncludeIp;
    ipList: outputs.GetZeroTrustAccessPoliciesResultIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessPoliciesResultIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessPoliciesResultIncludeOkta;
    saml: outputs.GetZeroTrustAccessPoliciesResultIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPoliciesResultIncludeServiceToken;
}

export interface GetZeroTrustAccessPoliciesResultIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPoliciesResultIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeCertificate {
}

export interface GetZeroTrustAccessPoliciesResultIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeEveryone {
}

export interface GetZeroTrustAccessPoliciesResultIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessPoliciesResultIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessPoliciesResultIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPoliciesResultRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPoliciesResultRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessPoliciesResultRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPoliciesResultRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessPoliciesResultRequireCertificate;
    commonName: outputs.GetZeroTrustAccessPoliciesResultRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessPoliciesResultRequireDevicePosture;
    email: outputs.GetZeroTrustAccessPoliciesResultRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessPoliciesResultRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessPoliciesResultRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPoliciesResultRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPoliciesResultRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPoliciesResultRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessPoliciesResultRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessPoliciesResultRequireGroup;
    gsuite: outputs.GetZeroTrustAccessPoliciesResultRequireGsuite;
    ip: outputs.GetZeroTrustAccessPoliciesResultRequireIp;
    ipList: outputs.GetZeroTrustAccessPoliciesResultRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessPoliciesResultRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessPoliciesResultRequireOkta;
    saml: outputs.GetZeroTrustAccessPoliciesResultRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessPoliciesResultRequireServiceToken;
}

export interface GetZeroTrustAccessPoliciesResultRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessPoliciesResultRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireCertificate {
}

export interface GetZeroTrustAccessPoliciesResultRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireEveryone {
}

export interface GetZeroTrustAccessPoliciesResultRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessPoliciesResultRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessPoliciesResultRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPoliciesResultRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid: string;
}

export interface GetZeroTrustAccessPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPolicyExcludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPolicyExcludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPolicyExcludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPolicyExcludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPolicyExcludeCertificate;
    commonName: outputs.GetZeroTrustAccessPolicyExcludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPolicyExcludeDevicePosture;
    email: outputs.GetZeroTrustAccessPolicyExcludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPolicyExcludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPolicyExcludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPolicyExcludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPolicyExcludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPolicyExcludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPolicyExcludeGroup;
    gsuite: outputs.GetZeroTrustAccessPolicyExcludeGsuite;
    ip: outputs.GetZeroTrustAccessPolicyExcludeIp;
    ipList: outputs.GetZeroTrustAccessPolicyExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessPolicyExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessPolicyExcludeOkta;
    saml: outputs.GetZeroTrustAccessPolicyExcludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPolicyExcludeServiceToken;
}

export interface GetZeroTrustAccessPolicyExcludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeCertificate {
}

export interface GetZeroTrustAccessPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyExcludeEveryone {
}

export interface GetZeroTrustAccessPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPolicyIncludeAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPolicyIncludeAuthContext;
    authMethod: outputs.GetZeroTrustAccessPolicyIncludeAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPolicyIncludeAzureAd;
    certificate: outputs.GetZeroTrustAccessPolicyIncludeCertificate;
    commonName: outputs.GetZeroTrustAccessPolicyIncludeCommonName;
    devicePosture: outputs.GetZeroTrustAccessPolicyIncludeDevicePosture;
    email: outputs.GetZeroTrustAccessPolicyIncludeEmail;
    emailDomain: outputs.GetZeroTrustAccessPolicyIncludeEmailDomain;
    emailList: outputs.GetZeroTrustAccessPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPolicyIncludeEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPolicyIncludeExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPolicyIncludeGeo;
    githubOrganization: outputs.GetZeroTrustAccessPolicyIncludeGithubOrganization;
    group: outputs.GetZeroTrustAccessPolicyIncludeGroup;
    gsuite: outputs.GetZeroTrustAccessPolicyIncludeGsuite;
    ip: outputs.GetZeroTrustAccessPolicyIncludeIp;
    ipList: outputs.GetZeroTrustAccessPolicyIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessPolicyIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessPolicyIncludeOkta;
    saml: outputs.GetZeroTrustAccessPolicyIncludeSaml;
    serviceToken: outputs.GetZeroTrustAccessPolicyIncludeServiceToken;
}

export interface GetZeroTrustAccessPolicyIncludeAnyValidServiceToken {
}

export interface GetZeroTrustAccessPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeCertificate {
}

export interface GetZeroTrustAccessPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyIncludeEveryone {
}

export interface GetZeroTrustAccessPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken: outputs.GetZeroTrustAccessPolicyRequireAnyValidServiceToken;
    authContext: outputs.GetZeroTrustAccessPolicyRequireAuthContext;
    authMethod: outputs.GetZeroTrustAccessPolicyRequireAuthMethod;
    azureAd: outputs.GetZeroTrustAccessPolicyRequireAzureAd;
    certificate: outputs.GetZeroTrustAccessPolicyRequireCertificate;
    commonName: outputs.GetZeroTrustAccessPolicyRequireCommonName;
    devicePosture: outputs.GetZeroTrustAccessPolicyRequireDevicePosture;
    email: outputs.GetZeroTrustAccessPolicyRequireEmail;
    emailDomain: outputs.GetZeroTrustAccessPolicyRequireEmailDomain;
    emailList: outputs.GetZeroTrustAccessPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone: outputs.GetZeroTrustAccessPolicyRequireEveryone;
    externalEvaluation: outputs.GetZeroTrustAccessPolicyRequireExternalEvaluation;
    geo: outputs.GetZeroTrustAccessPolicyRequireGeo;
    githubOrganization: outputs.GetZeroTrustAccessPolicyRequireGithubOrganization;
    group: outputs.GetZeroTrustAccessPolicyRequireGroup;
    gsuite: outputs.GetZeroTrustAccessPolicyRequireGsuite;
    ip: outputs.GetZeroTrustAccessPolicyRequireIp;
    ipList: outputs.GetZeroTrustAccessPolicyRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.GetZeroTrustAccessPolicyRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.GetZeroTrustAccessPolicyRequireOkta;
    saml: outputs.GetZeroTrustAccessPolicyRequireSaml;
    serviceToken: outputs.GetZeroTrustAccessPolicyRequireServiceToken;
}

export interface GetZeroTrustAccessPolicyRequireAnyValidServiceToken {
}

export interface GetZeroTrustAccessPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface GetZeroTrustAccessPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireCertificate {
}

export interface GetZeroTrustAccessPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface GetZeroTrustAccessPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface GetZeroTrustAccessPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface GetZeroTrustAccessPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface GetZeroTrustAccessPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyRequireEveryone {
}

export interface GetZeroTrustAccessPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface GetZeroTrustAccessPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface GetZeroTrustAccessPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team: string;
}

export interface GetZeroTrustAccessPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface GetZeroTrustAccessPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface GetZeroTrustAccessPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface GetZeroTrustAccessPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface GetZeroTrustAccessPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface GetZeroTrustAccessPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface GetZeroTrustAccessPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface GetZeroTrustAccessServiceTokenFilter {
    /**
     * The name of the service token.
     */
    name?: string;
    /**
     * Search for service tokens by other listed query parameters.
     */
    search?: string;
}

export interface GetZeroTrustAccessServiceTokensResult {
    /**
     * The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header.
     */
    clientId: string;
    createdAt: string;
    /**
     * The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. The default is 1 year in hours (8760h).
     */
    duration: string;
    expiresAt: string;
    /**
     * The ID of the service token.
     */
    id: string;
    lastSeenAt: string;
    /**
     * The name of the service token.
     */
    name: string;
    updatedAt: string;
}

export interface GetZeroTrustAccessShortLivedCertificatesResult {
    /**
     * The Application Audience (AUD) tag. Identifies the application associated with the CA.
     */
    aud: string;
    /**
     * The ID of the CA.
     */
    id: string;
    /**
     * The public key to add to your SSH server configuration.
     */
    publicKey: string;
}

export interface GetZeroTrustAccessTagsResult {
    /**
     * The number of applications that have this tag
     */
    appCount: number;
    createdAt: string;
    /**
     * The name of the tag
     */
    name: string;
    updatedAt: string;
}

export interface GetZeroTrustDeviceCustomProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface GetZeroTrustDeviceCustomProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface GetZeroTrustDeviceCustomProfileTargetTest {
    /**
     * The id of the DEX test targeting this policy
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy
     */
    name: string;
}

export interface GetZeroTrustDeviceCustomProfilesResult {
    /**
     * Whether to allow the user to switch WARP between modes.
     */
    allowModeSwitch: boolean;
    /**
     * Whether to receive update notifications when a new version of the client is available.
     */
    allowUpdates: boolean;
    /**
     * Whether to allow devices to leave the organization.
     */
    allowedToLeave: boolean;
    /**
     * The amount of time in seconds to reconnect after having been disabled.
     */
    autoConnect: number;
    /**
     * Turn on the captive portal after the specified amount of time.
     */
    captivePortal: number;
    /**
     * Whether the policy is the default policy for an account.
     */
    default: boolean;
    /**
     * A description of the policy.
     */
    description: string;
    /**
     * If the `dnsServer` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`.
     */
    disableAutoFallback: boolean;
    /**
     * Whether the policy will be applied to matching devices.
     */
    enabled: boolean;
    /**
     * Whether to add Microsoft IPs to Split Tunnel exclusions.
     */
    excludeOfficeIps: boolean;
    excludes: outputs.GetZeroTrustDeviceCustomProfilesResultExclude[];
    fallbackDomains: outputs.GetZeroTrustDeviceCustomProfilesResultFallbackDomain[];
    gatewayUniqueId: string;
    includes: outputs.GetZeroTrustDeviceCustomProfilesResultInclude[];
    /**
     * The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
     */
    lanAllowMinutes: number;
    /**
     * The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
     */
    lanAllowSubnetSize: number;
    /**
     * The wirefilter expression to match devices.
     */
    match: string;
    /**
     * The name of the device settings profile.
     */
    name: string;
    /**
     * Device ID.
     */
    policyId: string;
    /**
     * The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
     */
    precedence: number;
    serviceModeV2: outputs.GetZeroTrustDeviceCustomProfilesResultServiceModeV2;
    /**
     * The URL to launch when the Send Feedback button is clicked.
     */
    supportUrl: string;
    /**
     * Whether to allow the user to turn off the WARP switch and disconnect the client.
     */
    switchLocked: boolean;
    targetTests: outputs.GetZeroTrustDeviceCustomProfilesResultTargetTest[];
    /**
     * Determines which tunnel protocol to use.
     */
    tunnelProtocol: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceCustomProfilesResultServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface GetZeroTrustDeviceCustomProfilesResultTargetTest {
    /**
     * The id of the DEX test targeting this policy
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy
     */
    name: string;
}

export interface GetZeroTrustDeviceDefaultProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceDefaultProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface GetZeroTrustDeviceDefaultProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface GetZeroTrustDeviceDefaultProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode: string;
    /**
     * The port number when used with proxy mode.
     */
    port: number;
}

export interface GetZeroTrustDeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface GetZeroTrustDeviceManagedNetworksListResult {
    /**
     * The configuration object containing information for the WARP client to detect the managed network.
     */
    config: outputs.GetZeroTrustDeviceManagedNetworksListResultConfig;
    /**
     * The name of the device managed network. This name must be unique.
     */
    name: string;
    /**
     * API UUID.
     */
    networkId: string;
    /**
     * The type of device managed network.
     */
    type: string;
}

export interface GetZeroTrustDeviceManagedNetworksListResultConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface GetZeroTrustDevicePostureIntegrationConfig {
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId: string;
}

export interface GetZeroTrustDevicePostureIntegrationsResult {
    /**
<<<<<<< HEAD
     * The Workspace One Config Response.
=======
     * The configuration object containing third-party integration information.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     */
    config: outputs.GetZeroTrustDevicePostureIntegrationsResultConfig;
    /**
     * API UUID.
     */
    id: string;
    /**
     * The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`).
     */
    interval: string;
    /**
     * The name of the device posture integration.
     */
    name: string;
    /**
     * The type of device posture integration.
     */
    type: string;
}

export interface GetZeroTrustDevicePostureIntegrationsResultConfig {
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId: string;
}

export interface GetZeroTrustDevicePostureRuleInput {
    /**
     * The Number of active threats.
     */
    activeThreats: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey: boolean;
    /**
     * Common Name that is protected by the certificate
     */
    cn: string;
    /**
     * Compliance Status
     */
    complianceStatus: string;
    /**
     * Posture Integration ID.
     */
    connectionId: string;
    /**
     * Count Operator
     */
    countOperator: string;
    /**
     * Domain
     */
    domain: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen: string;
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Whether or not file exists
     */
    exists: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used
     */
    extendedKeyUsages: string[];
    /**
     * List ID.
     */
    id: string;
    /**
     * Whether device is infected.
     */
    infected: boolean;
    /**
     * Whether device is active.
     */
    isActive: boolean;
    /**
     * The Number of Issues.
     */
    issueCount: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen: string;
    locations: outputs.GetZeroTrustDevicePostureRuleInputLocations;
    /**
     * Network status of device.
     */
    networkStatus: string;
    /**
     * Operating system
     */
    operatingSystem: string;
    /**
     * Agent operational state.
     */
    operationalState: string;
    /**
     * operator
     */
    operator: string;
    /**
     * Os Version
     */
    os: string;
    /**
     * Operating System Distribution Name (linux only)
     */
    osDistroName: string;
    /**
     * Version of OS Distribution (linux only)
     */
    osDistroRevision: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
     */
    osVersionExtra: string;
    /**
     * overall
     */
    overall: string;
    /**
     * File path.
     */
    path: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     */
    riskLevel: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score: number;
    /**
     * Score Operator
     */
    scoreOperator: string;
    /**
     * SensorConfig
     */
    sensorConfig: string;
    /**
     * SHA-256.
     */
    sha256: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     */
    state: string;
    /**
     * Signing certificate thumbprint.
     */
    thumbprint: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore: number;
    /**
     * Version of OS
     */
    version: string;
    /**
     * Version Operator
     */
    versionOperator: string;
}

export interface GetZeroTrustDevicePostureRuleInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores: string[];
}

export interface GetZeroTrustDevicePostureRuleMatch {
    platform: string;
}

export interface GetZeroTrustDevicePostureRulesResult {
    /**
     * The description of the device posture rule.
     */
    description: string;
    /**
     * Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client.
     */
    expiration: string;
    /**
     * API UUID.
     */
    id: string;
    /**
     * The value to be checked against.
     */
    input: outputs.GetZeroTrustDevicePostureRulesResultInput;
    /**
     * The conditions that the client must match to run the rule.
     */
    matches: outputs.GetZeroTrustDevicePostureRulesResultMatch[];
    /**
     * The name of the device posture rule.
     */
    name: string;
    /**
     * Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`.
     */
    schedule: string;
    /**
     * The type of device posture rule.
     */
    type: string;
}

export interface GetZeroTrustDevicePostureRulesResultInput {
    /**
     * The Number of active threats.
     */
    activeThreats: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey: boolean;
    /**
     * Common Name that is protected by the certificate
     */
    cn: string;
    /**
     * Compliance Status
     */
    complianceStatus: string;
    /**
     * Posture Integration ID.
     */
    connectionId: string;
    /**
     * Count Operator
     */
    countOperator: string;
    /**
     * Domain
     */
    domain: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen: string;
    /**
     * Enabled
     */
    enabled: boolean;
    /**
     * Whether or not file exists
     */
    exists: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used
     */
    extendedKeyUsages: string[];
    /**
     * List ID.
     */
    id: string;
    /**
     * Whether device is infected.
     */
    infected: boolean;
    /**
     * Whether device is active.
     */
    isActive: boolean;
    /**
     * The Number of Issues.
     */
    issueCount: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen: string;
    locations: outputs.GetZeroTrustDevicePostureRulesResultInputLocations;
    /**
     * Network status of device.
     */
    networkStatus: string;
    /**
     * Operating system
     */
    operatingSystem: string;
    /**
     * Agent operational state.
     */
    operationalState: string;
    /**
     * operator
     */
    operator: string;
    /**
     * Os Version
     */
    os: string;
    /**
     * Operating System Distribution Name (linux only)
     */
    osDistroName: string;
    /**
     * Version of OS Distribution (linux only)
     */
    osDistroRevision: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
     */
    osVersionExtra: string;
    /**
     * overall
     */
    overall: string;
    /**
     * File path.
     */
    path: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     */
    riskLevel: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score: number;
    /**
     * Score Operator
     */
    scoreOperator: string;
    /**
     * SensorConfig
     */
    sensorConfig: string;
    /**
     * SHA-256.
     */
    sha256: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     */
    state: string;
    /**
     * Signing certificate thumbprint.
     */
    thumbprint: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore: number;
    /**
     * Version of OS
     */
    version: string;
    /**
     * Version Operator
     */
    versionOperator: string;
}

export interface GetZeroTrustDevicePostureRulesResultInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores: string[];
}

export interface GetZeroTrustDevicePostureRulesResultMatch {
    platform: string;
}

export interface GetZeroTrustDexTestData {
    /**
     * The desired endpoint to test.
     */
    host: string;
    /**
     * The type of test.
     */
    kind: string;
    /**
     * The HTTP request method type.
     */
    method: string;
}

export interface GetZeroTrustDexTestTargetPolicy {
    /**
     * Whether the profile is the account default
     */
    default: boolean;
    /**
     * The id of the device settings profile
     */
    id: string;
    /**
     * The name of the device settings profile
     */
    name: string;
}

export interface GetZeroTrustDexTestsResult {
    /**
     * The configuration object which contains the details for the WARP client to conduct the test.
     */
    data: outputs.GetZeroTrustDexTestsResultData;
    /**
     * Additional details about the test.
     */
    description: string;
    /**
     * Determines whether or not the test is active.
     */
    enabled: boolean;
    /**
     * How often the test will run.
     */
    interval: string;
    /**
     * The name of the DEX test. Must be unique.
     */
    name: string;
    /**
     * Device settings profiles targeted by this test
     */
    targetPolicies: outputs.GetZeroTrustDexTestsResultTargetPolicy[];
    targeted: boolean;
    /**
     * The unique identifier for the test.
     */
    testId: string;
}

export interface GetZeroTrustDexTestsResultData {
    /**
     * The desired endpoint to test.
     */
    host: string;
    /**
     * The type of test.
     */
    kind: string;
    /**
     * The HTTP request method type.
     */
    method: string;
}

export interface GetZeroTrustDexTestsResultTargetPolicy {
    /**
     * Whether the profile is the account default
     */
    default: boolean;
    /**
     * The id of the device settings profile
     */
    id: string;
    /**
     * The name of the device settings profile
     */
    name: string;
}

export interface GetZeroTrustDlpCustomProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.GetZeroTrustDlpCustomProfileContextAwarenessSkip;
}

export interface GetZeroTrustDlpCustomProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface GetZeroTrustDlpCustomProfileEntry {
    confidence: outputs.GetZeroTrustDlpCustomProfileEntryConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpCustomProfileEntryPattern;
    profileId: string;
    secret: boolean;
    type: string;
    updatedAt: string;
    wordList: string;
}

export interface GetZeroTrustDlpCustomProfileEntryConfidence {
<<<<<<< HEAD
=======
    aiContextAvailable: boolean;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
     * Profiles that use an entry with `available` set to true can use confidence thresholds
     */
    available: boolean;
}

export interface GetZeroTrustDlpCustomProfileEntryPattern {
    regex: string;
    validation: string;
}

export interface GetZeroTrustDlpDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus: string;
}

export interface GetZeroTrustDlpDatasetUpload {
    numCells: number;
    status: string;
    version: number;
}

export interface GetZeroTrustDlpDatasetsResult {
    columns: outputs.GetZeroTrustDlpDatasetsResultColumn[];
    createdAt: string;
    /**
     * The description of the dataset
     */
    description: string;
    encodingVersion: number;
    id: string;
    name: string;
    numCells: number;
    secret: boolean;
    status: string;
    /**
     * When the dataset was last updated.
     */
    updatedAt: string;
    uploads: outputs.GetZeroTrustDlpDatasetsResultUpload[];
}

export interface GetZeroTrustDlpDatasetsResultColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus: string;
}

export interface GetZeroTrustDlpDatasetsResultUpload {
    numCells: number;
    status: string;
    version: number;
}

export interface GetZeroTrustDlpEntriesResult {
    confidence: outputs.GetZeroTrustDlpEntriesResultConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpEntriesResultPattern;
    profileId: string;
    secret: boolean;
    type: string;
    updatedAt: string;
    wordList: string;
}

export interface GetZeroTrustDlpEntriesResultConfidence {
<<<<<<< HEAD
=======
    aiContextAvailable: boolean;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
     * Profiles that use an entry with `available` set to true can use confidence thresholds
     */
    available: boolean;
}

export interface GetZeroTrustDlpEntriesResultPattern {
    regex: string;
    validation: string;
}

export interface GetZeroTrustDlpEntryConfidence {
<<<<<<< HEAD
=======
    aiContextAvailable: boolean;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
     * Profiles that use an entry with `available` set to true can use confidence thresholds
     */
    available: boolean;
}

export interface GetZeroTrustDlpEntryPattern {
    regex: string;
    validation: string;
}

export interface GetZeroTrustDlpPredefinedProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.GetZeroTrustDlpPredefinedProfileContextAwarenessSkip;
}

export interface GetZeroTrustDlpPredefinedProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface GetZeroTrustDlpPredefinedProfileEntry {
    confidence: outputs.GetZeroTrustDlpPredefinedProfileEntryConfidence;
    createdAt: string;
    enabled: boolean;
    id: string;
    name: string;
    pattern: outputs.GetZeroTrustDlpPredefinedProfileEntryPattern;
    profileId: string;
    secret: boolean;
    type: string;
    updatedAt: string;
    wordList: string;
}

export interface GetZeroTrustDlpPredefinedProfileEntryConfidence {
<<<<<<< HEAD
=======
    aiContextAvailable: boolean;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
     * Profiles that use an entry with `available` set to true can use confidence thresholds
     */
    available: boolean;
}

export interface GetZeroTrustDlpPredefinedProfileEntryPattern {
    regex: string;
    validation: string;
}

export interface GetZeroTrustDnsLocationEndpoints {
    doh: outputs.GetZeroTrustDnsLocationEndpointsDoh;
    dot: outputs.GetZeroTrustDnsLocationEndpointsDot;
    ipv4: outputs.GetZeroTrustDnsLocationEndpointsIpv4;
    ipv6: outputs.GetZeroTrustDnsLocationEndpointsIpv6;
}

export interface GetZeroTrustDnsLocationEndpointsDoh {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationEndpointsDohNetwork[];
    /**
     * True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
     */
    requireToken: boolean;
}

export interface GetZeroTrustDnsLocationEndpointsDohNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationEndpointsDot {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationEndpointsDotNetwork[];
}

export interface GetZeroTrustDnsLocationEndpointsDotNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationEndpointsIpv4 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
}

export interface GetZeroTrustDnsLocationEndpointsIpv6 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationEndpointsIpv6Network[];
}

export interface GetZeroTrustDnsLocationEndpointsIpv6Network {
    /**
     * The IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationNetwork {
    /**
     * The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResult {
    /**
     * True if the location is the default location.
     */
    clientDefault: boolean;
    createdAt: string;
    /**
     * The identifier of the pair of IPv4 addresses assigned to this location.
     */
    dnsDestinationIpsId: string;
    /**
     * The uuid identifier of the IPv6 block brought to the gateway, so that this location's IPv6 address is allocated from the Bring Your Own Ipv6(BYOIPv6) block and not from the standard CloudFlare IPv6 block.
     */
    dnsDestinationIpv6BlockId: string;
    /**
     * The DNS over HTTPS domain to send DNS requests to. This field is auto-generated by Gateway.
     */
    dohSubdomain: string;
    /**
     * True if the location needs to resolve EDNS queries.
     */
    ecsSupport: boolean;
    /**
     * The destination endpoints configured for this location. When updating a location, if this field is absent or set with null, the endpoints configuration remains unchanged.
     */
    endpoints: outputs.GetZeroTrustDnsLocationsResultEndpoints;
    id: string;
    /**
     * IPV6 destination ip assigned to this location. DNS requests sent to this IP will counted as the request under this location. This field is auto-generated by Gateway.
     */
    ip: string;
    /**
     * The primary destination IPv4 address from the pair identified by the dns*destination*ips_id. This field is read-only.
     */
    ipv4Destination: string;
    /**
     * The backup destination IPv4 address from the pair identified by the dns*destination*ips_id. This field is read-only.
     */
    ipv4DestinationBackup: string;
    /**
     * The name of the location.
     */
    name: string;
    /**
     * A list of network ranges that requests from this location would originate from. A non-empty list is only effective if the ipv4 endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultNetwork[];
    updatedAt: string;
}

export interface GetZeroTrustDnsLocationsResultEndpoints {
    doh: outputs.GetZeroTrustDnsLocationsResultEndpointsDoh;
    dot: outputs.GetZeroTrustDnsLocationsResultEndpointsDot;
    ipv4: outputs.GetZeroTrustDnsLocationsResultEndpointsIpv4;
    ipv6: outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6;
}

export interface GetZeroTrustDnsLocationsResultEndpointsDoh {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultEndpointsDohNetwork[];
    /**
     * True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
     */
    requireToken: boolean;
}

export interface GetZeroTrustDnsLocationsResultEndpointsDohNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResultEndpointsDot {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultEndpointsDotNetwork[];
}

export interface GetZeroTrustDnsLocationsResultEndpointsDotNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResultEndpointsIpv4 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
}

export interface GetZeroTrustDnsLocationsResultEndpointsIpv6 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled: boolean;
    /**
     * A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.GetZeroTrustDnsLocationsResultEndpointsIpv6Network[];
}

export interface GetZeroTrustDnsLocationsResultEndpointsIpv6Network {
    /**
     * The IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface GetZeroTrustDnsLocationsResultNetwork {
    /**
     * The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
     */
    network: string;
}

export interface GetZeroTrustGatewayAppTypesListResult {
    /**
     * The identifier for the type of this application. There can be many applications with the same type. This refers to the `id` of a returned application type.
     */
    applicationTypeId: number;
    createdAt: string;
    /**
     * A short summary of applications with this type.
     */
    description: string;
    /**
     * The identifier for this application. There is only one application per ID.
     */
    id: number;
    /**
     * The name of the application or application type.
     */
    name: string;
}

export interface GetZeroTrustGatewayCategoriesListResult {
    /**
     * True if the category is in beta and subject to change.
     */
    beta: boolean;
    /**
     * Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
     */
    class: string;
    /**
     * A short summary of domains in the category.
     */
    description: string;
    /**
     * The identifier for this category. There is only one category per ID.
     */
    id: number;
    /**
     * The name of the category.
     */
    name: string;
    /**
     * All subcategories for this category.
     */
    subcategories: outputs.GetZeroTrustGatewayCategoriesListResultSubcategory[];
}

export interface GetZeroTrustGatewayCategoriesListResultSubcategory {
    /**
     * True if the category is in beta and subject to change.
     */
    beta: boolean;
    /**
     * Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
     */
    class: string;
    /**
     * A short summary of domains in the category.
     */
    description: string;
    /**
     * The identifier for this category. There is only one category per ID.
     */
    id: number;
    /**
     * The name of the category.
     */
    name: string;
}

export interface GetZeroTrustGatewayCertificatesResult {
    /**
     * The deployment status of the certificate on Cloudflare's edge. Certificates in the 'available' (previously called 'active') state may be used for Gateway TLS interception.
     */
    bindingStatus: string;
    /**
     * The CA certificate
     */
    certificate: string;
    createdAt: string;
    expiresOn: string;
    /**
     * The SHA256 fingerprint of the certificate.
     */
    fingerprint: string;
    /**
     * Certificate UUID tag.
     */
    id: string;
    /**
     * Use this certificate for Gateway TLS interception
     */
    inUse: boolean;
    /**
     * The organization that issued the certificate.
     */
    issuerOrg: string;
    /**
     * The entire issuer field of the certificate.
     */
    issuerRaw: string;
    /**
     * The type of certificate, either BYO-PKI (custom) or Gateway-managed.
     */
    type: string;
    updatedAt: string;
    uploadedOn: string;
}

<<<<<<< HEAD
export interface GetZeroTrustGatewayPoliciesResult {
    /**
     * The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to `true`.
     */
    action: string;
    createdAt: string;
    /**
     * Date of deletion, if any.
     */
    deletedAt: string;
    /**
=======
export interface GetZeroTrustGatewayLoggingSettingsByRuleType {
    /**
     * Logging settings for DNS firewall.
     */
    dns: string;
    /**
     * Logging settings for HTTP/HTTPS firewall.
     */
    http: string;
    /**
     * Logging settings for Network firewall.
     */
    l4: string;
}

export interface GetZeroTrustGatewayPoliciesResult {
    /**
     * The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to `true`.
     */
    action: string;
    createdAt: string;
    /**
     * Date of deletion, if any.
     */
    deletedAt: string;
    /**
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     * The description of the rule.
     */
    description: string;
    /**
     * The wirefilter expression used for device posture check matching.
     */
    devicePosture: string;
    /**
     * True if the rule is enabled.
     */
    enabled: boolean;
    /**
     * The expiration time stamp and default duration of a DNS policy. Takes
     * precedence over the policy's `schedule` configuration, if any.
     */
    expiration: outputs.GetZeroTrustGatewayPoliciesResultExpiration;
    /**
     * The protocol or layer to evaluate the traffic, identity, and device posture expressions.
     */
    filters: string[];
    /**
     * The API resource UUID.
     */
    id: string;
    /**
     * The wirefilter expression used for identity matching.
     */
    identity: string;
    /**
     * The name of the rule.
     */
    name: string;
    /**
     * Precedence sets the order of your rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value.
     */
    precedence: number;
    /**
     * Additional settings that modify the rule's action.
     */
    ruleSettings: outputs.GetZeroTrustGatewayPoliciesResultRuleSettings;
    /**
     * The schedule for activating DNS policies. This does not apply to HTTP or network policies.
     */
    schedule: outputs.GetZeroTrustGatewayPoliciesResultSchedule;
    /**
     * The wirefilter expression used for traffic matching.
     */
    traffic: string;
    updatedAt: string;
    /**
     * version number of the rule
     */
    version: number;
}

export interface GetZeroTrustGatewayPoliciesResultExpiration {
    /**
     * The default duration a policy will be active in minutes. Must be set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration: number;
    /**
     * Whether the policy has expired.
     */
    expired: boolean;
    /**
     * The time stamp at which the policy will expire and cease to be
     * applied.
     */
    expiresAt: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettings {
    /**
     * Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
     */
    addHeaders: {[key: string]: string};
    /**
     * Set by parent MSP accounts to enable their children to bypass this rule.
     */
    allowChildBypass: boolean;
    /**
     * Settings for the Audit SSH action.
     */
    auditSsh: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControls;
    /**
     * Enable the custom block page.
     */
    blockPageEnabled: boolean;
    /**
     * The text describing why this block occurred, displayed on the custom block page (if enabled).
     */
    blockReason: string;
    /**
     * Set by children MSP accounts to bypass their parent's rules.
     */
    bypassParentRule: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
     */
    dnsResolvers: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
     */
    egress: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsEgress;
    /**
     * Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
     */
    ignoreCnameCategoryMatches: boolean;
    /**
     * INSECURE - disable DNSSEC validation (for Allow actions).
     */
    insecureDisableDnssecValidation: boolean;
    /**
     * Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
     */
    ipCategories: boolean;
    /**
     * Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
     */
    ipIndicatorFeeds: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port.
     */
    l4override: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule is matched.
     */
    notificationSettings: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettings;
    /**
     * Override matching DNS queries with a hostname.
     */
    overrideHost: string;
    /**
     * Override matching DNS queries with an IP or set of IPs.
     */
    overrideIps: string[];
    /**
     * Configure DLP payload logging.
     */
    payloadLog: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLog;
    /**
     * Settings that apply to quarantine rules
     */
    quarantine: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantine;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsInternally: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsThroughCloudflare: boolean;
    /**
     * Configure behavior when an upstream cert is invalid or an SSL error occurs.
     */
    untrustedCert: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCert;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsAuditSsh {
    /**
     * Enable to turn on SSH command logging.
     */
    commandLogging: boolean;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsBisoAdminControls {
    /**
     * Configure whether copy is enabled or not. When set with "remoteOnly", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
     */
    copy: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk: boolean;
    /**
     * Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
     */
    download: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du: boolean;
    /**
     * Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
     */
    keyboard: string;
    /**
     * Configure whether pasting is enabled or not. When set with "remoteOnly", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
     */
    paste: string;
    /**
     * Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
     */
    printing: string;
    /**
     * Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
     */
    upload: string;
    /**
     * Indicates which version of the browser isolation controls should apply.
     */
    version: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: string;
    /**
     * Set to true to enable session enforcement.
     */
    enforce: boolean;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolvers {
    ipv4s: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4[];
    ipv6s: outputs.GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6[];
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv4 {
    /**
     * IPv4 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsDnsResolversIpv6 {
    /**
     * IPv6 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4: string;
    /**
     * The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsL4override {
    /**
     * IPv4 or IPv6 address.
     */
    ip: string;
    /**
     * A port number to use for TCP/UDP overrides.
     */
    port: number;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsNotificationSettings {
    /**
     * Set notification on
     */
    enabled: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsPayloadLog {
    /**
     * Set to true to enable DLP payload logging for this rule.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsQuarantine {
    /**
     * Types of files to sandbox.
     */
    fileTypes: string[];
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsResolveDnsInternally {
    /**
     * The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
     */
    fallback: string;
    /**
     * The internal DNS view identifier that's passed to the internal DNS service.
     */
    viewId: string;
}

export interface GetZeroTrustGatewayPoliciesResultRuleSettingsUntrustedCert {
    /**
     * The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
     */
    action: string;
}

export interface GetZeroTrustGatewayPoliciesResultSchedule {
    /**
     * The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
     */
    fri: string;
    /**
     * The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
     */
    mon: string;
    /**
     * The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
     */
    sat: string;
    /**
     * The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
     */
    sun: string;
    /**
     * The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
     */
    thu: string;
    /**
     * The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
     */
    timeZone: string;
    /**
     * The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
     */
    tue: string;
    /**
     * The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
     */
    wed: string;
}

export interface GetZeroTrustGatewayPolicyExpiration {
    /**
     * The default duration a policy will be active in minutes. Must be set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration: number;
    /**
     * Whether the policy has expired.
     */
    expired: boolean;
    /**
     * The time stamp at which the policy will expire and cease to be
     * applied.
     */
    expiresAt: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettings {
    /**
     * Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
     */
    addHeaders: {[key: string]: string};
    /**
     * Set by parent MSP accounts to enable their children to bypass this rule.
     */
    allowChildBypass: boolean;
    /**
     * Settings for the Audit SSH action.
     */
    auditSsh: outputs.GetZeroTrustGatewayPolicyRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls: outputs.GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControls;
    /**
     * Enable the custom block page.
     */
    blockPageEnabled: boolean;
    /**
     * The text describing why this block occurred, displayed on the custom block page (if enabled).
     */
    blockReason: string;
    /**
     * Set by children MSP accounts to bypass their parent's rules.
     */
    bypassParentRule: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession: outputs.GetZeroTrustGatewayPolicyRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
     */
    dnsResolvers: outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
     */
    egress: outputs.GetZeroTrustGatewayPolicyRuleSettingsEgress;
    /**
     * Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
     */
    ignoreCnameCategoryMatches: boolean;
    /**
     * INSECURE - disable DNSSEC validation (for Allow actions).
     */
    insecureDisableDnssecValidation: boolean;
    /**
     * Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
     */
    ipCategories: boolean;
    /**
     * Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
     */
    ipIndicatorFeeds: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port.
     */
    l4override: outputs.GetZeroTrustGatewayPolicyRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule is matched.
     */
    notificationSettings: outputs.GetZeroTrustGatewayPolicyRuleSettingsNotificationSettings;
    /**
     * Override matching DNS queries with a hostname.
     */
    overrideHost: string;
    /**
     * Override matching DNS queries with an IP or set of IPs.
     */
    overrideIps: string[];
    /**
     * Configure DLP payload logging.
     */
    payloadLog: outputs.GetZeroTrustGatewayPolicyRuleSettingsPayloadLog;
    /**
     * Settings that apply to quarantine rules
     */
    quarantine: outputs.GetZeroTrustGatewayPolicyRuleSettingsQuarantine;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsInternally: outputs.GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsThroughCloudflare: boolean;
    /**
     * Configure behavior when an upstream cert is invalid or an SSL error occurs.
     */
    untrustedCert: outputs.GetZeroTrustGatewayPolicyRuleSettingsUntrustedCert;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsAuditSsh {
    /**
     * Enable to turn on SSH command logging.
     */
    commandLogging: boolean;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsBisoAdminControls {
    /**
     * Configure whether copy is enabled or not. When set with "remoteOnly", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
     */
    copy: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk: boolean;
    /**
     * Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
     */
    download: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du: boolean;
    /**
     * Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
     */
    keyboard: string;
    /**
     * Configure whether pasting is enabled or not. When set with "remoteOnly", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
     */
    paste: string;
    /**
     * Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
     */
    printing: string;
    /**
     * Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
     */
    upload: string;
    /**
     * Indicates which version of the browser isolation controls should apply.
     */
    version: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: string;
    /**
     * Set to true to enable session enforcement.
     */
    enforce: boolean;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsDnsResolvers {
    ipv4s: outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4[];
    ipv6s: outputs.GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6[];
}

export interface GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4 {
    /**
     * IPv4 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6 {
    /**
     * IPv6 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4: string;
    /**
     * The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsL4override {
    /**
     * IPv4 or IPv6 address.
     */
    ip: string;
    /**
     * A port number to use for TCP/UDP overrides.
     */
    port: number;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsNotificationSettings {
    /**
     * Set notification on
     */
    enabled: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsPayloadLog {
    /**
     * Set to true to enable DLP payload logging for this rule.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsQuarantine {
    /**
     * Types of files to sandbox.
     */
    fileTypes: string[];
}

export interface GetZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally {
    /**
     * The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
     */
    fallback: string;
    /**
     * The internal DNS view identifier that's passed to the internal DNS service.
     */
    viewId: string;
}

export interface GetZeroTrustGatewayPolicyRuleSettingsUntrustedCert {
    /**
     * The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
     */
    action: string;
}

export interface GetZeroTrustGatewayPolicySchedule {
    /**
     * The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
     */
    fri: string;
    /**
     * The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
     */
    mon: string;
    /**
     * The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
     */
    sat: string;
    /**
     * The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
     */
    sun: string;
    /**
     * The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
     */
    thu: string;
    /**
     * The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
     */
    timeZone: string;
    /**
     * The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
     */
    tue: string;
    /**
     * The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
     */
    wed: string;
}

export interface GetZeroTrustGatewaySettingsSettings {
    /**
     * Activity log settings.
     */
    activityLog: outputs.GetZeroTrustGatewaySettingsSettingsActivityLog;
    /**
     * Anti-virus settings.
     */
    antivirus: outputs.GetZeroTrustGatewaySettingsSettingsAntivirus;
    /**
     * Block page layout settings.
     */
    blockPage: outputs.GetZeroTrustGatewaySettingsSettingsBlockPage;
    /**
     * DLP body scanning settings.
     */
    bodyScanning: outputs.GetZeroTrustGatewaySettingsSettingsBodyScanning;
    /**
     * Browser isolation settings.
     */
    browserIsolation: outputs.GetZeroTrustGatewaySettingsSettingsBrowserIsolation;
    /**
     * Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
     */
    certificate: outputs.GetZeroTrustGatewaySettingsSettingsCertificate;
    /**
     * Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
     */
    customCertificate: outputs.GetZeroTrustGatewaySettingsSettingsCustomCertificate;
    /**
     * Extended e-mail matching settings.
     */
    extendedEmailMatching: outputs.GetZeroTrustGatewaySettingsSettingsExtendedEmailMatching;
    /**
     * FIPS settings.
     */
    fips: outputs.GetZeroTrustGatewaySettingsSettingsFips;
    /**
     * Protocol Detection settings.
     */
    protocolDetection: outputs.GetZeroTrustGatewaySettingsSettingsProtocolDetection;
    /**
     * Sandbox settings.
     */
    sandbox: outputs.GetZeroTrustGatewaySettingsSettingsSandbox;
    /**
     * TLS interception settings.
     */
    tlsDecrypt: outputs.GetZeroTrustGatewaySettingsSettingsTlsDecrypt;
}

export interface GetZeroTrustGatewaySettingsSettingsActivityLog {
    /**
     * Enable activity logging.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsAntivirus {
    /**
     * Enable anti-virus scanning on downloads.
     */
    enabledDownloadPhase: boolean;
    /**
     * Enable anti-virus scanning on uploads.
     */
    enabledUploadPhase: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: boolean;
    /**
     * Configure a message to display on the user's device when an antivirus search is performed.
     */
    notificationSettings: outputs.GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings;
}

export interface GetZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings {
    /**
     * Set notification on
     */
    enabled: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl: string;
}

export interface GetZeroTrustGatewaySettingsSettingsBlockPage {
    /**
     * Block page background color in #rrggbb format.
     */
    backgroundColor: string;
    /**
     * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
     */
    enabled: boolean;
    /**
     * Block page footer text.
     */
    footerText: string;
    /**
     * Block page header text.
     */
    headerText: string;
    /**
     * Full URL to the logo file.
     */
    logoPath: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject: string;
    /**
     * Block page title.
     */
    name: string;
    /**
     * Suppress detailed info at the bottom of the block page.
     */
    suppressFooter: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsBodyScanning {
    /**
     * Set the inspection mode to either `deep` or `shallow`.
     */
    inspectionMode: string;
}

export interface GetZeroTrustGatewaySettingsSettingsBrowserIsolation {
    /**
     * Enable non-identity onramp support for Browser Isolation.
     */
    nonIdentityEnabled: boolean;
    /**
     * Enable Clientless Browser Isolation.
     */
    urlBrowserIsolationEnabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsCertificate {
    /**
     * UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
     */
    id: string;
}

export interface GetZeroTrustGatewaySettingsSettingsCustomCertificate {
    /**
     * Certificate status (internal).
     */
    bindingStatus: string;
    /**
     * Enable use of custom certificate authority for signing Gateway traffic.
     */
    enabled: boolean;
    /**
     * UUID of certificate (ID from MTLS certificate store).
     */
    id: string;
    updatedAt: string;
}

export interface GetZeroTrustGatewaySettingsSettingsExtendedEmailMatching {
    /**
     * Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsFips {
    /**
     * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
     */
    tls: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsProtocolDetection {
    /**
     * Enable detecting protocol on initial bytes of client traffic.
     */
    enabled: boolean;
}

export interface GetZeroTrustGatewaySettingsSettingsSandbox {
    /**
     * Enable sandbox.
     */
    enabled: boolean;
    /**
     * Action to take when the file cannot be scanned.
     */
    fallbackAction: string;
}

export interface GetZeroTrustGatewaySettingsSettingsTlsDecrypt {
    /**
     * Enable inspecting encrypted HTTP traffic.
     */
    enabled: boolean;
}

export interface GetZeroTrustListFilter {
    /**
     * The type of list.
     */
    type?: string;
}

export interface GetZeroTrustListsResult {
    createdAt: string;
    /**
     * The description of the list.
     */
    description: string;
    /**
     * API Resource UUID tag.
     */
    id: string;
    /**
     * The number of items in the list.
     */
    listCount: number;
    /**
     * The name of the list.
     */
    name: string;
    /**
     * The type of list.
     */
    type: string;
    updatedAt: string;
}

export interface GetZeroTrustOrganizationCustomPages {
    /**
     * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
     */
    forbidden: string;
    /**
     * The uid of the custom page to use when a user is denied access.
     */
    identityDenied: string;
}

export interface GetZeroTrustOrganizationLoginDesign {
    /**
     * The background color on your login page.
     */
    backgroundColor: string;
    /**
     * The text at the bottom of your login page.
     */
    footerText: string;
    /**
     * The text at the top of your login page.
     */
    headerText: string;
    /**
     * The URL of the logo on your login page.
     */
    logoPath: string;
    /**
     * The text color on your login page.
     */
    textColor: string;
}

export interface GetZeroTrustRiskBehaviorBehaviors {
    description: string;
    enabled: boolean;
    name: string;
    riskLevel: string;
}

export interface GetZeroTrustRiskScoringIntegrationsResult {
    /**
     * The Cloudflare account tag.
     */
    accountTag: string;
    /**
     * Whether this integration is enabled and should export changes in risk score.
     */
    active: boolean;
    /**
     * When the integration was created in RFC3339 format.
     */
    createdAt: string;
    /**
     * The id of the integration, a UUIDv4.
     */
    id: string;
    integrationType: string;
    /**
     * A reference ID defined by the client.
     * Should be set to the Access-Okta IDP integration ID.
     * Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that ID.
     */
    referenceId: string;
    /**
     * The base URL for the tenant. E.g. "https://tenant.okta.com"
     */
    tenantUrl: string;
    /**
     * The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration*uuid}/". https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1
     */
    wellKnownUrl: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfig {
    /**
     * List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
     */
    ingresses: outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngress[];
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest: outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequest;
    /**
     * Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
     */
    warpRouting: outputs.GetZeroTrustTunnelCloudflaredConfigConfigWarpRouting;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigIngress {
    /**
     * Public hostname for this service.
     */
    hostname: string;
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest: outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest;
    /**
     * Requests with this path route to this public hostname.
     */
    path: string;
    /**
     * Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
     */
    service: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access: outputs.GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout: number;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required: boolean;
    teamName: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access: outputs.GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout: number;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required: boolean;
    teamName: string;
}

export interface GetZeroTrustTunnelCloudflaredConfigConfigWarpRouting {
    enabled: boolean;
}

export interface GetZeroTrustTunnelCloudflaredConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface GetZeroTrustTunnelCloudflaredFilter {
    excludePrefix?: string;
    /**
     * If provided, include only tunnels that were created (and not deleted) before this time.
     */
    existedAt?: string;
    includePrefix?: string;
    /**
     * If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
     */
    isDeleted?: boolean;
    /**
     * A user-friendly name for a tunnel.
     */
    name?: string;
    /**
     * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
     */
    status?: string;
    /**
     * UUID of the tunnel.
     */
    uuid?: string;
    wasActiveAt?: string;
    wasInactiveAt?: string;
}

export interface GetZeroTrustTunnelCloudflaredRouteFilter {
    /**
     * Optional remark describing the route.
     */
    comment?: string;
    /**
     * If provided, include only tunnels that were created (and not deleted) before this time.
     */
    existedAt?: string;
    /**
     * If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
     */
    isDeleted?: boolean;
    /**
     * If set, only list routes that are contained within this IP range.
     */
    networkSubset?: string;
    /**
     * If set, only list routes that contain this IP range.
     */
    networkSuperset?: string;
    /**
     * UUID of the route.
     */
    routeId?: string;
    /**
     * The types of tunnels to filter separated by a comma.
     */
    tunTypes?: string;
    /**
     * UUID of the tunnel.
     */
    tunnelId?: string;
    /**
     * UUID of the virtual network.
     */
    virtualNetworkId?: string;
}

export interface GetZeroTrustTunnelCloudflaredRoutesResult {
    /**
     * Optional remark describing the route.
     */
    comment: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the route.
     */
    id: string;
    /**
     * The private IPv4 or IPv6 range connected by the route, in CIDR notation.
     */
    network: string;
    /**
     * The type of tunnel.
     */
    tunType: string;
    /**
     * UUID of the tunnel.
     */
    tunnelId: string;
    /**
     * A user-friendly name for a tunnel.
     */
    tunnelName: string;
    /**
     * UUID of the virtual network.
     */
    virtualNetworkId: string;
    /**
     * A user-friendly name for the virtual network.
     */
    virtualNetworkName: string;
}

export interface GetZeroTrustTunnelCloudflaredVirtualNetworkFilter {
    /**
     * UUID of the virtual network.
     */
    id?: string;
    /**
     * If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
     */
    isDefault?: boolean;
    /**
     * If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
     */
    isDeleted?: boolean;
    /**
     * A user-friendly name for the virtual network.
     */
    name?: string;
}

export interface GetZeroTrustTunnelCloudflaredVirtualNetworksResult {
    /**
     * Optional remark describing the virtual network.
     */
    comment: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the virtual network.
     */
    id: string;
    /**
     * If `true`, this virtual network is the default for the account.
     */
    isDefaultNetwork: boolean;
    /**
     * A user-friendly name for the virtual network.
     */
    name: string;
}

export interface GetZeroTrustTunnelCloudflaredsResult {
    /**
     * Cloudflare account ID
     */
    accountTag: string;
    /**
     * The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
     */
    connections: outputs.GetZeroTrustTunnelCloudflaredsResultConnection[];
    /**
     * Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
     */
    connsActiveAt: string;
    /**
     * Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
     */
    connsInactiveAt: string;
    /**
     * Timestamp of when the resource was created.
     */
    createdAt: string;
    /**
     * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
     */
    deletedAt: string;
    /**
     * UUID of the tunnel.
     */
    id: string;
    /**
     * Metadata associated with the tunnel.
     */
    metadata: string;
    /**
     * A user-friendly name for a tunnel.
     */
    name: string;
    /**
     * If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
     */
    remoteConfig: boolean;
    /**
     * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
     */
    status: string;
    /**
     * The type of tunnel.
     */
    tunType: string;
}

export interface GetZeroTrustTunnelCloudflaredsResultConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface GetZoneAccount {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the account
     */
    name: string;
}

export interface GetZoneFilter {
    account?: outputs.GetZoneFilterAccount;
    /**
     * Direction to order zones.
     */
    direction?: string;
    /**
     * Whether to match all search requirements or at least one (any).
     */
    match: string;
    /**
     * A domain name. Optional filter operators can be provided to extend refine the search:
     *   * `equal` (default)
     *   * `notEqual`
     *   * `startsWith`
     *   * `endsWith`
     *   * `contains`
     *   * `startsWithCaseSensitive`
     *   * `endsWithCaseSensitive`
     *   * `containsCaseSensitive`
     */
    name?: string;
    /**
     * Field to order zones by.
     */
    order?: string;
    /**
     * A zone status
     */
    status?: string;
}

export interface GetZoneFilterAccount {
    /**
     * An account ID
     */
    id?: string;
    /**
     * An account Name. Optional filter operators can be provided to extend refine the search:
     *   * `equal` (default)
     *   * `notEqual`
     *   * `startsWith`
     *   * `endsWith`
     *   * `contains`
     *   * `startsWithCaseSensitive`
     *   * `endsWithCaseSensitive`
     *   * `containsCaseSensitive`
     */
    name?: string;
}

export interface GetZoneLockdownConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetZoneLockdownFilter {
    /**
     * The timestamp of when the rule was created.
     */
    createdOn?: string;
    /**
     * A string to search for in the description of existing rules.
     */
    description?: string;
    /**
     * A string to search for in the description of existing rules.
     */
    descriptionSearch?: string;
    /**
     * A single IP address to search for in existing rules.
     */
    ip?: string;
    /**
     * A single IP address range to search for in existing rules.
     */
    ipRangeSearch?: string;
    /**
     * A single IP address to search for in existing rules.
     */
    ipSearch?: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    modifiedOn?: string;
    /**
     * The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
     */
    priority?: number;
    /**
     * A single URI to search for in the list of URLs of existing rules.
     */
    uriSearch?: string;
}

export interface GetZoneLockdownsResult {
    /**
     * A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ipRange` configurations.
     */
    configurations: outputs.GetZoneLockdownsResultConfiguration[];
    /**
     * The timestamp of when the rule was created.
     */
    createdOn: string;
    /**
     * An informative summary of the rule.
     */
    description: string;
    /**
     * The unique identifier of the Zone Lockdown rule.
     */
    id: string;
    /**
     * The timestamp of when the rule was last modified.
     */
    modifiedOn: string;
    /**
     * When true, indicates that the rule is currently paused.
     */
    paused: boolean;
    /**
     * The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
     */
    urls: string[];
}

export interface GetZoneLockdownsResultConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
     */
    target: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value: string;
}

export interface GetZoneMeta {
    /**
     * The zone is only configured for CDN
     */
    cdnOnly: boolean;
    /**
     * Number of Custom Certificates the zone can have
     */
    customCertificateQuota: number;
    /**
     * The zone is only configured for DNS
     */
    dnsOnly: boolean;
    /**
     * The zone is setup with Foundation DNS
     */
    foundationDns: boolean;
    /**
     * Number of Page Rules a zone can have
     */
    pageRuleQuota: number;
    /**
     * The zone has been flagged for phishing
     */
    phishingDetected: boolean;
    step: number;
}

export interface GetZoneOwner {
    /**
     * Identifier
     */
    id: string;
    /**
     * Name of the owner
     */
    name: string;
    /**
     * The type of owner
     */
    type: string;
}

export interface GetZonesAccount {
    /**
     * An account ID
     */
    id?: string;
    /**
     * An account Name. Optional filter operators can be provided to extend refine the search:
     *   * `equal` (default)
     *   * `notEqual`
     *   * `startsWith`
     *   * `endsWith`
     *   * `contains`
     *   * `startsWithCaseSensitive`
     *   * `endsWithCaseSensitive`
     *   * `containsCaseSensitive`
     */
    name?: string;
}

export interface GetZonesResult {
    /**
     * The account the zone belongs to
     */
    account: outputs.GetZonesResultAccount;
    /**
     * The last time proof of ownership was detected and the zone was made
     * active
     */
    activatedOn: string;
    /**
     * When the zone was created
     */
    createdOn: string;
    /**
     * The interval (in seconds) from when development mode expires
     * (positive integer) or last expired (negative integer) for the
     * domain. If development mode has never been enabled, this value is 0.
     */
    developmentMode: number;
    /**
     * Identifier
     */
    id: string;
    /**
     * Metadata about the zone
     */
    meta: outputs.GetZonesResultMeta;
    /**
     * When the zone was last modified
     */
    modifiedOn: string;
    /**
     * The domain name
     */
    name: string;
    /**
     * The name servers Cloudflare assigns to a zone
     */
    nameServers: string[];
    /**
     * DNS host at the time of switching to Cloudflare
     */
    originalDnshost: string;
    /**
     * Original name servers before moving to Cloudflare
     */
    originalNameServers: string[];
    /**
     * Registrar for the domain at the time of switching to Cloudflare
     */
    originalRegistrar: string;
    /**
     * The owner of the zone
     */
    owner: outputs.GetZonesResultOwner;
    /**
     * Indicates whether the zone is only using Cloudflare DNS services. A
     * true value means the zone will not receive security or performance
     * benefits.
     */
    paused: boolean;
    /**
     * The zone status on Cloudflare.
     */
    status: string;
    /**
     * A full zone implies that DNS is hosted with Cloudflare. A partial zone is
     * typically a partner-hosted zone or a CNAME setup.
     */
    type: string;
    /**
     * An array of domains used for custom name servers. This is only available for Business and Enterprise plans.
     */
    vanityNameServers: string[];
<<<<<<< HEAD
=======
    /**
     * Verification key for partial zone setup.
     */
    verificationKey: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface GetZonesResultAccount {
    /**
     * Identifier
     */
    id: string;
    /**
     * The name of the account
     */
    name: string;
}

export interface GetZonesResultMeta {
    /**
     * The zone is only configured for CDN
     */
    cdnOnly: boolean;
    /**
     * Number of Custom Certificates the zone can have
     */
    customCertificateQuota: number;
    /**
     * The zone is only configured for DNS
     */
    dnsOnly: boolean;
    /**
     * The zone is setup with Foundation DNS
     */
    foundationDns: boolean;
    /**
     * Number of Page Rules a zone can have
     */
    pageRuleQuota: number;
    /**
     * The zone has been flagged for phishing
     */
    phishingDetected: boolean;
    step: number;
}

export interface GetZonesResultOwner {
    /**
     * Identifier
     */
    id: string;
    /**
     * Name of the owner
     */
    name: string;
    /**
     * The type of owner
     */
    type: string;
}

export interface HealthcheckHttpConfig {
    /**
     * Do not validate the certificate when the health check uses HTTPS.
     */
    allowInsecure: boolean;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
     */
    expectedBody?: string;
    /**
     * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
     */
    expectedCodes?: string[];
    /**
     * Follow redirects if the origin returns a 3xx status code.
     */
    followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
     */
    header?: {[key: string]: string[]};
    /**
     * The HTTP method to use for the health check.
     */
    method: string;
    /**
     * The endpoint path to health check against.
     */
    path: string;
    /**
     * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
     */
    port: number;
}

export interface HealthcheckTcpConfig {
    /**
     * The TCP connection method to use for the health check.
     */
    method: string;
    /**
     * Port number to connect to for the health check. Defaults to 80.
     */
    port: number;
}

export interface HyperdriveConfigCaching {
    /**
     * When set to true, disables the caching of SQL responses. (Default: false)
     */
    disabled: boolean;
    /**
     * When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
     */
    maxAge?: number;
    /**
     * When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
     */
    staleWhileRevalidate?: number;
}

export interface HyperdriveConfigOrigin {
    /**
     * The Client ID of the Access token to use when connecting to the origin database.
     */
    accessClientId?: string;
    /**
     * The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
     */
    accessClientSecret?: string;
    /**
     * The name of your origin database.
     */
    database: string;
    /**
     * The host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * The password required to access your origin database. This value is write-only and never returned by the API.
     */
    password: string;
    /**
     * The port (default: 5432 for Postgres) of your origin database.
     */
    port?: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     */
    scheme: string;
    /**
     * The user of your origin database.
     */
    user: string;
}

export interface ImageVariantOptions {
    /**
     * The fit property describes how the width and height dimensions should be interpreted.
     */
    fit: string;
    /**
     * Maximum height in image pixels.
     */
    height: number;
    /**
     * What EXIF data should be preserved in the output image.
     */
    metadata: string;
    /**
     * Maximum width in image pixels.
     */
    width: number;
}

export interface ImageVariantVariant {
    id: string;
    /**
     * Indicates whether the variant can access an image without a signature, regardless of image access control.
     */
    neverRequireSignedUrls: boolean;
    /**
     * Allows you to define image resizing sizes for different use cases.
     */
    options: outputs.ImageVariantVariantOptions;
}

export interface ImageVariantVariantOptions {
    /**
     * The fit property describes how the width and height dimensions should be interpreted.
     */
    fit: string;
    /**
     * Maximum height in image pixels.
     */
    height: number;
    /**
     * What EXIF data should be preserved in the output image.
     */
    metadata: string;
    /**
     * Maximum width in image pixels.
     */
    width: number;
}

export interface KeylessCertificateTunnel {
    /**
     * Private IP of the Key Server Host
     */
    privateIp: string;
    /**
     * Cloudflare Tunnel Virtual Network ID
     */
    vnetId: string;
}

export interface ListItemHostname {
    urlHostname: string;
}

export interface ListItemRedirect {
    includeSubdomains: boolean;
    preservePathSuffix: boolean;
    preserveQueryString: boolean;
    sourceUrl: string;
    statusCode: number;
    subpathMatching: boolean;
    targetUrl: string;
}

export interface LoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface LoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
     */
    defaultPercent: number;
    /**
     * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
     */
    defaultPolicy: string;
    /**
     * The percent of existing sessions to shed from the pool, according to the session policy.
     */
    sessionPercent: number;
    /**
     * Only the hash policy is supported for existing sessions (to avoid exponential decay).
     */
    sessionPolicy: string;
}

export interface LoadBalancerPoolNotificationFilter {
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    origin: outputs.LoadBalancerPoolNotificationFilterOrigin;
    /**
     * Filter options for a particular resource type (pool or origin). Use null to reset.
     */
    pool: outputs.LoadBalancerPoolNotificationFilterPool;
}

export interface LoadBalancerPoolNotificationFilterOrigin {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy?: boolean;
}

export interface LoadBalancerPoolNotificationFilterPool {
    /**
     * If set true, disable notifications for this type of resource (pool or origin).
     */
    disable: boolean;
    /**
     * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
     */
    healthy?: boolean;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
     */
    address?: string;
    /**
     * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
     */
    disabledAt: string;
    /**
     * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
     */
    enabled: boolean;
    /**
     * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
     */
    header?: outputs.LoadBalancerPoolOriginHeader;
    /**
     * A human-identifiable name for the origin.
     */
    name?: string;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId?: string;
    /**
     * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
     */
    weight: number;
}

export interface LoadBalancerPoolOriginHeader {
    /**
     * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
     */
    hosts?: string[];
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * The type of origin steering policy to use.
     */
    policy: string;
}

export interface LoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRule {
    /**
     * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixedResponse in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
     */
    condition?: string;
    /**
     * Disable this specific rule. It will no longer be evaluated by this load balancer.
     */
    disabled: boolean;
    /**
     * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
     */
    fixedResponse: outputs.LoadBalancerRuleFixedResponse;
    /**
     * Name of this rule. Only used for human readability.
     */
    name?: string;
    /**
     * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
     */
    overrides: outputs.LoadBalancerRuleOverrides;
    /**
     * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
     */
    priority: number;
    /**
     * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
     */
    terminates: boolean;
}

export interface LoadBalancerRuleFixedResponse {
    /**
     * The http 'Content-Type' header to include in the response.
     */
    contentType?: string;
    /**
     * The http 'Location' header to include in the response.
     */
    location?: string;
    /**
     * Text to include as the http body.
     */
    messageBody?: string;
    /**
     * The http status code to respond with.
     */
    statusCode?: number;
}

export interface LoadBalancerRuleOverrides {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
     */
    adaptiveRouting: outputs.LoadBalancerRuleOverridesAdaptiveRouting;
    /**
     * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
     */
    countryPools: {[key: string]: string[]};
    /**
     * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when regionPools are not configured for a given region.
     */
    defaultPools?: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool?: string;
    /**
     * Controls location-based steering for non-proxied requests. See `steeringPolicy` to learn how steering is affected.
     */
    locationStrategy: outputs.LoadBalancerRuleOverridesLocationStrategy;
    /**
     * (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
     */
    popPools: {[key: string]: string[]};
    /**
     * Configures pool weights.
     */
    randomSteering: outputs.LoadBalancerRuleOverridesRandomSteering;
    /**
     * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
     */
    regionPools: {[key: string]: string[]};
    /**
     * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
     */
    sessionAffinity: string;
    /**
     * Configures attributes for session affinity.
     */
    sessionAffinityAttributes: outputs.LoadBalancerRuleOverridesSessionAffinityAttributes;
    /**
     * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `sessionAffinity` policy are:
     */
    sessionAffinityTtl: number;
    /**
     * Steering Policy for this load balancer.
     */
    steeringPolicy: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
     */
    ttl: number;
}

export interface LoadBalancerRuleOverridesAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `sessionAffinityAttributes` for control over when sessions are broken or reassigned.
     */
    failoverAcrossPools: boolean;
}

export interface LoadBalancerRuleOverridesLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
     */
    mode: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
     */
    preferEcs: string;
}

export interface LoadBalancerRuleOverridesRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the poolWeights map.
     */
    defaultWeight: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRuleOverridesSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers?: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
     */
    zeroDowntimeFailover: string;
}

export interface LoadBalancerSessionAffinityAttributes {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
     */
    drainDuration: number;
    /**
     * Configures the names of HTTP headers to base session affinity on when header `sessionAffinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
     */
    headers?: string[];
    /**
     * When header `sessionAffinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
     */
    requireAllHeaders: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
     */
    samesite: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
     */
    secure: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
     */
    zeroDowntimeFailover: string;
}

export interface LogpushJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix: string;
    /**
     * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
     */
    cve20214428: boolean;
    /**
     * String to join fields. This field be ignored when `recordTemplate` is set.
     */
    fieldDelimiter: string;
    /**
     * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
     */
    fieldNames?: string[];
    /**
     * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
     */
    outputType: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter: string;
    /**
     * String to be prepended before each record.
     */
    recordPrefix: string;
    /**
     * String to be appended after each record.
     */
    recordSuffix: string;
    /**
     * String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `fieldNames` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
     */
    recordTemplate: string;
    /**
     * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sampleInterval` of the data.
     */
    sampleRate: number;
    /**
     * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
     */
    timestampFormat: string;
}

export interface MagicNetworkMonitoringConfigurationWarpDevice {
    /**
     * Unique identifier for the warp device.
     */
    id: string;
    /**
     * Name of the warp device.
     */
    name: string;
    /**
     * IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
     */
    routerIp: string;
}

export interface MagicTransitConnectorDevice {
    id: string;
    serialNumber: string;
}

export interface MagicTransitSiteAclLan1 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName?: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges?: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports?: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets?: string[];
}

export interface MagicTransitSiteAclLan2 {
    /**
     * The identifier for the LAN you want to create an ACL policy with.
     */
    lanId: string;
    /**
     * The name of the LAN based on the provided lan_id.
     */
    lanName?: string;
    /**
     * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
     */
    portRanges?: string[];
    /**
     * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
     */
    ports?: number[];
    /**
     * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
     */
    subnets?: string[];
}

export interface MagicTransitSiteLanNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix?: string;
}

export interface MagicTransitSiteLanRoutedSubnet {
    nat: outputs.MagicTransitSiteLanRoutedSubnetNat;
    /**
     * A valid IPv4 address.
     */
    nextHop: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    prefix: string;
}

export interface MagicTransitSiteLanRoutedSubnetNat {
    /**
     * A valid CIDR notation representing an IP range.
     */
    staticPrefix?: string;
}

export interface MagicTransitSiteLanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    dhcpRelay: outputs.MagicTransitSiteLanStaticAddressingDhcpRelay;
    dhcpServer: outputs.MagicTransitSiteLanStaticAddressingDhcpServer;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress?: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    virtualAddress?: string;
}

export interface MagicTransitSiteLanStaticAddressingDhcpRelay {
    /**
     * List of DHCP server IPs.
     */
    serverAddresses?: string[];
}

export interface MagicTransitSiteLanStaticAddressingDhcpServer {
    /**
     * A valid IPv4 address.
     */
    dhcpPoolEnd?: string;
    /**
     * A valid IPv4 address.
     */
    dhcpPoolStart?: string;
    /**
     * A valid IPv4 address.
     */
    dnsServer?: string;
<<<<<<< HEAD
=======
    dnsServers?: string[];
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Mapping of MAC addresses to IP addresses
     */
    reservations?: {[key: string]: string};
}

export interface MagicTransitSiteLocation {
    /**
     * Latitude
     */
    lat?: string;
    /**
     * Longitude
     */
    lon?: string;
}

export interface MagicTransitSiteWanStaticAddressing {
    /**
     * A valid CIDR notation representing an IP range.
     */
    address: string;
    /**
     * A valid IPv4 address.
     */
    gatewayAddress: string;
    /**
     * A valid CIDR notation representing an IP range.
     */
    secondaryAddress?: string;
}

export interface MagicWanGreTunnelGreTunnel {
    /**
     * The IP address assigned to the Cloudflare side of the GRE tunnel.
     */
    cloudflareGreEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the GRE tunnel.
     */
    customerGreEndpoint: string;
    /**
     * An optional description of the GRE tunnel.
     */
    description: string;
    healthCheck: outputs.MagicWanGreTunnelGreTunnelHealthCheck;
    /**
     * Tunnel identifier tag.
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
     */
    mtu: number;
    /**
     * The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
     */
    name: string;
    /**
     * Time To Live (TTL) in number of hops of the GRE tunnel.
     */
    ttl: number;
}

export interface MagicWanGreTunnelGreTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanGreTunnelGreTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface MagicWanGreTunnelGreTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface MagicWanGreTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanGreTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface MagicWanGreTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved?: string;
}

export interface MagicWanGreTunnelModifiedGreTunnel {
    /**
     * The IP address assigned to the Cloudflare side of the GRE tunnel.
     */
    cloudflareGreEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the GRE tunnel.
     */
    customerGreEndpoint: string;
    /**
     * An optional description of the GRE tunnel.
     */
    description: string;
    healthCheck: outputs.MagicWanGreTunnelModifiedGreTunnelHealthCheck;
    /**
     * Tunnel identifier tag.
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
     */
    mtu: number;
    /**
     * The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
     */
    name: string;
    /**
     * Time To Live (TTL) in number of hops of the GRE tunnel.
     */
    ttl: number;
}

export interface MagicWanGreTunnelModifiedGreTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanGreTunnelModifiedGreTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface MagicWanGreTunnelModifiedGreTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface MagicWanIpsecTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanIpsecTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface MagicWanIpsecTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved?: string;
}

export interface MagicWanIpsecTunnelIpsecTunnel {
    /**
     * When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
     */
    allowNullCipher: boolean;
    /**
     * The IP address assigned to the Cloudflare side of the IPsec tunnel.
     */
    cloudflareEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
     */
    customerEndpoint: string;
    /**
     * An optional description forthe IPsec tunnel.
     */
    description: string;
    healthCheck: outputs.MagicWanIpsecTunnelIpsecTunnelHealthCheck;
    /**
     * Tunnel identifier tag.
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * The name of the IPsec tunnel. The name cannot share a name with other tunnels.
     */
    name: string;
    /**
     * The PSK metadata that includes when the PSK was generated.
     */
    pskMetadata: outputs.MagicWanIpsecTunnelIpsecTunnelPskMetadata;
    /**
     * If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
     */
    replayProtection: boolean;
}

export interface MagicWanIpsecTunnelIpsecTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanIpsecTunnelIpsecTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface MagicWanIpsecTunnelIpsecTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface MagicWanIpsecTunnelIpsecTunnelPskMetadata {
    /**
     * The date and time the tunnel was last modified.
     */
    lastGeneratedOn: string;
}

export interface MagicWanIpsecTunnelModifiedIpsecTunnel {
    /**
     * When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
     */
    allowNullCipher: boolean;
    /**
     * The IP address assigned to the Cloudflare side of the IPsec tunnel.
     */
    cloudflareEndpoint: string;
    /**
     * The date and time the tunnel was created.
     */
    createdOn: string;
    /**
     * The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
     */
    customerEndpoint: string;
    /**
     * An optional description forthe IPsec tunnel.
     */
    description: string;
    healthCheck: outputs.MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheck;
    /**
     * Tunnel identifier tag.
     */
    id: string;
    /**
     * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
     */
    interfaceAddress: string;
    /**
     * The date and time the tunnel was last modified.
     */
    modifiedOn: string;
    /**
     * The name of the IPsec tunnel. The name cannot share a name with other tunnels.
     */
    name: string;
    /**
     * The PSK metadata that includes when the PSK was generated.
     */
    pskMetadata: outputs.MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata;
    /**
     * If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
     */
    replayProtection: boolean;
}

export interface MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheck {
    /**
     * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
     */
    direction: string;
    /**
     * Determines whether to run healthchecks for a tunnel.
     */
    enabled: boolean;
    /**
     * How frequent the health check is run. The default value is `mid`.
     */
    rate: string;
    /**
     * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customerGreEndpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
     */
    target: outputs.MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTarget;
    /**
     * The type of healthcheck to run, reply or request. The default value is `reply`.
     */
    type: string;
}

export interface MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTarget {
    /**
     * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
     */
    effective: string;
    /**
     * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
     */
    saved: string;
}

export interface MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadata {
    /**
     * The date and time the tunnel was last modified.
     */
    lastGeneratedOn: string;
}

export interface MagicWanStaticRouteModifiedRoute {
    /**
     * When the route was created.
     */
    createdOn: string;
    /**
     * An optional human provided description of the static route.
     */
    description: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * When the route was last modified.
     */
    modifiedOn: string;
    /**
     * The next-hop IP Address for the static route.
     */
    nexthop: string;
    /**
     * IP Prefix in Classless Inter-Domain Routing format.
     */
    prefix: string;
    /**
     * Priority of the static route.
     */
    priority: number;
    /**
     * Used only for ECMP routes.
     */
    scope: outputs.MagicWanStaticRouteModifiedRouteScope;
    /**
     * Optional weight of the ECMP scope - if provided.
     */
    weight: number;
}

export interface MagicWanStaticRouteModifiedRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions: string[];
}

export interface MagicWanStaticRouteRoute {
    /**
     * When the route was created.
     */
    createdOn: string;
    /**
     * An optional human provided description of the static route.
     */
    description: string;
    /**
     * Identifier
     */
    id: string;
    /**
     * When the route was last modified.
     */
    modifiedOn: string;
    /**
     * The next-hop IP Address for the static route.
     */
    nexthop: string;
    /**
     * IP Prefix in Classless Inter-Domain Routing format.
     */
    prefix: string;
    /**
     * Priority of the static route.
     */
    priority: number;
    /**
     * Used only for ECMP routes.
     */
    scope: outputs.MagicWanStaticRouteRouteScope;
    /**
     * Optional weight of the ECMP scope - if provided.
     */
    weight: number;
}

export interface MagicWanStaticRouteRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions: string[];
}

export interface MagicWanStaticRouteScope {
    /**
     * List of colo names for the ECMP scope.
     */
    coloNames?: string[];
    /**
     * List of colo regions for the ECMP scope.
     */
    coloRegions?: string[];
}

export interface ManagedTransformsManagedRequestHeader {
    /**
     * The Managed Transforms that this Managed Transform conflicts with.
     */
    conflictsWiths: string[];
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
     */
    hasConflict: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface ManagedTransformsManagedResponseHeader {
    /**
     * The Managed Transforms that this Managed Transform conflicts with.
     */
    conflictsWiths: string[];
    /**
     * Whether the Managed Transform is enabled.
     */
    enabled: boolean;
    /**
     * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
     */
    hasConflict: boolean;
    /**
     * The human-readable identifier of the Managed Transform.
     */
    id: string;
}

export interface NotificationPolicyFilters {
    /**
     * Usage depends on specific alert type
     */
    actions?: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedAsns?: string[];
    /**
     * Used for configuring incident_alert
     */
    affectedComponents?: string[];
    /**
     * Used for configuring radar_notification
     */
    affectedLocations?: string[];
    /**
     * Used for configuring maintenance*event*notification
     */
    airportCodes?: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferences?: string[];
    /**
     * Usage depends on specific alert type
     */
    alertTriggerPreferencesValues?: string[];
    /**
     * Used for configuring load*balancing*pool*enablement*alert
     */
    enableds?: string[];
    /**
     * Used for configuring pages*event*alert
     */
    environments?: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    eventSources?: string[];
    /**
     * Usage depends on specific alert type
     */
    eventTypes?: string[];
    /**
     * Used for configuring pages*event*alert
     */
    events?: string[];
    /**
     * Usage depends on specific alert type
     */
    groupBies?: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    healthCheckIds?: string[];
    /**
     * Used for configuring incident_alert
     */
    incidentImpacts?: string[];
    /**
     * Used for configuring stream*live*notifications
     */
    inputIds?: string[];
    /**
     * Used for configuring security*insights*alert
     */
    insightClasses?: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    limits?: string[];
    /**
     * Used for configuring logo*match*alert
     */
    logoTags?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    megabitsPerSeconds?: string[];
    /**
     * Used for configuring load*balancing*health_alert
     */
    newHealths?: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    newStatuses?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    packetsPerSeconds?: string[];
    /**
     * Usage depends on specific alert type
     */
    poolIds?: string[];
    /**
     * Usage depends on specific alert type
     */
    popNames?: string[];
    /**
     * Used for configuring billing*usage*alert
     */
    products?: string[];
    /**
     * Used for configuring pages*event*alert
     */
    projectIds?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    protocols?: string[];
    /**
     * Usage depends on specific alert type
     */
    queryTags?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    requestsPerSeconds?: string[];
    /**
     * Usage depends on specific alert type
     */
    selectors?: string[];
    /**
     * Used for configuring clickhouse*alert*fw*ent*anomaly
     */
    services?: string[];
    /**
     * Usage depends on specific alert type
     */
    slos?: string[];
    /**
     * Used for configuring health*check*status_notification
     */
    statuses?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetHostnames?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l4*alert
     */
    targetIps?: string[];
    /**
     * Used for configuring advanced*ddos*attack*l7*alert
     */
    targetZoneNames?: string[];
    /**
     * Used for configuring traffic*anomalies*alert
     */
    trafficExclusions?: string[];
    /**
     * Used for configuring tunnel*health*event
     */
    tunnelIds?: string[];
    /**
     * Usage depends on specific alert type
     */
    tunnelNames?: string[];
    /**
     * Usage depends on specific alert type
     */
    wheres?: string[];
    /**
     * Usage depends on specific alert type
     */
    zones?: string[];
}

export interface NotificationPolicyMechanisms {
    emails?: outputs.NotificationPolicyMechanismsEmail[];
    pagerduties?: outputs.NotificationPolicyMechanismsPagerduty[];
    webhooks?: outputs.NotificationPolicyMechanismsWebhook[];
}

export interface NotificationPolicyMechanismsEmail {
    /**
     * The email address
     */
    id?: string;
}

export interface NotificationPolicyMechanismsPagerduty {
    /**
     * UUID
     */
    id: string;
}

export interface NotificationPolicyMechanismsWebhook {
    /**
     * UUID
     */
    id: string;
}

export interface ObservatoryScheduledTestSchedule {
    /**
     * The frequency of the test.
     */
    frequency: string;
    /**
     * A test region.
     */
    region: string;
    /**
     * A URL.
     */
    url: string;
}

export interface ObservatoryScheduledTestTest {
    date: string;
    /**
     * The Lighthouse report.
     */
    desktopReport: outputs.ObservatoryScheduledTestTestDesktopReport;
    /**
     * UUID
     */
    id: string;
    /**
     * The Lighthouse report.
     */
    mobileReport: outputs.ObservatoryScheduledTestTestMobileReport;
    /**
     * A test region with a label.
     */
    region: outputs.ObservatoryScheduledTestTestRegion;
    /**
     * The frequency of the test.
     */
    scheduleFrequency: string;
    /**
     * A URL.
     */
    url: string;
}

export interface ObservatoryScheduledTestTestDesktopReport {
    /**
     * Cumulative Layout Shift.
     */
    cls: number;
    /**
     * The type of device.
     */
    deviceType: string;
    error: outputs.ObservatoryScheduledTestTestDesktopReportError;
    /**
     * First Contentful Paint.
     */
    fcp: number;
    /**
     * The URL to the full Lighthouse JSON report.
     */
    jsonReportUrl: string;
    /**
     * Largest Contentful Paint.
     */
    lcp: number;
    /**
     * The Lighthouse performance score.
     */
    performanceScore: number;
    /**
     * Speed Index.
     */
    si: number;
    /**
     * The state of the Lighthouse report.
     */
    state: string;
    /**
     * Total Blocking Time.
     */
    tbt: number;
    /**
     * Time To First Byte.
     */
    ttfb: number;
    /**
     * Time To Interactive.
     */
    tti: number;
}

export interface ObservatoryScheduledTestTestDesktopReportError {
    /**
     * The error code of the Lighthouse result.
     */
    code: string;
    /**
     * Detailed error message.
     */
    detail: string;
    /**
     * The final URL displayed to the user.
     */
    finalDisplayedUrl: string;
}

export interface ObservatoryScheduledTestTestMobileReport {
    /**
     * Cumulative Layout Shift.
     */
    cls: number;
    /**
     * The type of device.
     */
    deviceType: string;
    error: outputs.ObservatoryScheduledTestTestMobileReportError;
    /**
     * First Contentful Paint.
     */
    fcp: number;
    /**
     * The URL to the full Lighthouse JSON report.
     */
    jsonReportUrl: string;
    /**
     * Largest Contentful Paint.
     */
    lcp: number;
    /**
     * The Lighthouse performance score.
     */
    performanceScore: number;
    /**
     * Speed Index.
     */
    si: number;
    /**
     * The state of the Lighthouse report.
     */
    state: string;
    /**
     * Total Blocking Time.
     */
    tbt: number;
    /**
     * Time To First Byte.
     */
    ttfb: number;
    /**
     * Time To Interactive.
     */
    tti: number;
}

export interface ObservatoryScheduledTestTestMobileReportError {
    /**
     * The error code of the Lighthouse result.
     */
    code: string;
    /**
     * Detailed error message.
     */
    detail: string;
    /**
     * The final URL displayed to the user.
     */
    finalDisplayedUrl: string;
}

export interface ObservatoryScheduledTestTestRegion {
    label: string;
    /**
     * A test region.
     */
    value: string;
}

export interface PageRuleActions {
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    alwaysUseHttps?: boolean;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    automaticHttpsRewrites?: string;
    /**
     * The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
     */
    browserCacheTtl?: number;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    browserCheck?: string;
    /**
     * String value of cookie name to conditionally bypass cache the page.
     */
    bypassCacheOnCookie?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheByDeviceType?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheDeceptionArmor?: string;
    /**
     * Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
     */
    cacheKeyFields?: outputs.PageRuleActionsCacheKeyFields;
    /**
     * Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cacheEverything"`.
     */
    cacheLevel?: string;
    /**
     * String value of cookie name to conditionally cache the page.
     */
    cacheOnCookie?: string;
    /**
     * Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
     */
    cacheTtlByStatus?: any;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableApps?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disablePerformance?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableSecurity?: boolean;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableZaraz?: boolean;
    /**
     * The Time To Live for the edge cache.
     */
    edgeCacheTtl?: number;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    emailObfuscation?: string;
    /**
     * Whether origin Cache-Control action is `"on"` or `"off"`.
     */
    explicitCacheControl?: string;
    /**
     * The URL to forward to, and with what status. See below.
     */
    forwardingUrl?: outputs.PageRuleActionsForwardingUrl;
    /**
     * Value of the Host header to send.
     */
    hostHeaderOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    ipGeolocation?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    mirage?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    opportunisticEncryption?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    originErrorPagePassThru?: string;
    /**
     * Whether this action is `"off"`, `"lossless"` or `"lossy"`.
     */
    polish?: string;
    /**
     * Overridden origin server name.
     */
    resolveOverride?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    respectStrongEtag?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    responseBuffering?: string;
    /**
     * Whether to set the rocket loader to `"on"`, `"off"`.
     */
    rocketLoader?: string;
    /**
     * Whether to set the security level to `"off"`, `"essentiallyOff"`, `"low"`, `"medium"`, `"high"`, or `"underAttack"`.
     */
    securityLevel?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    sortQueryStringForCache?: string;
    /**
     * Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"originPull"`.
     */
    ssl?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    trueClientIpHeader?: string;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    waf?: string;
}

export interface PageRuleActionsCacheKeyFields {
    /**
     * Controls what cookies go into Cache Key:
     */
    cookie?: outputs.PageRuleActionsCacheKeyFieldsCookie;
    /**
     * Controls what HTTP headers go into Cache Key:
     */
    header?: outputs.PageRuleActionsCacheKeyFieldsHeader;
    /**
     * Controls which Host header goes into Cache Key:
     */
    host?: outputs.PageRuleActionsCacheKeyFieldsHost;
    /**
     * Controls which URL query string parameters go into the Cache Key.
     */
    queryString?: outputs.PageRuleActionsCacheKeyFieldsQueryString;
    /**
     * Controls which end user-related features go into the Cache Key.
     */
    user?: outputs.PageRuleActionsCacheKeyFieldsUser;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    /**
     * Check for presence of specified cookies, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Use values of specified cookies in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    /**
     * Check for presence of specified HTTP headers, without including their actual values.
     */
    checkPresences: string[];
    /**
     * Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
     */
    excludes: string[];
    /**
     * Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHost {
    /**
     * `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
     */
    resolved?: boolean;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    /**
     * Exclude these query string parameters from Cache Key.
     */
    excludes: string[];
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsUser {
    /**
     * `true` - classifies a request as “mobile”, “desktop”, or “tablet” based on the User Agent; defaults to `false`.
     */
    deviceType?: boolean;
    /**
     * `true` - includes the client’s country, derived from the IP address; defaults to `false`.
     */
    geo?: boolean;
    /**
     * `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
     *
     * Example:
     */
    lang?: boolean;
}

export interface PageRuleActionsForwardingUrl {
    /**
     * The status code to use for the redirection.
     */
    statusCode: number;
    /**
     * The URL to which the page rule should forward.
     */
    url: string;
}

export interface PagesDomainValidationData {
    errorMessage: string;
    method: string;
    status: string;
    txtName: string;
    txtValue: string;
}

export interface PagesDomainVerificationData {
    errorMessage: string;
    status: string;
}

export interface PagesProjectBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching?: boolean;
    /**
     * Command used to build project.
     */
    buildCommand?: string;
    /**
     * Output directory of the build.
     */
    destinationDir?: string;
    /**
     * Directory to run the command.
     */
    rootDir?: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag?: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken?: string;
}

export interface PagesProjectCanonicalDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.PagesProjectCanonicalDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.PagesProjectCanonicalDeploymentDeploymentTrigger;
    /**
     * A dict of env variables to build this deploy.
     */
    envVars: {[key: string]: outputs.PagesProjectCanonicalDeploymentEnvVars};
    /**
     * Type of deploy.
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.PagesProjectCanonicalDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.PagesProjectCanonicalDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.PagesProjectCanonicalDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface PagesProjectCanonicalDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface PagesProjectCanonicalDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.PagesProjectCanonicalDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     */
    type: string;
}

export interface PagesProjectCanonicalDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface PagesProjectCanonicalDeploymentEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectCanonicalDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface PagesProjectCanonicalDeploymentSource {
    config: outputs.PagesProjectCanonicalDeploymentSourceConfig;
    type: string;
}

export interface PagesProjectCanonicalDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface PagesProjectCanonicalDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface PagesProjectDeploymentConfigs {
    /**
     * Configs for preview deploys.
     */
    preview: outputs.PagesProjectDeploymentConfigsPreview;
    /**
     * Configs for production deploys.
     */
    production: outputs.PagesProjectDeploymentConfigsProduction;
}

export interface PagesProjectDeploymentConfigsPreview {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers?: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate?: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags?: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewD1Databases};
    /**
     * Durabble Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces};
    /**
     * Environment variables for build configs.
     */
    envVars: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement: outputs.PagesProjectDeploymentConfigsPreviewPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings: {[key: string]: outputs.PagesProjectDeploymentConfigsPreviewVectorizeBindings};
}

export interface PagesProjectDeploymentConfigsPreviewAiBindings {
    projectId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset?: string;
}

export interface PagesProjectDeploymentConfigsPreviewBrowsers {
}

export interface PagesProjectDeploymentConfigsPreviewD1Databases {
    /**
     * UUID of the D1 database.
     */
    id?: string;
}

export interface PagesProjectDeploymentConfigsPreviewDurableObjectNamespaces {
    /**
     * ID of the Durabble Object namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewEnvVars {
    /**
     * The type of environment variable.
     */
    type?: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectDeploymentConfigsPreviewHyperdriveBindings {
    id?: string;
}

export interface PagesProjectDeploymentConfigsPreviewKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewMtlsCertificates {
    certificateId?: string;
}

export interface PagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement mode.
     */
    mode?: string;
}

export interface PagesProjectDeploymentConfigsPreviewQueueProducers {
    /**
     * Name of the Queue.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsPreviewR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction?: string;
    /**
     * Name of the R2 bucket.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsPreviewServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint?: string;
    /**
     * The Service environment.
     */
    environment?: string;
    /**
     * The Service name.
     */
    service?: string;
}

export interface PagesProjectDeploymentConfigsPreviewVectorizeBindings {
    indexName?: string;
}

export interface PagesProjectDeploymentConfigsProduction {
    /**
     * Constellation bindings used for Pages Functions.
     */
    aiBindings: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionAiBindings};
    /**
     * Analytics Engine bindings used for Pages Functions.
     */
    analyticsEngineDatasets: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets};
    /**
     * Browser bindings used for Pages Functions.
     */
    browsers?: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionBrowsers};
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate?: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags?: string[];
    /**
     * D1 databases used for Pages Functions.
     */
    d1Databases: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionD1Databases};
    /**
     * Durabble Object namespaces used for Pages Functions.
     */
    durableObjectNamespaces: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionDurableObjectNamespaces};
    /**
     * Environment variables for build configs.
     */
    envVars: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionEnvVars};
    /**
     * Hyperdrive bindings used for Pages Functions.
     */
    hyperdriveBindings: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionHyperdriveBindings};
    /**
     * KV namespaces used for Pages Functions.
     */
    kvNamespaces: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionKvNamespaces};
    /**
     * mTLS bindings used for Pages Functions.
     */
    mtlsCertificates: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionMtlsCertificates};
    /**
     * Placement setting used for Pages Functions.
     */
    placement: outputs.PagesProjectDeploymentConfigsProductionPlacement;
    /**
     * Queue Producer bindings used for Pages Functions.
     */
    queueProducers: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionQueueProducers};
    /**
     * R2 buckets used for Pages Functions.
     */
    r2Buckets: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionR2Buckets};
    /**
     * Services used for Pages Functions.
     */
    services: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionServices};
    /**
     * Vectorize bindings used for Pages Functions.
     */
    vectorizeBindings: {[key: string]: outputs.PagesProjectDeploymentConfigsProductionVectorizeBindings};
}

export interface PagesProjectDeploymentConfigsProductionAiBindings {
    projectId?: string;
}

export interface PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasets {
    /**
     * Name of the dataset.
     */
    dataset?: string;
}

export interface PagesProjectDeploymentConfigsProductionBrowsers {
}

export interface PagesProjectDeploymentConfigsProductionD1Databases {
    /**
     * UUID of the D1 database.
     */
    id?: string;
}

export interface PagesProjectDeploymentConfigsProductionDurableObjectNamespaces {
    /**
     * ID of the Durabble Object namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsProductionEnvVars {
    /**
     * The type of environment variable.
     */
    type?: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectDeploymentConfigsProductionHyperdriveBindings {
    id?: string;
}

export interface PagesProjectDeploymentConfigsProductionKvNamespaces {
    /**
     * ID of the KV namespace.
     */
    namespaceId?: string;
}

export interface PagesProjectDeploymentConfigsProductionMtlsCertificates {
    certificateId?: string;
}

export interface PagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement mode.
     */
    mode?: string;
}

export interface PagesProjectDeploymentConfigsProductionQueueProducers {
    /**
     * Name of the Queue.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsProductionR2Buckets {
    /**
     * Jurisdiction of the R2 bucket.
     */
    jurisdiction?: string;
    /**
     * Name of the R2 bucket.
     */
    name?: string;
}

export interface PagesProjectDeploymentConfigsProductionServices {
    /**
     * The entrypoint to bind to.
     */
    entrypoint?: string;
    /**
     * The Service environment.
     */
    environment?: string;
    /**
     * The Service name.
     */
    service?: string;
}

export interface PagesProjectDeploymentConfigsProductionVectorizeBindings {
    indexName?: string;
}

export interface PagesProjectLatestDeployment {
    /**
     * A list of alias URLs pointing to this deployment.
     */
    aliases: string[];
    /**
     * Configs for the project build process.
     */
    buildConfig: outputs.PagesProjectLatestDeploymentBuildConfig;
    /**
     * When the deployment was created.
     */
    createdOn: string;
    /**
     * Info about what caused the deployment.
     */
    deploymentTrigger: outputs.PagesProjectLatestDeploymentDeploymentTrigger;
    /**
     * A dict of env variables to build this deploy.
     */
    envVars: {[key: string]: outputs.PagesProjectLatestDeploymentEnvVars};
    /**
     * Type of deploy.
     */
    environment: string;
    /**
     * Id of the deployment.
     */
    id: string;
    /**
     * If the deployment has been skipped.
     */
    isSkipped: boolean;
    /**
     * The status of the deployment.
     */
    latestStage: outputs.PagesProjectLatestDeploymentLatestStage;
    /**
     * When the deployment was last modified.
     */
    modifiedOn: string;
    /**
     * Id of the project.
     */
    projectId: string;
    /**
     * Name of the project.
     */
    projectName: string;
    /**
     * Short Id (8 character) of the deployment.
     */
    shortId: string;
    source: outputs.PagesProjectLatestDeploymentSource;
    /**
     * List of past stages.
     */
    stages: outputs.PagesProjectLatestDeploymentStage[];
    /**
     * The live URL to view this deployment.
     */
    url: string;
}

export interface PagesProjectLatestDeploymentBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching: boolean;
    /**
     * Command used to build project.
     */
    buildCommand: string;
    /**
     * Output directory of the build.
     */
    destinationDir: string;
    /**
     * Directory to run the command.
     */
    rootDir: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken: string;
}

export interface PagesProjectLatestDeploymentDeploymentTrigger {
    /**
     * Additional info about the trigger.
     */
    metadata: outputs.PagesProjectLatestDeploymentDeploymentTriggerMetadata;
    /**
     * What caused the deployment.
     */
    type: string;
}

export interface PagesProjectLatestDeploymentDeploymentTriggerMetadata {
    /**
     * Where the trigger happened.
     */
    branch: string;
    /**
     * Hash of the deployment trigger commit.
     */
    commitHash: string;
    /**
     * Message of the deployment trigger commit.
     */
    commitMessage: string;
}

export interface PagesProjectLatestDeploymentEnvVars {
    /**
     * The type of environment variable.
     */
    type: string;
    /**
     * Environment variable value.
     */
    value: string;
}

export interface PagesProjectLatestDeploymentLatestStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface PagesProjectLatestDeploymentSource {
    config: outputs.PagesProjectLatestDeploymentSourceConfig;
    type: string;
}

export interface PagesProjectLatestDeploymentSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface PagesProjectLatestDeploymentStage {
    /**
     * When the stage ended.
     */
    endedOn: string;
    /**
     * The current build stage.
     */
    name: string;
    /**
     * When the stage started.
     */
    startedOn: string;
    /**
     * State of the current stage.
     */
    status: string;
}

export interface PagesProjectSource {
    config: outputs.PagesProjectSourceConfig;
    type: string;
}

export interface PagesProjectSourceConfig {
    deploymentsEnabled: boolean;
    owner: string;
    pathExcludes: string[];
    pathIncludes: string[];
    prCommentsEnabled: boolean;
    previewBranchExcludes: string[];
    previewBranchIncludes: string[];
    previewDeploymentSetting: string;
    productionBranch: string;
    productionDeploymentsEnabled: boolean;
    repoName: string;
}

export interface QueueConsumer {
    /**
     * A Resource identifier.
     */
    consumerId: string;
    createdOn: string;
    /**
     * A Resource identifier.
     */
    queueId: string;
    /**
     * Name of a Worker
     */
    script: string;
    /**
     * Name of a Worker
     */
    scriptName: string;
    settings: outputs.QueueConsumerSettings;
    type: string;
}

export interface QueueConsumerSettings {
    /**
     * The maximum number of messages to include in a batch.
     */
    batchSize?: number;
    /**
     * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
     */
    maxConcurrency?: number;
    /**
     * The maximum number of retries
     */
    maxRetries?: number;
    /**
     * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
     */
    maxWaitTimeMs?: number;
    /**
     * The number of seconds to delay before making the message available for another attempt.
     */
    retryDelay?: number;
    /**
     * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
     */
    visibilityTimeoutMs?: number;
}

export interface QueueProducer {
    bucketName: string;
    script: string;
    type: string;
}

export interface QueueSettings {
    /**
     * Number of seconds to delay delivery of all messages to consumers.
     */
    deliveryDelay?: number;
    /**
     * Number of seconds after which an unconsumed message will be delayed.
     */
    messageRetentionPeriod?: number;
<<<<<<< HEAD
=======
}

export interface R2BucketCorsRule {
    /**
     * Object specifying allowed origins, methods and headers for this CORS rule.
     */
    allowed: outputs.R2BucketCorsRuleAllowed;
    /**
     * Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
     */
    exposeHeaders?: string[];
    /**
     * Identifier for this rule
     */
    id?: string;
    /**
     * Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
     */
    maxAgeSeconds?: number;
}

export interface R2BucketCorsRuleAllowed {
    /**
     * Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
     */
    headers?: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
     */
    methods: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
     */
    origins: string[];
}

export interface R2BucketEventNotificationQueue {
    /**
     * Queue ID
     */
    queueId: string;
    /**
     * Name of the queue
     */
    queueName: string;
    rules: outputs.R2BucketEventNotificationQueueRule[];
}

export interface R2BucketEventNotificationQueueRule {
    /**
     * Array of R2 object actions that will trigger notifications
     */
    actions: string[];
    /**
     * Timestamp when the rule was created
     */
    createdAt: string;
    /**
     * A description that can be used to identify the event notification rule after creation
     */
    description: string;
    /**
     * Notifications will be sent only for objects with this prefix
     */
    prefix: string;
    /**
     * Rule ID
     */
    ruleId: string;
    /**
     * Notifications will be sent only for objects with this suffix
     */
    suffix: string;
}

export interface R2BucketEventNotificationRule {
    /**
     * Array of R2 object actions that will trigger notifications
     */
    actions: string[];
    /**
     * A description that can be used to identify the event notification rule after creation
     */
    description?: string;
    /**
     * Notifications will be sent only for objects with this prefix
     */
    prefix?: string;
    /**
     * Notifications will be sent only for objects with this suffix
     */
    suffix?: string;
}

export interface R2BucketLifecycleRule {
    /**
     * Transition to abort ongoing multipart uploads
     */
    abortMultipartUploadsTransition: outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransition;
    /**
     * Conditions that apply to all transitions of this rule
     */
    conditions: outputs.R2BucketLifecycleRuleConditions;
    /**
     * Transition to delete objects
     */
    deleteObjectsTransition: outputs.R2BucketLifecycleRuleDeleteObjectsTransition;
    /**
     * Whether or not this rule is in effect
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule
     */
    id: string;
    /**
     * Transitions to change the storage class of objects
     */
    storageClassTransitions: outputs.R2BucketLifecycleRuleStorageClassTransition[];
}

export interface R2BucketLifecycleRuleAbortMultipartUploadsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds
     */
    condition: outputs.R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition;
}

export interface R2BucketLifecycleRuleAbortMultipartUploadsTransitionCondition {
    maxAge: number;
    type: string;
}

export interface R2BucketLifecycleRuleConditions {
    /**
     * Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
     */
    prefix: string;
}

export interface R2BucketLifecycleRuleDeleteObjectsTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds
     */
    condition: outputs.R2BucketLifecycleRuleDeleteObjectsTransitionCondition;
}

export interface R2BucketLifecycleRuleDeleteObjectsTransitionCondition {
    date?: string;
    maxAge?: number;
    type: string;
}

export interface R2BucketLifecycleRuleStorageClassTransition {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds
     */
    condition: outputs.R2BucketLifecycleRuleStorageClassTransitionCondition;
    storageClass: string;
}

export interface R2BucketLifecycleRuleStorageClassTransitionCondition {
    date?: string;
    maxAge?: number;
    type: string;
}

export interface R2BucketLockRule {
    /**
     * Condition to apply a lock rule to an object for how long in seconds
     */
    condition: outputs.R2BucketLockRuleCondition;
    /**
     * Whether or not this rule is in effect
     */
    enabled: boolean;
    /**
     * Unique identifier for this rule
     */
    id: string;
    /**
     * Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
     */
    prefix?: string;
}

export interface R2BucketLockRuleCondition {
    date?: string;
    maxAgeSeconds?: number;
    type: string;
}

export interface R2BucketSippyDestination {
    /**
     * ID of a Cloudflare API token.
     * This is the value labelled "Access Key ID" when creating an API
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     */
    accessKeyId?: string;
    provider?: string;
    /**
     * Value of a Cloudflare API token.
     * This is the value labelled "Secret Access Key" when creating an API
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     *
     * Sippy will use this token when writing objects to R2, so it is
     * best to scope this token to the bucket you're enabling Sippy for.
     */
    secretAccessKey?: string;
}

export interface R2BucketSippySource {
    /**
     * Access Key ID of an IAM credential (ideally scoped to a single S3 bucket)
     */
    accessKeyId?: string;
    /**
     * Name of the AWS S3 bucket
     */
    bucket?: string;
    /**
     * Client email of an IAM credential (ideally scoped to a single GCS bucket)
     */
    clientEmail?: string;
    /**
     * Private Key of an IAM credential (ideally scoped to a single GCS bucket)
     */
    privateKey?: string;
    provider?: string;
    /**
     * Name of the AWS availability zone
     */
    region?: string;
    /**
     * Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket)
     */
    secretAccessKey?: string;
}

export interface R2CustomDomainStatus {
    /**
     * Ownership status of the domain
     */
    ownership: string;
    /**
     * SSL certificate status
     */
    ssl: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface RateLimitAction {
    /**
     * The action to perform.
     */
    mode?: string;
    /**
     * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
     * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
     */
    response?: outputs.RateLimitActionResponse;
    /**
     * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
     * Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
     */
    timeout?: number;
}

export interface RateLimitActionResponse {
    /**
     * The response body to return. The value must conform to the configured content type.
     */
    body?: string;
    /**
     * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
     */
    contentType?: string;
}

export interface RateLimitBypass {
    name: string;
    /**
     * The URL to bypass.
     */
    value: string;
}

export interface RateLimitMatch {
    headers?: outputs.RateLimitMatchHeader[];
    request?: outputs.RateLimitMatchRequest;
    response?: outputs.RateLimitMatchResponse;
}

export interface RateLimitMatchHeader {
    /**
     * The name of the response header to match.
     */
    name?: string;
    /**
     * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
     */
    op?: string;
    /**
     * The value of the response header, which must match exactly.
     */
    value?: string;
}

export interface RateLimitMatchRequest {
    /**
     * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
     */
    methods?: string[];
    /**
     * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
     */
    schemes?: string[];
    /**
     * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
     */
    url?: string;
}

export interface RateLimitMatchResponse {
    /**
     * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
     * Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
     */
    originTraffic?: boolean;
}

export interface RecordData {
    /**
     * Algorithm.
     */
    algorithm?: number;
    /**
     * Altitude of location in meters.
     */
    altitude?: number;
    /**
     * Certificate.
     */
    certificate?: string;
    /**
     * Digest.
     */
    digest?: string;
    /**
     * Digest Type.
     */
    digestType?: number;
    /**
     * fingerprint.
     */
    fingerprint?: string;
    /**
     * Flags for the CAA record.
     */
<<<<<<< HEAD
    flags?: any;
=======
    flags?: number;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    /**
     * Key Tag.
     */
    keyTag?: number;
    /**
     * Degrees of latitude.
     */
    latDegrees?: number;
    /**
     * Latitude direction.
     */
    latDirection?: string;
    /**
     * Minutes of latitude.
     */
    latMinutes: number;
    /**
     * Seconds of latitude.
     */
    latSeconds: number;
    /**
     * Degrees of longitude.
     */
    longDegrees?: number;
    /**
     * Longitude direction.
     */
    longDirection?: string;
    /**
     * Minutes of longitude.
     */
    longMinutes: number;
    /**
     * Seconds of longitude.
     */
    longSeconds: number;
    /**
     * Matching Type.
     */
    matchingType?: number;
    /**
     * Order.
     */
    order?: number;
    /**
     * The port of the service.
     */
    port?: number;
    /**
     * Horizontal precision of location.
     */
    precisionHorz: number;
    /**
     * Vertical precision of location.
     */
    precisionVert: number;
    /**
     * Preference.
     */
    preference?: number;
    /**
     * priority.
     */
    priority?: number;
    /**
     * Protocol.
     */
    protocol?: number;
    /**
     * Public Key.
     */
    publicKey?: string;
    /**
     * Regex.
     */
    regex?: string;
    /**
     * Replacement.
     */
    replacement?: string;
    /**
     * Selector.
     */
    selector?: number;
    /**
     * Service.
     */
    service?: string;
    /**
     * Size of location in meters.
     */
    size: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     */
    tag?: string;
    /**
     * target.
     */
    target?: string;
    /**
     * Type.
     */
    type?: number;
    /**
     * Usage.
     */
    usage?: number;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     */
    value?: string;
    /**
     * The record weight.
     */
    weight?: number;
}

export interface RecordSettings {
    /**
     * If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
     */
    flattenCname: boolean;
    /**
     * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv4Only: boolean;
    /**
     * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
     */
    ipv6Only: boolean;
}

export interface RulesetRule {
    /**
     * The action to perform when the rule matches.
     */
    action?: string;
    /**
     * The parameters configuring the rule's action.
     */
    actionParameters?: outputs.RulesetRuleActionParameters;
    /**
     * The categories of the rule.
     */
    categories: string[];
    /**
     * An informative description of the rule.
     */
    description: string;
    /**
     * Whether the rule should be executed.
     */
    enabled: boolean;
    /**
     * Configure checks for exposed credentials.
     */
    exposedCredentialCheck?: outputs.RulesetRuleExposedCredentialCheck;
    /**
     * The expression defining which traffic will match the rule.
     */
    expression?: string;
    /**
     * The unique ID of the rule.
     */
    id: string;
    /**
     * An object configuring the rule's logging behavior.
     */
    logging?: outputs.RulesetRuleLogging;
    /**
     * An object configuring the rule's ratelimit behavior.
     */
    ratelimit?: outputs.RulesetRuleRatelimit;
    /**
     * The reference of the rule (the rule ID by default).
     */
    ref: string;
}

export interface RulesetRuleActionParameters {
    /**
     * List of additional ports that caching can be enabled on.
     */
    additionalCacheablePorts?: number[];
    /**
     * Custom order for compression algorithms.
     */
    algorithms?: outputs.RulesetRuleActionParametersAlgorithm[];
    /**
     * Turn on or off Automatic HTTPS Rewrites.
     */
    automaticHttpsRewrites?: boolean;
    /**
     * Select which file extensions to minify automatically.
     */
    autominify?: outputs.RulesetRuleActionParametersAutominify;
    /**
     * Turn on or off Browser Integrity Check.
     */
    bic?: boolean;
    /**
     * Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
     */
    browserTtl?: outputs.RulesetRuleActionParametersBrowserTtl;
    /**
     * Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
     */
    cache?: boolean;
    /**
     * Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
     */
    cacheKey?: outputs.RulesetRuleActionParametersCacheKey;
    /**
     * Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
     */
    cacheReserve?: outputs.RulesetRuleActionParametersCacheReserve;
    /**
     * Error response content.
     */
    content?: string;
    /**
     * Content-type header to set with the response.
     */
    contentType?: string;
    /**
     * The cookie fields to log.
     */
    cookieFields?: outputs.RulesetRuleActionParametersCookieField[];
    /**
     * Turn off all active Cloudflare Apps.
     */
    disableApps?: boolean;
    /**
     * Turn off Real User Monitoring (RUM).
     */
    disableRum?: boolean;
    /**
     * Turn off Zaraz.
     */
    disableZaraz?: boolean;
    /**
     * TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
     */
    edgeTtl?: outputs.RulesetRuleActionParametersEdgeTtl;
    /**
     * Turn on or off Email Obfuscation.
     */
    emailObfuscation?: boolean;
    /**
     * Turn on or off Cloudflare Fonts.
     */
    fonts?: boolean;
    /**
     * Serve a redirect based on a bulk list lookup.
     */
    fromList?: outputs.RulesetRuleActionParametersFromList;
    /**
     * Serve a redirect based on the request properties.
     */
    fromValue?: outputs.RulesetRuleActionParametersFromValue;
    /**
     * Map of request headers to modify.
     */
    headers?: {[key: string]: outputs.RulesetRuleActionParametersHeaders};
    /**
     * Rewrite the HTTP Host header.
     */
    hostHeader?: string;
    /**
     * Turn on or off the Hotlink Protection.
     */
    hotlinkProtection?: boolean;
    /**
     * The ID of the ruleset to execute.
     */
    id?: string;
    /**
     * Increment contains the delta to change the score and can be either positive or negative.
     */
    increment?: number;
    /**
     * The configuration to use for matched data logging.
     */
    matchedData?: outputs.RulesetRuleActionParametersMatchedData;
    /**
     * Turn on or off Mirage.
     */
    mirage?: boolean;
    /**
     * Turn on or off Opportunistic Encryption.
     */
    opportunisticEncryption?: boolean;
    /**
     * Override the IP/TCP destination.
     */
    origin?: outputs.RulesetRuleActionParametersOrigin;
    /**
     * When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
     */
    originCacheControl?: boolean;
    /**
     * Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
     */
    originErrorPagePassthru?: boolean;
    /**
     * A set of overrides to apply to the target ruleset.
     */
    overrides?: outputs.RulesetRuleActionParametersOverrides;
    /**
     * A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
     */
    phases?: string[];
    /**
     * Configure the Polish level.
     */
    polish?: string;
    /**
     * A list of legacy security products to skip the execution of.
     */
    products?: string[];
    /**
     * Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
     */
    readTimeout?: number;
    /**
     * The request fields to log.
     */
    requestFields?: outputs.RulesetRuleActionParametersRequestField[];
    /**
     * Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
     */
    respectStrongEtags?: boolean;
    /**
     * The response to show when the block is applied.
     */
    response?: outputs.RulesetRuleActionParametersResponse;
    /**
     * The response fields to log.
     */
    responseFields?: outputs.RulesetRuleActionParametersResponseField[];
    /**
     * Turn on or off Rocket Loader
     */
    rocketLoader?: boolean;
    /**
     * A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
     */
    rules?: {[key: string]: string[]};
    /**
     * A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
     */
    ruleset?: string;
    /**
     * A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
     */
    rulesets?: string[];
    /**
     * Configure the Security Level.
     */
    securityLevel?: string;
    /**
     * Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
     */
    serveStale?: outputs.RulesetRuleActionParametersServeStale;
    /**
     * Turn on or off Server Side Excludes.
     */
    serverSideExcludes?: boolean;
    /**
     * Override the Server Name Indication (SNI).
     */
    sni?: outputs.RulesetRuleActionParametersSni;
    /**
     * Configure the SSL level.
     */
    ssl?: string;
    /**
     * The status code to use for the error.
     */
    statusCode?: number;
    /**
     * Turn on or off Signed Exchanges (SXG).
     */
    sxg?: boolean;
    /**
     * URI to rewrite the request to.
     */
    uri?: outputs.RulesetRuleActionParametersUri;
}

export interface RulesetRuleActionParametersAlgorithm {
    /**
     * Name of compression algorithm to enable.
     */
    name?: string;
}

export interface RulesetRuleActionParametersAutominify {
    /**
     * Minify CSS files.
     */
    css?: boolean;
    /**
     * Minify HTML files.
     */
    html?: boolean;
    /**
     * Minify JS files.
     */
    js?: boolean;
}

export interface RulesetRuleActionParametersBrowserTtl {
    /**
     * The TTL (in seconds) if you choose overrideOrigin mode.
     */
    default?: number;
    /**
     * Determines which browser ttl mode to use.
     */
    mode: string;
}

export interface RulesetRuleActionParametersCacheKey {
    /**
     * Separate cached content based on the visitor’s device type
     */
    cacheByDeviceType?: boolean;
    /**
     * Protect from web cache deception attacks while allowing static assets to be cached
     */
    cacheDeceptionArmor?: boolean;
    /**
     * Customize which components of the request are included or excluded from the cache key.
     */
    customKey?: outputs.RulesetRuleActionParametersCacheKeyCustomKey;
    /**
     * Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
     */
    ignoreQueryStringsOrder?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * The cookies to include in building the cache key.
     */
    cookie?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie;
    /**
     * The header names and values to include in building the cache key.
     */
    header?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader;
    /**
     * Whether to use the original host or the resolved host in the cache key.
     */
    host?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyHost;
    /**
     * Use the presence of parameters in the query string to build the cache key.
     */
    queryString?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString;
    /**
     * Characteristics of the request user agent used in building the cache key.
     */
    user?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyUser;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
     */
    checkPresences?: string[];
    /**
     * Include these cookies' names and their values.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * Checks for the presence of these header names. The presence of these headers is used in building the cache key.
     */
    checkPresences?: string[];
    /**
     * For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
     */
    contains?: {[key: string]: string[]};
    /**
     * Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
     */
    excludeOrigin?: boolean;
    /**
     * Include these headers' names and their values.
     */
    includes?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
     */
    resolved?: boolean;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
     */
    exclude?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude;
    /**
     * A list of query string parameters used to build the cache key.
     */
    include?: outputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExclude {
    /**
     * Determines whether to exclude all query string parameters from the cache key.
     */
    all?: boolean;
    lists?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryStringInclude {
    /**
     * Determines whether to include all query string parameters in the cache key.
     */
    all?: boolean;
    lists?: string[];
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Use the user agent's device type in the cache key.
     */
    deviceType?: boolean;
    /**
     * Use the user agents's country in the cache key.
     */
    geo?: boolean;
    /**
     * Use the user agent's language in the cache key.
     */
    lang?: boolean;
}

export interface RulesetRuleActionParametersCacheReserve {
    /**
     * Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
     */
    eligible: boolean;
    /**
     * The minimum file size eligible for store in cache reserve.
     */
    minimumFileSize: number;
}

export interface RulesetRuleActionParametersCookieField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface RulesetRuleActionParametersCookieField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface RulesetRuleActionParametersEdgeTtl {
    /**
     * The TTL (in seconds) if you choose overrideOrigin mode.
     */
    default?: number;
    /**
     * edge ttl options
     */
    mode: string;
    /**
     * List of single status codes, or status code ranges to apply the selected mode
     */
    statusCodeTtls?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl[];
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * Set the ttl for responses with this specific status code
     */
    statusCode?: number;
    /**
     * The range of status codes used to apply the selected mode.
     */
    statusCodeRange?: outputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange;
    /**
     * Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
     */
    value: number;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * response status code lower bound
     */
    from?: number;
    /**
     * response status code upper bound
     */
    to?: number;
}

export interface RulesetRuleActionParametersFromList {
    /**
     * Expression that evaluates to the list lookup key.
     */
    key?: string;
    /**
     * The name of the list to match against.
     */
    name?: string;
}

export interface RulesetRuleActionParametersFromValue {
    /**
     * Keep the query string of the original request.
     */
    preserveQueryString?: boolean;
    /**
     * The status code to be used for the redirect.
     */
    statusCode?: number;
    /**
     * The URL to redirect the request to.
     */
    targetUrl?: outputs.RulesetRuleActionParametersFromValueTargetUrl;
}

export interface RulesetRuleActionParametersFromValueTargetUrl {
    /**
     * An expression to evaluate to get the URL to redirect the request to.
     */
    expression?: string;
    /**
     * The URL to redirect the request to.
     */
    value?: string;
}

export interface RulesetRuleActionParametersHeaders {
    /**
     * Expression for the header value.
     */
    expression?: string;
    operation: string;
    /**
     * Static value for the header.
     */
    value?: string;
}

export interface RulesetRuleActionParametersMatchedData {
    /**
     * The public key to encrypt matched data logs with.
     */
    publicKey: string;
}

export interface RulesetRuleActionParametersOrigin {
    /**
     * Override the resolved hostname.
     */
    host?: string;
    /**
     * Override the destination port.
     */
    port?: number;
}

export interface RulesetRuleActionParametersOverrides {
    /**
     * An action to override all rules with. This option has lower precedence than rule and category overrides.
     */
    action?: string;
    /**
     * A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
     */
    categories?: outputs.RulesetRuleActionParametersOverridesCategory[];
    /**
     * Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
     */
    enabled?: boolean;
    /**
     * A list of rule-level overrides. This option has the highest precedence.
     */
    rules?: outputs.RulesetRuleActionParametersOverridesRule[];
    /**
     * A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersOverridesCategory {
    /**
     * The action to override rules in the category with.
     */
    action?: string;
    /**
     * The name of the category to override.
     */
    category: string;
    /**
     * Whether to enable execution of rules in the category.
     */
    enabled?: boolean;
    /**
     * The sensitivity level to use for rules in the category.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersOverridesRule {
    /**
     * The action to override the rule with.
     */
    action?: string;
    /**
     * Whether to enable execution of the rule.
     */
    enabled?: boolean;
    /**
     * The ID of the rule to override.
     */
    id: string;
    /**
     * The score threshold to use for the rule.
     */
    scoreThreshold?: number;
    /**
     * The sensitivity level to use for the rule.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParametersRequestField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface RulesetRuleActionParametersResponse {
    /**
     * The content to return.
     */
    content: string;
    /**
     * The type of the content to return.
     */
    contentType: string;
    /**
     * The status code to return.
     */
    statusCode: number;
}

export interface RulesetRuleActionParametersResponseField {
    /**
     * The name of the field.
     */
    name: string;
}

export interface RulesetRuleActionParametersServeStale {
    /**
     * Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
     */
    disableStaleWhileUpdating: boolean;
}

export interface RulesetRuleActionParametersSni {
    /**
     * The SNI override.
     */
    value: string;
}

export interface RulesetRuleActionParametersUri {
    /**
     * Path portion rewrite.
     */
    path?: outputs.RulesetRuleActionParametersUriPath;
    /**
     * Query portion rewrite.
     */
    query?: outputs.RulesetRuleActionParametersUriQuery;
}

export interface RulesetRuleActionParametersUriPath {
    /**
     * Expression to evaluate for the replacement value.
     */
    expression?: string;
    /**
     * Predefined replacement value.
     */
    value?: string;
}

export interface RulesetRuleActionParametersUriQuery {
    /**
     * Expression to evaluate for the replacement value.
     */
    expression?: string;
    /**
     * Predefined replacement value.
     */
    value?: string;
}

export interface RulesetRuleExposedCredentialCheck {
    /**
     * Expression that selects the password used in the credentials check.
     */
    passwordExpression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     */
    usernameExpression: string;
}

export interface RulesetRuleLogging {
    /**
     * Whether to generate a log when the rule matches.
     */
    enabled: boolean;
}

export interface RulesetRuleRatelimit {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     */
    countingExpression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     */
    mitigationTimeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     */
    requestsPerPeriod?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     */
    requestsToOrigin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     */
    scorePerPeriod?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     */
    scoreResponseHeaderName?: string;
}

export interface SnippetRulesRule {
    description?: string;
    enabled?: boolean;
    expression?: string;
    /**
     * Snippet identifying name
     */
    snippetName?: string;
}

export interface SnippetsMetadata {
    /**
     * Main module name of uploaded snippet
     */
    mainModule?: string;
}

export interface SpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name?: string;
    /**
     * The type of DNS record associated with the application.
     */
    type?: string;
}

export interface SpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs.
     */
    connectivity?: string;
    /**
     * The array of customer owned IPs we broadcast via anycast for this hostname and application.
     */
    ips?: string[];
    /**
     * The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
     */
    type?: string;
}

export interface SpectrumApplicationOriginDns {
    /**
     * The name of the DNS record associated with the origin.
     */
    name?: string;
    /**
     * The TTL of our resolution of your DNS record in seconds.
     */
    ttl?: number;
    /**
     * The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
     */
    type?: string;
}

export interface StreamInput {
    /**
     * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
     */
    height: number;
    /**
     * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
     */
    width: number;
}

export interface StreamLiveInputRecording {
    /**
     * Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
     */
    allowedOrigins?: string[];
    /**
     * Disables reporting the number of live viewers when this property is set to `true`.
     */
    hideLiveViewerCount: boolean;
    /**
     * Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
     */
    mode: string;
    /**
     * Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
     */
    requireSignedUrls: boolean;
    /**
     * Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
     */
    timeoutSeconds: number;
}

export interface StreamLiveInputRtmps {
    /**
     * The secret key to use when streaming via RTMPS to a live input.
     */
    streamKey: string;
    /**
     * The RTMPS URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface StreamLiveInputRtmpsPlayback {
    /**
     * The secret key to use for playback via RTMPS.
     */
    streamKey: string;
    /**
     * The URL used to play live video over RTMPS.
     */
    url: string;
}

export interface StreamLiveInputSrt {
    /**
     * The secret key to use when streaming via SRT to a live input.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use when streaming via SRT.
     */
    streamId: string;
    /**
     * The SRT URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface StreamLiveInputSrtPlayback {
    /**
     * The secret key to use for playback via SRT.
     */
    passphrase: string;
    /**
     * The identifier of the live input to use for playback via SRT.
     */
    streamId: string;
    /**
     * The URL used to play live video over SRT.
     */
    url: string;
}

export interface StreamLiveInputWebRtc {
    /**
     * The WebRTC URL you provide to the broadcaster, which they stream live video to.
     */
    url: string;
}

export interface StreamLiveInputWebRtcPlayback {
    /**
     * The URL used to play live video over WebRTC.
     */
    url: string;
}

export interface StreamPlayback {
    /**
     * DASH Media Presentation Description for the video.
     */
    dash: string;
    /**
     * The HLS manifest for the video.
     */
    hls: string;
}

export interface StreamStatus {
    /**
     * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
     */
    errorReasonCode: string;
    /**
     * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
     */
    errorReasonText: string;
    /**
     * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
     */
    pctComplete: string;
    /**
     * Specifies the processing status for all quality levels for a video.
     */
    state: string;
}

export interface StreamWatermark {
    /**
     * The date and a time a watermark profile was created.
     */
    created: string;
    /**
     * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
     */
    downloadedFrom: string;
    /**
     * The height of the image in pixels.
     */
    height: number;
    /**
     * A short description of the watermark profile.
     */
    name: string;
    /**
     * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
     */
    opacity: number;
    /**
     * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
     */
    padding: number;
    /**
     * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
     */
    position: string;
    /**
     * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
     */
    scale: number;
    /**
     * The size of the image in bytes.
     */
    size: number;
    /**
     * The unique identifier for a watermark profile.
     */
    uid: string;
    /**
     * The width of the image in pixels.
     */
    width: number;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
     */
    target?: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value?: string;
}

export interface WaitingRoomAdditionalRoute {
    /**
     * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
     */
    host?: string;
    /**
     * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
     */
    path: string;
}

export interface WaitingRoomCookieAttributes {
    /**
     * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
     */
    samesite: string;
    /**
     * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
     */
    secure: string;
}

export interface WaitingRoomRulesRule {
    /**
     * The action to take when the expression matches.
     */
    action: string;
    /**
     * The description of the rule.
     */
    description: string;
    /**
     * When set to true, the rule is enabled.
     */
    enabled: boolean;
    /**
     * Criteria defining when there is a match for the current rule.
     */
    expression: string;
}

export interface WebAnalyticsSiteRule {
    created: string;
    /**
     * The hostname the rule will be applied to.
     */
    host: string;
    /**
     * The Web Analytics rule identifier.
     */
    id: string;
    /**
     * Whether the rule includes or excludes traffic from being measured.
     */
    inclusive: boolean;
    /**
     * Whether the rule is paused or not.
     */
    isPaused: boolean;
    /**
     * The paths the rule will be applied to.
     */
    paths: string[];
    priority: number;
}

export interface WebAnalyticsSiteRuleset {
    /**
     * Whether the ruleset is enabled.
     */
    enabled: boolean;
    /**
     * The Web Analytics ruleset identifier.
     */
    id: string;
    zoneName: string;
    /**
     * The zone identifier.
     */
    zoneTag: string;
}

export interface WorkersCronTriggerSchedule {
    cron: string;
}

export interface WorkersDeploymentAnnotations {
    /**
     * Human-readable message about the deployment. Truncated to 100 bytes.
     */
    workersMessage?: string;
}

export interface WorkersDeploymentDeployment {
    annotations: outputs.WorkersDeploymentDeploymentAnnotations;
    authorEmail: string;
    createdOn: string;
    id: string;
    source: string;
    strategy: string;
    versions: outputs.WorkersDeploymentDeploymentVersion[];
}

export interface WorkersDeploymentDeploymentAnnotations {
    /**
     * Human-readable message about the deployment. Truncated to 100 bytes.
     */
    workersMessage: string;
}

export interface WorkersDeploymentDeploymentVersion {
    percentage: number;
    versionId: string;
}

export interface WorkersDeploymentVersion {
    percentage: number;
    versionId: string;
}

<<<<<<< HEAD
=======
export interface WorkersRouteError {
    code: number;
    message: string;
}

export interface WorkersRouteMessage {
    code: number;
    message: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface WorkersScriptAssets {
    /**
     * Configuration for assets within a Worker.
     */
    config?: outputs.WorkersScriptAssetsConfig;
    /**
     * Token provided upon successful upload of all files from a registered manifest.
     */
    jwt?: string;
}

export interface WorkersScriptAssetsConfig {
    /**
     * Determines the redirects and rewrites of requests for HTML content.
     */
    htmlHandling?: string;
    /**
     * Determines the response when a request does not match a static asset, and there is no Worker script.
     */
    notFoundHandling?: string;
    /**
     * When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
     */
    runWorkerFirst: boolean;
    /**
     * When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
     */
    serveDirectly: boolean;
}

export interface WorkersScriptBinding {
    /**
     * R2 bucket to bind to.
     */
    bucketName?: string;
    /**
     * Identifier of the certificate to bind to.
     */
    certificateId?: string;
    /**
     * The exported class name of the Durable Object.
     */
    className?: string;
    /**
     * The dataset name to bind to.
     */
    dataset?: string;
    /**
     * The environment of the scriptName to bind to.
     */
    environment?: string;
    /**
     * Identifier of the D1 database to bind to.
     */
    id?: string;
    /**
     * Name of the Vectorize index to bind to.
     */
    indexName?: string;
    /**
     * JSON data to use.
     */
    json?: string;
    /**
     * A JavaScript variable name for the binding.
     */
    name: string;
    /**
     * Namespace to bind to.
     */
    namespace?: string;
    /**
     * Namespace identifier tag.
     */
    namespaceId?: string;
    /**
     * Outbound worker.
     */
    outbound?: outputs.WorkersScriptBindingOutbound;
    /**
     * Name of the Queue to bind to.
     */
    queueName?: string;
    /**
     * The script where the Durable Object is defined, if it is external to this Worker.
     */
    scriptName?: string;
    /**
     * Name of Worker to bind to.
     */
    service?: string;
    /**
     * The text value to use.
     */
    text?: string;
    /**
     * The kind of resource that the binding provides.
     */
    type: string;
}

export interface WorkersScriptBindingOutbound {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params?: string[];
    /**
     * Outbound worker.
     */
    worker?: outputs.WorkersScriptBindingOutboundWorker;
}

export interface WorkersScriptBindingOutboundWorker {
    /**
     * Environment of the outbound worker.
     */
    environment?: string;
    /**
     * Name of the outbound worker.
     */
    service?: string;
}

export interface WorkersScriptMigrations {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses?: string[];
    /**
     * Tag to set as the latest migration tag.
     */
    newTag?: string;
    /**
     * Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
     */
    oldTag?: string;
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses?: outputs.WorkersScriptMigrationsRenamedClass[];
    /**
     * Migrations to apply in order.
     */
    steps?: outputs.WorkersScriptMigrationsStep[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses?: outputs.WorkersScriptMigrationsTransferredClass[];
}

export interface WorkersScriptMigrationsRenamedClass {
    from?: string;
    to?: string;
}

export interface WorkersScriptMigrationsStep {
    /**
     * A list of classes to delete Durable Object namespaces from.
     */
    deletedClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces from.
     */
    newClasses?: string[];
    /**
     * A list of classes to create Durable Object namespaces with SQLite from.
     */
    newSqliteClasses?: string[];
    /**
     * A list of classes with Durable Object namespaces that were renamed.
     */
    renamedClasses?: outputs.WorkersScriptMigrationsStepRenamedClass[];
    /**
     * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
     */
    transferredClasses?: outputs.WorkersScriptMigrationsStepTransferredClass[];
}

export interface WorkersScriptMigrationsStepRenamedClass {
    from?: string;
    to?: string;
}

export interface WorkersScriptMigrationsStepTransferredClass {
    from?: string;
    fromScript?: string;
    to?: string;
}

export interface WorkersScriptMigrationsTransferredClass {
    from?: string;
    fromScript?: string;
    to?: string;
}

export interface WorkersScriptObservability {
    /**
     * Whether observability is enabled for the Worker.
     */
    enabled: boolean;
    /**
     * The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
     */
    headSamplingRate?: number;
}

export interface WorkersScriptPlacement {
    /**
     * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    mode?: string;
    /**
     * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
     */
    status: string;
}

export interface WorkersScriptTailConsumer {
    /**
     * Optional environment if the Worker utilizes one.
     */
    environment?: string;
    /**
     * Optional dispatch namespace the script belongs to.
     */
    namespace?: string;
    /**
     * Name of Worker that is to be the consumer.
     */
    service: string;
}

export interface ZeroTrustAccessApplicationCorsHeaders {
    /**
     * Allows all HTTP request headers.
     */
    allowAllHeaders?: boolean;
    /**
     * Allows all HTTP request methods.
     */
    allowAllMethods?: boolean;
    /**
     * Allows all origins.
     */
    allowAllOrigins?: boolean;
    /**
     * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
     */
    allowCredentials?: boolean;
    /**
     * Allowed HTTP request headers.
     */
    allowedHeaders?: string[];
    /**
     * Allowed HTTP request methods.
     */
    allowedMethods?: string[];
    /**
     * Allowed origins.
     */
    allowedOrigins?: string[];
    /**
     * The maximum number of seconds the results of a preflight request can be cached.
     */
    maxAge?: number;
}

export interface ZeroTrustAccessApplicationDestination {
    /**
     * The CIDR range of the destination. Single IPs will be computed as /32.
     */
    cidr?: string;
    /**
     * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
     */
    hostname?: string;
    /**
     * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
     */
    l4Protocol?: string;
    /**
     * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
     */
    portRange?: string;
    type?: string;
    /**
     * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
     */
    uri?: string;
    /**
     * The VNET ID to match the destination. When omitted, all VNETs will match.
     */
    vnetId?: string;
}

export interface ZeroTrustAccessApplicationFooterLink {
    /**
     * The hypertext in the footer link.
     */
    name: string;
    /**
     * the hyperlink in the footer link.
     */
    url: string;
}

export interface ZeroTrustAccessApplicationLandingPageDesign {
    /**
     * The background color of the log in button on the landing page.
     */
    buttonColor?: string;
    /**
     * The color of the text in the log in button on the landing page.
     */
    buttonTextColor?: string;
    /**
     * The URL of the image shown on the landing page.
     */
    imageUrl?: string;
    /**
     * The message shown on the landing page.
     */
    message?: string;
    /**
     * The title shown on the landing page.
     */
    title: string;
}

export interface ZeroTrustAccessApplicationPolicy {
    /**
     * The rules that define how users may connect to the targets secured by your application.
     */
    connectionRules: outputs.ZeroTrustAccessApplicationPolicyConnectionRules;
    /**
     * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
     */
    decision?: string;
    /**
     * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
     */
    excludes: outputs.ZeroTrustAccessApplicationPolicyExclude[];
    /**
     * The UUID of the policy
     */
    id?: string;
    /**
     * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
     */
    includes: outputs.ZeroTrustAccessApplicationPolicyInclude[];
    /**
     * The name of the Access policy.
     */
    name?: string;
    /**
     * The order of execution for this policy. Must be unique for each policy within an app.
     */
    precedence?: number;
    /**
     * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
     */
    requires: outputs.ZeroTrustAccessApplicationPolicyRequire[];
}

export interface ZeroTrustAccessApplicationPolicyConnectionRules {
    /**
     * The SSH-specific rules that define how users may connect to the targets secured by your application.
     */
    ssh: outputs.ZeroTrustAccessApplicationPolicyConnectionRulesSsh;
}

export interface ZeroTrustAccessApplicationPolicyConnectionRulesSsh {
    /**
     * Enables using Identity Provider email alias as SSH username.
     */
    allowEmailAlias?: boolean;
    /**
     * Contains the Unix usernames that may be used when connecting over SSH.
     */
    usernames: string[];
}

export interface ZeroTrustAccessApplicationPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessApplicationPolicyExcludeAuthContext;
    authMethod: outputs.ZeroTrustAccessApplicationPolicyExcludeAuthMethod;
    azureAd: outputs.ZeroTrustAccessApplicationPolicyExcludeAzureAd;
    certificate?: outputs.ZeroTrustAccessApplicationPolicyExcludeCertificate;
    commonName: outputs.ZeroTrustAccessApplicationPolicyExcludeCommonName;
    devicePosture: outputs.ZeroTrustAccessApplicationPolicyExcludeDevicePosture;
    email: outputs.ZeroTrustAccessApplicationPolicyExcludeEmail;
    emailDomain: outputs.ZeroTrustAccessApplicationPolicyExcludeEmailDomain;
    emailList: outputs.ZeroTrustAccessApplicationPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessApplicationPolicyExcludeEveryone;
    externalEvaluation: outputs.ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation;
    geo: outputs.ZeroTrustAccessApplicationPolicyExcludeGeo;
    githubOrganization: outputs.ZeroTrustAccessApplicationPolicyExcludeGithubOrganization;
    group: outputs.ZeroTrustAccessApplicationPolicyExcludeGroup;
    gsuite: outputs.ZeroTrustAccessApplicationPolicyExcludeGsuite;
    ip: outputs.ZeroTrustAccessApplicationPolicyExcludeIp;
    ipList: outputs.ZeroTrustAccessApplicationPolicyExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessApplicationPolicyExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessApplicationPolicyExcludeOkta;
    saml: outputs.ZeroTrustAccessApplicationPolicyExcludeSaml;
    serviceToken: outputs.ZeroTrustAccessApplicationPolicyExcludeServiceToken;
}

export interface ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceToken {
}

export interface ZeroTrustAccessApplicationPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeCertificate {
}

export interface ZeroTrustAccessApplicationPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeEveryone {
}

export interface ZeroTrustAccessApplicationPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessApplicationPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessApplicationPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessApplicationPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessApplicationPolicyIncludeAuthContext;
    authMethod: outputs.ZeroTrustAccessApplicationPolicyIncludeAuthMethod;
    azureAd: outputs.ZeroTrustAccessApplicationPolicyIncludeAzureAd;
    certificate?: outputs.ZeroTrustAccessApplicationPolicyIncludeCertificate;
    commonName: outputs.ZeroTrustAccessApplicationPolicyIncludeCommonName;
    devicePosture: outputs.ZeroTrustAccessApplicationPolicyIncludeDevicePosture;
    email: outputs.ZeroTrustAccessApplicationPolicyIncludeEmail;
    emailDomain: outputs.ZeroTrustAccessApplicationPolicyIncludeEmailDomain;
    emailList: outputs.ZeroTrustAccessApplicationPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessApplicationPolicyIncludeEveryone;
    externalEvaluation: outputs.ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation;
    geo: outputs.ZeroTrustAccessApplicationPolicyIncludeGeo;
    githubOrganization: outputs.ZeroTrustAccessApplicationPolicyIncludeGithubOrganization;
    group: outputs.ZeroTrustAccessApplicationPolicyIncludeGroup;
    gsuite: outputs.ZeroTrustAccessApplicationPolicyIncludeGsuite;
    ip: outputs.ZeroTrustAccessApplicationPolicyIncludeIp;
    ipList: outputs.ZeroTrustAccessApplicationPolicyIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessApplicationPolicyIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessApplicationPolicyIncludeOkta;
    saml: outputs.ZeroTrustAccessApplicationPolicyIncludeSaml;
    serviceToken: outputs.ZeroTrustAccessApplicationPolicyIncludeServiceToken;
}

export interface ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceToken {
}

export interface ZeroTrustAccessApplicationPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeCertificate {
}

export interface ZeroTrustAccessApplicationPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeEveryone {
}

export interface ZeroTrustAccessApplicationPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessApplicationPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessApplicationPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessApplicationPolicyRequireAuthContext;
    authMethod: outputs.ZeroTrustAccessApplicationPolicyRequireAuthMethod;
    azureAd: outputs.ZeroTrustAccessApplicationPolicyRequireAzureAd;
    certificate?: outputs.ZeroTrustAccessApplicationPolicyRequireCertificate;
    commonName: outputs.ZeroTrustAccessApplicationPolicyRequireCommonName;
    devicePosture: outputs.ZeroTrustAccessApplicationPolicyRequireDevicePosture;
    email: outputs.ZeroTrustAccessApplicationPolicyRequireEmail;
    emailDomain: outputs.ZeroTrustAccessApplicationPolicyRequireEmailDomain;
    emailList: outputs.ZeroTrustAccessApplicationPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessApplicationPolicyRequireEveryone;
    externalEvaluation: outputs.ZeroTrustAccessApplicationPolicyRequireExternalEvaluation;
    geo: outputs.ZeroTrustAccessApplicationPolicyRequireGeo;
    githubOrganization: outputs.ZeroTrustAccessApplicationPolicyRequireGithubOrganization;
    group: outputs.ZeroTrustAccessApplicationPolicyRequireGroup;
    gsuite: outputs.ZeroTrustAccessApplicationPolicyRequireGsuite;
    ip: outputs.ZeroTrustAccessApplicationPolicyRequireIp;
    ipList: outputs.ZeroTrustAccessApplicationPolicyRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessApplicationPolicyRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessApplicationPolicyRequireOkta;
    saml: outputs.ZeroTrustAccessApplicationPolicyRequireSaml;
    serviceToken: outputs.ZeroTrustAccessApplicationPolicyRequireServiceToken;
}

export interface ZeroTrustAccessApplicationPolicyRequireAnyValidServiceToken {
}

export interface ZeroTrustAccessApplicationPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireCertificate {
}

export interface ZeroTrustAccessApplicationPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireEveryone {
}

export interface ZeroTrustAccessApplicationPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessApplicationPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessApplicationPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessApplicationPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessApplicationSaasApp {
    /**
     * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime?: string;
    /**
     * If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
     */
    allowPkceWithoutClientSecret?: boolean;
    /**
     * The URL where this applications tile redirects users
     */
    appLauncherUrl?: string;
    /**
     * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
     */
    authType: string;
    /**
     * The application client id
     */
    clientId: string;
    /**
     * The application client secret, only returned on POST request.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl?: string;
    createdAt: string;
    customAttributes: outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute[];
    customClaims: outputs.ZeroTrustAccessApplicationSaasAppCustomClaim[];
    /**
     * The URL that the user will be redirected to after a successful login for IDP initiated logins.
     */
    defaultRelayState?: string;
    /**
     * The OIDC flows supported by this application
     */
    grantTypes?: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
     */
    groupFilterRegex?: string;
    hybridAndImplicitOptions: outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for your SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     */
    nameIdFormat?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `nameIdFormat` setting.
     */
    nameIdTransformJsonata?: string;
    /**
     * The Access public certificate that will be used to verify your identity.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
     */
    redirectUris?: string[];
    refreshTokenOptions: outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOptions;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata?: string;
    /**
     * Define the user information shared with access, "offlineAccess" scope will be automatically enabled if refresh tokens are enabled
     */
    scopes?: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId?: string;
    /**
     * The endpoint where your SaaS application will send login requests.
     */
    ssoEndpoint: string;
    updatedAt: string;
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttribute {
    /**
     * The SAML FriendlyName of the attribute.
     */
    friendlyName?: string;
    /**
     * The name of the attribute.
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat?: string;
    /**
     * If the attribute is required when building a SAML assertion.
     */
    required?: boolean;
    source: outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource;
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the IdP attribute.
     */
    name?: string;
    /**
     * A mapping from IdP ID to attribute name.
     */
    nameByIdps: outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp[];
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdp {
    /**
     * The UID of the IdP.
     */
    idpId?: string;
    /**
     * The name of the IdP provided attribute.
     */
    sourceName?: string;
}

export interface ZeroTrustAccessApplicationSaasAppCustomClaim {
    /**
     * The name of the claim.
     */
    name?: string;
    /**
     * If the claim is required when building an OIDC token.
     */
    required?: boolean;
    /**
     * The scope of the claim.
     */
    scope?: string;
    source: outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource;
}

export interface ZeroTrustAccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the IdP claim.
     */
    name?: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    returnAccessTokenFromAuthorizationEndpoint?: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    returnIdTokenFromAuthorizationEndpoint?: boolean;
}

export interface ZeroTrustAccessApplicationSaasAppRefreshTokenOptions {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     */
    lifetime?: string;
}

export interface ZeroTrustAccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
     */
    authentication: outputs.ZeroTrustAccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete?: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled?: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings: outputs.ZeroTrustAccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface ZeroTrustAccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation.
     */
    authorizationUrl?: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
     */
    clientId?: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
     */
    clientSecret?: string;
    /**
     * Password used to authenticate with the remote SCIM service.
     */
    password?: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
     */
    scopes?: string[];
    /**
     * Token used to authenticate with the remote SCIM service.
     */
    token?: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service.
     */
    tokenUrl?: string;
    /**
     * User name used to authenticate with the remote SCIM service.
     */
    user?: string;
}

export interface ZeroTrustAccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled?: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter?: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations: outputs.ZeroTrustAccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
     */
    strictness?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata?: string;
}

export interface ZeroTrustAccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
}

export interface ZeroTrustAccessApplicationTargetCriteria {
    /**
     * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
     */
    port: number;
    /**
     * The communication protocol your application secures.
     */
    protocol: string;
    /**
     * Contains a map of target attribute keys to target attribute values.
     */
    targetAttributes: {[key: string]: string[]};
}

export interface ZeroTrustAccessGroupExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessGroupExcludeAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessGroupExcludeAuthContext;
    authMethod: outputs.ZeroTrustAccessGroupExcludeAuthMethod;
    azureAd: outputs.ZeroTrustAccessGroupExcludeAzureAd;
    certificate?: outputs.ZeroTrustAccessGroupExcludeCertificate;
    commonName: outputs.ZeroTrustAccessGroupExcludeCommonName;
    devicePosture: outputs.ZeroTrustAccessGroupExcludeDevicePosture;
    email: outputs.ZeroTrustAccessGroupExcludeEmail;
    emailDomain: outputs.ZeroTrustAccessGroupExcludeEmailDomain;
    emailList: outputs.ZeroTrustAccessGroupExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessGroupExcludeEveryone;
    externalEvaluation: outputs.ZeroTrustAccessGroupExcludeExternalEvaluation;
    geo: outputs.ZeroTrustAccessGroupExcludeGeo;
    githubOrganization: outputs.ZeroTrustAccessGroupExcludeGithubOrganization;
    group: outputs.ZeroTrustAccessGroupExcludeGroup;
    gsuite: outputs.ZeroTrustAccessGroupExcludeGsuite;
    ip: outputs.ZeroTrustAccessGroupExcludeIp;
    ipList: outputs.ZeroTrustAccessGroupExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessGroupExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessGroupExcludeOkta;
    saml: outputs.ZeroTrustAccessGroupExcludeSaml;
    serviceToken: outputs.ZeroTrustAccessGroupExcludeServiceToken;
}

export interface ZeroTrustAccessGroupExcludeAnyValidServiceToken {
}

export interface ZeroTrustAccessGroupExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessGroupExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeCertificate {
}

export interface ZeroTrustAccessGroupExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessGroupExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessGroupExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessGroupExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessGroupExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupExcludeEveryone {
}

export interface ZeroTrustAccessGroupExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessGroupExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessGroupExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessGroupExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessGroupExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessGroupExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessGroupExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessGroupExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessGroupExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessGroupInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessGroupIncludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessGroupIncludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessGroupIncludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessGroupIncludeAzureAd;
    certificate?: outputs.ZeroTrustAccessGroupIncludeCertificate;
    commonName?: outputs.ZeroTrustAccessGroupIncludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessGroupIncludeDevicePosture;
    email?: outputs.ZeroTrustAccessGroupIncludeEmail;
    emailDomain?: outputs.ZeroTrustAccessGroupIncludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessGroupIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessGroupIncludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessGroupIncludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessGroupIncludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessGroupIncludeGithubOrganization;
    group?: outputs.ZeroTrustAccessGroupIncludeGroup;
    gsuite?: outputs.ZeroTrustAccessGroupIncludeGsuite;
    ip?: outputs.ZeroTrustAccessGroupIncludeIp;
    ipList?: outputs.ZeroTrustAccessGroupIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod?: outputs.ZeroTrustAccessGroupIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta?: outputs.ZeroTrustAccessGroupIncludeOkta;
    saml?: outputs.ZeroTrustAccessGroupIncludeSaml;
    serviceToken?: outputs.ZeroTrustAccessGroupIncludeServiceToken;
}

export interface ZeroTrustAccessGroupIncludeAnyValidServiceToken {
}

export interface ZeroTrustAccessGroupIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessGroupIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeCertificate {
}

export interface ZeroTrustAccessGroupIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessGroupIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessGroupIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessGroupIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessGroupIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupIncludeEveryone {
}

export interface ZeroTrustAccessGroupIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessGroupIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessGroupIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessGroupIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessGroupIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessGroupIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessGroupIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessGroupIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessGroupIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessGroupRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessGroupRequireAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessGroupRequireAuthContext;
    authMethod: outputs.ZeroTrustAccessGroupRequireAuthMethod;
    azureAd: outputs.ZeroTrustAccessGroupRequireAzureAd;
    certificate?: outputs.ZeroTrustAccessGroupRequireCertificate;
    commonName: outputs.ZeroTrustAccessGroupRequireCommonName;
    devicePosture: outputs.ZeroTrustAccessGroupRequireDevicePosture;
    email: outputs.ZeroTrustAccessGroupRequireEmail;
    emailDomain: outputs.ZeroTrustAccessGroupRequireEmailDomain;
    emailList: outputs.ZeroTrustAccessGroupRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessGroupRequireEveryone;
    externalEvaluation: outputs.ZeroTrustAccessGroupRequireExternalEvaluation;
    geo: outputs.ZeroTrustAccessGroupRequireGeo;
    githubOrganization: outputs.ZeroTrustAccessGroupRequireGithubOrganization;
    group: outputs.ZeroTrustAccessGroupRequireGroup;
    gsuite: outputs.ZeroTrustAccessGroupRequireGsuite;
    ip: outputs.ZeroTrustAccessGroupRequireIp;
    ipList: outputs.ZeroTrustAccessGroupRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessGroupRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessGroupRequireOkta;
    saml: outputs.ZeroTrustAccessGroupRequireSaml;
    serviceToken: outputs.ZeroTrustAccessGroupRequireServiceToken;
}

export interface ZeroTrustAccessGroupRequireAnyValidServiceToken {
}

export interface ZeroTrustAccessGroupRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessGroupRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireCertificate {
}

export interface ZeroTrustAccessGroupRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessGroupRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessGroupRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessGroupRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessGroupRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessGroupRequireEveryone {
}

export interface ZeroTrustAccessGroupRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessGroupRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessGroupRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessGroupRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessGroupRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessGroupRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessGroupRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessGroupRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessGroupRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessIdentityProviderConfig {
    /**
     * Your companies TLD
     */
    appsDomain?: string;
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     */
    attributes?: string[];
    /**
     * The authorizationEndpoint URL of your IdP
     */
    authUrl?: string;
    /**
     * Your okta authorization server id
     */
    authorizationServerId?: string;
    /**
     * Your centrify account url
     */
    centrifyAccount?: string;
    /**
     * Your centrify app id
     */
    centrifyAppId?: string;
    /**
     * The jwksUri endpoint of your IdP to allow the IdP keys to sign the tokens
     */
    certsUrl?: string;
    /**
     * Custom claims
     */
    claims?: string[];
    /**
     * Your OAuth Client ID
     */
    clientId?: string;
    /**
     * Your OAuth Client Secret
     */
    clientSecret?: string;
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditionalAccessEnabled?: boolean;
    /**
     * Your Azure directory uuid
     */
    directoryId?: string;
    /**
     * The attribute name for email in the SAML response.
     */
    emailAttributeName?: string;
    /**
     * The claim name for email in the idToken response.
     */
    emailClaimName?: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    headerAttributes?: outputs.ZeroTrustAccessIdentityProviderConfigHeaderAttribute[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idpPublicCerts?: string[];
    /**
     * IdP Entity ID or Issuer URL
     */
    issuerUrl?: string;
    /**
     * Your okta account url
     */
    oktaAccount?: string;
    /**
     * Your OneLogin account url
     */
    oneloginAccount?: string;
    /**
     * Your PingOne environment identifier
     */
    pingEnvId?: string;
    /**
     * Enable Proof Key for Code Exchange (PKCE)
     */
    pkceEnabled?: boolean;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     */
    prompt?: string;
    redirectUrl: string;
    /**
     * OAuth scopes
     */
    scopes?: string[];
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    signRequest?: boolean;
    /**
     * URL to send the SAML authentication requests to
     */
    ssoTargetUrl?: string;
    /**
     * Should Cloudflare try to load groups from your account
     */
    supportGroups?: boolean;
    /**
     * The tokenEndpoint URL of your IdP
     */
    tokenUrl?: string;
}

export interface ZeroTrustAccessIdentityProviderConfigHeaderAttribute {
    /**
     * attribute name from the IDP
     */
    attributeName?: string;
    /**
     * header that will be added on the request to the origin
     */
    headerName?: string;
}

export interface ZeroTrustAccessIdentityProviderScimConfig {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "noAction" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     */
    identityUpdateBehavior?: string;
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scimBaseUrl: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless userDeprovision is also enabled.
     */
    seatDeprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
     */
    secret: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     */
    userDeprovision?: boolean;
}

export interface ZeroTrustAccessInfrastructureTargetIp {
    /**
     * The target's IPv4 address
     */
    ipv4?: outputs.ZeroTrustAccessInfrastructureTargetIpIpv4;
    /**
     * The target's IPv6 address
     */
    ipv6?: outputs.ZeroTrustAccessInfrastructureTargetIpIpv6;
}

export interface ZeroTrustAccessInfrastructureTargetIpIpv4 {
    /**
     * IP address of the target
     */
    ipAddr?: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId?: string;
}

export interface ZeroTrustAccessInfrastructureTargetIpIpv6 {
    /**
     * IP address of the target
     */
    ipAddr?: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     */
    virtualNetworkId?: string;
}

export interface ZeroTrustAccessMtlsHostnameSettingsSetting {
    /**
     * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
     */
    chinaNetwork: boolean;
    /**
     * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
     */
    clientCertificateForwarding: boolean;
    /**
     * The hostname that these settings apply to.
     */
    hostname: string;
}

export interface ZeroTrustAccessPolicyApprovalGroup {
    /**
     * The number of approvals needed to obtain access.
     */
    approvalsNeeded: number;
    /**
     * A list of emails that can approve the access request.
     */
    emailAddresses?: string[];
    /**
     * The UUID of an re-usable email list.
     */
    emailListUuid?: string;
}

export interface ZeroTrustAccessPolicyExclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessPolicyExcludeAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessPolicyExcludeAuthContext;
    authMethod: outputs.ZeroTrustAccessPolicyExcludeAuthMethod;
    azureAd: outputs.ZeroTrustAccessPolicyExcludeAzureAd;
    certificate?: outputs.ZeroTrustAccessPolicyExcludeCertificate;
    commonName: outputs.ZeroTrustAccessPolicyExcludeCommonName;
    devicePosture: outputs.ZeroTrustAccessPolicyExcludeDevicePosture;
    email: outputs.ZeroTrustAccessPolicyExcludeEmail;
    emailDomain: outputs.ZeroTrustAccessPolicyExcludeEmailDomain;
    emailList: outputs.ZeroTrustAccessPolicyExcludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessPolicyExcludeEveryone;
    externalEvaluation: outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation;
    geo: outputs.ZeroTrustAccessPolicyExcludeGeo;
    githubOrganization: outputs.ZeroTrustAccessPolicyExcludeGithubOrganization;
    group: outputs.ZeroTrustAccessPolicyExcludeGroup;
    gsuite: outputs.ZeroTrustAccessPolicyExcludeGsuite;
    ip: outputs.ZeroTrustAccessPolicyExcludeIp;
    ipList: outputs.ZeroTrustAccessPolicyExcludeIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessPolicyExcludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessPolicyExcludeOkta;
    saml: outputs.ZeroTrustAccessPolicyExcludeSaml;
    serviceToken: outputs.ZeroTrustAccessPolicyExcludeServiceToken;
}

export interface ZeroTrustAccessPolicyExcludeAnyValidServiceToken {
}

export interface ZeroTrustAccessPolicyExcludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessPolicyExcludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeCertificate {
}

export interface ZeroTrustAccessPolicyExcludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessPolicyExcludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessPolicyExcludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessPolicyExcludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessPolicyExcludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyExcludeEveryone {
}

export interface ZeroTrustAccessPolicyExcludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessPolicyExcludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessPolicyExcludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessPolicyExcludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyExcludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessPolicyExcludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessPolicyExcludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessPolicyExcludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessPolicyExcludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessPolicyInclude {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessPolicyIncludeAnyValidServiceToken;
    authContext?: outputs.ZeroTrustAccessPolicyIncludeAuthContext;
    authMethod?: outputs.ZeroTrustAccessPolicyIncludeAuthMethod;
    azureAd?: outputs.ZeroTrustAccessPolicyIncludeAzureAd;
    certificate?: outputs.ZeroTrustAccessPolicyIncludeCertificate;
    commonName?: outputs.ZeroTrustAccessPolicyIncludeCommonName;
    devicePosture?: outputs.ZeroTrustAccessPolicyIncludeDevicePosture;
    email?: outputs.ZeroTrustAccessPolicyIncludeEmail;
    emailDomain?: outputs.ZeroTrustAccessPolicyIncludeEmailDomain;
    emailList?: outputs.ZeroTrustAccessPolicyIncludeEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessPolicyIncludeEveryone;
    externalEvaluation?: outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation;
    geo?: outputs.ZeroTrustAccessPolicyIncludeGeo;
    githubOrganization?: outputs.ZeroTrustAccessPolicyIncludeGithubOrganization;
    group?: outputs.ZeroTrustAccessPolicyIncludeGroup;
    gsuite?: outputs.ZeroTrustAccessPolicyIncludeGsuite;
    ip?: outputs.ZeroTrustAccessPolicyIncludeIp;
    ipList?: outputs.ZeroTrustAccessPolicyIncludeIpList;
<<<<<<< HEAD
=======
    loginMethod?: outputs.ZeroTrustAccessPolicyIncludeLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta?: outputs.ZeroTrustAccessPolicyIncludeOkta;
    saml?: outputs.ZeroTrustAccessPolicyIncludeSaml;
    serviceToken?: outputs.ZeroTrustAccessPolicyIncludeServiceToken;
}

export interface ZeroTrustAccessPolicyIncludeAnyValidServiceToken {
}

export interface ZeroTrustAccessPolicyIncludeAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessPolicyIncludeAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeCertificate {
}

export interface ZeroTrustAccessPolicyIncludeCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessPolicyIncludeDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessPolicyIncludeEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessPolicyIncludeEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessPolicyIncludeEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyIncludeEveryone {
}

export interface ZeroTrustAccessPolicyIncludeExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessPolicyIncludeGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessPolicyIncludeGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessPolicyIncludeGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyIncludeGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessPolicyIncludeIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessPolicyIncludeLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessPolicyIncludeOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessPolicyIncludeSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustAccessPolicyRequire {
    /**
     * An empty object which matches on all service tokens.
     */
    anyValidServiceToken?: outputs.ZeroTrustAccessPolicyRequireAnyValidServiceToken;
    authContext: outputs.ZeroTrustAccessPolicyRequireAuthContext;
    authMethod: outputs.ZeroTrustAccessPolicyRequireAuthMethod;
    azureAd: outputs.ZeroTrustAccessPolicyRequireAzureAd;
    certificate?: outputs.ZeroTrustAccessPolicyRequireCertificate;
    commonName: outputs.ZeroTrustAccessPolicyRequireCommonName;
    devicePosture: outputs.ZeroTrustAccessPolicyRequireDevicePosture;
    email: outputs.ZeroTrustAccessPolicyRequireEmail;
    emailDomain: outputs.ZeroTrustAccessPolicyRequireEmailDomain;
    emailList: outputs.ZeroTrustAccessPolicyRequireEmailList;
    /**
     * An empty object which matches on all users.
     */
    everyone?: outputs.ZeroTrustAccessPolicyRequireEveryone;
    externalEvaluation: outputs.ZeroTrustAccessPolicyRequireExternalEvaluation;
    geo: outputs.ZeroTrustAccessPolicyRequireGeo;
    githubOrganization: outputs.ZeroTrustAccessPolicyRequireGithubOrganization;
    group: outputs.ZeroTrustAccessPolicyRequireGroup;
    gsuite: outputs.ZeroTrustAccessPolicyRequireGsuite;
    ip: outputs.ZeroTrustAccessPolicyRequireIp;
    ipList: outputs.ZeroTrustAccessPolicyRequireIpList;
<<<<<<< HEAD
=======
    loginMethod: outputs.ZeroTrustAccessPolicyRequireLoginMethod;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
    okta: outputs.ZeroTrustAccessPolicyRequireOkta;
    saml: outputs.ZeroTrustAccessPolicyRequireSaml;
    serviceToken: outputs.ZeroTrustAccessPolicyRequireServiceToken;
}

export interface ZeroTrustAccessPolicyRequireAnyValidServiceToken {
}

export interface ZeroTrustAccessPolicyRequireAuthContext {
    /**
     * The ACID of an Authentication context.
     */
    acId: string;
    /**
     * The ID of an Authentication context.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireAuthMethod {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     */
    authMethod: string;
}

export interface ZeroTrustAccessPolicyRequireAzureAd {
    /**
     * The ID of an Azure group.
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireCertificate {
}

export interface ZeroTrustAccessPolicyRequireCommonName {
    /**
     * The common name to match.
     */
    commonName: string;
}

export interface ZeroTrustAccessPolicyRequireDevicePosture {
    /**
     * The ID of a device posture integration.
     */
    integrationUid: string;
}

export interface ZeroTrustAccessPolicyRequireEmail {
    /**
     * The email of the user.
     */
    email: string;
}

export interface ZeroTrustAccessPolicyRequireEmailDomain {
    /**
     * The email domain to match.
     */
    domain: string;
}

export interface ZeroTrustAccessPolicyRequireEmailList {
    /**
     * The ID of a previously created email list.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyRequireEveryone {
}

export interface ZeroTrustAccessPolicyRequireExternalEvaluation {
    /**
     * The API endpoint containing your business logic.
     */
    evaluateUrl: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     */
    keysUrl: string;
}

export interface ZeroTrustAccessPolicyRequireGeo {
    /**
     * The country code that should be matched.
     */
    countryCode: string;
}

export interface ZeroTrustAccessPolicyRequireGithubOrganization {
    /**
     * The ID of your Github identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The name of the team
     */
    team?: string;
}

export interface ZeroTrustAccessPolicyRequireGroup {
    /**
     * The ID of a previously created Access group.
     */
    id: string;
}

export interface ZeroTrustAccessPolicyRequireGsuite {
    /**
     * The email of the Google Workspace group.
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireIp {
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ip: string;
}

export interface ZeroTrustAccessPolicyRequireIpList {
    /**
     * The ID of a previously created IP list.
     */
    id: string;
}

<<<<<<< HEAD
=======
export interface ZeroTrustAccessPolicyRequireLoginMethod {
    /**
     * The ID of an identity provider.
     */
    id: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustAccessPolicyRequireOkta {
    /**
     * The ID of your Okta identity provider.
     */
    identityProviderId: string;
    /**
     * The name of the Okta group.
     */
    name: string;
}

export interface ZeroTrustAccessPolicyRequireSaml {
    /**
     * The name of the SAML attribute.
     */
    attributeName: string;
    /**
     * The SAML attribute value to look for.
     */
    attributeValue: string;
    /**
     * The ID of your SAML identity provider.
     */
    identityProviderId: string;
<<<<<<< HEAD
}

export interface ZeroTrustAccessPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
    tokenId: string;
}

export interface ZeroTrustDeviceCustomProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceCustomProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceCustomProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceCustomProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode?: string;
    /**
     * The port number when used with proxy mode.
     */
    port?: number;
}

export interface ZeroTrustDeviceCustomProfileTargetTest {
    /**
     * The id of the DEX test targeting this policy
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy
     */
    name: string;
}

export interface ZeroTrustDeviceDefaultProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceDefaultProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceDefaultProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceDefaultProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode?: string;
    /**
     * The port number when used with proxy mode.
     */
    port?: number;
=======
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface ZeroTrustAccessPolicyRequireServiceToken {
    /**
     * The ID of a Service Token.
     */
<<<<<<< HEAD
    sha256?: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
=======
    tokenId: string;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
}

export interface ZeroTrustDeviceCustomProfileExclude {
    /**
<<<<<<< HEAD
     * If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `apiUrl`
=======
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     */
    address: string;
    /**
<<<<<<< HEAD
     * If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `apiUrl`
=======
     * A description of the Split Tunnel item, displayed in the client UI.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     */
    description: string;
    /**
<<<<<<< HEAD
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl?: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl?: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId?: string;
    /**
     * The Uptycs client secret.
     */
    clientKey?: string;
    /**
     * The Workspace One client secret provided in the Workspace One Admin Dashboard.
     */
    clientSecret?: string;
    /**
     * The Crowdstrike customer ID.
     */
    customerId?: string;
}

export interface ZeroTrustDevicePostureRuleInput {
    /**
     * The Number of active threats.
     */
    activeThreats?: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks?: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey?: boolean;
    /**
     * Common Name that is protected by the certificate
     */
    cn?: string;
    /**
     * Compliance Status
     */
    complianceStatus?: string;
    /**
     * Posture Integration ID.
     */
    connectionId?: string;
    /**
     * Count Operator
     */
    countOperator?: string;
    /**
     * Domain
     */
    domain?: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen?: string;
    /**
     * Enabled
     */
    enabled?: boolean;
    /**
     * Whether or not file exists
     */
    exists?: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used
     */
    extendedKeyUsages?: string[];
    /**
     * List ID.
     */
    id?: string;
    /**
     * Whether device is infected.
     */
    infected?: boolean;
    /**
     * Whether device is active.
     */
    isActive?: boolean;
    /**
     * The Number of Issues.
     */
    issueCount?: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen?: string;
    locations: outputs.ZeroTrustDevicePostureRuleInputLocations;
    /**
     * Network status of device.
     */
    networkStatus?: string;
    /**
     * Operating system
     */
    operatingSystem?: string;
    /**
     * Agent operational state.
     */
    operationalState?: string;
    /**
     * operator
     */
    operator?: string;
    /**
     * Os Version
     */
    os?: string;
    /**
     * Operating System Distribution Name (linux only)
     */
    osDistroName?: string;
    /**
     * Version of OS Distribution (linux only)
     */
    osDistroRevision?: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
     */
    osVersionExtra?: string;
    /**
     * overall
     */
    overall?: string;
    /**
     * File path.
     */
    path?: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll?: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     */
    riskLevel?: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score?: number;
    /**
     * Score Operator
     */
    scoreOperator?: string;
    /**
     * SensorConfig
     */
    sensorConfig?: string;
    /**
     * SHA-256.
     */
    sha256?: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     */
    state?: string;
    /**
     * Signing certificate thumbprint.
     */
    thumbprint?: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore?: number;
    /**
     * Version of OS
     */
    version?: string;
    /**
     * Version Operator
     */
    versionOperator?: string;
}

export interface ZeroTrustDevicePostureRuleInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths?: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores?: string[];
}

export interface ZeroTrustDevicePostureRuleMatch {
    platform?: string;
}

export interface ZeroTrustDexTestData {
    /**
     * The desired endpoint to test.
     */
    host?: string;
    /**
     * The type of test.
     */
    kind?: string;
    /**
     * The HTTP request method type.
     */
    method?: string;
}

export interface ZeroTrustDexTestTargetPolicy {
    /**
     * Whether the profile is the account default
     */
    default?: boolean;
    /**
     * The id of the device settings profile
     */
    id?: string;
    /**
     * The name of the device settings profile
     */
    name?: string;
}

export interface ZeroTrustDlpCustomProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpCustomProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpCustomProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpCustomProfileEntry {
    enabled: boolean;
    name: string;
    pattern: outputs.ZeroTrustDlpCustomProfileEntryPattern;
    words?: string[];
}

export interface ZeroTrustDlpCustomProfileEntryPattern {
    regex: string;
    validation?: string;
}

export interface ZeroTrustDlpCustomProfileProfile {
    /**
     * Related DLP policies will trigger when the match count exceeds the number set.
     */
    allowedMatchCount: number;
    confidenceThreshold?: string;
    /**
     * Scan the context of predefined entries to only return matches surrounded by keywords.
     */
    contextAwareness: outputs.ZeroTrustDlpCustomProfileProfileContextAwareness;
    /**
     * The description of the profile
     */
    description?: string;
    entries: outputs.ZeroTrustDlpCustomProfileProfileEntry[];
    name: string;
    ocrEnabled?: boolean;
    /**
     * Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
     */
    sharedEntries: outputs.ZeroTrustDlpCustomProfileProfileSharedEntry[];
}

export interface ZeroTrustDlpCustomProfileProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpCustomProfileProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpCustomProfileProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpCustomProfileProfileEntry {
    enabled: boolean;
    name: string;
    pattern?: outputs.ZeroTrustDlpCustomProfileProfileEntryPattern;
    words?: string[];
}

export interface ZeroTrustDlpCustomProfileProfileEntryPattern {
    regex: string;
    validation?: string;
}

export interface ZeroTrustDlpCustomProfileProfileSharedEntry {
    enabled: boolean;
    entryId: string;
    entryType: string;
}

export interface ZeroTrustDlpCustomProfileSharedEntry {
    enabled: boolean;
    entryId: string;
    entryType: string;
}

export interface ZeroTrustDlpDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus: string;
}

export interface ZeroTrustDlpDatasetDataset {
    columns: outputs.ZeroTrustDlpDatasetDatasetColumn[];
    createdAt: string;
    /**
     * The description of the dataset
     */
    description: string;
    encodingVersion: number;
    id: string;
    name: string;
    numCells: number;
    secret: boolean;
    status: string;
    /**
     * When the dataset was last updated.
     */
    updatedAt: string;
    uploads: outputs.ZeroTrustDlpDatasetDatasetUpload[];
}

export interface ZeroTrustDlpDatasetDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus: string;
}

export interface ZeroTrustDlpDatasetDatasetUpload {
    numCells: number;
    status: string;
    version: number;
}

export interface ZeroTrustDlpDatasetUpload {
    numCells: number;
    status: string;
    version: number;
}

export interface ZeroTrustDlpEntryConfidence {
    /**
     * Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
     * Profiles that use an entry with `available` set to true can use confidence thresholds
     */
    available: boolean;
}

export interface ZeroTrustDlpEntryPattern {
    regex: string;
    validation?: string;
}

export interface ZeroTrustDlpPredefinedProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpPredefinedProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpPredefinedProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpPredefinedProfileEntry {
    enabled: boolean;
    id: string;
}

export interface ZeroTrustDnsLocationEndpoints {
    doh: outputs.ZeroTrustDnsLocationEndpointsDoh;
    dot: outputs.ZeroTrustDnsLocationEndpointsDot;
    ipv4: outputs.ZeroTrustDnsLocationEndpointsIpv4;
    ipv6: outputs.ZeroTrustDnsLocationEndpointsIpv6;
}

export interface ZeroTrustDnsLocationEndpointsDoh {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsDohNetwork[];
    /**
     * True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
     */
    requireToken?: boolean;
}

export interface ZeroTrustDnsLocationEndpointsDohNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationEndpointsDot {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsDotNetwork[];
}

export interface ZeroTrustDnsLocationEndpointsDotNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationEndpointsIpv4 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
}

export interface ZeroTrustDnsLocationEndpointsIpv6 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
    /**
     * A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsIpv6Network[];
}

export interface ZeroTrustDnsLocationEndpointsIpv6Network {
    /**
     * The IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationNetwork {
    /**
     * The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
     */
    network: string;
}

export interface ZeroTrustGatewayPolicyExpiration {
    /**
     * The default duration a policy will be active in minutes. Must be set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration?: number;
    /**
     * Whether the policy has expired.
     */
    expired?: boolean;
    /**
     * The time stamp at which the policy will expire and cease to be
     * applied.
     */
    expiresAt: string;
}

export interface ZeroTrustGatewayPolicyRuleSettings {
    /**
     * Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
     */
    addHeaders?: {[key: string]: string};
    /**
     * Set by parent MSP accounts to enable their children to bypass this rule.
     */
    allowChildBypass?: boolean;
    /**
     * Settings for the Audit SSH action.
     */
    auditSsh: outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls: outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls;
    /**
     * Enable the custom block page.
     */
    blockPageEnabled?: boolean;
    /**
     * The text describing why this block occurred, displayed on the custom block page (if enabled).
     */
    blockReason?: string;
    /**
     * Set by children MSP accounts to bypass their parent's rules.
     */
    bypassParentRule?: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession: outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
     */
    dnsResolvers: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
     */
    egress: outputs.ZeroTrustGatewayPolicyRuleSettingsEgress;
    /**
     * Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
     */
    ignoreCnameCategoryMatches?: boolean;
    /**
     * INSECURE - disable DNSSEC validation (for Allow actions).
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
     */
    ipCategories?: boolean;
    /**
     * Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
     */
    ipIndicatorFeeds?: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port.
     */
    l4override: outputs.ZeroTrustGatewayPolicyRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule is matched.
     */
    notificationSettings: outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings;
    /**
     * Override matching DNS queries with a hostname.
     */
    overrideHost?: string;
    /**
     * Override matching DNS queries with an IP or set of IPs.
     */
    overrideIps?: string[];
    /**
     * Configure DLP payload logging.
     */
    payloadLog: outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog;
    /**
     * Settings that apply to quarantine rules
     */
    quarantine: outputs.ZeroTrustGatewayPolicyRuleSettingsQuarantine;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsInternally: outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsThroughCloudflare?: boolean;
    /**
     * Configure behavior when an upstream cert is invalid or an SSL error occurs.
     */
    untrustedCert: outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert;
}

export interface ZeroTrustGatewayPolicyRuleSettingsAuditSsh {
    /**
     * Enable to turn on SSH command logging.
     */
    commandLogging?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls {
    /**
     * Configure whether copy is enabled or not. When set with "remoteOnly", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
     */
    copy?: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp?: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd?: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk?: boolean;
    /**
     * Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
     */
    download?: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp?: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du?: boolean;
    /**
     * Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
     */
    keyboard?: string;
    /**
     * Configure whether pasting is enabled or not. When set with "remoteOnly", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
     */
    paste?: string;
    /**
     * Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
     */
    printing?: string;
    /**
     * Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
     */
    upload?: string;
    /**
     * Indicates which version of the browser isolation controls should apply.
     */
    version: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration?: string;
    /**
     * Set to true to enable session enforcement.
     */
    enforce?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolvers {
    ipv4s: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4[];
    ipv6s: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4 {
    /**
     * IPv4 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6 {
    /**
     * IPv6 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4?: string;
    /**
     * The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback?: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsL4override {
    /**
     * IPv4 or IPv6 address.
     */
    ip?: string;
    /**
     * A port number to use for TCP/UDP overrides.
     */
    port?: number;
}

export interface ZeroTrustGatewayPolicyRuleSettingsNotificationSettings {
    /**
     * Set notification on
     */
    enabled?: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg?: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsPayloadLog {
    /**
     * Set to true to enable DLP payload logging for this rule.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsQuarantine {
    /**
     * Types of files to sandbox.
     */
    fileTypes?: string[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally {
    /**
     * The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
     */
    fallback?: string;
    /**
     * The internal DNS view identifier that's passed to the internal DNS service.
     */
    viewId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsUntrustedCert {
    /**
     * The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
     */
    action?: string;
}

export interface ZeroTrustGatewayPolicySchedule {
    /**
     * The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
     */
    fri?: string;
    /**
     * The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
     */
    mon?: string;
    /**
     * The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
     */
    sat?: string;
    /**
     * The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
     */
    sun?: string;
    /**
     * The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
     */
    thu?: string;
    /**
     * The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
     */
    timeZone?: string;
    /**
     * The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
     */
    tue?: string;
    /**
     * The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
     */
    wed?: string;
}

export interface ZeroTrustGatewaySettingsSettings {
    /**
     * Activity log settings.
     */
    activityLog: outputs.ZeroTrustGatewaySettingsSettingsActivityLog;
    /**
     * Anti-virus settings.
     */
    antivirus: outputs.ZeroTrustGatewaySettingsSettingsAntivirus;
    /**
     * Block page layout settings.
     */
    blockPage: outputs.ZeroTrustGatewaySettingsSettingsBlockPage;
    /**
     * DLP body scanning settings.
     */
    bodyScanning: outputs.ZeroTrustGatewaySettingsSettingsBodyScanning;
    /**
     * Browser isolation settings.
     */
    browserIsolation: outputs.ZeroTrustGatewaySettingsSettingsBrowserIsolation;
    /**
     * Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
     */
    certificate: outputs.ZeroTrustGatewaySettingsSettingsCertificate;
    /**
     * Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
     */
    customCertificate: outputs.ZeroTrustGatewaySettingsSettingsCustomCertificate;
    /**
     * Extended e-mail matching settings.
     */
    extendedEmailMatching: outputs.ZeroTrustGatewaySettingsSettingsExtendedEmailMatching;
    /**
     * FIPS settings.
     */
    fips: outputs.ZeroTrustGatewaySettingsSettingsFips;
    /**
     * Protocol Detection settings.
     */
    protocolDetection: outputs.ZeroTrustGatewaySettingsSettingsProtocolDetection;
    /**
     * Sandbox settings.
     */
    sandbox: outputs.ZeroTrustGatewaySettingsSettingsSandbox;
    /**
     * TLS interception settings.
     */
    tlsDecrypt: outputs.ZeroTrustGatewaySettingsSettingsTlsDecrypt;
}

export interface ZeroTrustGatewaySettingsSettingsActivityLog {
    /**
     * Enable activity logging.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsAntivirus {
    /**
     * Enable anti-virus scanning on downloads.
     */
    enabledDownloadPhase?: boolean;
    /**
     * Enable anti-virus scanning on uploads.
     */
    enabledUploadPhase?: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed?: boolean;
    /**
     * Configure a message to display on the user's device when an antivirus search is performed.
     */
    notificationSettings: outputs.ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings;
}

export interface ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings {
    /**
     * Set notification on
     */
    enabled?: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg?: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewaySettingsSettingsBlockPage {
    /**
     * Block page background color in #rrggbb format.
     */
    backgroundColor?: string;
    /**
     * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
     */
    enabled?: boolean;
    /**
     * Block page footer text.
     */
    footerText?: string;
    /**
     * Block page header text.
     */
    headerText?: string;
    /**
     * Full URL to the logo file.
     */
    logoPath?: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: string;
    /**
     * Block page title.
     */
    name?: string;
    /**
     * Suppress detailed info at the bottom of the block page.
     */
    suppressFooter?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsBodyScanning {
    /**
     * Set the inspection mode to either `deep` or `shallow`.
     */
    inspectionMode?: string;
}

export interface ZeroTrustGatewaySettingsSettingsBrowserIsolation {
    /**
     * Enable non-identity onramp support for Browser Isolation.
     */
    nonIdentityEnabled?: boolean;
    /**
     * Enable Clientless Browser Isolation.
     */
    urlBrowserIsolationEnabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsCertificate {
    /**
     * UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
     */
    id: string;
}

export interface ZeroTrustGatewaySettingsSettingsCustomCertificate {
    /**
     * Certificate status (internal).
     */
    bindingStatus: string;
    /**
     * Enable use of custom certificate authority for signing Gateway traffic.
     */
    enabled: boolean;
    /**
     * UUID of certificate (ID from MTLS certificate store).
     */
    id?: string;
    updatedAt: string;
}

export interface ZeroTrustGatewaySettingsSettingsExtendedEmailMatching {
    /**
     * Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsFips {
    /**
     * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
     */
    tls?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsProtocolDetection {
    /**
     * Enable detecting protocol on initial bytes of client traffic.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsSandbox {
    /**
     * Enable sandbox.
     */
    enabled?: boolean;
    /**
     * Action to take when the file cannot be scanned.
     */
    fallbackAction?: string;
}

export interface ZeroTrustGatewaySettingsSettingsTlsDecrypt {
    /**
     * Enable inspecting encrypted HTTP traffic.
     */
    enabled?: boolean;
}

export interface ZeroTrustListItem {
    createdAt: string;
    /**
     * The description of the list item, if present
=======
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceCustomProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceCustomProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceCustomProfileLocalDomainFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
     */
    description?: string;
    /**
     * The value of the item in a list.
     */
<<<<<<< HEAD
    value?: string;
}

export interface ZeroTrustOrganizationCustomPages {
    /**
     * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
     */
    forbidden?: string;
    /**
     * The uid of the custom page to use when a user is denied access.
     */
    identityDenied?: string;
}

export interface ZeroTrustOrganizationLoginDesign {
    /**
     * The background color on your login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of your login page.
     */
    footerText?: string;
    /**
     * The text at the top of your login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on your login page.
     */
    logoPath?: string;
    /**
     * The text color on your login page.
     */
    textColor?: string;
}

export interface ZeroTrustRiskBehaviorBehaviors {
    enabled: boolean;
    riskLevel: string;
}

=======
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceCustomProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode?: string;
    /**
     * The port number when used with proxy mode.
     */
    port?: number;
}

export interface ZeroTrustDeviceCustomProfileTargetTest {
    /**
     * The id of the DEX test targeting this policy
     */
    id: string;
    /**
     * The name of the DEX test targeting this policy
     */
    name: string;
}

export interface ZeroTrustDeviceDefaultProfileExclude {
    /**
     * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
     */
    address: string;
    /**
     * A description of the Split Tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceDefaultProfileFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceDefaultProfileInclude {
    /**
     * The address in CIDR format to include in the tunnel. If address is present, host must not be present.
     */
    address: string;
    /**
     * A description of the split tunnel item, displayed in the client UI.
     */
    description: string;
    /**
     * The domain name to include in the tunnel. If host is present, address must not be present.
     */
    host: string;
}

export interface ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix: string;
}

export interface ZeroTrustDeviceDefaultProfileServiceModeV2 {
    /**
     * The mode to run the WARP client under.
     */
    mode?: string;
    /**
     * The port number when used with proxy mode.
     */
    port?: number;
}

export interface ZeroTrustDeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256?: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface ZeroTrustDevicePostureIntegrationConfig {
    /**
     * If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `apiUrl`
     */
    accessClientId?: string;
    /**
     * If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `apiUrl`
     */
    accessClientSecret?: string;
    /**
     * The Workspace One API URL provided in the Workspace One Admin Dashboard.
     */
    apiUrl?: string;
    /**
     * The Workspace One Authorization URL depending on your region.
     */
    authUrl?: string;
    /**
     * The Workspace One client ID provided in the Workspace One Admin Dashboard.
     */
    clientId?: string;
    /**
     * The Uptycs client secret.
     */
    clientKey?: string;
    /**
     * The Workspace One client secret provided in the Workspace One Admin Dashboard.
     */
    clientSecret?: string;
    /**
     * The Crowdstrike customer ID.
     */
    customerId?: string;
}

export interface ZeroTrustDevicePostureRuleInput {
    /**
     * The Number of active threats.
     */
    activeThreats?: number;
    /**
     * UUID of Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * List of volume names to be checked for encryption.
     */
    checkDisks?: string[];
    /**
     * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
     */
    checkPrivateKey?: boolean;
    /**
     * Common Name that is protected by the certificate
     */
    cn?: string;
    /**
     * Compliance Status
     */
    complianceStatus?: string;
    /**
     * Posture Integration ID.
     */
    connectionId?: string;
    /**
     * Count Operator
     */
    countOperator?: string;
    /**
     * Domain
     */
    domain?: string;
    /**
     * For more details on eid last seen, refer to the Tanium documentation.
     */
    eidLastSeen?: string;
    /**
     * Enabled
     */
    enabled?: boolean;
    /**
     * Whether or not file exists
     */
    exists?: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used
     */
    extendedKeyUsages?: string[];
    /**
     * List ID.
     */
    id?: string;
    /**
     * Whether device is infected.
     */
    infected?: boolean;
    /**
     * Whether device is active.
     */
    isActive?: boolean;
    /**
     * The Number of Issues.
     */
    issueCount?: string;
    /**
     * For more details on last seen, please refer to the Crowdstrike documentation.
     */
    lastSeen?: string;
    locations: outputs.ZeroTrustDevicePostureRuleInputLocations;
    /**
     * Network status of device.
     */
    networkStatus?: string;
    /**
     * Operating system
     */
    operatingSystem?: string;
    /**
     * Agent operational state.
     */
    operationalState?: string;
    /**
     * operator
     */
    operator?: string;
    /**
     * Os Version
     */
    os?: string;
    /**
     * Operating System Distribution Name (linux only)
     */
    osDistroName?: string;
    /**
     * Version of OS Distribution (linux only)
     */
    osDistroRevision?: string;
    /**
     * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
     */
    osVersionExtra?: string;
    /**
     * overall
     */
    overall?: string;
    /**
     * File path.
     */
    path?: string;
    /**
     * Whether to check all disks for encryption.
     */
    requireAll?: boolean;
    /**
     * For more details on risk level, refer to the Tanium documentation.
     */
    riskLevel?: string;
    /**
     * A value between 0-100 assigned to devices set by the 3rd party posture provider.
     */
    score?: number;
    /**
     * Score Operator
     */
    scoreOperator?: string;
    /**
     * SensorConfig
     */
    sensorConfig?: string;
    /**
     * SHA-256.
     */
    sha256?: string;
    /**
     * For more details on state, please refer to the Crowdstrike documentation.
     */
    state?: string;
    /**
     * Signing certificate thumbprint.
     */
    thumbprint?: string;
    /**
     * For more details on total score, refer to the Tanium documentation.
     */
    totalScore?: number;
    /**
     * Version of OS
     */
    version?: string;
    /**
     * Version Operator
     */
    versionOperator?: string;
}

export interface ZeroTrustDevicePostureRuleInputLocations {
    /**
     * List of paths to check for client certificate on linux.
     */
    paths?: string[];
    /**
     * List of trust stores to check for client certificate.
     */
    trustStores?: string[];
}

export interface ZeroTrustDevicePostureRuleMatch {
    platform?: string;
}

export interface ZeroTrustDexTestData {
    /**
     * The desired endpoint to test.
     */
    host?: string;
    /**
     * The type of test.
     */
    kind?: string;
    /**
     * The HTTP request method type.
     */
    method?: string;
}

export interface ZeroTrustDexTestTargetPolicy {
    /**
     * Whether the profile is the account default
     */
    default?: boolean;
    /**
     * The id of the device settings profile
     */
    id?: string;
    /**
     * The name of the device settings profile
     */
    name?: string;
}

export interface ZeroTrustDlpCustomProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpCustomProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpCustomProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpCustomProfileEntry {
    enabled: boolean;
    name: string;
    pattern: outputs.ZeroTrustDlpCustomProfileEntryPattern;
    words?: string[];
}

export interface ZeroTrustDlpCustomProfileEntryPattern {
    regex: string;
    validation?: string;
}

export interface ZeroTrustDlpCustomProfileProfile {
    aiContextEnabled?: boolean;
    /**
     * Related DLP policies will trigger when the match count exceeds the number set.
     */
    allowedMatchCount: number;
    confidenceThreshold?: string;
    /**
     * Scan the context of predefined entries to only return matches surrounded by keywords.
     */
    contextAwareness: outputs.ZeroTrustDlpCustomProfileProfileContextAwareness;
    /**
     * The description of the profile
     */
    description?: string;
    entries: outputs.ZeroTrustDlpCustomProfileProfileEntry[];
    name: string;
    ocrEnabled?: boolean;
    /**
     * Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
     */
    sharedEntries: outputs.ZeroTrustDlpCustomProfileProfileSharedEntry[];
}

export interface ZeroTrustDlpCustomProfileProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpCustomProfileProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpCustomProfileProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpCustomProfileProfileEntry {
    enabled: boolean;
    name: string;
    pattern?: outputs.ZeroTrustDlpCustomProfileProfileEntryPattern;
    words?: string[];
}

export interface ZeroTrustDlpCustomProfileProfileEntryPattern {
    regex: string;
    validation?: string;
}

export interface ZeroTrustDlpCustomProfileProfileSharedEntry {
    enabled: boolean;
    entryId: string;
    entryType: string;
}

export interface ZeroTrustDlpCustomProfileSharedEntry {
    enabled: boolean;
    entryId: string;
    entryType: string;
}

export interface ZeroTrustDlpDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus: string;
}

export interface ZeroTrustDlpDatasetDataset {
    columns: outputs.ZeroTrustDlpDatasetDatasetColumn[];
    createdAt: string;
    /**
     * The description of the dataset
     */
    description: string;
    encodingVersion: number;
    id: string;
    name: string;
    numCells: number;
    secret: boolean;
    status: string;
    /**
     * When the dataset was last updated.
     */
    updatedAt: string;
    uploads: outputs.ZeroTrustDlpDatasetDatasetUpload[];
}

export interface ZeroTrustDlpDatasetDatasetColumn {
    entryId: string;
    headerName: string;
    numCells: number;
    uploadStatus: string;
}

export interface ZeroTrustDlpDatasetDatasetUpload {
    numCells: number;
    status: string;
    version: number;
}

export interface ZeroTrustDlpDatasetUpload {
    numCells: number;
    status: string;
    version: number;
}

export interface ZeroTrustDlpEntryConfidence {
    aiContextAvailable: boolean;
    /**
     * Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
     * Profiles that use an entry with `available` set to true can use confidence thresholds
     */
    available: boolean;
}

export interface ZeroTrustDlpEntryPattern {
    regex: string;
    validation?: string;
}

export interface ZeroTrustDlpPredefinedProfileContextAwareness {
    /**
     * If true, scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpPredefinedProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpPredefinedProfileContextAwarenessSkip {
    /**
     * If the content type is a file, skip context analysis and return all matches.
     */
    files: boolean;
}

export interface ZeroTrustDlpPredefinedProfileEntry {
    enabled: boolean;
    id: string;
}

export interface ZeroTrustDnsLocationEndpoints {
    doh: outputs.ZeroTrustDnsLocationEndpointsDoh;
    dot: outputs.ZeroTrustDnsLocationEndpointsDot;
    ipv4: outputs.ZeroTrustDnsLocationEndpointsIpv4;
    ipv6: outputs.ZeroTrustDnsLocationEndpointsIpv6;
}

export interface ZeroTrustDnsLocationEndpointsDoh {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsDohNetwork[];
    /**
     * True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
     */
    requireToken?: boolean;
}

export interface ZeroTrustDnsLocationEndpointsDohNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationEndpointsDot {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
    /**
     * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsDotNetwork[];
}

export interface ZeroTrustDnsLocationEndpointsDotNetwork {
    /**
     * The IP address or IP CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationEndpointsIpv4 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
}

export interface ZeroTrustDnsLocationEndpointsIpv6 {
    /**
     * True if the endpoint is enabled for this location.
     */
    enabled?: boolean;
    /**
     * A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
     */
    networks: outputs.ZeroTrustDnsLocationEndpointsIpv6Network[];
}

export interface ZeroTrustDnsLocationEndpointsIpv6Network {
    /**
     * The IPv6 address or IPv6 CIDR.
     */
    network: string;
}

export interface ZeroTrustDnsLocationNetwork {
    /**
     * The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
     */
    network: string;
}

export interface ZeroTrustGatewayLoggingSettingsByRuleType {
    /**
     * Logging settings for DNS firewall.
     */
    dns?: string;
    /**
     * Logging settings for HTTP/HTTPS firewall.
     */
    http?: string;
    /**
     * Logging settings for Network firewall.
     */
    l4?: string;
}

export interface ZeroTrustGatewayPolicyExpiration {
    /**
     * The default duration a policy will be active in minutes. Must be set in order to use the `resetExpiration` endpoint on this rule.
     */
    duration?: number;
    /**
     * Whether the policy has expired.
     */
    expired?: boolean;
    /**
     * The time stamp at which the policy will expire and cease to be
     * applied.
     */
    expiresAt: string;
}

export interface ZeroTrustGatewayPolicyRuleSettings {
    /**
     * Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
     */
    addHeaders?: {[key: string]: string};
    /**
     * Set by parent MSP accounts to enable their children to bypass this rule.
     */
    allowChildBypass?: boolean;
    /**
     * Settings for the Audit SSH action.
     */
    auditSsh: outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls: outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls;
    /**
     * Enable the custom block page.
     */
    blockPageEnabled?: boolean;
    /**
     * The text describing why this block occurred, displayed on the custom block page (if enabled).
     */
    blockReason?: string;
    /**
     * Set by children MSP accounts to bypass their parent's rules.
     */
    bypassParentRule?: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession: outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
     */
    dnsResolvers: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers;
    /**
     * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
     */
    egress: outputs.ZeroTrustGatewayPolicyRuleSettingsEgress;
    /**
     * Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
     */
    ignoreCnameCategoryMatches?: boolean;
    /**
     * INSECURE - disable DNSSEC validation (for Allow actions).
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
     */
    ipCategories?: boolean;
    /**
     * Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
     */
    ipIndicatorFeeds?: boolean;
    /**
     * Send matching traffic to the supplied destination IP address and port.
     */
    l4override: outputs.ZeroTrustGatewayPolicyRuleSettingsL4override;
    /**
     * Configure a notification to display on the user's device when this rule is matched.
     */
    notificationSettings: outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings;
    /**
     * Override matching DNS queries with a hostname.
     */
    overrideHost?: string;
    /**
     * Override matching DNS queries with an IP or set of IPs.
     */
    overrideIps?: string[];
    /**
     * Configure DLP payload logging.
     */
    payloadLog: outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog;
    /**
     * Settings that apply to quarantine rules
     */
    quarantine: outputs.ZeroTrustGatewayPolicyRuleSettingsQuarantine;
    /**
     * Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsInternally: outputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally;
    /**
     * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
     */
    resolveDnsThroughCloudflare?: boolean;
    /**
     * Configure behavior when an upstream cert is invalid or an SSL error occurs.
     */
    untrustedCert: outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert;
}

export interface ZeroTrustGatewayPolicyRuleSettingsAuditSsh {
    /**
     * Enable to turn on SSH command logging.
     */
    commandLogging?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls {
    /**
     * Configure whether copy is enabled or not. When set with "remoteOnly", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
     */
    copy?: string;
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     */
    dcp?: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     */
    dd?: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     */
    dk?: boolean;
    /**
     * Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
     */
    download?: string;
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     */
    dp?: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     */
    du?: boolean;
    /**
     * Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
     */
    keyboard?: string;
    /**
     * Configure whether pasting is enabled or not. When set with "remoteOnly", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
     */
    paste?: string;
    /**
     * Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
     */
    printing?: string;
    /**
     * Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
     */
    upload?: string;
    /**
     * Indicates which version of the browser isolation controls should apply.
     */
    version: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration?: string;
    /**
     * Set to true to enable session enforcement.
     */
    enforce?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolvers {
    ipv4s: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4[];
    ipv6s: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4 {
    /**
     * IPv4 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6 {
    /**
     * IPv6 address of upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for upstream resolver. Defaults to 53 if unspecified.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when vnetId is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4?: string;
    /**
     * The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
     */
    ipv4Fallback?: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsL4override {
    /**
     * IPv4 or IPv6 address.
     */
    ip?: string;
    /**
     * A port number to use for TCP/UDP overrides.
     */
    port?: number;
}

export interface ZeroTrustGatewayPolicyRuleSettingsNotificationSettings {
    /**
     * Set notification on
     */
    enabled?: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg?: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsPayloadLog {
    /**
     * Set to true to enable DLP payload logging for this rule.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsQuarantine {
    /**
     * Types of files to sandbox.
     */
    fileTypes?: string[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternally {
    /**
     * The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
     */
    fallback: string;
    /**
     * The internal DNS view identifier that's passed to the internal DNS service.
     */
    viewId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsUntrustedCert {
    /**
     * The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
     */
    action?: string;
}

export interface ZeroTrustGatewayPolicySchedule {
    /**
     * The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
     */
    fri?: string;
    /**
     * The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
     */
    mon?: string;
    /**
     * The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
     */
    sat?: string;
    /**
     * The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
     */
    sun?: string;
    /**
     * The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
     */
    thu?: string;
    /**
     * The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
     */
    timeZone?: string;
    /**
     * The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
     */
    tue?: string;
    /**
     * The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
     */
    wed?: string;
}

export interface ZeroTrustGatewaySettingsSettings {
    /**
     * Activity log settings.
     */
    activityLog: outputs.ZeroTrustGatewaySettingsSettingsActivityLog;
    /**
     * Anti-virus settings.
     */
    antivirus: outputs.ZeroTrustGatewaySettingsSettingsAntivirus;
    /**
     * Block page layout settings.
     */
    blockPage: outputs.ZeroTrustGatewaySettingsSettingsBlockPage;
    /**
     * DLP body scanning settings.
     */
    bodyScanning: outputs.ZeroTrustGatewaySettingsSettingsBodyScanning;
    /**
     * Browser isolation settings.
     */
    browserIsolation: outputs.ZeroTrustGatewaySettingsSettingsBrowserIsolation;
    /**
     * Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
     */
    certificate: outputs.ZeroTrustGatewaySettingsSettingsCertificate;
    /**
     * Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
     */
    customCertificate: outputs.ZeroTrustGatewaySettingsSettingsCustomCertificate;
    /**
     * Extended e-mail matching settings.
     */
    extendedEmailMatching: outputs.ZeroTrustGatewaySettingsSettingsExtendedEmailMatching;
    /**
     * FIPS settings.
     */
    fips: outputs.ZeroTrustGatewaySettingsSettingsFips;
    /**
     * Protocol Detection settings.
     */
    protocolDetection: outputs.ZeroTrustGatewaySettingsSettingsProtocolDetection;
    /**
     * Sandbox settings.
     */
    sandbox: outputs.ZeroTrustGatewaySettingsSettingsSandbox;
    /**
     * TLS interception settings.
     */
    tlsDecrypt: outputs.ZeroTrustGatewaySettingsSettingsTlsDecrypt;
}

export interface ZeroTrustGatewaySettingsSettingsActivityLog {
    /**
     * Enable activity logging.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsAntivirus {
    /**
     * Enable anti-virus scanning on downloads.
     */
    enabledDownloadPhase?: boolean;
    /**
     * Enable anti-virus scanning on uploads.
     */
    enabledUploadPhase?: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed?: boolean;
    /**
     * Configure a message to display on the user's device when an antivirus search is performed.
     */
    notificationSettings: outputs.ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings;
}

export interface ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettings {
    /**
     * Set notification on
     */
    enabled?: boolean;
    /**
     * Customize the message shown in the notification.
     */
    msg?: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewaySettingsSettingsBlockPage {
    /**
     * Block page background color in #rrggbb format.
     */
    backgroundColor?: string;
    /**
     * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
     */
    enabled?: boolean;
    /**
     * Block page footer text.
     */
    footerText?: string;
    /**
     * Block page header text.
     */
    headerText?: string;
    /**
     * Full URL to the logo file.
     */
    logoPath?: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: string;
    /**
     * Block page title.
     */
    name?: string;
    /**
     * Suppress detailed info at the bottom of the block page.
     */
    suppressFooter?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsBodyScanning {
    /**
     * Set the inspection mode to either `deep` or `shallow`.
     */
    inspectionMode?: string;
}

export interface ZeroTrustGatewaySettingsSettingsBrowserIsolation {
    /**
     * Enable non-identity onramp support for Browser Isolation.
     */
    nonIdentityEnabled?: boolean;
    /**
     * Enable Clientless Browser Isolation.
     */
    urlBrowserIsolationEnabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsCertificate {
    /**
     * UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
     */
    id: string;
}

export interface ZeroTrustGatewaySettingsSettingsCustomCertificate {
    /**
     * Certificate status (internal).
     */
    bindingStatus: string;
    /**
     * Enable use of custom certificate authority for signing Gateway traffic.
     */
    enabled: boolean;
    /**
     * UUID of certificate (ID from MTLS certificate store).
     */
    id?: string;
    updatedAt: string;
}

export interface ZeroTrustGatewaySettingsSettingsExtendedEmailMatching {
    /**
     * Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsFips {
    /**
     * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
     */
    tls?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsProtocolDetection {
    /**
     * Enable detecting protocol on initial bytes of client traffic.
     */
    enabled?: boolean;
}

export interface ZeroTrustGatewaySettingsSettingsSandbox {
    /**
     * Enable sandbox.
     */
    enabled?: boolean;
    /**
     * Action to take when the file cannot be scanned.
     */
    fallbackAction?: string;
}

export interface ZeroTrustGatewaySettingsSettingsTlsDecrypt {
    /**
     * Enable inspecting encrypted HTTP traffic.
     */
    enabled?: boolean;
}

export interface ZeroTrustListItem {
    createdAt: string;
    /**
     * The description of the list item, if present
     */
    description?: string;
    /**
     * The value of the item in a list.
     */
    value?: string;
}

export interface ZeroTrustOrganizationCustomPages {
    /**
     * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
     */
    forbidden?: string;
    /**
     * The uid of the custom page to use when a user is denied access.
     */
    identityDenied?: string;
}

export interface ZeroTrustOrganizationLoginDesign {
    /**
     * The background color on your login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of your login page.
     */
    footerText?: string;
    /**
     * The text at the top of your login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on your login page.
     */
    logoPath?: string;
    /**
     * The text color on your login page.
     */
    textColor?: string;
}

export interface ZeroTrustRiskBehaviorBehaviors {
    enabled: boolean;
    riskLevel: string;
}

>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
export interface ZeroTrustTunnelCloudflaredConfigConfig {
    /**
     * List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
     */
    ingresses: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngress[];
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest;
    /**
     * Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
     */
    warpRouting: outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngress {
    /**
     * Public hostname for this service.
     */
    hostname?: string;
    /**
     * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
     */
    originRequest: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest;
    /**
     * Requests with this path route to this public hostname.
     */
    path: string;
    /**
     * Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
     */
    service: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader?: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout: number;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required: boolean;
    teamName: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequest {
    /**
     * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
     */
    access: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
     */
    caPool: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
     */
    connectTimeout: number;
    /**
     * Disables chunked transfer encoding. Useful if you are running a WSGI server.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Attempt to connect to origin using HTTP2. Origin must be configured as https.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service.
     */
    httpHostHeader?: string;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
     */
    keepAliveConnections: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded.
     */
    keepAliveTimeout: number;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
     */
    noHappyEyeballs: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
     */
    noTlsVerify: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate.
     */
    originServerName: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
     */
    proxyType: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
     */
    tcpKeepAlive: number;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
     */
    tlsTimeout: number;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTags: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     */
    required: boolean;
    teamName: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigWarpRouting {
    enabled: boolean;
}

export interface ZeroTrustTunnelCloudflaredConnection {
    /**
     * UUID of the Cloudflare Tunnel connector.
     */
    clientId: string;
    /**
     * The cloudflared version used to establish this connection.
     */
    clientVersion: string;
    /**
     * The Cloudflare data center used for this connection.
     */
    coloName: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    id: string;
    /**
     * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
     */
    isPendingReconnect: boolean;
    /**
     * Timestamp of when the connection was established.
     */
    openedAt: string;
    /**
     * The public IP address of the host running cloudflared.
     */
    originIp: string;
    /**
     * UUID of the Cloudflare Tunnel connection.
     */
    uuid: string;
}

export interface ZoneAccount {
    /**
     * Identifier
     */
    id?: string;
}

export interface ZoneCacheVariantsValue {
    /**
     * List of strings with the MIME types of all the variants that should be served for avif.
     */
    avifs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for bmp.
     */
    bmps?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for gif.
     */
    gifs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jp2.
     */
    jp2s?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpeg.
     */
    jpegs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpg2.
     */
    jpg2s?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for jpg.
     */
    jpgs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for png.
     */
    pngs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for tiff.
     */
    tiffs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for tif.
     */
    tifs?: string[];
    /**
     * List of strings with the MIME types of all the variants that should be served for webp.
     */
    webps?: string[];
}

export interface ZoneLockdownConfiguration {
    /**
     * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
     */
    target?: string;
    /**
     * The IP address to match. This address will be compared to the IP address of incoming requests.
     */
    value?: string;
}

export interface ZoneMeta {
    /**
     * The zone is only configured for CDN
     */
    cdnOnly: boolean;
    /**
     * Number of Custom Certificates the zone can have
     */
    customCertificateQuota: number;
    /**
     * The zone is only configured for DNS
     */
    dnsOnly: boolean;
    /**
     * The zone is setup with Foundation DNS
     */
    foundationDns: boolean;
    /**
     * Number of Page Rules a zone can have
     */
    pageRuleQuota: number;
    /**
     * The zone has been flagged for phishing
     */
    phishingDetected: boolean;
    step: number;
}

export interface ZoneOwner {
    /**
     * Identifier
     */
    id: string;
    /**
     * Name of the owner
     */
    name: string;
    /**
     * The type of owner
     */
    type: string;
}

export interface ZoneSubscriptionRatePlan {
    /**
     * The currency applied to the rate plan subscription.
     */
    currency?: string;
    /**
     * Whether this rate plan is managed externally from Cloudflare.
     */
    externallyManaged?: boolean;
    /**
     * The ID of the rate plan.
     */
    id?: string;
    /**
     * Whether a rate plan is enterprise-based (or newly adopted term contract).
     */
    isContract?: boolean;
    /**
     * The full name of the rate plan.
     */
    publicName?: string;
    /**
     * The scope that this rate plan applies to.
     */
    scope?: string;
    /**
     * The list of sets this rate plan applies to.
     */
    sets?: string[];
}

