// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApplicationCorsHeader {
    /**
     * Value to determine whether all HTTP headers are exposed.
     */
    allowAllHeaders?: pulumi.Input<boolean>;
    /**
     * Value to determine whether all methods are exposed.
     */
    allowAllMethods?: pulumi.Input<boolean>;
    /**
     * Value to determine whether all origins are permitted to make CORS requests.
     */
    allowAllOrigins?: pulumi.Input<boolean>;
    /**
     * Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
     */
    allowCredentials?: pulumi.Input<boolean>;
    /**
     * List of HTTP headers to expose via CORS.
     */
    allowedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of methods to expose via CORS.
     */
    allowedMethods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of origins permitted to make CORS requests.
     */
    allowedOrigins?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum time a preflight request will be cached.
     */
    maxAge?: pulumi.Input<number>;
}

export interface AccessApplicationFooterLink {
    /**
     * The name of the footer link.
     */
    name?: pulumi.Input<string>;
    /**
     * The URL of the footer link.
     */
    url?: pulumi.Input<string>;
}

export interface AccessApplicationLandingPageDesign {
    /**
     * The button color of the landing page.
     */
    buttonColor?: pulumi.Input<string>;
    /**
     * The button text color of the landing page.
     */
    buttonTextColor?: pulumi.Input<string>;
    /**
     * The URL of the image to be displayed in the landing page.
     */
    imageUrl?: pulumi.Input<string>;
    /**
     * The message of the landing page.
     */
    message?: pulumi.Input<string>;
    /**
     * The title of the landing page.
     */
    title?: pulumi.Input<string>;
}

export interface AccessApplicationSaasApp {
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl: pulumi.Input<string>;
    /**
     * Custom attribute mapped from IDPs.
     */
    customAttributes?: pulumi.Input<pulumi.Input<inputs.AccessApplicationSaasAppCustomAttribute>[]>;
    /**
     * The relay state used if not provided by the identity provider.
     */
    defaultRelayState?: pulumi.Input<string>;
    /**
     * The unique identifier for the SaaS application.
     */
    idpEntityId?: pulumi.Input<string>;
    /**
     * The format of the name identifier sent to the SaaS application. Defaults to `email`.
     */
    nameIdFormat?: pulumi.Input<string>;
    /**
     * The public certificate that will be used to verify identities.
     */
    publicKey?: pulumi.Input<string>;
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId: pulumi.Input<string>;
    /**
     * The endpoint where the SaaS application will send login requests.
     */
    ssoEndpoint?: pulumi.Input<string>;
}

export interface AccessApplicationSaasAppCustomAttribute {
    /**
     * A friendly name for the attribute as provided to the SaaS app.
     */
    friendlyName?: pulumi.Input<string>;
    /**
     * The name of the footer link.
     */
    name?: pulumi.Input<string>;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat?: pulumi.Input<string>;
    /**
     * True if the attribute must be always present.
     */
    required?: pulumi.Input<boolean>;
    source: pulumi.Input<inputs.AccessApplicationSaasAppCustomAttributeSource>;
}

export interface AccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the footer link.
     */
    name: pulumi.Input<string>;
}

export interface AccessGroupExclude {
    anyValidServiceToken?: pulumi.Input<boolean>;
    authContexts?: pulumi.Input<pulumi.Input<inputs.AccessGroupExcludeAuthContext>[]>;
    authMethod?: pulumi.Input<string>;
    azures?: pulumi.Input<pulumi.Input<inputs.AccessGroupExcludeAzure>[]>;
    certificate?: pulumi.Input<boolean>;
    commonName?: pulumi.Input<string>;
    devicePostures?: pulumi.Input<pulumi.Input<string>[]>;
    emailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    everyone?: pulumi.Input<boolean>;
    externalEvaluation?: pulumi.Input<inputs.AccessGroupExcludeExternalEvaluation>;
    geos?: pulumi.Input<pulumi.Input<string>[]>;
    githubs?: pulumi.Input<pulumi.Input<inputs.AccessGroupExcludeGithub>[]>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    gsuites?: pulumi.Input<pulumi.Input<inputs.AccessGroupExcludeGsuite>[]>;
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    loginMethods?: pulumi.Input<pulumi.Input<string>[]>;
    oktas?: pulumi.Input<pulumi.Input<inputs.AccessGroupExcludeOkta>[]>;
    samls?: pulumi.Input<pulumi.Input<inputs.AccessGroupExcludeSaml>[]>;
    serviceTokens?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    id: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: pulumi.Input<string>;
}

export interface AccessGroupExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    ids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupExcludeExternalEvaluation {
    evaluateUrl?: pulumi.Input<string>;
    keysUrl?: pulumi.Input<string>;
}

export interface AccessGroupExcludeGithub {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    teams?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupExcludeGsuite {
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessGroupExcludeOkta {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupExcludeSaml {
    attributeName?: pulumi.Input<string>;
    attributeValue?: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessGroupInclude {
    anyValidServiceToken?: pulumi.Input<boolean>;
    authContexts?: pulumi.Input<pulumi.Input<inputs.AccessGroupIncludeAuthContext>[]>;
    authMethod?: pulumi.Input<string>;
    azures?: pulumi.Input<pulumi.Input<inputs.AccessGroupIncludeAzure>[]>;
    certificate?: pulumi.Input<boolean>;
    commonName?: pulumi.Input<string>;
    devicePostures?: pulumi.Input<pulumi.Input<string>[]>;
    emailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    everyone?: pulumi.Input<boolean>;
    externalEvaluation?: pulumi.Input<inputs.AccessGroupIncludeExternalEvaluation>;
    geos?: pulumi.Input<pulumi.Input<string>[]>;
    githubs?: pulumi.Input<pulumi.Input<inputs.AccessGroupIncludeGithub>[]>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    gsuites?: pulumi.Input<pulumi.Input<inputs.AccessGroupIncludeGsuite>[]>;
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    loginMethods?: pulumi.Input<pulumi.Input<string>[]>;
    oktas?: pulumi.Input<pulumi.Input<inputs.AccessGroupIncludeOkta>[]>;
    samls?: pulumi.Input<pulumi.Input<inputs.AccessGroupIncludeSaml>[]>;
    serviceTokens?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    id: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: pulumi.Input<string>;
}

export interface AccessGroupIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    ids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupIncludeExternalEvaluation {
    evaluateUrl?: pulumi.Input<string>;
    keysUrl?: pulumi.Input<string>;
}

export interface AccessGroupIncludeGithub {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    teams?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupIncludeGsuite {
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessGroupIncludeOkta {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupIncludeSaml {
    attributeName?: pulumi.Input<string>;
    attributeValue?: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessGroupRequire {
    anyValidServiceToken?: pulumi.Input<boolean>;
    authContexts?: pulumi.Input<pulumi.Input<inputs.AccessGroupRequireAuthContext>[]>;
    authMethod?: pulumi.Input<string>;
    azures?: pulumi.Input<pulumi.Input<inputs.AccessGroupRequireAzure>[]>;
    certificate?: pulumi.Input<boolean>;
    commonName?: pulumi.Input<string>;
    devicePostures?: pulumi.Input<pulumi.Input<string>[]>;
    emailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    everyone?: pulumi.Input<boolean>;
    externalEvaluation?: pulumi.Input<inputs.AccessGroupRequireExternalEvaluation>;
    geos?: pulumi.Input<pulumi.Input<string>[]>;
    githubs?: pulumi.Input<pulumi.Input<inputs.AccessGroupRequireGithub>[]>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    gsuites?: pulumi.Input<pulumi.Input<inputs.AccessGroupRequireGsuite>[]>;
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    loginMethods?: pulumi.Input<pulumi.Input<string>[]>;
    oktas?: pulumi.Input<pulumi.Input<inputs.AccessGroupRequireOkta>[]>;
    samls?: pulumi.Input<pulumi.Input<inputs.AccessGroupRequireSaml>[]>;
    serviceTokens?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    id: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: pulumi.Input<string>;
}

export interface AccessGroupRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    ids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupRequireExternalEvaluation {
    evaluateUrl?: pulumi.Input<string>;
    keysUrl?: pulumi.Input<string>;
}

export interface AccessGroupRequireGithub {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    teams?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupRequireGsuite {
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessGroupRequireOkta {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessGroupRequireSaml {
    attributeName?: pulumi.Input<string>;
    attributeValue?: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessIdentityProviderConfig {
    apiToken?: pulumi.Input<string>;
    appsDomain?: pulumi.Input<string>;
    attributes?: pulumi.Input<pulumi.Input<string>[]>;
    authUrl?: pulumi.Input<string>;
    authorizationServerId?: pulumi.Input<string>;
    centrifyAccount?: pulumi.Input<string>;
    centrifyAppId?: pulumi.Input<string>;
    certsUrl?: pulumi.Input<string>;
    claims?: pulumi.Input<pulumi.Input<string>[]>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    conditionalAccessEnabled?: pulumi.Input<boolean>;
    directoryId?: pulumi.Input<string>;
    emailAttributeName?: pulumi.Input<string>;
    emailClaimName?: pulumi.Input<string>;
    idpPublicCert?: pulumi.Input<string>;
    issuerUrl?: pulumi.Input<string>;
    oktaAccount?: pulumi.Input<string>;
    oneloginAccount?: pulumi.Input<string>;
    pingEnvId?: pulumi.Input<string>;
    pkceEnabled?: pulumi.Input<boolean>;
    redirectUrl?: pulumi.Input<string>;
    scopes?: pulumi.Input<pulumi.Input<string>[]>;
    signRequest?: pulumi.Input<boolean>;
    ssoTargetUrl?: pulumi.Input<string>;
    supportGroups?: pulumi.Input<boolean>;
    tokenUrl?: pulumi.Input<string>;
}

export interface AccessIdentityProviderScimConfig {
    enabled?: pulumi.Input<boolean>;
    groupMemberDeprovision?: pulumi.Input<boolean>;
    seatDeprovision?: pulumi.Input<boolean>;
    secret?: pulumi.Input<string>;
    userDeprovision?: pulumi.Input<boolean>;
}

export interface AccessOrganizationCustomPage {
    /**
     * The id of the forbidden page.
     */
    forbidden?: pulumi.Input<string>;
    /**
     * The id of the identity denied page.
     */
    identityDenied?: pulumi.Input<string>;
}

export interface AccessOrganizationLoginDesign {
    /**
     * The background color on the login page.
     */
    backgroundColor?: pulumi.Input<string>;
    /**
     * The text at the bottom of the login page.
     */
    footerText?: pulumi.Input<string>;
    /**
     * The text at the top of the login page.
     */
    headerText?: pulumi.Input<string>;
    /**
     * The URL of the logo on the login page.
     */
    logoPath?: pulumi.Input<string>;
    /**
     * The text color on the login page.
     */
    textColor?: pulumi.Input<string>;
}

export interface AccessPolicyApprovalGroup {
    /**
     * Number of approvals needed.
     */
    approvalsNeeded: pulumi.Input<number>;
    /**
     * List of emails to request approval from.
     */
    emailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    emailListUuid?: pulumi.Input<string>;
}

export interface AccessPolicyExclude {
    anyValidServiceToken?: pulumi.Input<boolean>;
    authContexts?: pulumi.Input<pulumi.Input<inputs.AccessPolicyExcludeAuthContext>[]>;
    authMethod?: pulumi.Input<string>;
    azures?: pulumi.Input<pulumi.Input<inputs.AccessPolicyExcludeAzure>[]>;
    certificate?: pulumi.Input<boolean>;
    commonName?: pulumi.Input<string>;
    devicePostures?: pulumi.Input<pulumi.Input<string>[]>;
    emailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    everyone?: pulumi.Input<boolean>;
    externalEvaluation?: pulumi.Input<inputs.AccessPolicyExcludeExternalEvaluation>;
    geos?: pulumi.Input<pulumi.Input<string>[]>;
    githubs?: pulumi.Input<pulumi.Input<inputs.AccessPolicyExcludeGithub>[]>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    gsuites?: pulumi.Input<pulumi.Input<inputs.AccessPolicyExcludeGsuite>[]>;
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    loginMethods?: pulumi.Input<pulumi.Input<string>[]>;
    oktas?: pulumi.Input<pulumi.Input<inputs.AccessPolicyExcludeOkta>[]>;
    samls?: pulumi.Input<pulumi.Input<inputs.AccessPolicyExcludeSaml>[]>;
    serviceTokens?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    id: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: pulumi.Input<string>;
}

export interface AccessPolicyExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    ids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyExcludeExternalEvaluation {
    evaluateUrl?: pulumi.Input<string>;
    keysUrl?: pulumi.Input<string>;
}

export interface AccessPolicyExcludeGithub {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    teams?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyExcludeGsuite {
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessPolicyExcludeOkta {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyExcludeSaml {
    attributeName?: pulumi.Input<string>;
    attributeValue?: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessPolicyInclude {
    anyValidServiceToken?: pulumi.Input<boolean>;
    authContexts?: pulumi.Input<pulumi.Input<inputs.AccessPolicyIncludeAuthContext>[]>;
    authMethod?: pulumi.Input<string>;
    azures?: pulumi.Input<pulumi.Input<inputs.AccessPolicyIncludeAzure>[]>;
    certificate?: pulumi.Input<boolean>;
    commonName?: pulumi.Input<string>;
    devicePostures?: pulumi.Input<pulumi.Input<string>[]>;
    emailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    everyone?: pulumi.Input<boolean>;
    externalEvaluation?: pulumi.Input<inputs.AccessPolicyIncludeExternalEvaluation>;
    geos?: pulumi.Input<pulumi.Input<string>[]>;
    githubs?: pulumi.Input<pulumi.Input<inputs.AccessPolicyIncludeGithub>[]>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    gsuites?: pulumi.Input<pulumi.Input<inputs.AccessPolicyIncludeGsuite>[]>;
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    loginMethods?: pulumi.Input<pulumi.Input<string>[]>;
    oktas?: pulumi.Input<pulumi.Input<inputs.AccessPolicyIncludeOkta>[]>;
    samls?: pulumi.Input<pulumi.Input<inputs.AccessPolicyIncludeSaml>[]>;
    serviceTokens?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    id: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: pulumi.Input<string>;
}

export interface AccessPolicyIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    ids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyIncludeExternalEvaluation {
    evaluateUrl?: pulumi.Input<string>;
    keysUrl?: pulumi.Input<string>;
}

export interface AccessPolicyIncludeGithub {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    teams?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyIncludeGsuite {
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessPolicyIncludeOkta {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyIncludeSaml {
    attributeName?: pulumi.Input<string>;
    attributeValue?: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessPolicyRequire {
    anyValidServiceToken?: pulumi.Input<boolean>;
    authContexts?: pulumi.Input<pulumi.Input<inputs.AccessPolicyRequireAuthContext>[]>;
    authMethod?: pulumi.Input<string>;
    azures?: pulumi.Input<pulumi.Input<inputs.AccessPolicyRequireAzure>[]>;
    certificate?: pulumi.Input<boolean>;
    commonName?: pulumi.Input<string>;
    devicePostures?: pulumi.Input<pulumi.Input<string>[]>;
    emailDomains?: pulumi.Input<pulumi.Input<string>[]>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    everyone?: pulumi.Input<boolean>;
    externalEvaluation?: pulumi.Input<inputs.AccessPolicyRequireExternalEvaluation>;
    geos?: pulumi.Input<pulumi.Input<string>[]>;
    githubs?: pulumi.Input<pulumi.Input<inputs.AccessPolicyRequireGithub>[]>;
    groups?: pulumi.Input<pulumi.Input<string>[]>;
    gsuites?: pulumi.Input<pulumi.Input<inputs.AccessPolicyRequireGsuite>[]>;
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    loginMethods?: pulumi.Input<pulumi.Input<string>[]>;
    oktas?: pulumi.Input<pulumi.Input<inputs.AccessPolicyRequireOkta>[]>;
    samls?: pulumi.Input<pulumi.Input<inputs.AccessPolicyRequireSaml>[]>;
    serviceTokens?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    id: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: pulumi.Input<string>;
}

export interface AccessPolicyRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    /**
     * The ID of the Authentication Context.
     */
    ids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyRequireExternalEvaluation {
    evaluateUrl?: pulumi.Input<string>;
    keysUrl?: pulumi.Input<string>;
}

export interface AccessPolicyRequireGithub {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    teams?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyRequireGsuite {
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessPolicyRequireOkta {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AccessPolicyRequireSaml {
    attributeName?: pulumi.Input<string>;
    attributeValue?: pulumi.Input<string>;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: pulumi.Input<string>;
}

export interface AccessRuleConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ip6`, `ipRange`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
     */
    target: pulumi.Input<string>;
    /**
     * The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
     */
    value: pulumi.Input<string>;
}

export interface AddressMapIp {
    /**
     * An IPv4 or IPv6 address.
     */
    ip: pulumi.Input<string>;
}

export interface AddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete?: pulumi.Input<boolean>;
    /**
     * Identifier of the account or zone.
     */
    identifier: pulumi.Input<string>;
    /**
     * The type of the membership.
     */
    kind: pulumi.Input<string>;
}

export interface ApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic.
     */
    name?: pulumi.Input<string>;
    /**
     * The type of characteristic. Available values: `header`, `cookie`.
     */
    type?: pulumi.Input<string>;
}

export interface ApiTokenCondition {
    /**
     * Request IP related conditions.
     */
    requestIp?: pulumi.Input<inputs.ApiTokenConditionRequestIp>;
}

export interface ApiTokenConditionRequestIp {
    /**
     * List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
     */
    ins?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of IP addresses or CIDR notation where the token should not be used from.
     */
    notIns?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ApiTokenPolicy {
    /**
     * Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
     */
    effect?: pulumi.Input<string>;
    /**
     * List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
     */
    permissionGroups: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Describes what operations against which resources are allowed or denied.
     */
    resources: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface CertificatePackValidationError {
    message?: pulumi.Input<string>;
}

export interface CertificatePackValidationRecord {
    cnameName?: pulumi.Input<string>;
    cnameTarget?: pulumi.Input<string>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    httpBody?: pulumi.Input<string>;
    httpUrl?: pulumi.Input<string>;
    txtName?: pulumi.Input<string>;
    txtValue?: pulumi.Input<string>;
}

export interface CustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: pulumi.Input<string>;
    certificateAuthority?: pulumi.Input<string>;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate?: pulumi.Input<string>;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: pulumi.Input<string>;
    /**
     * Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     */
    method?: pulumi.Input<string>;
    /**
     * SSL/TLS settings for the certificate.
     */
    settings?: pulumi.Input<pulumi.Input<inputs.CustomHostnameSslSetting>[]>;
    status?: pulumi.Input<string>;
    /**
     * Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     */
    type?: pulumi.Input<string>;
    validationErrors?: pulumi.Input<pulumi.Input<inputs.CustomHostnameSslValidationError>[]>;
    validationRecords?: pulumi.Input<pulumi.Input<inputs.CustomHostnameSslValidationRecord>[]>;
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: pulumi.Input<boolean>;
}

export interface CustomHostnameSslSetting {
    /**
     * List of SSL/TLS ciphers to associate with this certificate.
     */
    ciphers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether early hints should be supported. Available values: `on`, `off`.
     */
    earlyHints?: pulumi.Input<string>;
    /**
     * Whether HTTP2 should be supported. Available values: `on`, `off`.
     */
    http2?: pulumi.Input<string>;
    /**
     * Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
     */
    minTlsVersion?: pulumi.Input<string>;
    /**
     * Whether TLSv1.3 should be supported. Available values: `on`, `off`.
     */
    tls13?: pulumi.Input<string>;
}

export interface CustomHostnameSslValidationError {
    message?: pulumi.Input<string>;
}

export interface CustomHostnameSslValidationRecord {
    cnameName?: pulumi.Input<string>;
    cnameTarget?: pulumi.Input<string>;
    emails?: pulumi.Input<pulumi.Input<string>[]>;
    httpBody?: pulumi.Input<string>;
    httpUrl?: pulumi.Input<string>;
    txtName?: pulumi.Input<string>;
    txtValue?: pulumi.Input<string>;
}

export interface CustomSslCustomSslOptions {
    /**
     * Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: pulumi.Input<string>;
    /**
     * Certificate certificate and the intermediate(s).
     */
    certificate?: pulumi.Input<string>;
    /**
     * Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highestSecurity`.
     */
    geoRestrictions?: pulumi.Input<string>;
    /**
     * Certificate's private key.
     */
    privateKey?: pulumi.Input<string>;
    /**
     * Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacyCustom`, `sniCustom`.
     */
    type?: pulumi.Input<string>;
}

export interface CustomSslCustomSslPriority {
    /**
     * The ID of this resource.
     */
    id?: pulumi.Input<string>;
    priority?: pulumi.Input<number>;
}

export interface DeviceDexTestData {
    /**
     * The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
     */
    host: pulumi.Input<string>;
    /**
     * The type of Device Dex Test. Available values: `http`, `traceroute`.
     */
    kind: pulumi.Input<string>;
    /**
     * The http request method. Available values: `GET`.
     */
    method?: pulumi.Input<string>;
}

export interface DeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: pulumi.Input<string>;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: pulumi.Input<string>;
}

export interface DevicePostureIntegrationConfig {
    /**
     * The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `apiUrl`.
     */
    accessClientId?: pulumi.Input<string>;
    /**
     * The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `apiUrl`.
     */
    accessClientSecret?: pulumi.Input<string>;
    /**
     * The third-party API's URL.
     */
    apiUrl?: pulumi.Input<string>;
    /**
     * The third-party authorization API URL.
     */
    authUrl?: pulumi.Input<string>;
    /**
     * The client identifier for authenticating API calls.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The client key for authenticating API calls.
     */
    clientKey?: pulumi.Input<string>;
    /**
     * The client secret for authenticating API calls.
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * The customer identifier for authenticating API calls.
     */
    customerId?: pulumi.Input<string>;
}

export interface DevicePostureRuleInput {
    /**
     * The number of active threats from SentinelOne.
     */
    activeThreats?: pulumi.Input<number>;
    /**
     * The UUID of a Cloudflare managed certificate.
     */
    certificateId?: pulumi.Input<string>;
    /**
     * Specific volume(s) to check for encryption.
     */
    checkDisks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The common name for a certificate.
     */
    cn?: pulumi.Input<string>;
    /**
     * The workspace one device compliance status. Available values: `compliant`, `noncompliant`.
     */
    complianceStatus?: pulumi.Input<string>;
    /**
     * The workspace one connection id.
     */
    connectionId?: pulumi.Input<string>;
    /**
     * The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    countOperator?: pulumi.Input<string>;
    /**
     * The domain that the client must join.
     */
    domain?: pulumi.Input<string>;
    /**
     * The datetime a device last seen in RFC 3339 format from Tanium.
     */
    eidLastSeen?: pulumi.Input<string>;
    /**
     * True if the firewall must be enabled.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Checks if the file should exist.
     */
    exists?: pulumi.Input<boolean>;
    /**
     * The Teams List id. Required for `serialNumber` and `uniqueClientId` rule types.
     */
    id?: pulumi.Input<string>;
    /**
     * True if SentinelOne device is infected.
     */
    infected?: pulumi.Input<boolean>;
    /**
     * True if SentinelOne device is active.
     */
    isActive?: pulumi.Input<boolean>;
    /**
     * The number of issues for kolide.
     */
    issueCount?: pulumi.Input<string>;
    /**
     * The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
     */
    networkStatus?: pulumi.Input<string>;
    /**
     * The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    operator?: pulumi.Input<string>;
    /**
     * OS signal score from Crowdstrike. Value must be between 1 and 100.
     */
    os?: pulumi.Input<string>;
    /**
     * The operating system excluding version information.
     */
    osDistroName?: pulumi.Input<string>;
    /**
     * The operating system version excluding OS name information or release name.
     */
    osDistroRevision?: pulumi.Input<string>;
    /**
     * Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
     */
    overall?: pulumi.Input<string>;
    /**
     * The path to the file.
     */
    path?: pulumi.Input<string>;
    /**
     * True if all drives must be encrypted.
     */
    requireAll?: pulumi.Input<boolean>;
    /**
     * The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
     */
    riskLevel?: pulumi.Input<string>;
    /**
     * Checks if the application should be running.
     */
    running?: pulumi.Input<boolean>;
    /**
     * Sensor signal score from Crowdstrike. Value must be between 1 and 100.
     */
    sensorConfig?: pulumi.Input<string>;
    /**
     * The sha256 hash of the file.
     */
    sha256?: pulumi.Input<string>;
    /**
     * The thumbprint of the file certificate.
     */
    thumbprint?: pulumi.Input<string>;
    /**
     * The total score from Tanium.
     */
    totalScore?: pulumi.Input<number>;
    /**
     * The operating system semantic version.
     */
    version?: pulumi.Input<string>;
    /**
     * The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    versionOperator?: pulumi.Input<string>;
}

export interface DevicePostureRuleMatch {
    /**
     * The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
     */
    platform?: pulumi.Input<string>;
}

export interface DlpProfileEntry {
    /**
     * Whether the entry is active. Defaults to `false`.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Unique entry identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the entry to deploy.
     */
    name: pulumi.Input<string>;
    pattern?: pulumi.Input<inputs.DlpProfileEntryPattern>;
}

export interface DlpProfileEntryPattern {
    /**
     * The regex that defines the pattern.
     */
    regex: pulumi.Input<string>;
    /**
     * The validation algorithm to apply with this pattern.
     */
    validation?: pulumi.Input<string>;
}

export interface EmailRoutingCatchAllAction {
    /**
     * Type of supported action. Available values: `drop`, `forward`, `worker`.
     */
    type: pulumi.Input<string>;
    /**
     * A list with items in the following form.
     */
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface EmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Available values: `all`.
     */
    type: pulumi.Input<string>;
}

export interface EmailRoutingRuleAction {
    /**
     * Type of action. Available values: `forward`, `worker`, `drop`
     */
    type: pulumi.Input<string>;
    /**
     * Value to match on. Required for `type` of `literal`.
     */
    values?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface EmailRoutingRuleMatcher {
    /**
     * Field to match on. Required for `type` of `literal`.
     */
    field?: pulumi.Input<string>;
    /**
     * Type of matcher. Available values: `literal`, `all`
     */
    type: pulumi.Input<string>;
    /**
     * Value to match on. Required for `type` of `literal`.
     */
    value?: pulumi.Input<string>;
}

export interface FallbackDomainDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: pulumi.Input<string>;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix?: pulumi.Input<string>;
}

export interface GetLoadBalancerPoolsFilter {
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name?: string;
}

export interface GetLoadBalancerPoolsFilterArgs {
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name?: pulumi.Input<string>;
}

export interface GetLoadBalancerPoolsPool {
    /**
     * List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
     */
    checkRegions?: string[];
    /**
     * The RFC3339 timestamp of when the load balancer was created.
     */
    createdOn?: string;
    /**
     * Brief description of the Load Balancer Pool intention.
     */
    description?: string;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled?: boolean;
    /**
     * ID for this load balancer pool.
     */
    id?: string;
    /**
     * Latitude this pool is physically located at; used for proximity steering.
     */
    latitude?: number;
    /**
     * Setting for controlling load shedding for this pool.
     */
    loadSheddings?: inputs.GetLoadBalancerPoolsPoolLoadShedding[];
    /**
     * Longitude this pool is physically located at; used for proximity steering.
     */
    longitude?: number;
    /**
     * Minimum number of origins that must be healthy for this pool to serve traffic.
     */
    minimumOrigins?: number;
    /**
     * The RFC3339 timestamp of when the load balancer was last modified.
     */
    modifiedOn?: string;
    /**
     * ID of the Monitor to use for health checking origins within this pool.
     */
    monitor?: string;
    /**
     * Short name (tag) for the pool.
     */
    name?: string;
    /**
     * Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
     */
    notificationEmail?: string;
    /**
     * The list of origins within this pool.
     */
    origins?: inputs.GetLoadBalancerPoolsPoolOrigin[];
}

export interface GetLoadBalancerPoolsPoolArgs {
    /**
     * List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
     */
    checkRegions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The RFC3339 timestamp of when the load balancer was created.
     */
    createdOn?: pulumi.Input<string>;
    /**
     * Brief description of the Load Balancer Pool intention.
     */
    description?: pulumi.Input<string>;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * ID for this load balancer pool.
     */
    id?: pulumi.Input<string>;
    /**
     * Latitude this pool is physically located at; used for proximity steering.
     */
    latitude?: pulumi.Input<number>;
    /**
     * Setting for controlling load shedding for this pool.
     */
    loadSheddings?: pulumi.Input<pulumi.Input<inputs.GetLoadBalancerPoolsPoolLoadSheddingArgs>[]>;
    /**
     * Longitude this pool is physically located at; used for proximity steering.
     */
    longitude?: pulumi.Input<number>;
    /**
     * Minimum number of origins that must be healthy for this pool to serve traffic.
     */
    minimumOrigins?: pulumi.Input<number>;
    /**
     * The RFC3339 timestamp of when the load balancer was last modified.
     */
    modifiedOn?: pulumi.Input<string>;
    /**
     * ID of the Monitor to use for health checking origins within this pool.
     */
    monitor?: pulumi.Input<string>;
    /**
     * Short name (tag) for the pool.
     */
    name?: pulumi.Input<string>;
    /**
     * Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
     */
    notificationEmail?: pulumi.Input<string>;
    /**
     * The list of origins within this pool.
     */
    origins?: pulumi.Input<pulumi.Input<inputs.GetLoadBalancerPoolsPoolOriginArgs>[]>;
}

export interface GetLoadBalancerPoolsPoolLoadShedding {
    defaultPercent?: number;
    defaultPolicy?: string;
    sessionPercent?: number;
    sessionPolicy?: string;
}

export interface GetLoadBalancerPoolsPoolLoadSheddingArgs {
    defaultPercent?: pulumi.Input<number>;
    defaultPolicy?: pulumi.Input<string>;
    sessionPercent?: pulumi.Input<number>;
    sessionPolicy?: pulumi.Input<string>;
}

export interface GetLoadBalancerPoolsPoolOrigin {
    address: string;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled?: boolean;
    headers?: inputs.GetLoadBalancerPoolsPoolOriginHeader[];
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name: string;
    weight?: number;
}

export interface GetLoadBalancerPoolsPoolOriginArgs {
    address: pulumi.Input<string>;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled?: pulumi.Input<boolean>;
    headers?: pulumi.Input<pulumi.Input<inputs.GetLoadBalancerPoolsPoolOriginHeaderArgs>[]>;
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name: pulumi.Input<string>;
    weight?: pulumi.Input<number>;
}

export interface GetLoadBalancerPoolsPoolOriginHeader {
    header: string;
    values: string[];
}

export interface GetLoadBalancerPoolsPoolOriginHeaderArgs {
    header: pulumi.Input<string>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetRulesetsFilter {
    /**
     * The ID of the Ruleset to target.
     */
    id?: string;
    /**
     * Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
     */
    kind?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`.
     */
    phase?: string;
    /**
     * Version of the ruleset to filter on.
     */
    version?: string;
}

export interface GetRulesetsFilterArgs {
    /**
     * The ID of the Ruleset to target.
     */
    id?: pulumi.Input<string>;
    /**
     * Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
     */
    kind?: pulumi.Input<string>;
    /**
     * Name of the ruleset.
     */
    name?: pulumi.Input<string>;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`.
     */
    phase?: pulumi.Input<string>;
    /**
     * Version of the ruleset to filter on.
     */
    version?: pulumi.Input<string>;
}

export interface GetZonesFilter {
    /**
     * The account identifier to target for the resource.
     */
    accountId?: string;
    /**
     * The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
     */
    lookupType?: string;
    /**
     * A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookupType`	are performed on the Cloudflare server side.
     */
    match?: string;
    /**
     * A string value to search for.
     */
    name?: string;
    /**
     * Paused status of the zone to lookup. Defaults to `false`.
     */
    paused?: boolean;
    /**
     * Status of the zone to lookup.
     */
    status?: string;
}

export interface GetZonesFilterArgs {
    /**
     * The account identifier to target for the resource.
     */
    accountId?: pulumi.Input<string>;
    /**
     * The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
     */
    lookupType?: pulumi.Input<string>;
    /**
     * A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookupType`	are performed on the Cloudflare server side.
     */
    match?: pulumi.Input<string>;
    /**
     * A string value to search for.
     */
    name?: pulumi.Input<string>;
    /**
     * Paused status of the zone to lookup. Defaults to `false`.
     */
    paused?: pulumi.Input<boolean>;
    /**
     * Status of the zone to lookup.
     */
    status?: pulumi.Input<string>;
}

export interface HealthcheckHeader {
    /**
     * The header name.
     */
    header: pulumi.Input<string>;
    /**
     * A list of string values for the header.
     */
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ListItem {
    /**
     * An optional comment for the item.
     */
    comment?: pulumi.Input<string>;
    value: pulumi.Input<inputs.ListItemValue>;
}

export interface ListItemHostname {
    /**
     * The FQDN to match on.
     */
    urlHostname: pulumi.Input<string>;
}

export interface ListItemRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url.
     */
    includeSubdomains?: pulumi.Input<boolean>;
    /**
     * Whether the redirect target url should keep the query string of the request's url.
     */
    preservePathSuffix?: pulumi.Input<boolean>;
    /**
     * Whether the redirect target url should keep the query string of the request's url.
     */
    preserveQueryString?: pulumi.Input<boolean>;
    /**
     * The source url of the redirect.
     */
    sourceUrl: pulumi.Input<string>;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: pulumi.Input<number>;
    /**
     * Whether the redirect also matches subpaths of the source url.
     */
    subpathMatching?: pulumi.Input<boolean>;
    /**
     * The target url of the redirect.
     */
    targetUrl: pulumi.Input<string>;
}

export interface ListItemValue {
    asn?: pulumi.Input<number>;
    hostnames?: pulumi.Input<pulumi.Input<inputs.ListItemValueHostname>[]>;
    ip?: pulumi.Input<string>;
    redirects?: pulumi.Input<pulumi.Input<inputs.ListItemValueRedirect>[]>;
}

export interface ListItemValueHostname {
    /**
     * The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
     */
    urlHostname: pulumi.Input<string>;
}

export interface ListItemValueRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
     */
    includeSubdomains?: pulumi.Input<string>;
    /**
     * Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
     */
    preservePathSuffix?: pulumi.Input<string>;
    /**
     * Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
     */
    preserveQueryString?: pulumi.Input<string>;
    /**
     * The source url of the redirect.
     */
    sourceUrl: pulumi.Input<string>;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: pulumi.Input<number>;
    /**
     * Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
     */
    subpathMatching?: pulumi.Input<string>;
    /**
     * The target url of the redirect.
     */
    targetUrl: pulumi.Input<string>;
}

export interface LoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
     */
    failoverAcrossPools?: pulumi.Input<boolean>;
}

export interface LoadBalancerCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: pulumi.Input<string>;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: pulumi.Input<pulumi.Input<string>[]>;
}

export interface LoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolverIp` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolverIp`. Defaults to `pop`.
     */
    mode?: pulumi.Input<string>;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
     */
    preferEcs?: pulumi.Input<string>;
}

export interface LoadBalancerMonitorHeader {
    /**
     * The header name.
     */
    header: pulumi.Input<string>;
    /**
     * A list of values for the header.
     */
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * Percent of traffic to shed 0 - 100. Defaults to `0`.
     */
    defaultPercent?: pulumi.Input<number>;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
     */
    defaultPolicy?: pulumi.Input<string>;
    /**
     * Percent of session traffic to shed 0 - 100. Defaults to `0`.
     */
    sessionPercent?: pulumi.Input<number>;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
     */
    sessionPolicy?: pulumi.Input<string>;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
     */
    address: pulumi.Input<string>;
    /**
     * Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * HTTP request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.LoadBalancerPoolOriginHeader>[]>;
    /**
     * A human-identifiable name for the origin.
     */
    name: pulumi.Input<string>;
    /**
     * The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="leastOutstandingRequests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="leastConnections"`, weight is used to scale the origin's open connections. Defaults to `1`.
     */
    weight?: pulumi.Input<number>;
}

export interface LoadBalancerPoolOriginHeader {
    /**
     * HTTP request headers.
     */
    header: pulumi.Input<string>;
    /**
     * Values for the HTTP headers.
     */
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `leastOutstandingRequests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `leastConnections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `leastOutstandingRequests`, `leastConnections`. Defaults to `random`.
     */
    policy?: pulumi.Input<string>;
}

export interface LoadBalancerPopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: pulumi.Input<string>;
}

export interface LoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `poolWeights` map.
     */
    defaultWeight?: pulumi.Input<number>;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
}

export interface LoadBalancerRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: pulumi.Input<string>;
}

export interface LoadBalancerRule {
    /**
     * The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
     */
    condition?: pulumi.Input<string>;
    /**
     * A disabled rule will not be executed.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixedResponse` must be set.
     */
    fixedResponse?: pulumi.Input<inputs.LoadBalancerRuleFixedResponse>;
    /**
     * Human readable name for this rule.
     */
    name: pulumi.Input<string>;
    /**
     * The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixedResponse` must be set.
     */
    overrides?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverride>[]>;
    /**
     * Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
     */
    priority?: pulumi.Input<number>;
    /**
     * Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixedResponse` forces this field to `true`.
     */
    terminates?: pulumi.Input<boolean>;
}

export interface LoadBalancerRuleFixedResponse {
    /**
     * The value of the HTTP context-type header for this fixed response.
     */
    contentType?: pulumi.Input<string>;
    /**
     * The value of the HTTP location header for this fixed response.
     */
    location?: pulumi.Input<string>;
    /**
     * The text used as the html body for this fixed response.
     */
    messageBody?: pulumi.Input<string>;
    /**
     * The HTTP status code used for this fixed response.
     */
    statusCode?: pulumi.Input<number>;
}

export interface LoadBalancerRuleOverride {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     */
    adaptiveRoutings?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverrideAdaptiveRouting>[]>;
    /**
     * A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     */
    countryPools?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverrideCountryPool>[]>;
    /**
     * A list of pool IDs ordered by their failover priority. Used whenever `popPools`/`countryPools`/`regionPools` are not defined.
     */
    defaultPools?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool?: pulumi.Input<string>;
    /**
     * Controls location-based steering for non-proxied requests.
     */
    locationStrategies?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverrideLocationStrategy>[]>;
    /**
     * A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     */
    popPools?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverridePopPool>[]>;
    /**
     * Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="leastOutstandingRequests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="leastConnections"`, pool weights are used to scale each pool's open connections.
     */
    randomSteerings?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverrideRandomSteering>[]>;
    /**
     * A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     */
    regionPools?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverrideRegionPool>[]>;
    /**
     * Configure attributes for session affinity.
     */
    sessionAffinity?: pulumi.Input<string>;
    /**
     * Configure attributes for session affinity. Note that the property `drainDuration` is not currently supported as a rule override.
     */
    sessionAffinityAttributes?: pulumi.Input<pulumi.Input<inputs.LoadBalancerRuleOverrideSessionAffinityAttribute>[]>;
    /**
     * Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `sessionAffinityTtl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     */
    sessionAffinityTtl?: pulumi.Input<number>;
    /**
     * The method the load balancer uses to determine the route to your origin. Value `off` uses `defaultPoolIds`. Value `geo` uses `popPools`/`countryPools`/`regionPools`. For non-proxied requests, the `country` for `countryPools` is determined by `locationStrategy`. Value `random` selects a pool randomly. Value `dynamicLatency` uses round trip time to select the closest pool in `defaultPoolIds` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `locationStrategy` for non-proxied requests. Value `leastOutstandingRequests` selects a pool by taking into consideration `randomSteering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `leastConnections` selects a pool by taking into consideration `randomSteering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `popPools`/`countryPools`/`regionPools` otherwise `off`. Available values: `off`, `geo`, `dynamicLatency`, `random`, `proximity`, `leastOutstandingRequests`, `leastConnections`, `""` Defaults to `""`.
     */
    steeringPolicy?: pulumi.Input<string>;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
     */
    ttl?: pulumi.Input<number>;
}

export interface LoadBalancerRuleOverrideAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
     */
    failoverAcrossPools?: pulumi.Input<boolean>;
}

export interface LoadBalancerRuleOverrideCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: pulumi.Input<string>;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: pulumi.Input<pulumi.Input<string>[]>;
}

export interface LoadBalancerRuleOverrideLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolverIp` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolverIp`. Defaults to `pop`.
     */
    mode?: pulumi.Input<string>;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
     */
    preferEcs?: pulumi.Input<string>;
}

export interface LoadBalancerRuleOverridePopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: pulumi.Input<string>;
}

export interface LoadBalancerRuleOverrideRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `poolWeights` map.
     */
    defaultWeight?: pulumi.Input<number>;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: pulumi.Input<{[key: string]: pulumi.Input<number>}>;
}

export interface LoadBalancerRuleOverrideRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: pulumi.Input<string>;
}

export interface LoadBalancerRuleOverrideSessionAffinityAttribute {
    /**
     * Configures the HTTP header names to use when header session affinity is enabled.
     */
    headers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
     */
    requireAllHeaders?: pulumi.Input<boolean>;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
     */
    samesite?: pulumi.Input<string>;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
     */
    secure?: pulumi.Input<string>;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
     */
    zeroDowntimeFailover?: pulumi.Input<string>;
}

export interface LoadBalancerSessionAffinityAttribute {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
     */
    drainDuration?: pulumi.Input<number>;
    /**
     * Configures the HTTP header names to use when header session affinity is enabled.
     */
    headers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
     */
    requireAllHeaders?: pulumi.Input<boolean>;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
     */
    samesite?: pulumi.Input<string>;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
     */
    secure?: pulumi.Input<string>;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
     */
    zeroDowntimeFailover?: pulumi.Input<string>;
}

export interface ManagedHeadersManagedRequestHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Unique headers rule identifier.
     */
    id: pulumi.Input<string>;
}

export interface ManagedHeadersManagedResponseHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Unique headers rule identifier.
     */
    id: pulumi.Input<string>;
}

export interface NotificationPolicyEmailIntegration {
    /**
     * The ID of this resource.
     */
    id: pulumi.Input<string>;
    name?: pulumi.Input<string>;
}

export interface NotificationPolicyFilters {
    /**
     * Targeted actions for alert.
     */
    actions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
     */
    affectedComponents?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Alert trigger preferences. Example: `slo`.
     */
    alertTriggerPreferences?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * State of the pool to alert on.
     */
    enableds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
     */
    environments?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Source configuration to alert on for pool or origin.
     */
    eventSources?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Stream event type to alert on.
     */
    eventTypes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
     */
    events?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Alert grouping.
     */
    groupBies?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Identifier health check. Required when using `filters.0.status`.
     */
    healthCheckIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
     */
    incidentImpacts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Stream input id to alert on.
     */
    inputIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A numerical limit. Example: `100`.
     */
    limits?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Megabits per second threshold for dos alert.
     */
    megabitsPerSeconds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Health status to alert on for pool or origin.
     */
    newHealths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Tunnel health status to alert on.
     */
    newStatuses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Packets per second threshold for dos alert.
     */
    packetsPerSeconds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Load balancer pool identifier.
     */
    poolIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Product name. Available values: `workerRequests`, `workerDurableObjectsRequests`, `workerDurableObjectsDuration`, `workerDurableObjectsDataTransfer`, `workerDurableObjectsStoredData`, `workerDurableObjectsStorageDeletes`, `workerDurableObjectsStorageWrites`, `workerDurableObjectsStorageReads`.
     */
    products?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Identifier of pages project.
     */
    projectIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Protocol to alert on for dos.
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Requests per second threshold for dos alert.
     */
    requestsPerSeconds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Selectors for alert. Valid options depend on the alert type.
     */
    selectors?: pulumi.Input<pulumi.Input<string>[]>;
    services?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A numerical limit. Example: `99.9`.
     */
    slos?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Status to alert on.
     */
    statuses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target host to alert on for dos.
     */
    targetHostnames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target domain to alert on.
     */
    targetZoneNames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Tunnel IDs to alert on.
     */
    tunnelIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Filter for alert.
     */
    wheres?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of zone identifiers.
     */
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface NotificationPolicyPagerdutyIntegration {
    /**
     * The ID of this resource.
     */
    id: pulumi.Input<string>;
    name?: pulumi.Input<string>;
}

export interface NotificationPolicyWebhooksIntegration {
    /**
     * The ID of this resource.
     */
    id: pulumi.Input<string>;
    name?: pulumi.Input<string>;
}

export interface PageRuleActions {
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    alwaysUseHttps?: pulumi.Input<boolean>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    automaticHttpsRewrites?: pulumi.Input<string>;
    /**
     * The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
     */
    browserCacheTtl?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    browserCheck?: pulumi.Input<string>;
    /**
     * String value of cookie name to conditionally bypass cache the page.
     */
    bypassCacheOnCookie?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheByDeviceType?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    cacheDeceptionArmor?: pulumi.Input<string>;
    /**
     * Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
     */
    cacheKeyFields?: pulumi.Input<inputs.PageRuleActionsCacheKeyFields>;
    /**
     * Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cacheEverything"`.
     */
    cacheLevel?: pulumi.Input<string>;
    /**
     * String value of cookie name to conditionally cache the page.
     */
    cacheOnCookie?: pulumi.Input<string>;
    /**
     * Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
     */
    cacheTtlByStatuses?: pulumi.Input<pulumi.Input<inputs.PageRuleActionsCacheTtlByStatus>[]>;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableApps?: pulumi.Input<boolean>;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disablePerformance?: pulumi.Input<boolean>;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableRailgun?: pulumi.Input<boolean>;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableSecurity?: pulumi.Input<boolean>;
    /**
     * Boolean of whether this action is enabled. Default: false.
     */
    disableZaraz?: pulumi.Input<boolean>;
    /**
     * The Time To Live for the edge cache.
     */
    edgeCacheTtl?: pulumi.Input<number>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    emailObfuscation?: pulumi.Input<string>;
    /**
     * Whether origin Cache-Control action is `"on"` or `"off"`.
     */
    explicitCacheControl?: pulumi.Input<string>;
    /**
     * The URL to forward to, and with what status. See below.
     */
    forwardingUrl?: pulumi.Input<inputs.PageRuleActionsForwardingUrl>;
    /**
     * Value of the Host header to send.
     */
    hostHeaderOverride?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    ipGeolocation?: pulumi.Input<string>;
    /**
     * The configuration for HTML, CSS and JS minification. See below for full list of options.
     */
    minifies?: pulumi.Input<pulumi.Input<inputs.PageRuleActionsMinify>[]>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    mirage?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    opportunisticEncryption?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    originErrorPagePassThru?: pulumi.Input<string>;
    /**
     * Whether this action is `"off"`, `"lossless"` or `"lossy"`.
     */
    polish?: pulumi.Input<string>;
    /**
     * Overridden origin server name.
     */
    resolveOverride?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    respectStrongEtag?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    responseBuffering?: pulumi.Input<string>;
    /**
     * Whether to set the rocket loader to `"on"`, `"off"`.
     */
    rocketLoader?: pulumi.Input<string>;
    /**
     * Whether to set the security level to `"off"`, `"essentiallyOff"`, `"low"`, `"medium"`, `"high"`, or `"underAttack"`.
     */
    securityLevel?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    serverSideExclude?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    sortQueryStringForCache?: pulumi.Input<string>;
    /**
     * Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"originPull"`.
     */
    ssl?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    trueClientIpHeader?: pulumi.Input<string>;
    /**
     * Whether this action is `"on"` or `"off"`.
     */
    waf?: pulumi.Input<string>;
}

export interface PageRuleActionsCacheKeyFields {
    /**
     * Controls what cookies go into Cache Key:
     */
    cookie?: pulumi.Input<inputs.PageRuleActionsCacheKeyFieldsCookie>;
    /**
     * Controls what HTTP headers go into Cache Key:
     */
    header?: pulumi.Input<inputs.PageRuleActionsCacheKeyFieldsHeader>;
    /**
     * Controls which Host header goes into Cache Key:
     */
    host: pulumi.Input<inputs.PageRuleActionsCacheKeyFieldsHost>;
    /**
     * Controls which URL query string parameters go into the Cache Key.
     */
    queryString: pulumi.Input<inputs.PageRuleActionsCacheKeyFieldsQueryString>;
    /**
     * Controls which end user-related features go into the Cache Key.
     */
    user: pulumi.Input<inputs.PageRuleActionsCacheKeyFieldsUser>;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    /**
     * Check for presence of specified HTTP headers, without including their actual values.
     */
    checkPresences?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    /**
     * Check for presence of specified HTTP headers, without including their actual values.
     */
    checkPresences?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Exclude these query string parameters from Cache Key.
     */
    excludes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PageRuleActionsCacheKeyFieldsHost {
    /**
     * `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
     */
    resolved?: pulumi.Input<boolean>;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    /**
     * Exclude these query string parameters from Cache Key.
     */
    excludes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * `false` (default) - all query string parameters are used for Cache Key, unless explicitly excluded; `true` - all query string parameters are ignored; value should be `false` if any of `exclude` or `include` is non-empty.
     */
    ignore?: pulumi.Input<boolean>;
    /**
     * Only use values of specified query string parameters in Cache Key.
     */
    includes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PageRuleActionsCacheKeyFieldsUser {
    /**
     * `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
     */
    deviceType?: pulumi.Input<boolean>;
    /**
     * `true` - includes the clients country, derived from the IP address; defaults to `false`.
     */
    geo?: pulumi.Input<boolean>;
    /**
     * `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
     *
     * Example:
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as cloudflare from "@pulumi/cloudflare";
     *
     * // Unrealistic example with all features used
     * const foobar = new cloudflare.PageRule("foobar", {
     *     zoneId: _var.cloudflare_zone_id,
     *     target: `${_var.cloudflare_zone}/app/*`,
     *     priority: 1,
     *     actions: {
     *         cacheKeyFields: {
     *             cookie: {
     *                 checkPresences: ["wordpress_test_cookie"],
     *             },
     *             header: {
     *                 checkPresences: ["header_present"],
     *                 excludes: ["origin"],
     *                 includes: [
     *                     "api-key",
     *                     "dnt",
     *                 ],
     *             },
     *             host: {
     *                 resolved: true,
     *             },
     *             queryString: {
     *                 ignore: true,
     *             },
     *             user: {
     *                 deviceType: false,
     *                 geo: true,
     *                 lang: true,
     *             },
     *         },
     *     },
     * });
     * ```
     */
    lang?: pulumi.Input<boolean>;
}

export interface PageRuleActionsCacheTtlByStatus {
    /**
     * A HTTP code (e.g. `404`) or range of codes (e.g. `400-499`)
     */
    codes: pulumi.Input<string>;
    /**
     * Duration a resource lives in the Cloudflare cache.
     * - positive number - cache for specified duration in seconds
     */
    ttl: pulumi.Input<number>;
}

export interface PageRuleActionsForwardingUrl {
    /**
     * The status code to use for the redirection.
     */
    statusCode: pulumi.Input<number>;
    /**
     * The URL to which the page rule should forward.
     */
    url: pulumi.Input<string>;
}

export interface PageRuleActionsMinify {
    /**
     * Whether CSS should be minified. Valid values are `"on"` or `"off"`.
     */
    css: pulumi.Input<string>;
    /**
     * Whether HTML should be minified. Valid values are `"on"` or `"off"`.
     */
    html: pulumi.Input<string>;
    /**
     * Whether Javascript should be minified. Valid values are `"on"` or `"off"`.
     */
    js: pulumi.Input<string>;
}

export interface PagesProjectBuildConfig {
    /**
     * Command used to build project.
     */
    buildCommand?: pulumi.Input<string>;
    /**
     * Output directory of the build.
     */
    destinationDir?: pulumi.Input<string>;
    /**
     * Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
     */
    rootDir?: pulumi.Input<string>;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag?: pulumi.Input<string>;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken?: pulumi.Input<string>;
}

export interface PagesProjectDeploymentConfigs {
    /**
     * Configuration for preview deploys.
     */
    preview?: pulumi.Input<inputs.PagesProjectDeploymentConfigsPreview>;
    /**
     * Configuration for production deploys.
     */
    production?: pulumi.Input<inputs.PagesProjectDeploymentConfigsProduction>;
}

export interface PagesProjectDeploymentConfigsPreview {
    /**
     * Use latest compatibility date for Pages Functions. Defaults to `false`.
     */
    alwaysUseLatestCompatibilityDate?: pulumi.Input<boolean>;
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate?: pulumi.Input<string>;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * D1 Databases used for Pages Functions. Defaults to `map[]`.
     */
    d1Databases?: pulumi.Input<{[key: string]: any}>;
    /**
     * Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
     */
    durableObjectNamespaces?: pulumi.Input<{[key: string]: any}>;
    /**
     * Environment variables for Pages Functions. Defaults to `map[]`.
     */
    environmentVariables?: pulumi.Input<{[key: string]: any}>;
    /**
     * Fail open used for Pages Functions. Defaults to `false`.
     */
    failOpen?: pulumi.Input<boolean>;
    /**
     * KV namespaces used for Pages Functions. Defaults to `map[]`.
     */
    kvNamespaces?: pulumi.Input<{[key: string]: any}>;
    /**
     * Configuration for placement in the Cloudflare Pages project.
     */
    placement?: pulumi.Input<inputs.PagesProjectDeploymentConfigsPreviewPlacement>;
    /**
     * R2 Buckets used for Pages Functions. Defaults to `map[]`.
     */
    r2Buckets?: pulumi.Input<{[key: string]: any}>;
    /**
     * Encrypted environment variables for Pages Functions. Defaults to `map[]`.
     */
    secrets?: pulumi.Input<{[key: string]: any}>;
    /**
     * Services used for Pages Functions.
     */
    serviceBindings?: pulumi.Input<pulumi.Input<inputs.PagesProjectDeploymentConfigsPreviewServiceBinding>[]>;
    /**
     * Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
     */
    usageModel?: pulumi.Input<string>;
}

export interface PagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement Mode for the Pages Function.
     */
    mode?: pulumi.Input<string>;
}

export interface PagesProjectDeploymentConfigsPreviewServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
    /**
     * The name of the Worker to bind to.
     */
    service: pulumi.Input<string>;
}

export interface PagesProjectDeploymentConfigsProduction {
    /**
     * Use latest compatibility date for Pages Functions. Defaults to `false`.
     */
    alwaysUseLatestCompatibilityDate?: pulumi.Input<boolean>;
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate?: pulumi.Input<string>;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * D1 Databases used for Pages Functions. Defaults to `map[]`.
     */
    d1Databases?: pulumi.Input<{[key: string]: any}>;
    /**
     * Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
     */
    durableObjectNamespaces?: pulumi.Input<{[key: string]: any}>;
    /**
     * Environment variables for Pages Functions. Defaults to `map[]`.
     */
    environmentVariables?: pulumi.Input<{[key: string]: any}>;
    /**
     * Fail open used for Pages Functions. Defaults to `false`.
     */
    failOpen?: pulumi.Input<boolean>;
    /**
     * KV namespaces used for Pages Functions. Defaults to `map[]`.
     */
    kvNamespaces?: pulumi.Input<{[key: string]: any}>;
    /**
     * Configuration for placement in the Cloudflare Pages project.
     */
    placement?: pulumi.Input<inputs.PagesProjectDeploymentConfigsProductionPlacement>;
    /**
     * R2 Buckets used for Pages Functions. Defaults to `map[]`.
     */
    r2Buckets?: pulumi.Input<{[key: string]: any}>;
    /**
     * Encrypted environment variables for Pages Functions. Defaults to `map[]`.
     */
    secrets?: pulumi.Input<{[key: string]: any}>;
    /**
     * Services used for Pages Functions.
     */
    serviceBindings?: pulumi.Input<pulumi.Input<inputs.PagesProjectDeploymentConfigsProductionServiceBinding>[]>;
    /**
     * Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
     */
    usageModel?: pulumi.Input<string>;
}

export interface PagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement Mode for the Pages Function.
     */
    mode?: pulumi.Input<string>;
}

export interface PagesProjectDeploymentConfigsProductionServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
    /**
     * The name of the Worker to bind to.
     */
    service: pulumi.Input<string>;
}

export interface PagesProjectSource {
    /**
     * Configuration for the source of the Cloudflare Pages project.
     */
    config?: pulumi.Input<inputs.PagesProjectSourceConfig>;
    /**
     * Project host type.
     */
    type?: pulumi.Input<string>;
}

export interface PagesProjectSourceConfig {
    /**
     * Toggle deployments on this repo. Defaults to `true`.
     */
    deploymentsEnabled?: pulumi.Input<boolean>;
    /**
     * Project owner username. **Modifying this attribute will force creation of a new resource.**
     */
    owner?: pulumi.Input<string>;
    /**
     * Enable Pages to comment on Pull Requests. Defaults to `true`.
     */
    prCommentsEnabled?: pulumi.Input<boolean>;
    /**
     * Branches will be excluded from automatic deployment.
     */
    previewBranchExcludes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Branches will be included for automatic deployment.
     */
    previewBranchIncludes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
     */
    previewDeploymentSetting?: pulumi.Input<string>;
    /**
     * Project production branch name.
     */
    productionBranch: pulumi.Input<string>;
    /**
     * Enable production deployments. Defaults to `true`.
     */
    productionDeploymentEnabled?: pulumi.Input<boolean>;
    /**
     * Project repository name. **Modifying this attribute will force creation of a new resource.**
     */
    repoName?: pulumi.Input<string>;
}

export interface RateLimitAction {
    /**
     * The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `jsChallenge`, `managedChallenge`.
     */
    mode: pulumi.Input<string>;
    /**
     * Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
     */
    response?: pulumi.Input<inputs.RateLimitActionResponse>;
    /**
     * The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
     */
    timeout?: pulumi.Input<number>;
}

export interface RateLimitActionResponse {
    /**
     * The body to return, the content here should conform to the `contentType`.
     */
    body: pulumi.Input<string>;
    /**
     * The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
     */
    contentType: pulumi.Input<string>;
}

export interface RateLimitCorrelate {
    /**
     * If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
     */
    by?: pulumi.Input<string>;
}

export interface RateLimitMatch {
    /**
     * Matches HTTP requests (from the client to Cloudflare).
     */
    request?: pulumi.Input<inputs.RateLimitMatchRequest>;
    /**
     * Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
     */
    response?: pulumi.Input<inputs.RateLimitMatchResponse>;
}

export interface RateLimitMatchRequest {
    /**
     * HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
     */
    methods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
     */
    schemes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
     */
    urlPattern?: pulumi.Input<string>;
}

export interface RateLimitMatchResponse {
    /**
     * List of HTTP headers maps to match the origin response on.
     */
    headers?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
    /**
     * Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
     */
    originTraffic?: pulumi.Input<boolean>;
    /**
     * HTTP Status codes, can be one, many or indicate all by not providing this value.
     */
    statuses?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface RecordData {
    algorithm?: pulumi.Input<number>;
    altitude?: pulumi.Input<number>;
    certificate?: pulumi.Input<string>;
    content?: pulumi.Input<string>;
    digest?: pulumi.Input<string>;
    digestType?: pulumi.Input<number>;
    fingerprint?: pulumi.Input<string>;
    flags?: pulumi.Input<string>;
    keyTag?: pulumi.Input<number>;
    latDegrees?: pulumi.Input<number>;
    latDirection?: pulumi.Input<string>;
    latMinutes?: pulumi.Input<number>;
    latSeconds?: pulumi.Input<number>;
    longDegrees?: pulumi.Input<number>;
    longDirection?: pulumi.Input<string>;
    longMinutes?: pulumi.Input<number>;
    longSeconds?: pulumi.Input<number>;
    matchingType?: pulumi.Input<number>;
    name?: pulumi.Input<string>;
    order?: pulumi.Input<number>;
    port?: pulumi.Input<number>;
    precisionHorz?: pulumi.Input<number>;
    precisionVert?: pulumi.Input<number>;
    preference?: pulumi.Input<number>;
    priority?: pulumi.Input<number>;
    proto?: pulumi.Input<string>;
    protocol?: pulumi.Input<number>;
    publicKey?: pulumi.Input<string>;
    regex?: pulumi.Input<string>;
    replacement?: pulumi.Input<string>;
    selector?: pulumi.Input<number>;
    service?: pulumi.Input<string>;
    size?: pulumi.Input<number>;
    tag?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    type?: pulumi.Input<number>;
    usage?: pulumi.Input<number>;
    value?: pulumi.Input<string>;
    weight?: pulumi.Input<number>;
}

export interface RulesetRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: pulumi.Input<string>;
    /**
     * List of parameters that configure the behavior of the ruleset rule action.
     */
    actionParameters?: pulumi.Input<inputs.RulesetRuleActionParameters>;
    /**
     * Brief summary of the ruleset rule and its intended use.
     */
    description?: pulumi.Input<string>;
    /**
     * Whether the rule is active.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * List of parameters that configure exposed credential checks.
     */
    exposedCredentialCheck?: pulumi.Input<inputs.RulesetRuleExposedCredentialCheck>;
    /**
     * Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression: pulumi.Input<string>;
    /**
     * Unique rule identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * The most recent update to this rule.
     */
    lastUpdated?: pulumi.Input<string>;
    /**
     * List parameters to configure how the rule generates logs. Only valid for skip action.
     */
    logging?: pulumi.Input<inputs.RulesetRuleLogging>;
    /**
     * List of parameters that configure HTTP rate limiting behaviour.
     */
    ratelimit?: pulumi.Input<inputs.RulesetRuleRatelimit>;
    /**
     * Rule reference.
     */
    ref?: pulumi.Input<string>;
    /**
     * Version of the ruleset to deploy.
     */
    version?: pulumi.Input<string>;
}

export interface RulesetRuleActionParameters {
    /**
     * Specifies uncommon ports to allow cacheable assets to be served from.
     */
    additionalCacheablePorts?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Compression algorithms to use in order of preference.
     */
    algorithms?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersAlgorithm>[]>;
    /**
     * Turn on or off Cloudflare Automatic HTTPS rewrites.
     */
    automaticHttpsRewrites?: pulumi.Input<boolean>;
    /**
     * Indicate which file extensions to minify automatically.
     */
    autominifies?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersAutominify>[]>;
    /**
     * Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
     */
    bic?: pulumi.Input<boolean>;
    /**
     * List of browser TTL parameters to apply to the request.
     */
    browserTtl?: pulumi.Input<inputs.RulesetRuleActionParametersBrowserTtl>;
    /**
     * Whether to cache if expression matches.
     */
    cache?: pulumi.Input<boolean>;
    /**
     * List of cache key parameters to apply to the request.
     */
    cacheKey?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKey>;
    /**
     * Content of the custom error response.
     */
    content?: pulumi.Input<string>;
    /**
     * Content-Type of the custom error response.
     */
    contentType?: pulumi.Input<string>;
    /**
     * List of cookie values to include as part of custom fields logging.
     */
    cookieFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Turn off all active Cloudflare Apps.
     */
    disableApps?: pulumi.Input<boolean>;
    /**
     * Turn off railgun feature of the Cloudflare Speed app.
     */
    disableRailgun?: pulumi.Input<boolean>;
    /**
     * Turn off zaraz feature.
     */
    disableZaraz?: pulumi.Input<boolean>;
    /**
     * List of edge TTL parameters to apply to the request.
     */
    edgeTtl?: pulumi.Input<inputs.RulesetRuleActionParametersEdgeTtl>;
    /**
     * Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
     */
    emailObfuscation?: pulumi.Input<boolean>;
    /**
     * Use a list to lookup information for the action.
     */
    fromList?: pulumi.Input<inputs.RulesetRuleActionParametersFromList>;
    /**
     * Use a value to lookup information for the action.
     */
    fromValue?: pulumi.Input<inputs.RulesetRuleActionParametersFromValue>;
    /**
     * List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersHeader>[]>;
    /**
     * Host Header that request origin receives.
     */
    hostHeader?: pulumi.Input<string>;
    /**
     * Turn on or off the hotlink protection feature.
     */
    hotlinkProtection?: pulumi.Input<boolean>;
    /**
     * Identifier of the action parameter to modify.
     */
    id?: pulumi.Input<string>;
    increment?: pulumi.Input<number>;
    /**
     * List of properties to configure WAF payload logging.
     */
    matchedData?: pulumi.Input<inputs.RulesetRuleActionParametersMatchedData>;
    /**
     * Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
     */
    mirage?: pulumi.Input<boolean>;
    /**
     * Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    opportunisticEncryption?: pulumi.Input<boolean>;
    /**
     * List of properties to change request origin.
     */
    origin?: pulumi.Input<inputs.RulesetRuleActionParametersOrigin>;
    /**
     * Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
     */
    originCacheControl?: pulumi.Input<boolean>;
    /**
     * Pass-through error page for origin.
     */
    originErrorPagePassthru?: pulumi.Input<boolean>;
    /**
     * List of override configurations to apply to the ruleset.
     */
    overrides?: pulumi.Input<inputs.RulesetRuleActionParametersOverrides>;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddosL4`, `ddosL7`, `httpConfigSettings`, `httpCustomErrors`, `httpLogCustomFields`, `httpRatelimit`, `httpRequestCacheSettings`, `httpRequestDynamicRedirect`, `httpRequestFirewallCustom`, `httpRequestFirewallManaged`, `httpRequestLateTransform`, `httpRequestOrigin`, `httpRequestRedirect`, `httpRequestSanitize`, `httpRequestSbfm`, `httpRequestTransform`, `httpResponseCompression`, `httpResponseFirewallManaged`, `httpResponseHeadersTransform`, `magicTransit`.
     */
    phases?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Apply options from the Polish feature of the Cloudflare Speed app.
     */
    polish?: pulumi.Input<string>;
    /**
     * Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
     */
    products?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies a maximum timeout for reading content from an origin server.
     */
    readTimeout?: pulumi.Input<number>;
    /**
     * List of request headers to include as part of custom fields logging, in lowercase.
     */
    requestFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Respect strong ETags.
     */
    respectStrongEtags?: pulumi.Input<boolean>;
    /**
     * List of response headers to include as part of custom fields logging, in lowercase.
     */
    responseFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of parameters that configure the response given to end users.
     */
    responses?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersResponse>[]>;
    /**
     * Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
     */
    rocketLoader?: pulumi.Input<boolean>;
    /**
     * List of rule-based overrides.
     */
    rules?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Which ruleset ID to target.
     */
    ruleset?: pulumi.Input<string>;
    /**
     * List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
     */
    rulesets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Control options for the Security Level feature from the Security app.
     */
    securityLevel?: pulumi.Input<string>;
    /**
     * List of serve stale parameters to apply to the request.
     */
    serveStale?: pulumi.Input<inputs.RulesetRuleActionParametersServeStale>;
    /**
     * Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
     */
    serverSideExcludes?: pulumi.Input<boolean>;
    /**
     * List of properties to manange Server Name Indication.
     */
    sni?: pulumi.Input<inputs.RulesetRuleActionParametersSni>;
    /**
     * Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    ssl?: pulumi.Input<string>;
    /**
     * Status code for which the edge TTL is applied.
     */
    statusCode?: pulumi.Input<number>;
    /**
     * Turn on or off the SXG feature.
     */
    sxg?: pulumi.Input<boolean>;
    /**
     * List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
     */
    uri?: pulumi.Input<inputs.RulesetRuleActionParametersUri>;
    /**
     * Version of the ruleset to deploy.
     */
    version?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersAlgorithm {
    /**
     * Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
     */
    name: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersAutominify {
    /**
     * CSS minification.
     */
    css?: pulumi.Input<boolean>;
    /**
     * HTML minification.
     */
    html?: pulumi.Input<boolean>;
    /**
     * JS minification.
     */
    js?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionParametersBrowserTtl {
    /**
     * Default browser TTL. This value is required when overrideOrigin is set
     */
    default?: pulumi.Input<number>;
    /**
     * Mode of the browser TTL. Available values: `overrideOrigin`, `respectOrigin`, `bypass`
     */
    mode: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersCacheKey {
    /**
     * Cache by device type.
     */
    cacheByDeviceType?: pulumi.Input<boolean>;
    /**
     * Cache deception armor.
     */
    cacheDeceptionArmor?: pulumi.Input<boolean>;
    /**
     * Custom key parameters for the request.
     */
    customKey?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKeyCustomKey>;
    /**
     * Ignore query strings order.
     */
    ignoreQueryStringsOrder?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionParametersCacheKeyCustomKey {
    /**
     * Cookie parameters for the custom key.
     */
    cookie?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKeyCustomKeyCookie>;
    /**
     * Header parameters for the custom key.
     */
    header?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKeyCustomKeyHeader>;
    /**
     * Host parameters for the custom key.
     */
    host?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKeyCustomKeyHost>;
    /**
     * Query string parameters for the custom key.
     */
    queryString?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryString>;
    /**
     * User parameters for the custom key.
     */
    user?: pulumi.Input<inputs.RulesetRuleActionParametersCacheKeyCustomKeyUser>;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyCookie {
    /**
     * List of cookies to check for presence in the custom key.
     */
    checkPresences?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of cookies to include in the custom key.
     */
    includes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHeader {
    /**
     * List of cookies to check for presence in the custom key.
     */
    checkPresences?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Exclude the origin header from the custom key.
     */
    excludeOrigin?: pulumi.Input<boolean>;
    /**
     * List of cookies to include in the custom key.
     */
    includes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyHost {
    /**
     * Resolve hostname to IP address.
     */
    resolved?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyQueryString {
    /**
     * List of query string parameters to exclude from the custom key.
     */
    excludes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of cookies to include in the custom key.
     */
    includes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RulesetRuleActionParametersCacheKeyCustomKeyUser {
    /**
     * Add device type to the custom key.
     */
    deviceType?: pulumi.Input<boolean>;
    /**
     * Add geo data to the custom key.
     */
    geo?: pulumi.Input<boolean>;
    /**
     * Add language data to the custom key.
     */
    lang?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionParametersEdgeTtl {
    /**
     * Default browser TTL. This value is required when overrideOrigin is set
     */
    default?: pulumi.Input<number>;
    /**
     * Mode of the browser TTL. Available values: `overrideOrigin`, `respectOrigin`, `bypass`
     */
    mode: pulumi.Input<string>;
    /**
     * Edge TTL for the status codes.
     */
    statusCodeTtls?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtl>[]>;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtl {
    /**
     * Status code for which the edge TTL is applied.
     */
    statusCode?: pulumi.Input<number>;
    /**
     * Status code range for which the edge TTL is applied.
     */
    statusCodeRanges?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange>[]>;
    /**
     * Status code edge TTL value.
     */
    value?: pulumi.Input<number>;
}

export interface RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * From status code.
     */
    from?: pulumi.Input<number>;
    /**
     * To status code.
     */
    to?: pulumi.Input<number>;
}

export interface RulesetRuleActionParametersFromList {
    /**
     * Expression to use for the list lookup.
     */
    key?: pulumi.Input<string>;
    /**
     * Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
     */
    name?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersFromValue {
    /**
     * Preserve query string for redirect URL.
     */
    preserveQueryString?: pulumi.Input<boolean>;
    /**
     * Status code for which the edge TTL is applied.
     */
    statusCode?: pulumi.Input<number>;
    /**
     * Target URL for redirect.
     */
    targetUrl?: pulumi.Input<inputs.RulesetRuleActionParametersFromValueTargetUrl>;
}

export interface RulesetRuleActionParametersFromValueTargetUrl {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: pulumi.Input<string>;
    /**
     * Status code edge TTL value.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersHeader {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: pulumi.Input<string>;
    /**
     * Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
     */
    name?: pulumi.Input<string>;
    /**
     * Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
     */
    operation?: pulumi.Input<string>;
    /**
     * Status code edge TTL value.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersMatchedData {
    /**
     * Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
     */
    publicKey?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersOrigin {
    /**
     * Host parameters for the custom key.
     */
    host?: pulumi.Input<string>;
    /**
     * Origin Port where request is sent.
     */
    port?: pulumi.Input<number>;
}

export interface RulesetRuleActionParametersOverrides {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: pulumi.Input<string>;
    /**
     * List of tag-based overrides.
     */
    categories?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersOverridesCategory>[]>;
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * List of rule-based overrides.
     */
    rules?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionParametersOverridesRule>[]>;
    /**
     * Sensitivity level for a ruleset rule override.
     */
    sensitivityLevel?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersOverridesCategory {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: pulumi.Input<string>;
    /**
     * Tag name to apply the ruleset rule override to.
     */
    category?: pulumi.Input<string>;
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
     */
    enabled?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionParametersOverridesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compressResponse`, `ddosDynamic`, `ddosMitigation`, `execute`, `forceConnectionClose`, `jsChallenge`, `log`, `logCustomField`, `managedChallenge`, `redirect`, `rewrite`, `route`, `score`, `serveError`, `setCacheSettings`, `setConfig`, `skip`.
     */
    action?: pulumi.Input<string>;
    /**
     * Whether the rule is active.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Unique rule identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
     */
    scoreThreshold?: pulumi.Input<number>;
    /**
     * Sensitivity level for a ruleset rule override.
     */
    sensitivityLevel?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersResponse {
    /**
     * Content of the custom error response.
     */
    content?: pulumi.Input<string>;
    /**
     * Content-Type of the custom error response.
     */
    contentType?: pulumi.Input<string>;
    /**
     * Status code for which the edge TTL is applied.
     */
    statusCode?: pulumi.Input<number>;
}

export interface RulesetRuleActionParametersServeStale {
    /**
     * Disable stale while updating.
     */
    disableStaleWhileUpdating?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionParametersSni {
    /**
     * Status code edge TTL value.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersUri {
    /**
     * List of properties to change request origin.
     */
    origin?: pulumi.Input<boolean>;
    /**
     * URI path configuration when performing a URL rewrite.
     */
    path?: pulumi.Input<inputs.RulesetRuleActionParametersUriPath>;
    /**
     * Query string configuration when performing a URL rewrite.
     */
    query?: pulumi.Input<inputs.RulesetRuleActionParametersUriQuery>;
}

export interface RulesetRuleActionParametersUriPath {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: pulumi.Input<string>;
    /**
     * Status code edge TTL value.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionParametersUriQuery {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: pulumi.Input<string>;
    /**
     * Status code edge TTL value.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleExposedCredentialCheck {
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    passwordExpression?: pulumi.Input<string>;
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    usernameExpression?: pulumi.Input<string>;
}

export interface RulesetRuleLogging {
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
     */
    enabled?: pulumi.Input<boolean>;
}

export interface RulesetRuleRatelimit {
    /**
     * List of parameters that define how Cloudflare tracks the request rate for this rule.
     */
    characteristics?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    countingExpression?: pulumi.Input<string>;
    /**
     * Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
     */
    mitigationTimeout?: pulumi.Input<number>;
    /**
     * The period of time to consider (in seconds) when evaluating the request rate.
     */
    period?: pulumi.Input<number>;
    /**
     * The number of requests over the period of time that will trigger the Rate Limiting rule.
     */
    requestsPerPeriod?: pulumi.Input<number>;
    /**
     * Whether to include requests to origin within the Rate Limiting count.
     */
    requestsToOrigin?: pulumi.Input<boolean>;
    /**
     * The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
     */
    scorePerPeriod?: pulumi.Input<number>;
    /**
     * Name of HTTP header in the response, set by the origin server, with the score for the current request.
     */
    scoreResponseHeaderName?: pulumi.Input<string>;
}

export interface SpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name: pulumi.Input<string>;
    /**
     * The type of DNS record associated with the application.
     */
    type: pulumi.Input<string>;
}

export interface SpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
     */
    connectivity?: pulumi.Input<string>;
    /**
     * The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
     */
    ips?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The type of edge IP configuration specified. Available values: `dynamic`, `static`.
     */
    type: pulumi.Input<string>;
}

export interface SpectrumApplicationOriginDns {
    /**
     * Fully qualified domain name of the origin.
     */
    name: pulumi.Input<string>;
}

export interface SpectrumApplicationOriginPortRange {
    /**
     * Upper bound of the origin port range.
     */
    end: pulumi.Input<number>;
    /**
     * Lower bound of the origin port range.
     */
    start: pulumi.Input<number>;
}

export interface SplitTunnelTunnel {
    /**
     * The address for the tunnel.
     */
    address?: pulumi.Input<string>;
    /**
     * A description for the tunnel.
     */
    description?: pulumi.Input<string>;
    /**
     * The domain name for the tunnel.
     */
    host?: pulumi.Input<string>;
}

export interface TeamsAccountAntivirus {
    /**
     * Scan on file download.
     */
    enabledDownloadPhase: pulumi.Input<boolean>;
    /**
     * Scan on file upload.
     */
    enabledUploadPhase: pulumi.Input<boolean>;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: pulumi.Input<boolean>;
}

export interface TeamsAccountBlockPage {
    /**
     * Hex code of block page background color.
     */
    backgroundColor?: pulumi.Input<string>;
    /**
     * Indicator of enablement.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Block page footer text.
     */
    footerText?: pulumi.Input<string>;
    /**
     * Block page header text.
     */
    headerText?: pulumi.Input<string>;
    /**
     * URL of block page logo.
     */
    logoPath?: pulumi.Input<string>;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: pulumi.Input<string>;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: pulumi.Input<string>;
    /**
     * Name of block page configuration.
     */
    name?: pulumi.Input<string>;
}

export interface TeamsAccountBodyScanning {
    /**
     * Body scanning inspection mode. Available values: `deep`, `shallow`.
     */
    inspectionMode: pulumi.Input<string>;
}

export interface TeamsAccountFips {
    /**
     * Only allow FIPS-compliant TLS configuration.
     */
    tls?: pulumi.Input<boolean>;
}

export interface TeamsAccountLogging {
    /**
     * Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
     */
    redactPii: pulumi.Input<boolean>;
    /**
     * Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
     */
    settingsByRuleType: pulumi.Input<inputs.TeamsAccountLoggingSettingsByRuleType>;
}

export interface TeamsAccountLoggingSettingsByRuleType {
    /**
     * Logging configuration for DNS requests.
     */
    dns: pulumi.Input<inputs.TeamsAccountLoggingSettingsByRuleTypeDns>;
    /**
     * Logging configuration for HTTP requests.
     */
    http: pulumi.Input<inputs.TeamsAccountLoggingSettingsByRuleTypeHttp>;
    /**
     * Logging configuration for layer 4 requests.
     */
    l4: pulumi.Input<inputs.TeamsAccountLoggingSettingsByRuleTypeL4>;
}

export interface TeamsAccountLoggingSettingsByRuleTypeDns {
    /**
     * Whether to log all activity.
     */
    logAll: pulumi.Input<boolean>;
    logBlocks: pulumi.Input<boolean>;
}

export interface TeamsAccountLoggingSettingsByRuleTypeHttp {
    /**
     * Whether to log all activity.
     */
    logAll: pulumi.Input<boolean>;
    logBlocks: pulumi.Input<boolean>;
}

export interface TeamsAccountLoggingSettingsByRuleTypeL4 {
    /**
     * Whether to log all activity.
     */
    logAll: pulumi.Input<boolean>;
    logBlocks: pulumi.Input<boolean>;
}

export interface TeamsAccountPayloadLog {
    /**
     * Public key used to encrypt matched payloads.
     */
    publicKey: pulumi.Input<string>;
}

export interface TeamsAccountProxy {
    /**
     * Whether root ca is enabled account wide for ZT clients.
     */
    rootCa: pulumi.Input<boolean>;
    /**
     * Whether gateway proxy is enabled on gateway devices for TCP traffic.
     */
    tcp: pulumi.Input<boolean>;
    /**
     * Whether gateway proxy is enabled on gateway devices for UDP traffic.
     */
    udp: pulumi.Input<boolean>;
}

export interface TeamsAccountSshSessionLog {
    /**
     * Public key used to encrypt ssh session.
     */
    publicKey: pulumi.Input<string>;
}

export interface TeamsLocationNetwork {
    /**
     * The ID of this resource.
     */
    id?: pulumi.Input<string>;
    /**
     * CIDR notation representation of the network IP.
     */
    network: pulumi.Input<string>;
}

export interface TeamsRuleRuleSettings {
    /**
     * Add custom headers to allowed requests in the form of key-value pairs.
     */
    addHeaders?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Allow parent MSP accounts to enable bypass their children's rules.
     */
    allowChildBypass?: pulumi.Input<boolean>;
    /**
     * Settings for auditing SSH usage.
     */
    auditSsh?: pulumi.Input<inputs.TeamsRuleRuleSettingsAuditSsh>;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls?: pulumi.Input<inputs.TeamsRuleRuleSettingsBisoAdminControls>;
    /**
     * Indicator of block page enablement.
     */
    blockPageEnabled?: pulumi.Input<boolean>;
    /**
     * The displayed reason for a user being blocked.
     */
    blockPageReason?: pulumi.Input<string>;
    /**
     * Allow child MSP accounts to bypass their parent's rule.
     */
    bypassParentRule?: pulumi.Input<boolean>;
    /**
     * Configure how session check behaves.
     */
    checkSession?: pulumi.Input<inputs.TeamsRuleRuleSettingsCheckSession>;
    /**
     * Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
     */
    egress?: pulumi.Input<inputs.TeamsRuleRuleSettingsEgress>;
    /**
     * Disable DNSSEC validation (must be Allow rule).
     */
    insecureDisableDnssecValidation?: pulumi.Input<boolean>;
    /**
     * Turns on IP category based filter on dns if the rule contains dns category checks.
     */
    ipCategories?: pulumi.Input<boolean>;
    /**
     * Settings to forward layer 4 traffic.
     */
    l4override?: pulumi.Input<inputs.TeamsRuleRuleSettingsL4override>;
    /**
     * Notification settings on a block rule.
     */
    notificationSettings?: pulumi.Input<inputs.TeamsRuleRuleSettingsNotificationSettings>;
    /**
     * The host to override matching DNS queries with.
     */
    overrideHost?: pulumi.Input<string>;
    /**
     * The IPs to override matching DNS queries with.
     */
    overrideIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Configure DLP Payload Logging settings for this rule.
     */
    payloadLog?: pulumi.Input<inputs.TeamsRuleRuleSettingsPayloadLog>;
    /**
     * Configure untrusted certificate settings for this rule.
     */
    untrustedCert?: pulumi.Input<inputs.TeamsRuleRuleSettingsUntrustedCert>;
}

export interface TeamsRuleRuleSettingsAuditSsh {
    /**
     * Log all SSH commands.
     */
    commandLogging: pulumi.Input<boolean>;
}

export interface TeamsRuleRuleSettingsBisoAdminControls {
    /**
     * Disable copy-paste.
     */
    disableCopyPaste?: pulumi.Input<boolean>;
    /**
     * Disable download.
     */
    disableDownload?: pulumi.Input<boolean>;
    /**
     * Disable keyboard usage.
     */
    disableKeyboard?: pulumi.Input<boolean>;
    /**
     * Disable printing.
     */
    disablePrinting?: pulumi.Input<boolean>;
    /**
     * Disable upload.
     */
    disableUpload?: pulumi.Input<boolean>;
}

export interface TeamsRuleRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: pulumi.Input<string>;
    /**
     * Enable session enforcement for this rule.
     */
    enforce: pulumi.Input<boolean>;
}

export interface TeamsRuleRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4: pulumi.Input<string>;
    /**
     * The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
     */
    ipv4Fallback?: pulumi.Input<string>;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6: pulumi.Input<string>;
}

export interface TeamsRuleRuleSettingsL4override {
    /**
     * Override IP to forward traffic to.
     */
    ip: pulumi.Input<string>;
    /**
     * Override Port to forward traffic to.
     */
    port: pulumi.Input<number>;
}

export interface TeamsRuleRuleSettingsNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Notification content.
     */
    message?: pulumi.Input<string>;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: pulumi.Input<string>;
}

export interface TeamsRuleRuleSettingsPayloadLog {
    /**
     * Enable notification settings.
     */
    enabled: pulumi.Input<boolean>;
}

export interface TeamsRuleRuleSettingsUntrustedCert {
    /**
     * Action to be taken when the SSL certificate of upstream is invalid. Available values: `passThrough`, `block`, `error`.
     */
    action?: pulumi.Input<string>;
}

export interface TunnelConfigConfig {
    /**
     * Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
     */
    ingressRules: pulumi.Input<pulumi.Input<inputs.TunnelConfigConfigIngressRule>[]>;
    originRequest?: pulumi.Input<inputs.TunnelConfigConfigOriginRequest>;
    /**
     * If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
     */
    warpRouting?: pulumi.Input<inputs.TunnelConfigConfigWarpRouting>;
}

export interface TunnelConfigConfigIngressRule {
    /**
     * Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
     */
    hostname?: pulumi.Input<string>;
    originRequest?: pulumi.Input<inputs.TunnelConfigConfigIngressRuleOriginRequest>;
    /**
     * Path of the incoming request. If the path matches, the request will be sent to the local service.
     */
    path?: pulumi.Input<string>;
    /**
     * Name of the service to which the request will be sent.
     */
    service: pulumi.Input<string>;
}

export interface TunnelConfigConfigIngressRuleOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: pulumi.Input<inputs.TunnelConfigConfigIngressRuleOriginRequestAccess>;
    /**
     * Runs as jump host.
     */
    bastionMode?: pulumi.Input<boolean>;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: pulumi.Input<string>;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: pulumi.Input<string>;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: pulumi.Input<boolean>;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: pulumi.Input<boolean>;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: pulumi.Input<string>;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: pulumi.Input<pulumi.Input<inputs.TunnelConfigConfigIngressRuleOriginRequestIpRule>[]>;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: pulumi.Input<number>;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: pulumi.Input<string>;
    /**
     * Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: pulumi.Input<boolean>;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: pulumi.Input<boolean>;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: pulumi.Input<string>;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: pulumi.Input<string>;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: pulumi.Input<number>;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: pulumi.Input<string>;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: pulumi.Input<string>;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: pulumi.Input<string>;
}

export interface TunnelConfigConfigIngressRuleOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether the access rule is required.
     */
    required?: pulumi.Input<boolean>;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: pulumi.Input<string>;
}

export interface TunnelConfigConfigIngressRuleOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: pulumi.Input<boolean>;
    /**
     * Ports to use within the IP rule.
     */
    ports?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * IP rule prefix.
     */
    prefix?: pulumi.Input<string>;
}

export interface TunnelConfigConfigOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: pulumi.Input<inputs.TunnelConfigConfigOriginRequestAccess>;
    /**
     * Runs as jump host.
     */
    bastionMode?: pulumi.Input<boolean>;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: pulumi.Input<string>;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: pulumi.Input<string>;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: pulumi.Input<boolean>;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: pulumi.Input<boolean>;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: pulumi.Input<string>;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: pulumi.Input<pulumi.Input<inputs.TunnelConfigConfigOriginRequestIpRule>[]>;
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: pulumi.Input<number>;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: pulumi.Input<string>;
    /**
     * Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: pulumi.Input<boolean>;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: pulumi.Input<boolean>;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: pulumi.Input<string>;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: pulumi.Input<string>;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: pulumi.Input<number>;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: pulumi.Input<string>;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: pulumi.Input<string>;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: pulumi.Input<string>;
}

export interface TunnelConfigConfigOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether the access rule is required.
     */
    required?: pulumi.Input<boolean>;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: pulumi.Input<string>;
}

export interface TunnelConfigConfigOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: pulumi.Input<boolean>;
    /**
     * Ports to use within the IP rule.
     */
    ports?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * IP rule prefix.
     */
    prefix?: pulumi.Input<string>;
}

export interface TunnelConfigConfigWarpRouting {
    /**
     * Whether WARP routing is enabled.
     */
    enabled?: pulumi.Input<boolean>;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
     */
    target: pulumi.Input<string>;
    /**
     * The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
     */
    value: pulumi.Input<string>;
}

export interface WaitingRoomAdditionalRoute {
    /**
     * The additional host name for which the waiting room to be applied on (no wildcards).
     */
    host: pulumi.Input<string>;
    /**
     * The path within the additional host to enable the waiting room on. Defaults to `/`.
     */
    path?: pulumi.Input<string>;
}

export interface WaitingRoomRulesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `bypassWaitingRoom`.
     */
    action: pulumi.Input<string>;
    /**
     * Brief summary of the waiting room rule and its intended use.
     */
    description?: pulumi.Input<string>;
    /**
     * Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
     */
    expression: pulumi.Input<string>;
    /**
     * Unique rule identifier.
     */
    id?: pulumi.Input<string>;
    /**
     * Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
     */
    status?: pulumi.Input<string>;
    /**
     * Version of the waiting room rule.
     */
    version?: pulumi.Input<string>;
}

export interface WorkerScriptAnalyticsEngineBinding {
    /**
     * The name of the Analytics Engine dataset to write to.
     */
    dataset: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
}

export interface WorkerScriptD1DatabaseBinding {
    /**
     * Database ID of D1 database to use.
     */
    databaseId: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
}

export interface WorkerScriptKvNamespaceBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
    /**
     * ID of the KV namespace you want to use.
     */
    namespaceId: pulumi.Input<string>;
}

export interface WorkerScriptPlacement {
    /**
     * The placement mode for the Worker. Available values: `smart`.
     */
    mode: pulumi.Input<string>;
}

export interface WorkerScriptPlainTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
    /**
     * The plain text you want to store.
     */
    text: pulumi.Input<string>;
}

export interface WorkerScriptQueueBinding {
    /**
     * The name of the global variable for the binding in your Worker code.
     */
    binding: pulumi.Input<string>;
    /**
     * Name of the queue you want to use.
     */
    queue: pulumi.Input<string>;
}

export interface WorkerScriptR2BucketBinding {
    /**
     * The name of the Bucket to bind to.
     */
    bucketName: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
}

export interface WorkerScriptSecretTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
    /**
     * The secret text you want to store.
     */
    text: pulumi.Input<string>;
}

export interface WorkerScriptServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
    /**
     * The name of the Worker to bind to.
     */
    service: pulumi.Input<string>;
}

export interface WorkerScriptWebassemblyBinding {
    /**
     * The base64 encoded wasm module you want to store.
     */
    module: pulumi.Input<string>;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: pulumi.Input<string>;
}

export interface ZoneLockdownConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ipRange`.
     */
    target: pulumi.Input<string>;
    /**
     * The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
     */
    value: pulumi.Input<string>;
}

export interface ZoneSettingsOverrideInitialSetting {
    alwaysOnline?: pulumi.Input<string>;
    alwaysUseHttps?: pulumi.Input<string>;
    automaticHttpsRewrites?: pulumi.Input<string>;
    binaryAst?: pulumi.Input<string>;
    brotli?: pulumi.Input<string>;
    browserCacheTtl?: pulumi.Input<number>;
    browserCheck?: pulumi.Input<string>;
    cacheLevel?: pulumi.Input<string>;
    challengeTtl?: pulumi.Input<number>;
    ciphers?: pulumi.Input<pulumi.Input<string>[]>;
    cnameFlattening?: pulumi.Input<string>;
    developmentMode?: pulumi.Input<string>;
    earlyHints?: pulumi.Input<string>;
    emailObfuscation?: pulumi.Input<string>;
    filterLogsToCloudflare?: pulumi.Input<string>;
    fonts?: pulumi.Input<string>;
    h2Prioritization?: pulumi.Input<string>;
    hotlinkProtection?: pulumi.Input<string>;
    http2?: pulumi.Input<string>;
    http3?: pulumi.Input<string>;
    imageResizing?: pulumi.Input<string>;
    ipGeolocation?: pulumi.Input<string>;
    ipv6?: pulumi.Input<string>;
    logToCloudflare?: pulumi.Input<string>;
    maxUpload?: pulumi.Input<number>;
    minTlsVersion?: pulumi.Input<string>;
    minify?: pulumi.Input<inputs.ZoneSettingsOverrideInitialSettingMinify>;
    mirage?: pulumi.Input<string>;
    mobileRedirect?: pulumi.Input<inputs.ZoneSettingsOverrideInitialSettingMobileRedirect>;
    opportunisticEncryption?: pulumi.Input<string>;
    opportunisticOnion?: pulumi.Input<string>;
    orangeToOrange?: pulumi.Input<string>;
    originErrorPagePassThru?: pulumi.Input<string>;
    originMaxHttpVersion?: pulumi.Input<string>;
    polish?: pulumi.Input<string>;
    prefetchPreload?: pulumi.Input<string>;
    privacyPass?: pulumi.Input<string>;
    proxyReadTimeout?: pulumi.Input<string>;
    pseudoIpv4?: pulumi.Input<string>;
    responseBuffering?: pulumi.Input<string>;
    rocketLoader?: pulumi.Input<string>;
    securityHeader?: pulumi.Input<inputs.ZoneSettingsOverrideInitialSettingSecurityHeader>;
    securityLevel?: pulumi.Input<string>;
    serverSideExclude?: pulumi.Input<string>;
    sortQueryStringForCache?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `min_tls_version = "1.2"` instead.
     */
    tls12Only?: pulumi.Input<string>;
    tls13?: pulumi.Input<string>;
    tlsClientAuth?: pulumi.Input<string>;
    trueClientIpHeader?: pulumi.Input<string>;
    universalSsl?: pulumi.Input<string>;
    visitorIp?: pulumi.Input<string>;
    waf?: pulumi.Input<string>;
    webp?: pulumi.Input<string>;
    websockets?: pulumi.Input<string>;
    zeroRtt?: pulumi.Input<string>;
}

export interface ZoneSettingsOverrideInitialSettingMinify {
    css: pulumi.Input<string>;
    html: pulumi.Input<string>;
    js: pulumi.Input<string>;
}

export interface ZoneSettingsOverrideInitialSettingMobileRedirect {
    mobileSubdomain: pulumi.Input<string>;
    status: pulumi.Input<string>;
    stripUri: pulumi.Input<boolean>;
}

export interface ZoneSettingsOverrideInitialSettingSecurityHeader {
    enabled?: pulumi.Input<boolean>;
    includeSubdomains?: pulumi.Input<boolean>;
    maxAge?: pulumi.Input<number>;
    nosniff?: pulumi.Input<boolean>;
    preload?: pulumi.Input<boolean>;
}

export interface ZoneSettingsOverrideSettings {
    alwaysOnline?: pulumi.Input<string>;
    alwaysUseHttps?: pulumi.Input<string>;
    automaticHttpsRewrites?: pulumi.Input<string>;
    binaryAst?: pulumi.Input<string>;
    brotli?: pulumi.Input<string>;
    browserCacheTtl?: pulumi.Input<number>;
    browserCheck?: pulumi.Input<string>;
    cacheLevel?: pulumi.Input<string>;
    challengeTtl?: pulumi.Input<number>;
    ciphers?: pulumi.Input<pulumi.Input<string>[]>;
    cnameFlattening?: pulumi.Input<string>;
    developmentMode?: pulumi.Input<string>;
    earlyHints?: pulumi.Input<string>;
    emailObfuscation?: pulumi.Input<string>;
    filterLogsToCloudflare?: pulumi.Input<string>;
    fonts?: pulumi.Input<string>;
    h2Prioritization?: pulumi.Input<string>;
    hotlinkProtection?: pulumi.Input<string>;
    http2?: pulumi.Input<string>;
    http3?: pulumi.Input<string>;
    imageResizing?: pulumi.Input<string>;
    ipGeolocation?: pulumi.Input<string>;
    ipv6?: pulumi.Input<string>;
    logToCloudflare?: pulumi.Input<string>;
    maxUpload?: pulumi.Input<number>;
    minTlsVersion?: pulumi.Input<string>;
    minify?: pulumi.Input<inputs.ZoneSettingsOverrideSettingsMinify>;
    mirage?: pulumi.Input<string>;
    mobileRedirect?: pulumi.Input<inputs.ZoneSettingsOverrideSettingsMobileRedirect>;
    opportunisticEncryption?: pulumi.Input<string>;
    opportunisticOnion?: pulumi.Input<string>;
    orangeToOrange?: pulumi.Input<string>;
    originErrorPagePassThru?: pulumi.Input<string>;
    originMaxHttpVersion?: pulumi.Input<string>;
    polish?: pulumi.Input<string>;
    prefetchPreload?: pulumi.Input<string>;
    privacyPass?: pulumi.Input<string>;
    proxyReadTimeout?: pulumi.Input<string>;
    pseudoIpv4?: pulumi.Input<string>;
    responseBuffering?: pulumi.Input<string>;
    rocketLoader?: pulumi.Input<string>;
    securityHeader?: pulumi.Input<inputs.ZoneSettingsOverrideSettingsSecurityHeader>;
    securityLevel?: pulumi.Input<string>;
    serverSideExclude?: pulumi.Input<string>;
    sortQueryStringForCache?: pulumi.Input<string>;
    ssl?: pulumi.Input<string>;
    /**
     * @deprecated tls_1_2_only has been deprecated in favour of using `min_tls_version = "1.2"` instead.
     */
    tls12Only?: pulumi.Input<string>;
    tls13?: pulumi.Input<string>;
    tlsClientAuth?: pulumi.Input<string>;
    trueClientIpHeader?: pulumi.Input<string>;
    universalSsl?: pulumi.Input<string>;
    visitorIp?: pulumi.Input<string>;
    waf?: pulumi.Input<string>;
    webp?: pulumi.Input<string>;
    websockets?: pulumi.Input<string>;
    zeroRtt?: pulumi.Input<string>;
}

export interface ZoneSettingsOverrideSettingsMinify {
    css: pulumi.Input<string>;
    html: pulumi.Input<string>;
    js: pulumi.Input<string>;
}

export interface ZoneSettingsOverrideSettingsMobileRedirect {
    mobileSubdomain: pulumi.Input<string>;
    status: pulumi.Input<string>;
    stripUri: pulumi.Input<boolean>;
}

export interface ZoneSettingsOverrideSettingsSecurityHeader {
    enabled?: pulumi.Input<boolean>;
    includeSubdomains?: pulumi.Input<boolean>;
    maxAge?: pulumi.Input<number>;
    nosniff?: pulumi.Input<boolean>;
    preload?: pulumi.Input<boolean>;
}
