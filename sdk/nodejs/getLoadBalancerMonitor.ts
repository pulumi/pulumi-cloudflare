// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleLoadBalancerMonitor = cloudflare.getLoadBalancerMonitor({
 *     accountId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     monitorId: "f1aba936b94213e5b8dca0c0dbf1f9cc",
 * });
 * ```
 */
export function getLoadBalancerMonitor(args: GetLoadBalancerMonitorArgs, opts?: pulumi.InvokeOptions): Promise<GetLoadBalancerMonitorResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("cloudflare:index/getLoadBalancerMonitor:getLoadBalancerMonitor", {
        "accountId": args.accountId,
        "monitorId": args.monitorId,
    }, opts);
}

/**
 * A collection of arguments for invoking getLoadBalancerMonitor.
 */
export interface GetLoadBalancerMonitorArgs {
    /**
     * Identifier
     */
    accountId: string;
    monitorId?: string;
}

/**
 * A collection of values returned by getLoadBalancerMonitor.
 */
export interface GetLoadBalancerMonitorResult {
    /**
     * Identifier
     */
    readonly accountId: string;
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     */
    readonly allowInsecure: boolean;
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     */
    readonly consecutiveDown: number;
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     */
    readonly consecutiveUp: number;
    readonly createdOn: string;
    /**
     * Object description.
     */
    readonly description: string;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     */
    readonly expectedBody: string;
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     */
    readonly expectedCodes: string;
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     */
    readonly followRedirects: boolean;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     */
    readonly header: {[key: string]: string[]};
    /**
     * The ID of this resource.
     */
    readonly id: string;
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     */
    readonly interval: number;
    /**
     * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
     */
    readonly method: string;
    readonly modifiedOn: string;
    readonly monitorId?: string;
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     */
    readonly path: string;
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     */
    readonly port: number;
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     */
    readonly probeZone: string;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    readonly retries: number;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    readonly timeout: number;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
     */
    readonly type: string;
}
/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleLoadBalancerMonitor = cloudflare.getLoadBalancerMonitor({
 *     accountId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     monitorId: "f1aba936b94213e5b8dca0c0dbf1f9cc",
 * });
 * ```
 */
export function getLoadBalancerMonitorOutput(args: GetLoadBalancerMonitorOutputArgs, opts?: pulumi.InvokeOutputOptions): pulumi.Output<GetLoadBalancerMonitorResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invokeOutput("cloudflare:index/getLoadBalancerMonitor:getLoadBalancerMonitor", {
        "accountId": args.accountId,
        "monitorId": args.monitorId,
    }, opts);
}

/**
 * A collection of arguments for invoking getLoadBalancerMonitor.
 */
export interface GetLoadBalancerMonitorOutputArgs {
    /**
     * Identifier
     */
    accountId: pulumi.Input<string>;
    monitorId?: pulumi.Input<string>;
}
