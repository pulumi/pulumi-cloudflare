// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleWaitingRoomEvent = new cloudflare.WaitingRoomEvent("example_waiting_room_event", {
 *     zoneId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     waitingRoomId: "699d98642c564d2e855e9661899b7252",
 *     eventEndTime: "2021-09-28T17:00:00.000Z",
 *     eventStartTime: "2021-09-28T15:30:00.000Z",
 *     name: "production_webinar_event",
 *     customPageHtml: "{{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Event is prequeueing / Queue all enabled {{/waitTimeKnown}}",
 *     description: "Production event - DO NOT MODIFY",
 *     disableSessionRenewal: true,
 *     newUsersPerMinute: 200,
 *     prequeueStartTime: "2021-09-28T15:00:00.000Z",
 *     queueingMethod: "random",
 *     sessionDuration: 1,
 *     shuffleAtEventStart: true,
 *     suspended: true,
 *     totalActiveUsers: 200,
 *     turnstileAction: "log",
 *     turnstileMode: "off",
 * });
 * ```
 *
 * ## Import
 *
 * ```sh
 * $ pulumi import cloudflare:index/waitingRoomEvent:WaitingRoomEvent example '<zone_id>/<waiting_room_id>/<event_id>'
 * ```
 */
export class WaitingRoomEvent extends pulumi.CustomResource {
    /**
     * Get an existing WaitingRoomEvent resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: WaitingRoomEventState, opts?: pulumi.CustomResourceOptions): WaitingRoomEvent {
        return new WaitingRoomEvent(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'cloudflare:index/waitingRoomEvent:WaitingRoomEvent';

    /**
     * Returns true if the given object is an instance of WaitingRoomEvent.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is WaitingRoomEvent {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === WaitingRoomEvent.__pulumiType;
    }

    public /*out*/ readonly createdOn!: pulumi.Output<string>;
    /**
     * If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
     */
    public readonly customPageHtml!: pulumi.Output<string | undefined>;
    /**
     * A note that you can use to add more details about the event.
     */
    public readonly description!: pulumi.Output<string>;
    /**
     * If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
     */
    public readonly disableSessionRenewal!: pulumi.Output<boolean | undefined>;
    /**
     * An ISO 8601 timestamp that marks the end of the event.
     */
    public readonly eventEndTime!: pulumi.Output<string>;
    /**
     * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
     */
    public readonly eventStartTime!: pulumi.Output<string>;
    public /*out*/ readonly modifiedOn!: pulumi.Output<string>;
    /**
     * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
     */
    public readonly newUsersPerMinute!: pulumi.Output<number | undefined>;
    /**
     * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
     */
    public readonly prequeueStartTime!: pulumi.Output<string | undefined>;
    /**
     * If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
     */
    public readonly queueingMethod!: pulumi.Output<string | undefined>;
    /**
     * If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
     */
    public readonly sessionDuration!: pulumi.Output<number | undefined>;
    /**
     * If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     */
    public readonly shuffleAtEventStart!: pulumi.Output<boolean>;
    /**
     * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     */
    public readonly suspended!: pulumi.Output<boolean>;
    /**
     * If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
     */
    public readonly totalActiveUsers!: pulumi.Output<number | undefined>;
    /**
     * If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
     * Available values: "log", "infiniteQueue".
     */
    public readonly turnstileAction!: pulumi.Output<string | undefined>;
    /**
     * If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
     * Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
     */
    public readonly turnstileMode!: pulumi.Output<string | undefined>;
    public readonly waitingRoomId!: pulumi.Output<string>;
    /**
     * Identifier.
     */
    public readonly zoneId!: pulumi.Output<string>;

    /**
     * Create a WaitingRoomEvent resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: WaitingRoomEventArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: WaitingRoomEventArgs | WaitingRoomEventState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as WaitingRoomEventState | undefined;
            resourceInputs["createdOn"] = state ? state.createdOn : undefined;
            resourceInputs["customPageHtml"] = state ? state.customPageHtml : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["disableSessionRenewal"] = state ? state.disableSessionRenewal : undefined;
            resourceInputs["eventEndTime"] = state ? state.eventEndTime : undefined;
            resourceInputs["eventStartTime"] = state ? state.eventStartTime : undefined;
            resourceInputs["modifiedOn"] = state ? state.modifiedOn : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["newUsersPerMinute"] = state ? state.newUsersPerMinute : undefined;
            resourceInputs["prequeueStartTime"] = state ? state.prequeueStartTime : undefined;
            resourceInputs["queueingMethod"] = state ? state.queueingMethod : undefined;
            resourceInputs["sessionDuration"] = state ? state.sessionDuration : undefined;
            resourceInputs["shuffleAtEventStart"] = state ? state.shuffleAtEventStart : undefined;
            resourceInputs["suspended"] = state ? state.suspended : undefined;
            resourceInputs["totalActiveUsers"] = state ? state.totalActiveUsers : undefined;
            resourceInputs["turnstileAction"] = state ? state.turnstileAction : undefined;
            resourceInputs["turnstileMode"] = state ? state.turnstileMode : undefined;
            resourceInputs["waitingRoomId"] = state ? state.waitingRoomId : undefined;
            resourceInputs["zoneId"] = state ? state.zoneId : undefined;
        } else {
            const args = argsOrState as WaitingRoomEventArgs | undefined;
            if ((!args || args.eventEndTime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'eventEndTime'");
            }
            if ((!args || args.eventStartTime === undefined) && !opts.urn) {
                throw new Error("Missing required property 'eventStartTime'");
            }
            if ((!args || args.name === undefined) && !opts.urn) {
                throw new Error("Missing required property 'name'");
            }
            if ((!args || args.waitingRoomId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'waitingRoomId'");
            }
            if ((!args || args.zoneId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'zoneId'");
            }
            resourceInputs["customPageHtml"] = args ? args.customPageHtml : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["disableSessionRenewal"] = args ? args.disableSessionRenewal : undefined;
            resourceInputs["eventEndTime"] = args ? args.eventEndTime : undefined;
            resourceInputs["eventStartTime"] = args ? args.eventStartTime : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["newUsersPerMinute"] = args ? args.newUsersPerMinute : undefined;
            resourceInputs["prequeueStartTime"] = args ? args.prequeueStartTime : undefined;
            resourceInputs["queueingMethod"] = args ? args.queueingMethod : undefined;
            resourceInputs["sessionDuration"] = args ? args.sessionDuration : undefined;
            resourceInputs["shuffleAtEventStart"] = args ? args.shuffleAtEventStart : undefined;
            resourceInputs["suspended"] = args ? args.suspended : undefined;
            resourceInputs["totalActiveUsers"] = args ? args.totalActiveUsers : undefined;
            resourceInputs["turnstileAction"] = args ? args.turnstileAction : undefined;
            resourceInputs["turnstileMode"] = args ? args.turnstileMode : undefined;
            resourceInputs["waitingRoomId"] = args ? args.waitingRoomId : undefined;
            resourceInputs["zoneId"] = args ? args.zoneId : undefined;
            resourceInputs["createdOn"] = undefined /*out*/;
            resourceInputs["modifiedOn"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(WaitingRoomEvent.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering WaitingRoomEvent resources.
 */
export interface WaitingRoomEventState {
    createdOn?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
     */
    customPageHtml?: pulumi.Input<string>;
    /**
     * A note that you can use to add more details about the event.
     */
    description?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
     */
    disableSessionRenewal?: pulumi.Input<boolean>;
    /**
     * An ISO 8601 timestamp that marks the end of the event.
     */
    eventEndTime?: pulumi.Input<string>;
    /**
     * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
     */
    eventStartTime?: pulumi.Input<string>;
    modifiedOn?: pulumi.Input<string>;
    /**
     * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
     */
    newUsersPerMinute?: pulumi.Input<number>;
    /**
     * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
     */
    prequeueStartTime?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
     */
    queueingMethod?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
     */
    sessionDuration?: pulumi.Input<number>;
    /**
     * If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     */
    shuffleAtEventStart?: pulumi.Input<boolean>;
    /**
     * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     */
    suspended?: pulumi.Input<boolean>;
    /**
     * If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
     */
    totalActiveUsers?: pulumi.Input<number>;
    /**
     * If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
     * Available values: "log", "infiniteQueue".
     */
    turnstileAction?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
     * Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
     */
    turnstileMode?: pulumi.Input<string>;
    waitingRoomId?: pulumi.Input<string>;
    /**
     * Identifier.
     */
    zoneId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a WaitingRoomEvent resource.
 */
export interface WaitingRoomEventArgs {
    /**
     * If set, the event will override the waiting room's `customPageHtml` property while it is active. If null, the event will inherit it.
     */
    customPageHtml?: pulumi.Input<string>;
    /**
     * A note that you can use to add more details about the event.
     */
    description?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `disableSessionRenewal` property while it is active. If null, the event will inherit it.
     */
    disableSessionRenewal?: pulumi.Input<boolean>;
    /**
     * An ISO 8601 timestamp that marks the end of the event.
     */
    eventEndTime: pulumi.Input<string>;
    /**
     * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `eventEndTime`.
     */
    eventStartTime: pulumi.Input<string>;
    /**
     * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
     */
    name: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `newUsersPerMinute` property while it is active. If null, the event will inherit it. This can only be set if the event's `totalActiveUsers` property is also set.
     */
    newUsersPerMinute?: pulumi.Input<number>;
    /**
     * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `eventStartTime`.
     */
    prequeueStartTime?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `queueingMethod` property while it is active. If null, the event will inherit it.
     */
    queueingMethod?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `sessionDuration` property while it is active. If null, the event will inherit it.
     */
    sessionDuration?: pulumi.Input<number>;
    /**
     * If enabled, users in the prequeue will be shuffled randomly at the `eventStartTime`. Requires that `prequeueStartTime` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueingMethod` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
     */
    shuffleAtEventStart?: pulumi.Input<boolean>;
    /**
     * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
     */
    suspended?: pulumi.Input<boolean>;
    /**
     * If set, the event will override the waiting room's `totalActiveUsers` property while it is active. If null, the event will inherit it. This can only be set if the event's `newUsersPerMinute` property is also set.
     */
    totalActiveUsers?: pulumi.Input<number>;
    /**
     * If set, the event will override the waiting room's `turnstileAction` property while it is active. If null, the event will inherit it.
     * Available values: "log", "infiniteQueue".
     */
    turnstileAction?: pulumi.Input<string>;
    /**
     * If set, the event will override the waiting room's `turnstileMode` property while it is active. If null, the event will inherit it.
     * Available values: "off", "invisible", "visible*non*interactive", "visibleManaged".
     */
    turnstileMode?: pulumi.Input<string>;
    waitingRoomId: pulumi.Input<string>;
    /**
     * Identifier.
     */
    zoneId: pulumi.Input<string>;
}
