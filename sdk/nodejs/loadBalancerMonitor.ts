// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleLoadBalancerMonitor = new cloudflare.LoadBalancerMonitor("example_load_balancer_monitor", {
 *     accountId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     allowInsecure: true,
 *     consecutiveDown: 0,
 *     consecutiveUp: 0,
 *     description: "Login page monitor",
 *     expectedBody: "alive",
 *     expectedCodes: "2xx",
 *     followRedirects: true,
 *     header: {
 *         Host: ["example.com"],
 *         "X-App-ID": ["abc123"],
 *     },
 *     interval: 0,
 *     method: "GET",
 *     path: "/health",
 *     port: 0,
 *     probeZone: "example.com",
 *     retries: 0,
 *     timeout: 0,
 *     type: "https",
 * });
 * ```
 *
 * ## Import
 *
 * ```sh
 * $ pulumi import cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor example '<account_id>/<monitor_id>'
 * ```
 */
export class LoadBalancerMonitor extends pulumi.CustomResource {
    /**
     * Get an existing LoadBalancerMonitor resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: LoadBalancerMonitorState, opts?: pulumi.CustomResourceOptions): LoadBalancerMonitor {
        return new LoadBalancerMonitor(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor';

    /**
     * Returns true if the given object is an instance of LoadBalancerMonitor.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is LoadBalancerMonitor {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === LoadBalancerMonitor.__pulumiType;
    }

    /**
     * Identifier.
     */
    declare public readonly accountId: pulumi.Output<string>;
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     */
    declare public readonly allowInsecure: pulumi.Output<boolean>;
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     */
    declare public readonly consecutiveDown: pulumi.Output<number | undefined>;
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     */
    declare public readonly consecutiveUp: pulumi.Output<number | undefined>;
    declare public /*out*/ readonly createdOn: pulumi.Output<string>;
    /**
     * Object description.
     */
    declare public readonly description: pulumi.Output<string>;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     */
    declare public readonly expectedBody: pulumi.Output<string>;
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     */
    declare public readonly expectedCodes: pulumi.Output<string>;
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     */
    declare public readonly followRedirects: pulumi.Output<boolean>;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     */
    declare public readonly header: pulumi.Output<{[key: string]: string[]} | undefined>;
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     */
    declare public readonly interval: pulumi.Output<number>;
    /**
     * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
     */
    declare public readonly method: pulumi.Output<string>;
    declare public /*out*/ readonly modifiedOn: pulumi.Output<string>;
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     */
    declare public readonly path: pulumi.Output<string>;
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     */
    declare public readonly port: pulumi.Output<number | undefined>;
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     */
    declare public readonly probeZone: pulumi.Output<string>;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    declare public readonly retries: pulumi.Output<number>;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    declare public readonly timeout: pulumi.Output<number>;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
     * Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
     */
    declare public readonly type: pulumi.Output<string>;

    /**
     * Create a LoadBalancerMonitor resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: LoadBalancerMonitorArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: LoadBalancerMonitorArgs | LoadBalancerMonitorState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as LoadBalancerMonitorState | undefined;
            resourceInputs["accountId"] = state?.accountId;
            resourceInputs["allowInsecure"] = state?.allowInsecure;
            resourceInputs["consecutiveDown"] = state?.consecutiveDown;
            resourceInputs["consecutiveUp"] = state?.consecutiveUp;
            resourceInputs["createdOn"] = state?.createdOn;
            resourceInputs["description"] = state?.description;
            resourceInputs["expectedBody"] = state?.expectedBody;
            resourceInputs["expectedCodes"] = state?.expectedCodes;
            resourceInputs["followRedirects"] = state?.followRedirects;
            resourceInputs["header"] = state?.header;
            resourceInputs["interval"] = state?.interval;
            resourceInputs["method"] = state?.method;
            resourceInputs["modifiedOn"] = state?.modifiedOn;
            resourceInputs["path"] = state?.path;
            resourceInputs["port"] = state?.port;
            resourceInputs["probeZone"] = state?.probeZone;
            resourceInputs["retries"] = state?.retries;
            resourceInputs["timeout"] = state?.timeout;
            resourceInputs["type"] = state?.type;
        } else {
            const args = argsOrState as LoadBalancerMonitorArgs | undefined;
            if (args?.accountId === undefined && !opts.urn) {
                throw new Error("Missing required property 'accountId'");
            }
            resourceInputs["accountId"] = args?.accountId;
            resourceInputs["allowInsecure"] = args?.allowInsecure;
            resourceInputs["consecutiveDown"] = args?.consecutiveDown;
            resourceInputs["consecutiveUp"] = args?.consecutiveUp;
            resourceInputs["description"] = args?.description;
            resourceInputs["expectedBody"] = args?.expectedBody;
            resourceInputs["expectedCodes"] = args?.expectedCodes;
            resourceInputs["followRedirects"] = args?.followRedirects;
            resourceInputs["header"] = args?.header;
            resourceInputs["interval"] = args?.interval;
            resourceInputs["method"] = args?.method;
            resourceInputs["path"] = args?.path;
            resourceInputs["port"] = args?.port;
            resourceInputs["probeZone"] = args?.probeZone;
            resourceInputs["retries"] = args?.retries;
            resourceInputs["timeout"] = args?.timeout;
            resourceInputs["type"] = args?.type;
            resourceInputs["createdOn"] = undefined /*out*/;
            resourceInputs["modifiedOn"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(LoadBalancerMonitor.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering LoadBalancerMonitor resources.
 */
export interface LoadBalancerMonitorState {
    /**
     * Identifier.
     */
    accountId?: pulumi.Input<string>;
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     */
    allowInsecure?: pulumi.Input<boolean>;
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     */
    consecutiveDown?: pulumi.Input<number>;
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     */
    consecutiveUp?: pulumi.Input<number>;
    createdOn?: pulumi.Input<string>;
    /**
     * Object description.
     */
    description?: pulumi.Input<string>;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedBody?: pulumi.Input<string>;
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedCodes?: pulumi.Input<string>;
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     */
    header?: pulumi.Input<{[key: string]: pulumi.Input<pulumi.Input<string>[]>}>;
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     */
    interval?: pulumi.Input<number>;
    /**
     * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
     */
    method?: pulumi.Input<string>;
    modifiedOn?: pulumi.Input<string>;
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     */
    path?: pulumi.Input<string>;
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     */
    port?: pulumi.Input<number>;
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     */
    probeZone?: pulumi.Input<string>;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    retries?: pulumi.Input<number>;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    timeout?: pulumi.Input<number>;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
     * Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
     */
    type?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a LoadBalancerMonitor resource.
 */
export interface LoadBalancerMonitorArgs {
    /**
     * Identifier.
     */
    accountId: pulumi.Input<string>;
    /**
     * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
     */
    allowInsecure?: pulumi.Input<boolean>;
    /**
     * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
     */
    consecutiveDown?: pulumi.Input<number>;
    /**
     * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
     */
    consecutiveUp?: pulumi.Input<number>;
    /**
     * Object description.
     */
    description?: pulumi.Input<string>;
    /**
     * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedBody?: pulumi.Input<string>;
    /**
     * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
     */
    expectedCodes?: pulumi.Input<string>;
    /**
     * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
     */
    header?: pulumi.Input<{[key: string]: pulumi.Input<pulumi.Input<string>[]>}>;
    /**
     * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
     */
    interval?: pulumi.Input<number>;
    /**
     * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
     */
    method?: pulumi.Input<string>;
    /**
     * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
     */
    path?: pulumi.Input<string>;
    /**
     * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
     */
    port?: pulumi.Input<number>;
    /**
     * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
     */
    probeZone?: pulumi.Input<string>;
    /**
     * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
     */
    retries?: pulumi.Input<number>;
    /**
     * The timeout (in seconds) before marking the health check as failed.
     */
    timeout?: pulumi.Input<number>;
    /**
     * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
     * Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
     */
    type?: pulumi.Input<string>;
}
