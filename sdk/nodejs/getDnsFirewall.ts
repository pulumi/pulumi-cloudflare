// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleDnsFirewall = cloudflare.getDnsFirewall({
 *     accountId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     dnsFirewallId: "023e105f4ecef8ad9ca31a8372d0c353",
 * });
 * ```
 */
export function getDnsFirewall(args: GetDnsFirewallArgs, opts?: pulumi.InvokeOptions): Promise<GetDnsFirewallResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("cloudflare:index/getDnsFirewall:getDnsFirewall", {
        "accountId": args.accountId,
        "dnsFirewallId": args.dnsFirewallId,
    }, opts);
}

/**
 * A collection of arguments for invoking getDnsFirewall.
 */
export interface GetDnsFirewallArgs {
    /**
     * Identifier.
     */
    accountId: string;
    /**
     * Identifier.
     */
    dnsFirewallId?: string;
}

/**
 * A collection of values returned by getDnsFirewall.
 */
export interface GetDnsFirewallResult {
    /**
     * Identifier.
     */
    readonly accountId: string;
    /**
     * Attack mitigation settings
     */
    readonly attackMitigation: outputs.GetDnsFirewallAttackMitigation;
    /**
     * Whether to refuse to answer queries for the ANY type
     */
    readonly deprecateAnyRequests: boolean;
    /**
     * Identifier.
     */
    readonly dnsFirewallId?: string;
    readonly dnsFirewallIps: string[];
    /**
     * Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
     */
    readonly ecsFallback: boolean;
    /**
     * Identifier.
     */
    readonly id: string;
    /**
     * By default, Cloudflare attempts to cache responses for as long as
     * indicated by the TTL received from upstream nameservers. This setting
     * sets an upper bound on this duration. For caching purposes, higher TTLs
     * will be decreased to the maximum value defined by this setting.
     */
    readonly maximumCacheTtl: number;
    readonly minimumCacheTtl: number;
    readonly modifiedOn: string;
    readonly name: string;
    readonly negativeCacheTtl: number;
    readonly ratelimit: number;
    readonly retries: number;
    readonly upstreamIps: string[];
}
/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleDnsFirewall = cloudflare.getDnsFirewall({
 *     accountId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     dnsFirewallId: "023e105f4ecef8ad9ca31a8372d0c353",
 * });
 * ```
 */
export function getDnsFirewallOutput(args: GetDnsFirewallOutputArgs, opts?: pulumi.InvokeOutputOptions): pulumi.Output<GetDnsFirewallResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invokeOutput("cloudflare:index/getDnsFirewall:getDnsFirewall", {
        "accountId": args.accountId,
        "dnsFirewallId": args.dnsFirewallId,
    }, opts);
}

/**
 * A collection of arguments for invoking getDnsFirewall.
 */
export interface GetDnsFirewallOutputArgs {
    /**
     * Identifier.
     */
    accountId: pulumi.Input<string>;
    /**
     * Identifier.
     */
    dnsFirewallId?: pulumi.Input<string>;
}
