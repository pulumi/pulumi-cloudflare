// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleCustomSsl = cloudflare.getCustomSsl({
 *     zoneId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     customCertificateId: "023e105f4ecef8ad9ca31a8372d0c353",
 * });
 * ```
 */
export function getCustomSsl(args: GetCustomSslArgs, opts?: pulumi.InvokeOptions): Promise<GetCustomSslResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("cloudflare:index/getCustomSsl:getCustomSsl", {
        "customCertificateId": args.customCertificateId,
        "filter": args.filter,
        "zoneId": args.zoneId,
    }, opts);
}

/**
 * A collection of arguments for invoking getCustomSsl.
 */
export interface GetCustomSslArgs {
    /**
     * Identifier
     */
    customCertificateId?: string;
    filter?: inputs.GetCustomSslFilter;
    /**
     * Identifier
     */
    zoneId: string;
}

/**
 * A collection of values returned by getCustomSsl.
 */
export interface GetCustomSslResult {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
     * Available values: "ubiquitous", "optimal", "force".
     */
    readonly bundleMethod: string;
    /**
     * Identifier
     */
    readonly customCertificateId?: string;
    /**
     * When the certificate from the authority expires.
     */
    readonly expiresOn: string;
    readonly filter?: outputs.GetCustomSslFilter;
    /**
     * Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
     */
    readonly geoRestrictions: outputs.GetCustomSslGeoRestrictions;
    readonly hosts: string[];
    /**
     * Identifier
     */
    readonly id: string;
    /**
     * The certificate authority that issued the certificate.
     */
    readonly issuer: string;
    readonly keylessServer: outputs.GetCustomSslKeylessServer;
    /**
     * When the certificate was last modified.
     */
    readonly modifiedOn: string;
    /**
     * Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO*3166-1*alpha-2#Officially*assigned*code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
     */
    readonly policy: string;
    /**
     * The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy*custom' certificates, but 'legacy*custom' certificates will always supercede 'sni_custom' certificates.
     */
    readonly priority: number;
    /**
     * The type of hash used for the certificate.
     */
    readonly signature: string;
    /**
     * Status of the zone's custom SSL.
     * Available values: "active", "expired", "deleted", "pending", "initializing".
     */
    readonly status: string;
    /**
     * When the certificate was uploaded to Cloudflare.
     */
    readonly uploadedOn: string;
    /**
     * Identifier
     */
    readonly zoneId: string;
}
/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 *
 * const exampleCustomSsl = cloudflare.getCustomSsl({
 *     zoneId: "023e105f4ecef8ad9ca31a8372d0c353",
 *     customCertificateId: "023e105f4ecef8ad9ca31a8372d0c353",
 * });
 * ```
 */
export function getCustomSslOutput(args: GetCustomSslOutputArgs, opts?: pulumi.InvokeOutputOptions): pulumi.Output<GetCustomSslResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invokeOutput("cloudflare:index/getCustomSsl:getCustomSsl", {
        "customCertificateId": args.customCertificateId,
        "filter": args.filter,
        "zoneId": args.zoneId,
    }, opts);
}

/**
 * A collection of arguments for invoking getCustomSsl.
 */
export interface GetCustomSslOutputArgs {
    /**
     * Identifier
     */
    customCertificateId?: pulumi.Input<string>;
    filter?: pulumi.Input<inputs.GetCustomSslFilterArgs>;
    /**
     * Identifier
     */
    zoneId: pulumi.Input<string>;
}
