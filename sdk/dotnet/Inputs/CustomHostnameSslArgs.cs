// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare.Inputs
{

    public sealed class CustomHostnameSslArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        /// Available values: "ubiquitous", "optimal", "force".
        /// </summary>
        [Input("bundleMethod")]
        public Input<string>? BundleMethod { get; set; }

        /// <summary>
        /// The Certificate Authority that will issue the certificate
        /// Available values: "digicert", "google", "lets*encrypt", "ssl*com".
        /// </summary>
        [Input("certificateAuthority")]
        public Input<string>? CertificateAuthority { get; set; }

        /// <summary>
        /// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        /// </summary>
        [Input("cloudflareBranding")]
        public Input<bool>? CloudflareBranding { get; set; }

        [Input("customCertBundles")]
        private InputList<Inputs.CustomHostnameSslCustomCertBundleArgs>? _customCertBundles;

        /// <summary>
        /// Array of custom certificate and key pairs (1 or 2 pairs allowed)
        /// </summary>
        public InputList<Inputs.CustomHostnameSslCustomCertBundleArgs> CustomCertBundles
        {
            get => _customCertBundles ?? (_customCertBundles = new InputList<Inputs.CustomHostnameSslCustomCertBundleArgs>());
            set => _customCertBundles = value;
        }

        /// <summary>
        /// If a custom uploaded certificate is used.
        /// </summary>
        [Input("customCertificate")]
        public Input<string>? CustomCertificate { get; set; }

        [Input("customKey")]
        private Input<string>? _customKey;

        /// <summary>
        /// The key for a custom uploaded certificate.
        /// </summary>
        public Input<string>? CustomKey
        {
            get => _customKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _customKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Domain control validation (DCV) method used for this hostname.
        /// Available values: "http", "txt", "email".
        /// </summary>
        [Input("method")]
        public Input<string>? Method { get; set; }

        /// <summary>
        /// SSL specific settings.
        /// </summary>
        [Input("settings")]
        public Input<Inputs.CustomHostnameSslSettingsArgs>? Settings { get; set; }

        /// <summary>
        /// Level of validation to be used for this hostname. Domain validation (dv) must be used.
        /// Available values: "dv".
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Indicates whether the certificate covers a wildcard.
        /// </summary>
        [Input("wildcard")]
        public Input<bool>? Wildcard { get; set; }

        public CustomHostnameSslArgs()
        {
        }
        public static new CustomHostnameSslArgs Empty => new CustomHostnameSslArgs();
    }
}
