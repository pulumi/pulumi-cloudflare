// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare.Inputs
{

    public sealed class CustomHostnameSslArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        /// </summary>
        [Input("bundleMethod")]
        public Input<string>? BundleMethod { get; set; }

        /// <summary>
        /// The Certificate Authority that will issue the certificate
        /// </summary>
        [Input("certificateAuthority")]
        public Input<string>? CertificateAuthority { get; set; }

        /// <summary>
        /// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        /// </summary>
        [Input("cloudflareBranding")]
        public Input<bool>? CloudflareBranding { get; set; }

        [Input("customCertBundles")]
        private InputList<Inputs.CustomHostnameSslCustomCertBundleArgs>? _customCertBundles;

        /// <summary>
        /// Array of custom certificate and key pairs (1 or 2 pairs allowed)
        /// </summary>
        public InputList<Inputs.CustomHostnameSslCustomCertBundleArgs> CustomCertBundles
        {
            get => _customCertBundles ?? (_customCertBundles = new InputList<Inputs.CustomHostnameSslCustomCertBundleArgs>());
            set => _customCertBundles = value;
        }

        /// <summary>
        /// If a custom uploaded certificate is used.
        /// </summary>
        [Input("customCertificate")]
        public Input<string>? CustomCertificate { get; set; }

        /// <summary>
        /// The key for a custom uploaded certificate.
        /// </summary>
        [Input("customKey")]
        public Input<string>? CustomKey { get; set; }

        /// <summary>
        /// Domain control validation (DCV) method used for this hostname.
        /// </summary>
        [Input("method")]
        public Input<string>? Method { get; set; }

        /// <summary>
        /// SSL specific settings.
        /// </summary>
        [Input("settings")]
        public Input<Inputs.CustomHostnameSslSettingsArgs>? Settings { get; set; }

        /// <summary>
        /// Level of validation to be used for this hostname. Domain validation (dv) must be used.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Indicates whether the certificate covers a wildcard.
        /// </summary>
        [Input("wildcard")]
        public Input<bool>? Wildcard { get; set; }

        public CustomHostnameSslArgs()
        {
        }
        public static new CustomHostnameSslArgs Empty => new CustomHostnameSslArgs();
    }
}
