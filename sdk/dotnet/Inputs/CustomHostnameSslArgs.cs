// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare.Inputs
{

    public sealed class CustomHostnameSslArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        /// </summary>
        [Input("bundleMethod")]
        public Input<string>? BundleMethod { get; set; }

        [Input("certificateAuthority")]
        public Input<string>? CertificateAuthority { get; set; }

        /// <summary>
        /// If a custom uploaded certificate is used.
        /// </summary>
        [Input("customCertificate")]
        public Input<string>? CustomCertificate { get; set; }

        /// <summary>
        /// The key for a custom uploaded certificate.
        /// </summary>
        [Input("customKey")]
        public Input<string>? CustomKey { get; set; }

        /// <summary>
        /// Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        /// </summary>
        [Input("method")]
        public Input<string>? Method { get; set; }

        [Input("settings")]
        private InputList<Inputs.CustomHostnameSslSettingArgs>? _settings;

        /// <summary>
        /// SSL/TLS settings for the certificate.
        /// </summary>
        public InputList<Inputs.CustomHostnameSslSettingArgs> Settings
        {
            get => _settings ?? (_settings = new InputList<Inputs.CustomHostnameSslSettingArgs>());
            set => _settings = value;
        }

        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        [Input("validationErrors")]
        private InputList<Inputs.CustomHostnameSslValidationErrorArgs>? _validationErrors;
        public InputList<Inputs.CustomHostnameSslValidationErrorArgs> ValidationErrors
        {
            get => _validationErrors ?? (_validationErrors = new InputList<Inputs.CustomHostnameSslValidationErrorArgs>());
            set => _validationErrors = value;
        }

        [Input("validationRecords")]
        private InputList<Inputs.CustomHostnameSslValidationRecordArgs>? _validationRecords;
        public InputList<Inputs.CustomHostnameSslValidationRecordArgs> ValidationRecords
        {
            get => _validationRecords ?? (_validationRecords = new InputList<Inputs.CustomHostnameSslValidationRecordArgs>());
            set => _validationRecords = value;
        }

        /// <summary>
        /// Indicates whether the certificate covers a wildcard.
        /// </summary>
        [Input("wildcard")]
        public Input<bool>? Wildcard { get; set; }

        public CustomHostnameSslArgs()
        {
        }
        public static new CustomHostnameSslArgs Empty => new CustomHostnameSslArgs();
    }
}
