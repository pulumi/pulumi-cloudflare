// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare.Inputs
{

    public sealed class ZeroTrustAccessIdentityProviderConfigArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Your companies TLD
        /// </summary>
        [Input("appsDomain")]
        public Input<string>? AppsDomain { get; set; }

        [Input("attributes")]
        private InputList<string>? _attributes;

        /// <summary>
        /// A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        /// </summary>
        public InputList<string> Attributes
        {
            get => _attributes ?? (_attributes = new InputList<string>());
            set => _attributes = value;
        }

        /// <summary>
        /// The authorization_endpoint URL of your IdP
        /// </summary>
        [Input("authUrl")]
        public Input<string>? AuthUrl { get; set; }

        /// <summary>
        /// Your okta authorization server id
        /// </summary>
        [Input("authorizationServerId")]
        public Input<string>? AuthorizationServerId { get; set; }

        /// <summary>
        /// Your centrify account url
        /// </summary>
        [Input("centrifyAccount")]
        public Input<string>? CentrifyAccount { get; set; }

        /// <summary>
        /// Your centrify app id
        /// </summary>
        [Input("centrifyAppId")]
        public Input<string>? CentrifyAppId { get; set; }

        /// <summary>
        /// The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        /// </summary>
        [Input("certsUrl")]
        public Input<string>? CertsUrl { get; set; }

        [Input("claims")]
        private InputList<string>? _claims;

        /// <summary>
        /// Custom claims
        /// </summary>
        public InputList<string> Claims
        {
            get => _claims ?? (_claims = new InputList<string>());
            set => _claims = value;
        }

        /// <summary>
        /// Your OAuth Client ID
        /// </summary>
        [Input("clientId")]
        public Input<string>? ClientId { get; set; }

        [Input("clientSecret")]
        private Input<string>? _clientSecret;

        /// <summary>
        /// Your OAuth Client Secret
        /// </summary>
        public Input<string>? ClientSecret
        {
            get => _clientSecret;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _clientSecret = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Should Cloudflare try to load authentication contexts from your account
        /// </summary>
        [Input("conditionalAccessEnabled")]
        public Input<bool>? ConditionalAccessEnabled { get; set; }

        /// <summary>
        /// Your Azure directory uuid
        /// </summary>
        [Input("directoryId")]
        public Input<string>? DirectoryId { get; set; }

        /// <summary>
        /// The attribute name for email in the SAML response.
        /// </summary>
        [Input("emailAttributeName")]
        public Input<string>? EmailAttributeName { get; set; }

        /// <summary>
        /// The claim name for email in the id_token response.
        /// </summary>
        [Input("emailClaimName")]
        public Input<string>? EmailClaimName { get; set; }

        [Input("headerAttributes")]
        private InputList<Inputs.ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs>? _headerAttributes;

        /// <summary>
        /// Add a list of attribute names that will be returned in the response header from the Access callback.
        /// </summary>
        public InputList<Inputs.ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs> HeaderAttributes
        {
            get => _headerAttributes ?? (_headerAttributes = new InputList<Inputs.ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs>());
            set => _headerAttributes = value;
        }

        [Input("idpPublicCerts")]
        private InputList<string>? _idpPublicCerts;

        /// <summary>
        /// X509 certificate to verify the signature in the SAML authentication response
        /// </summary>
        public InputList<string> IdpPublicCerts
        {
            get => _idpPublicCerts ?? (_idpPublicCerts = new InputList<string>());
            set => _idpPublicCerts = value;
        }

        /// <summary>
        /// IdP Entity ID or Issuer URL
        /// </summary>
        [Input("issuerUrl")]
        public Input<string>? IssuerUrl { get; set; }

        /// <summary>
        /// Your okta account url
        /// </summary>
        [Input("oktaAccount")]
        public Input<string>? OktaAccount { get; set; }

        /// <summary>
        /// Your OneLogin account url
        /// </summary>
        [Input("oneloginAccount")]
        public Input<string>? OneloginAccount { get; set; }

        /// <summary>
        /// Your PingOne environment identifier
        /// </summary>
        [Input("pingEnvId")]
        public Input<string>? PingEnvId { get; set; }

        /// <summary>
        /// Enable Proof Key for Code Exchange (PKCE)
        /// </summary>
        [Input("pkceEnabled")]
        public Input<bool>? PkceEnabled { get; set; }

        /// <summary>
        /// Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        /// Available values: "login", "select_account", "none".
        /// </summary>
        [Input("prompt")]
        public Input<string>? Prompt { get; set; }

        [Input("redirectUrl")]
        public Input<string>? RedirectUrl { get; set; }

        [Input("scopes")]
        private InputList<string>? _scopes;

        /// <summary>
        /// OAuth scopes
        /// </summary>
        public InputList<string> Scopes
        {
            get => _scopes ?? (_scopes = new InputList<string>());
            set => _scopes = value;
        }

        /// <summary>
        /// Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        /// </summary>
        [Input("signRequest")]
        public Input<bool>? SignRequest { get; set; }

        /// <summary>
        /// URL to send the SAML authentication requests to
        /// </summary>
        [Input("ssoTargetUrl")]
        public Input<string>? SsoTargetUrl { get; set; }

        /// <summary>
        /// Should Cloudflare try to load groups from your account
        /// </summary>
        [Input("supportGroups")]
        public Input<bool>? SupportGroups { get; set; }

        /// <summary>
        /// The token_endpoint URL of your IdP
        /// </summary>
        [Input("tokenUrl")]
        public Input<string>? TokenUrl { get; set; }

        public ZeroTrustAccessIdentityProviderConfigArgs()
        {
        }
        public static new ZeroTrustAccessIdentityProviderConfigArgs Empty => new ZeroTrustAccessIdentityProviderConfigArgs();
    }
}
