// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Cloudflare = Pulumi.Cloudflare;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var exampleZeroTrustGatewayPolicy = new Cloudflare.ZeroTrustGatewayPolicy("example_zero_trust_gateway_policy", new()
    ///     {
    ///         AccountId = "699d98642c564d2e855e9661899b7252",
    ///         Action = "allow",
    ///         Name = "block bad websites",
    ///         Description = "Block bad websites based on their host name.",
    ///         DevicePosture = "any(device_posture.checks.passed[*] in {\"1308749e-fcfb-4ebc-b051-fe022b632644\"})",
    ///         Enabled = true,
    ///         Expiration = new Cloudflare.Inputs.ZeroTrustGatewayPolicyExpirationArgs
    ///         {
    ///             Expires_at = "2014-01-01T05:20:20Z",
    ///             Duration = 10,
    ///         },
    ///         Filters = new[]
    ///         {
    ///             "http",
    ///         },
    ///         Identity = "any(identity.groups.name[*] in {\"finance\"})",
    ///         Precedence = 0,
    ///         RuleSettings = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsArgs
    ///         {
    ///             Add_headers = 
    ///             {
    ///                 { "my-Next-Header", new[]
    ///                 {
    ///                     "foo",
    ///                     "bar",
    ///                 } },
    ///                 { "x-Custom-Header-Name", new[]
    ///                 {
    ///                     "somecustomvalue",
    ///                 } },
    ///             },
    ///             Allow_child_bypass = false,
    ///             Audit_ssh = 
    ///             {
    ///                 { "commandLogging", false },
    ///             },
    ///             Biso_admin_controls = 
    ///             {
    ///                 { "copy", "remote_only" },
    ///                 { "dcp", true },
    ///                 { "dd", true },
    ///                 { "dk", true },
    ///                 { "download", "enabled" },
    ///                 { "dp", false },
    ///                 { "du", true },
    ///                 { "keyboard", "enabled" },
    ///                 { "paste", "enabled" },
    ///                 { "printing", "enabled" },
    ///                 { "upload", "enabled" },
    ///                 { "version", "v1" },
    ///             },
    ///             Block_page = 
    ///             {
    ///                 { "targetUri", "https://example.com" },
    ///                 { "includeContext", true },
    ///             },
    ///             Block_page_enabled = true,
    ///             Block_reason = "This website is a security risk",
    ///             Bypass_parent_rule = false,
    ///             Check_session = 
    ///             {
    ///                 { "duration", "300s" },
    ///                 { "enforce", true },
    ///             },
    ///             Dns_resolvers = 
    ///             {
    ///                 { "ipv4", new[]
    ///                 {
    ///                     
    ///                     {
    ///                         { "ip", "2.2.2.2" },
    ///                         { "port", 5053 },
    ///                         { "routeThroughPrivateNetwork", true },
    ///                         { "vnetId", "f174e90a-fafe-4643-bbbc-4a0ed4fc8415" },
    ///                     },
    ///                 } },
    ///                 { "ipv6", new[]
    ///                 {
    ///                     
    ///                     {
    ///                         { "ip", "2001:DB8::" },
    ///                         { "port", 5053 },
    ///                         { "routeThroughPrivateNetwork", true },
    ///                         { "vnetId", "f174e90a-fafe-4643-bbbc-4a0ed4fc8415" },
    ///                     },
    ///                 } },
    ///             },
    ///             Egress = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsEgressArgs
    ///             {
    ///                 Ipv4 = "192.0.2.2",
    ///                 Ipv4Fallback = "192.0.2.3",
    ///                 Ipv6 = "2001:DB8::/64",
    ///             },
    ///             Ignore_cname_category_matches = true,
    ///             Insecure_disable_dnssec_validation = false,
    ///             Ip_categories = true,
    ///             Ip_indicator_feeds = true,
    ///             L4override = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs
    ///             {
    ///                 Ip = "1.1.1.1",
    ///                 Port = 0,
    ///             },
    ///             Notification_settings = 
    ///             {
    ///                 { "enabled", true },
    ///                 { "includeContext", true },
    ///                 { "msg", "msg" },
    ///                 { "supportUrl", "support_url" },
    ///             },
    ///             Override_host = "example.com",
    ///             Override_ips = new[]
    ///             {
    ///                 "1.1.1.1",
    ///                 "2.2.2.2",
    ///             },
    ///             Payload_log = 
    ///             {
    ///                 { "enabled", true },
    ///             },
    ///             Quarantine = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs
    ///             {
    ///                 FileTypes = new[]
    ///                 {
    ///                     "exe",
    ///                 },
    ///             },
    ///             Redirect = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsRedirectArgs
    ///             {
    ///                 TargetUri = "https://example.com",
    ///                 IncludeContext = true,
    ///                 PreservePathAndQuery = true,
    ///             },
    ///             Resolve_dns_internally = 
    ///             {
    ///                 { "fallback", "none" },
    ///                 { "viewId", "view_id" },
    ///             },
    ///             Resolve_dns_through_cloudflare = true,
    ///             Untrusted_cert = 
    ///             {
    ///                 { "action", "error" },
    ///             },
    ///         },
    ///         Schedule = new Cloudflare.Inputs.ZeroTrustGatewayPolicyScheduleArgs
    ///         {
    ///             Fri = "08:00-12:30,13:30-17:00",
    ///             Mon = "08:00-12:30,13:30-17:00",
    ///             Sat = "08:00-12:30,13:30-17:00",
    ///             Sun = "08:00-12:30,13:30-17:00",
    ///             Thu = "08:00-12:30,13:30-17:00",
    ///             Time_zone = "America/New York",
    ///             Tue = "08:00-12:30,13:30-17:00",
    ///             Wed = "08:00-12:30,13:30-17:00",
    ///         },
    ///         Traffic = "http.request.uri matches \".*a/partial/uri.*\" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ```sh
    /// $ pulumi import cloudflare:index/teamsRule:TeamsRule example '&lt;account_id&gt;/&lt;rule_id&gt;'
    /// ```
    /// </summary>
    [Obsolete(@"cloudflare.index/teamsrule.TeamsRule has been deprecated in favor of cloudflare.index/zerotrustgatewaypolicy.ZeroTrustGatewayPolicy")]
    [CloudflareResourceType("cloudflare:index/teamsRule:TeamsRule")]
    public partial class TeamsRule : global::Pulumi.CustomResource
    {
        [Output("accountId")]
        public Output<string> AccountId { get; private set; } = null!;

        /// <summary>
        /// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `True`.
        /// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "L4Override", "egress", "resolve", "quarantine", "redirect".
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        [Output("createdAt")]
        public Output<string> CreatedAt { get; private set; } = null!;

        /// <summary>
        /// Indicate the date of deletion, if any.
        /// </summary>
        [Output("deletedAt")]
        public Output<string> DeletedAt { get; private set; } = null!;

        /// <summary>
        /// Specify the rule description.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        [Output("devicePosture")]
        public Output<string> DevicePosture { get; private set; } = null!;

        /// <summary>
        /// Specify whether the rule is enabled.
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `Schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `Dns` rules.
        /// </summary>
        [Output("expiration")]
        public Output<Outputs.TeamsRuleExpiration> Expiration { get; private set; } = null!;

        /// <summary>
        /// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions.
        /// </summary>
        [Output("filters")]
        public Output<ImmutableArray<string>> Filters { get; private set; } = null!;

        [Output("identity")]
        public Output<string> Identity { get; private set; } = null!;

        /// <summary>
        /// Specify the rule name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("precedence")]
        public Output<int> Precedence { get; private set; } = null!;

        /// <summary>
        /// Indicate that this rule is shared via the Orgs API and read only.
        /// </summary>
        [Output("readOnly")]
        public Output<bool> ReadOnly { get; private set; } = null!;

        [Output("ruleSettings")]
        public Output<Outputs.TeamsRuleRuleSettings> RuleSettings { get; private set; } = null!;

        /// <summary>
        /// Defines the schedule for activating DNS policies. Settable only for `Dns` and `DnsResolver` rules.
        /// </summary>
        [Output("schedule")]
        public Output<Outputs.TeamsRuleSchedule> Schedule { get; private set; } = null!;

        /// <summary>
        /// Indicate that this rule is sharable via the Orgs API.
        /// </summary>
        [Output("sharable")]
        public Output<bool> Sharable { get; private set; } = null!;

        /// <summary>
        /// Provide the account tag of the account that created the rule.
        /// </summary>
        [Output("sourceAccount")]
        public Output<string> SourceAccount { get; private set; } = null!;

        [Output("traffic")]
        public Output<string> Traffic { get; private set; } = null!;

        [Output("updatedAt")]
        public Output<string> UpdatedAt { get; private set; } = null!;

        /// <summary>
        /// Indicate the version number of the rule(read-only).
        /// </summary>
        [Output("version")]
        public Output<int> Version { get; private set; } = null!;

        /// <summary>
        /// Indicate a warning for a misconfigured rule, if any.
        /// </summary>
        [Output("warningStatus")]
        public Output<string> WarningStatus { get; private set; } = null!;


        /// <summary>
        /// Create a TeamsRule resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public TeamsRule(string name, TeamsRuleArgs args, CustomResourceOptions? options = null)
            : base("cloudflare:index/teamsRule:TeamsRule", name, args ?? new TeamsRuleArgs(), MakeResourceOptions(options, ""))
        {
        }

        private TeamsRule(string name, Input<string> id, TeamsRuleState? state = null, CustomResourceOptions? options = null)
            : base("cloudflare:index/teamsRule:TeamsRule", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                Aliases =
                {
                    new global::Pulumi.Alias { Type = "cloudflare:index/teamsRule:TeamsRule" },
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing TeamsRule resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static TeamsRule Get(string name, Input<string> id, TeamsRuleState? state = null, CustomResourceOptions? options = null)
        {
            return new TeamsRule(name, id, state, options);
        }
    }

    public sealed class TeamsRuleArgs : global::Pulumi.ResourceArgs
    {
        [Input("accountId", required: true)]
        public Input<string> AccountId { get; set; } = null!;

        /// <summary>
        /// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `True`.
        /// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "L4Override", "egress", "resolve", "quarantine", "redirect".
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// Specify the rule description.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("devicePosture")]
        public Input<string>? DevicePosture { get; set; }

        /// <summary>
        /// Specify whether the rule is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `Schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `Dns` rules.
        /// </summary>
        [Input("expiration")]
        public Input<Inputs.TeamsRuleExpirationArgs>? Expiration { get; set; }

        [Input("filters")]
        private InputList<string>? _filters;

        /// <summary>
        /// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions.
        /// </summary>
        public InputList<string> Filters
        {
            get => _filters ?? (_filters = new InputList<string>());
            set => _filters = value;
        }

        [Input("identity")]
        public Input<string>? Identity { get; set; }

        /// <summary>
        /// Specify the rule name.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        [Input("precedence")]
        public Input<int>? Precedence { get; set; }

        [Input("ruleSettings")]
        public Input<Inputs.TeamsRuleRuleSettingsArgs>? RuleSettings { get; set; }

        /// <summary>
        /// Defines the schedule for activating DNS policies. Settable only for `Dns` and `DnsResolver` rules.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.TeamsRuleScheduleArgs>? Schedule { get; set; }

        [Input("traffic")]
        public Input<string>? Traffic { get; set; }

        public TeamsRuleArgs()
        {
        }
        public static new TeamsRuleArgs Empty => new TeamsRuleArgs();
    }

    public sealed class TeamsRuleState : global::Pulumi.ResourceArgs
    {
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `True`.
        /// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "L4Override", "egress", "resolve", "quarantine", "redirect".
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        [Input("createdAt")]
        public Input<string>? CreatedAt { get; set; }

        /// <summary>
        /// Indicate the date of deletion, if any.
        /// </summary>
        [Input("deletedAt")]
        public Input<string>? DeletedAt { get; set; }

        /// <summary>
        /// Specify the rule description.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("devicePosture")]
        public Input<string>? DevicePosture { get; set; }

        /// <summary>
        /// Specify whether the rule is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `Schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `Dns` rules.
        /// </summary>
        [Input("expiration")]
        public Input<Inputs.TeamsRuleExpirationGetArgs>? Expiration { get; set; }

        [Input("filters")]
        private InputList<string>? _filters;

        /// <summary>
        /// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions.
        /// </summary>
        public InputList<string> Filters
        {
            get => _filters ?? (_filters = new InputList<string>());
            set => _filters = value;
        }

        [Input("identity")]
        public Input<string>? Identity { get; set; }

        /// <summary>
        /// Specify the rule name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("precedence")]
        public Input<int>? Precedence { get; set; }

        /// <summary>
        /// Indicate that this rule is shared via the Orgs API and read only.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        [Input("ruleSettings")]
        public Input<Inputs.TeamsRuleRuleSettingsGetArgs>? RuleSettings { get; set; }

        /// <summary>
        /// Defines the schedule for activating DNS policies. Settable only for `Dns` and `DnsResolver` rules.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.TeamsRuleScheduleGetArgs>? Schedule { get; set; }

        /// <summary>
        /// Indicate that this rule is sharable via the Orgs API.
        /// </summary>
        [Input("sharable")]
        public Input<bool>? Sharable { get; set; }

        /// <summary>
        /// Provide the account tag of the account that created the rule.
        /// </summary>
        [Input("sourceAccount")]
        public Input<string>? SourceAccount { get; set; }

        [Input("traffic")]
        public Input<string>? Traffic { get; set; }

        [Input("updatedAt")]
        public Input<string>? UpdatedAt { get; set; }

        /// <summary>
        /// Indicate the version number of the rule(read-only).
        /// </summary>
        [Input("version")]
        public Input<int>? Version { get; set; }

        /// <summary>
        /// Indicate a warning for a misconfigured rule, if any.
        /// </summary>
        [Input("warningStatus")]
        public Input<string>? WarningStatus { get; set; }

        public TeamsRuleState()
        {
        }
        public static new TeamsRuleState Empty => new TeamsRuleState();
    }
}
