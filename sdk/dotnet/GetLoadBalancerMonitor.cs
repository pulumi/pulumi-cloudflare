// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare
{
    public static class GetLoadBalancerMonitor
    {
        /// <summary>
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Cloudflare = Pulumi.Cloudflare;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var exampleLoadBalancerMonitor = Cloudflare.GetLoadBalancerMonitor.Invoke(new()
        ///     {
        ///         AccountId = "023e105f4ecef8ad9ca31a8372d0c353",
        ///         MonitorId = "f1aba936b94213e5b8dca0c0dbf1f9cc",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Task<GetLoadBalancerMonitorResult> InvokeAsync(GetLoadBalancerMonitorArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetLoadBalancerMonitorResult>("cloudflare:index/getLoadBalancerMonitor:getLoadBalancerMonitor", args ?? new GetLoadBalancerMonitorArgs(), options.WithDefaults());

        /// <summary>
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Cloudflare = Pulumi.Cloudflare;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var exampleLoadBalancerMonitor = Cloudflare.GetLoadBalancerMonitor.Invoke(new()
        ///     {
        ///         AccountId = "023e105f4ecef8ad9ca31a8372d0c353",
        ///         MonitorId = "f1aba936b94213e5b8dca0c0dbf1f9cc",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetLoadBalancerMonitorResult> Invoke(GetLoadBalancerMonitorInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetLoadBalancerMonitorResult>("cloudflare:index/getLoadBalancerMonitor:getLoadBalancerMonitor", args ?? new GetLoadBalancerMonitorInvokeArgs(), options.WithDefaults());

        /// <summary>
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Cloudflare = Pulumi.Cloudflare;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var exampleLoadBalancerMonitor = Cloudflare.GetLoadBalancerMonitor.Invoke(new()
        ///     {
        ///         AccountId = "023e105f4ecef8ad9ca31a8372d0c353",
        ///         MonitorId = "f1aba936b94213e5b8dca0c0dbf1f9cc",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetLoadBalancerMonitorResult> Invoke(GetLoadBalancerMonitorInvokeArgs args, InvokeOutputOptions options)
            => global::Pulumi.Deployment.Instance.Invoke<GetLoadBalancerMonitorResult>("cloudflare:index/getLoadBalancerMonitor:getLoadBalancerMonitor", args ?? new GetLoadBalancerMonitorInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetLoadBalancerMonitorArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Identifier
        /// </summary>
        [Input("accountId", required: true)]
        public string AccountId { get; set; } = null!;

        [Input("monitorId")]
        public string? MonitorId { get; set; }

        public GetLoadBalancerMonitorArgs()
        {
        }
        public static new GetLoadBalancerMonitorArgs Empty => new GetLoadBalancerMonitorArgs();
    }

    public sealed class GetLoadBalancerMonitorInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Identifier
        /// </summary>
        [Input("accountId", required: true)]
        public Input<string> AccountId { get; set; } = null!;

        [Input("monitorId")]
        public Input<string>? MonitorId { get; set; }

        public GetLoadBalancerMonitorInvokeArgs()
        {
        }
        public static new GetLoadBalancerMonitorInvokeArgs Empty => new GetLoadBalancerMonitorInvokeArgs();
    }


    [OutputType]
    public sealed class GetLoadBalancerMonitorResult
    {
        /// <summary>
        /// Identifier
        /// </summary>
        public readonly string AccountId;
        /// <summary>
        /// Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly bool AllowInsecure;
        /// <summary>
        /// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
        /// </summary>
        public readonly int ConsecutiveDown;
        /// <summary>
        /// To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
        /// </summary>
        public readonly int ConsecutiveUp;
        public readonly string CreatedOn;
        /// <summary>
        /// Object description.
        /// </summary>
        public readonly string Description;
        /// <summary>
        /// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly string ExpectedBody;
        /// <summary>
        /// The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly string ExpectedCodes;
        /// <summary>
        /// Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly bool FollowRedirects;
        /// <summary>
        /// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly ImmutableDictionary<string, ImmutableArray<string>> Header;
        /// <summary>
        /// The ID of this resource.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
        /// </summary>
        public readonly int Interval;
        /// <summary>
        /// The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
        /// </summary>
        public readonly string Method;
        public readonly string ModifiedOn;
        public readonly string? MonitorId;
        /// <summary>
        /// The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly string Path;
        /// <summary>
        /// The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
        /// </summary>
        public readonly int Port;
        /// <summary>
        /// Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
        /// </summary>
        public readonly string ProbeZone;
        /// <summary>
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
        /// </summary>
        public readonly int Retries;
        /// <summary>
        /// The timeout (in seconds) before marking the health check as failed.
        /// </summary>
        public readonly int Timeout;
        /// <summary>
        /// The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
        /// Available values: "http", "https", "tcp", "udp*icmp", "icmp*ping", "smtp".
        /// </summary>
        public readonly string Type;

        [OutputConstructor]
        private GetLoadBalancerMonitorResult(
            string accountId,

            bool allowInsecure,

            int consecutiveDown,

            int consecutiveUp,

            string createdOn,

            string description,

            string expectedBody,

            string expectedCodes,

            bool followRedirects,

            ImmutableDictionary<string, ImmutableArray<string>> header,

            string id,

            int interval,

            string method,

            string modifiedOn,

            string? monitorId,

            string path,

            int port,

            string probeZone,

            int retries,

            int timeout,

            string type)
        {
            AccountId = accountId;
            AllowInsecure = allowInsecure;
            ConsecutiveDown = consecutiveDown;
            ConsecutiveUp = consecutiveUp;
            CreatedOn = createdOn;
            Description = description;
            ExpectedBody = expectedBody;
            ExpectedCodes = expectedCodes;
            FollowRedirects = followRedirects;
            Header = header;
            Id = id;
            Interval = interval;
            Method = method;
            ModifiedOn = modifiedOn;
            MonitorId = monitorId;
            Path = path;
            Port = port;
            ProbeZone = probeZone;
            Retries = retries;
            Timeout = timeout;
            Type = type;
        }
    }
}
