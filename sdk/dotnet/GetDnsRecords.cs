// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare
{
    public static class GetDnsRecords
    {
        /// <summary>
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Cloudflare = Pulumi.Cloudflare;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var exampleDnsRecords = Cloudflare.GetDnsRecords.Invoke(new()
        ///     {
        ///         ZoneId = "023e105f4ecef8ad9ca31a8372d0c353",
        ///         Comment = new Cloudflare.Inputs.GetDnsRecordsCommentInputArgs
        ///         {
        ///             Absent = "absent",
        ///             Contains = "ello, worl",
        ///             Endswith = "o, world",
        ///             Exact = "Hello, world",
        ///             Present = "present",
        ///             Startswith = "Hello, w",
        ///         },
        ///         Content = new Cloudflare.Inputs.GetDnsRecordsContentInputArgs
        ///         {
        ///             Contains = "7.0.0.",
        ///             Endswith = ".0.1",
        ///             Exact = "127.0.0.1",
        ///             Startswith = "127.0.",
        ///         },
        ///         Name = new Cloudflare.Inputs.GetDnsRecordsNameInputArgs
        ///         {
        ///             Contains = "w.example.",
        ///             Endswith = ".example.com",
        ///             Exact = "www.example.com",
        ///             Startswith = "www.example",
        ///         },
        ///         Search = "www.cloudflare.com",
        ///         Tag = new Cloudflare.Inputs.GetDnsRecordsTagInputArgs
        ///         {
        ///             Absent = "important",
        ///             Contains = "greeting:ello, worl",
        ///             Endswith = "greeting:o, world",
        ///             Exact = "greeting:Hello, world",
        ///             Present = "important",
        ///             Startswith = "greeting:Hello, w",
        ///         },
        ///         Type = "A",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Task<GetDnsRecordsResult> InvokeAsync(GetDnsRecordsArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetDnsRecordsResult>("cloudflare:index/getDnsRecords:getDnsRecords", args ?? new GetDnsRecordsArgs(), options.WithDefaults());

        /// <summary>
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Cloudflare = Pulumi.Cloudflare;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var exampleDnsRecords = Cloudflare.GetDnsRecords.Invoke(new()
        ///     {
        ///         ZoneId = "023e105f4ecef8ad9ca31a8372d0c353",
        ///         Comment = new Cloudflare.Inputs.GetDnsRecordsCommentInputArgs
        ///         {
        ///             Absent = "absent",
        ///             Contains = "ello, worl",
        ///             Endswith = "o, world",
        ///             Exact = "Hello, world",
        ///             Present = "present",
        ///             Startswith = "Hello, w",
        ///         },
        ///         Content = new Cloudflare.Inputs.GetDnsRecordsContentInputArgs
        ///         {
        ///             Contains = "7.0.0.",
        ///             Endswith = ".0.1",
        ///             Exact = "127.0.0.1",
        ///             Startswith = "127.0.",
        ///         },
        ///         Name = new Cloudflare.Inputs.GetDnsRecordsNameInputArgs
        ///         {
        ///             Contains = "w.example.",
        ///             Endswith = ".example.com",
        ///             Exact = "www.example.com",
        ///             Startswith = "www.example",
        ///         },
        ///         Search = "www.cloudflare.com",
        ///         Tag = new Cloudflare.Inputs.GetDnsRecordsTagInputArgs
        ///         {
        ///             Absent = "important",
        ///             Contains = "greeting:ello, worl",
        ///             Endswith = "greeting:o, world",
        ///             Exact = "greeting:Hello, world",
        ///             Present = "important",
        ///             Startswith = "greeting:Hello, w",
        ///         },
        ///         Type = "A",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetDnsRecordsResult> Invoke(GetDnsRecordsInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetDnsRecordsResult>("cloudflare:index/getDnsRecords:getDnsRecords", args ?? new GetDnsRecordsInvokeArgs(), options.WithDefaults());

        /// <summary>
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using Cloudflare = Pulumi.Cloudflare;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var exampleDnsRecords = Cloudflare.GetDnsRecords.Invoke(new()
        ///     {
        ///         ZoneId = "023e105f4ecef8ad9ca31a8372d0c353",
        ///         Comment = new Cloudflare.Inputs.GetDnsRecordsCommentInputArgs
        ///         {
        ///             Absent = "absent",
        ///             Contains = "ello, worl",
        ///             Endswith = "o, world",
        ///             Exact = "Hello, world",
        ///             Present = "present",
        ///             Startswith = "Hello, w",
        ///         },
        ///         Content = new Cloudflare.Inputs.GetDnsRecordsContentInputArgs
        ///         {
        ///             Contains = "7.0.0.",
        ///             Endswith = ".0.1",
        ///             Exact = "127.0.0.1",
        ///             Startswith = "127.0.",
        ///         },
        ///         Name = new Cloudflare.Inputs.GetDnsRecordsNameInputArgs
        ///         {
        ///             Contains = "w.example.",
        ///             Endswith = ".example.com",
        ///             Exact = "www.example.com",
        ///             Startswith = "www.example",
        ///         },
        ///         Search = "www.cloudflare.com",
        ///         Tag = new Cloudflare.Inputs.GetDnsRecordsTagInputArgs
        ///         {
        ///             Absent = "important",
        ///             Contains = "greeting:ello, worl",
        ///             Endswith = "greeting:o, world",
        ///             Exact = "greeting:Hello, world",
        ///             Present = "important",
        ///             Startswith = "greeting:Hello, w",
        ///         },
        ///         Type = "A",
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public static Output<GetDnsRecordsResult> Invoke(GetDnsRecordsInvokeArgs args, InvokeOutputOptions options)
            => global::Pulumi.Deployment.Instance.Invoke<GetDnsRecordsResult>("cloudflare:index/getDnsRecords:getDnsRecords", args ?? new GetDnsRecordsInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetDnsRecordsArgs : global::Pulumi.InvokeArgs
    {
        [Input("comment")]
        public Inputs.GetDnsRecordsCommentArgs? Comment { get; set; }

        [Input("content")]
        public Inputs.GetDnsRecordsContentArgs? Content { get; set; }

        /// <summary>
        /// Direction to order DNS records in.
        /// Available values: "asc", "desc".
        /// </summary>
        [Input("direction")]
        public string? Direction { get; set; }

        /// <summary>
        /// Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        /// Available values: "any", "all".
        /// </summary>
        [Input("match")]
        public string? Match { get; set; }

        /// <summary>
        /// Max items to fetch, default: 1000
        /// </summary>
        [Input("maxItems")]
        public int? MaxItems { get; set; }

        [Input("name")]
        public Inputs.GetDnsRecordsNameArgs? Name { get; set; }

        /// <summary>
        /// Field to order DNS records by.
        /// Available values: "type", "name", "content", "ttl", "proxied".
        /// </summary>
        [Input("order")]
        public string? Order { get; set; }

        /// <summary>
        /// Whether the record is receiving the performance and security benefits of Cloudflare.
        /// </summary>
        [Input("proxied")]
        public bool? Proxied { get; set; }

        /// <summary>
        /// Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        /// </summary>
        [Input("search")]
        public string? Search { get; set; }

        [Input("tag")]
        public Inputs.GetDnsRecordsTagArgs? Tag { get; set; }

        /// <summary>
        /// Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        /// Available values: "any", "all".
        /// </summary>
        [Input("tagMatch")]
        public string? TagMatch { get; set; }

        /// <summary>
        /// Record type.
        /// Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
        /// </summary>
        [Input("type")]
        public string? Type { get; set; }

        /// <summary>
        /// Identifier.
        /// </summary>
        [Input("zoneId", required: true)]
        public string ZoneId { get; set; } = null!;

        public GetDnsRecordsArgs()
        {
        }
        public static new GetDnsRecordsArgs Empty => new GetDnsRecordsArgs();
    }

    public sealed class GetDnsRecordsInvokeArgs : global::Pulumi.InvokeArgs
    {
        [Input("comment")]
        public Input<Inputs.GetDnsRecordsCommentInputArgs>? Comment { get; set; }

        [Input("content")]
        public Input<Inputs.GetDnsRecordsContentInputArgs>? Content { get; set; }

        /// <summary>
        /// Direction to order DNS records in.
        /// Available values: "asc", "desc".
        /// </summary>
        [Input("direction")]
        public Input<string>? Direction { get; set; }

        /// <summary>
        /// Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        /// Available values: "any", "all".
        /// </summary>
        [Input("match")]
        public Input<string>? Match { get; set; }

        /// <summary>
        /// Max items to fetch, default: 1000
        /// </summary>
        [Input("maxItems")]
        public Input<int>? MaxItems { get; set; }

        [Input("name")]
        public Input<Inputs.GetDnsRecordsNameInputArgs>? Name { get; set; }

        /// <summary>
        /// Field to order DNS records by.
        /// Available values: "type", "name", "content", "ttl", "proxied".
        /// </summary>
        [Input("order")]
        public Input<string>? Order { get; set; }

        /// <summary>
        /// Whether the record is receiving the performance and security benefits of Cloudflare.
        /// </summary>
        [Input("proxied")]
        public Input<bool>? Proxied { get; set; }

        /// <summary>
        /// Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        /// </summary>
        [Input("search")]
        public Input<string>? Search { get; set; }

        [Input("tag")]
        public Input<Inputs.GetDnsRecordsTagInputArgs>? Tag { get; set; }

        /// <summary>
        /// Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        /// Available values: "any", "all".
        /// </summary>
        [Input("tagMatch")]
        public Input<string>? TagMatch { get; set; }

        /// <summary>
        /// Record type.
        /// Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Identifier.
        /// </summary>
        [Input("zoneId", required: true)]
        public Input<string> ZoneId { get; set; } = null!;

        public GetDnsRecordsInvokeArgs()
        {
        }
        public static new GetDnsRecordsInvokeArgs Empty => new GetDnsRecordsInvokeArgs();
    }


    [OutputType]
    public sealed class GetDnsRecordsResult
    {
        public readonly Outputs.GetDnsRecordsCommentResult? Comment;
        public readonly Outputs.GetDnsRecordsContentResult? Content;
        /// <summary>
        /// Direction to order DNS records in.
        /// Available values: "asc", "desc".
        /// </summary>
        public readonly string Direction;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        /// Available values: "any", "all".
        /// </summary>
        public readonly string Match;
        /// <summary>
        /// Max items to fetch, default: 1000
        /// </summary>
        public readonly int? MaxItems;
        public readonly Outputs.GetDnsRecordsNameResult? Name;
        /// <summary>
        /// Field to order DNS records by.
        /// Available values: "type", "name", "content", "ttl", "proxied".
        /// </summary>
        public readonly string Order;
        /// <summary>
        /// Whether the record is receiving the performance and security benefits of Cloudflare.
        /// </summary>
        public readonly bool Proxied;
        /// <summary>
        /// The items returned by the data source
        /// </summary>
        public readonly ImmutableArray<Outputs.GetDnsRecordsResultResult> Results;
        /// <summary>
        /// Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        /// </summary>
        public readonly string? Search;
        public readonly Outputs.GetDnsRecordsTagResult? Tag;
        /// <summary>
        /// Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        /// Available values: "any", "all".
        /// </summary>
        public readonly string TagMatch;
        /// <summary>
        /// Record type.
        /// Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
        /// </summary>
        public readonly string? Type;
        /// <summary>
        /// Identifier.
        /// </summary>
        public readonly string ZoneId;

        [OutputConstructor]
        private GetDnsRecordsResult(
            Outputs.GetDnsRecordsCommentResult? comment,

            Outputs.GetDnsRecordsContentResult? content,

            string direction,

            string id,

            string match,

            int? maxItems,

            Outputs.GetDnsRecordsNameResult? name,

            string order,

            bool proxied,

            ImmutableArray<Outputs.GetDnsRecordsResultResult> results,

            string? search,

            Outputs.GetDnsRecordsTagResult? tag,

            string tagMatch,

            string? type,

            string zoneId)
        {
            Comment = comment;
            Content = content;
            Direction = direction;
            Id = id;
            Match = match;
            MaxItems = maxItems;
            Name = name;
            Order = order;
            Proxied = proxied;
            Results = results;
            Search = search;
            Tag = tag;
            TagMatch = tagMatch;
            Type = type;
            ZoneId = zoneId;
        }
    }
}
