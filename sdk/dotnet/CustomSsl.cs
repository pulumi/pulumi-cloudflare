// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare
{
    /// <summary>
    /// Provides a Cloudflare custom ssl resource.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-cloudflare/blob/master/website/docs/r/custom_ssl.html.markdown.
    /// </summary>
    public partial class CustomSsl : Pulumi.CustomResource
    {
        /// <summary>
        /// The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.
        /// </summary>
        [Output("customSslOptions")]
        public Output<Outputs.CustomSslCustomSslOptions?> CustomSslOptions { get; private set; } = null!;

        [Output("customSslPriorities")]
        public Output<ImmutableArray<Outputs.CustomSslCustomSslPriorities>> CustomSslPriorities { get; private set; } = null!;

        [Output("expiresOn")]
        public Output<string> ExpiresOn { get; private set; } = null!;

        [Output("hosts")]
        public Output<ImmutableArray<string>> Hosts { get; private set; } = null!;

        [Output("issuer")]
        public Output<string> Issuer { get; private set; } = null!;

        [Output("modifiedOn")]
        public Output<string> ModifiedOn { get; private set; } = null!;

        [Output("priority")]
        public Output<int> Priority { get; private set; } = null!;

        [Output("signature")]
        public Output<string> Signature { get; private set; } = null!;

        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        [Output("uploadedOn")]
        public Output<string> UploadedOn { get; private set; } = null!;

        /// <summary>
        /// The DNS zone id to the custom ssl cert should be added.
        /// </summary>
        [Output("zoneId")]
        public Output<string> ZoneId { get; private set; } = null!;


        /// <summary>
        /// Create a CustomSsl resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public CustomSsl(string name, CustomSslArgs args, CustomResourceOptions? options = null)
            : base("cloudflare:index/customSsl:CustomSsl", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private CustomSsl(string name, Input<string> id, CustomSslState? state = null, CustomResourceOptions? options = null)
            : base("cloudflare:index/customSsl:CustomSsl", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing CustomSsl resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static CustomSsl Get(string name, Input<string> id, CustomSslState? state = null, CustomResourceOptions? options = null)
        {
            return new CustomSsl(name, id, state, options);
        }
    }

    public sealed class CustomSslArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.
        /// </summary>
        [Input("customSslOptions")]
        public Input<Inputs.CustomSslCustomSslOptionsArgs>? CustomSslOptions { get; set; }

        [Input("customSslPriorities")]
        private InputList<Inputs.CustomSslCustomSslPrioritiesArgs>? _customSslPriorities;
        public InputList<Inputs.CustomSslCustomSslPrioritiesArgs> CustomSslPriorities
        {
            get => _customSslPriorities ?? (_customSslPriorities = new InputList<Inputs.CustomSslCustomSslPrioritiesArgs>());
            set => _customSslPriorities = value;
        }

        /// <summary>
        /// The DNS zone id to the custom ssl cert should be added.
        /// </summary>
        [Input("zoneId", required: true)]
        public Input<string> ZoneId { get; set; } = null!;

        public CustomSslArgs()
        {
        }
    }

    public sealed class CustomSslState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.
        /// </summary>
        [Input("customSslOptions")]
        public Input<Inputs.CustomSslCustomSslOptionsGetArgs>? CustomSslOptions { get; set; }

        [Input("customSslPriorities")]
        private InputList<Inputs.CustomSslCustomSslPrioritiesGetArgs>? _customSslPriorities;
        public InputList<Inputs.CustomSslCustomSslPrioritiesGetArgs> CustomSslPriorities
        {
            get => _customSslPriorities ?? (_customSslPriorities = new InputList<Inputs.CustomSslCustomSslPrioritiesGetArgs>());
            set => _customSslPriorities = value;
        }

        [Input("expiresOn")]
        public Input<string>? ExpiresOn { get; set; }

        [Input("hosts")]
        private InputList<string>? _hosts;
        public InputList<string> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<string>());
            set => _hosts = value;
        }

        [Input("issuer")]
        public Input<string>? Issuer { get; set; }

        [Input("modifiedOn")]
        public Input<string>? ModifiedOn { get; set; }

        [Input("priority")]
        public Input<int>? Priority { get; set; }

        [Input("signature")]
        public Input<string>? Signature { get; set; }

        [Input("status")]
        public Input<string>? Status { get; set; }

        [Input("uploadedOn")]
        public Input<string>? UploadedOn { get; set; }

        /// <summary>
        /// The DNS zone id to the custom ssl cert should be added.
        /// </summary>
        [Input("zoneId")]
        public Input<string>? ZoneId { get; set; }

        public CustomSslState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class CustomSslCustomSslOptionsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
        /// </summary>
        [Input("bundleMethod")]
        public Input<string>? BundleMethod { get; set; }

        /// <summary>
        /// Certificate certificate and the intermediate(s)
        /// </summary>
        [Input("certificate", required: true)]
        public Input<string> Certificate { get; set; } = null!;

        /// <summary>
        /// Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
        /// </summary>
        [Input("geoRestrictions")]
        public Input<string>? GeoRestrictions { get; set; }

        /// <summary>
        /// Certificate's private key
        /// </summary>
        [Input("privateKey", required: true)]
        public Input<string> PrivateKey { get; set; } = null!;

        /// <summary>
        /// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public CustomSslCustomSslOptionsArgs()
        {
        }
    }

    public sealed class CustomSslCustomSslOptionsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
        /// </summary>
        [Input("bundleMethod")]
        public Input<string>? BundleMethod { get; set; }

        /// <summary>
        /// Certificate certificate and the intermediate(s)
        /// </summary>
        [Input("certificate", required: true)]
        public Input<string> Certificate { get; set; } = null!;

        /// <summary>
        /// Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
        /// </summary>
        [Input("geoRestrictions")]
        public Input<string>? GeoRestrictions { get; set; }

        /// <summary>
        /// Certificate's private key
        /// </summary>
        [Input("privateKey", required: true)]
        public Input<string> PrivateKey { get; set; } = null!;

        /// <summary>
        /// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public CustomSslCustomSslOptionsGetArgs()
        {
        }
    }

    public sealed class CustomSslCustomSslPrioritiesArgs : Pulumi.ResourceArgs
    {
        [Input("id")]
        public Input<string>? Id { get; set; }

        [Input("priority")]
        public Input<int>? Priority { get; set; }

        public CustomSslCustomSslPrioritiesArgs()
        {
        }
    }

    public sealed class CustomSslCustomSslPrioritiesGetArgs : Pulumi.ResourceArgs
    {
        [Input("id")]
        public Input<string>? Id { get; set; }

        [Input("priority")]
        public Input<int>? Priority { get; set; }

        public CustomSslCustomSslPrioritiesGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class CustomSslCustomSslOptions
    {
        /// <summary>
        /// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are `ubiquitous` (default), `optimal`, `force`.
        /// </summary>
        public readonly string? BundleMethod;
        /// <summary>
        /// Certificate certificate and the intermediate(s)
        /// </summary>
        public readonly string Certificate;
        /// <summary>
        /// Specifies the region where your private key can be held locally. Valid values are `us`, `eu`, `highest_security`.
        /// </summary>
        public readonly string? GeoRestrictions;
        /// <summary>
        /// Certificate's private key
        /// </summary>
        public readonly string PrivateKey;
        /// <summary>
        /// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are `legacy_custom` (default), `sni_custom`.
        /// </summary>
        public readonly string? Type;

        [OutputConstructor]
        private CustomSslCustomSslOptions(
            string? bundleMethod,
            string certificate,
            string? geoRestrictions,
            string privateKey,
            string? type)
        {
            BundleMethod = bundleMethod;
            Certificate = certificate;
            GeoRestrictions = geoRestrictions;
            PrivateKey = privateKey;
            Type = type;
        }
    }

    [OutputType]
    public sealed class CustomSslCustomSslPriorities
    {
        public readonly string? Id;
        public readonly int? Priority;

        [OutputConstructor]
        private CustomSslCustomSslPriorities(
            string? id,
            int? priority)
        {
            Id = id;
            Priority = priority;
        }
    }
    }
}
