// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare.Outputs
{

    [OutputType]
    public sealed class CustomHostnameSsl
    {
        /// <summary>
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
        /// </summary>
        public readonly string? BundleMethod;
        public readonly string? CertificateAuthority;
        /// <summary>
        /// If a custom uploaded certificate is used.
        /// </summary>
        public readonly string? CustomCertificate;
        /// <summary>
        /// The key for a custom uploaded certificate.
        /// </summary>
        public readonly string? CustomKey;
        /// <summary>
        /// Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
        /// </summary>
        public readonly string? Method;
        /// <summary>
        /// SSL/TLS settings for the certificate.
        /// </summary>
        public readonly ImmutableArray<Outputs.CustomHostnameSslSetting> Settings;
        public readonly string? Status;
        /// <summary>
        /// Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
        /// </summary>
        public readonly string? Type;
        public readonly ImmutableArray<Outputs.CustomHostnameSslValidationError> ValidationErrors;
        public readonly ImmutableArray<Outputs.CustomHostnameSslValidationRecord> ValidationRecords;
        /// <summary>
        /// Indicates whether the certificate covers a wildcard.
        /// </summary>
        public readonly bool? Wildcard;

        [OutputConstructor]
        private CustomHostnameSsl(
            string? bundleMethod,

            string? certificateAuthority,

            string? customCertificate,

            string? customKey,

            string? method,

            ImmutableArray<Outputs.CustomHostnameSslSetting> settings,

            string? status,

            string? type,

            ImmutableArray<Outputs.CustomHostnameSslValidationError> validationErrors,

            ImmutableArray<Outputs.CustomHostnameSslValidationRecord> validationRecords,

            bool? wildcard)
        {
            BundleMethod = bundleMethod;
            CertificateAuthority = certificateAuthority;
            CustomCertificate = customCertificate;
            CustomKey = customKey;
            Method = method;
            Settings = settings;
            Status = status;
            Type = type;
            ValidationErrors = validationErrors;
            ValidationRecords = validationRecords;
            Wildcard = wildcard;
        }
    }
}
