// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Cloudflare = Pulumi.Cloudflare;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var exampleZeroTrustGatewayPolicy = new Cloudflare.ZeroTrustGatewayPolicy("example_zero_trust_gateway_policy", new()
    ///     {
    ///         AccountId = "699d98642c564d2e855e9661899b7252",
    ///         Action = "allow",
    ///         Name = "block bad websites",
    ///         Description = "Block bad websites based on their host name.",
    ///         DevicePosture = "any(device_posture.checks.passed[*] in {\"1308749e-fcfb-4ebc-b051-fe022b632644\"})",
    ///         Enabled = true,
    ///         Expiration = new Cloudflare.Inputs.ZeroTrustGatewayPolicyExpirationArgs
    ///         {
    ///             ExpiresAt = "2014-01-01T05:20:20Z",
    ///             Duration = 10,
    ///         },
    ///         Filters = new[]
    ///         {
    ///             "http",
    ///         },
    ///         Identity = "any(identity.groups.name[*] in {\"finance\"})",
    ///         Precedence = 0,
    ///         RuleSettings = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsArgs
    ///         {
    ///             AddHeaders = 
    ///             {
    ///                 { "My-Next-Header", new[]
    ///                 {
    ///                     "foo",
    ///                     "bar",
    ///                 } },
    ///                 { "X-Custom-Header-Name", new[]
    ///                 {
    ///                     "somecustomvalue",
    ///                 } },
    ///             },
    ///             AllowChildBypass = false,
    ///             AuditSsh = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs
    ///             {
    ///                 CommandLogging = false,
    ///             },
    ///             BisoAdminControls = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs
    ///             {
    ///                 Copy = "remote_only",
    ///                 Dcp = true,
    ///                 Dd = true,
    ///                 Dk = true,
    ///                 Download = "enabled",
    ///                 Dp = false,
    ///                 Du = true,
    ///                 Keyboard = "enabled",
    ///                 Paste = "enabled",
    ///                 Printing = "enabled",
    ///                 Upload = "enabled",
    ///                 Version = "v1",
    ///             },
    ///             BlockPage = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs
    ///             {
    ///                 TargetUri = "https://example.com",
    ///                 IncludeContext = true,
    ///             },
    ///             BlockPageEnabled = true,
    ///             BlockReason = "This website is a security risk",
    ///             BypassParentRule = false,
    ///             CheckSession = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs
    ///             {
    ///                 Duration = "300s",
    ///                 Enforce = true,
    ///             },
    ///             DnsResolvers = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs
    ///             {
    ///                 Ipv4s = new[]
    ///                 {
    ///                     new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args
    ///                     {
    ///                         Ip = "2.2.2.2",
    ///                         Port = 5053,
    ///                         RouteThroughPrivateNetwork = true,
    ///                         VnetId = "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
    ///                     },
    ///                 },
    ///                 Ipv6s = new[]
    ///                 {
    ///                     new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args
    ///                     {
    ///                         Ip = "2001:DB8::",
    ///                         Port = 5053,
    ///                         RouteThroughPrivateNetwork = true,
    ///                         VnetId = "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
    ///                     },
    ///                 },
    ///             },
    ///             Egress = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsEgressArgs
    ///             {
    ///                 Ipv4 = "192.0.2.2",
    ///                 Ipv4Fallback = "192.0.2.3",
    ///                 Ipv6 = "2001:DB8::/64",
    ///             },
    ///             ForensicCopy = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsForensicCopyArgs
    ///             {
    ///                 Enabled = true,
    ///             },
    ///             IgnoreCnameCategoryMatches = true,
    ///             InsecureDisableDnssecValidation = false,
    ///             IpCategories = true,
    ///             IpIndicatorFeeds = true,
    ///             L4override = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs
    ///             {
    ///                 Ip = "1.1.1.1",
    ///                 Port = 0,
    ///             },
    ///             NotificationSettings = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs
    ///             {
    ///                 Enabled = true,
    ///                 IncludeContext = true,
    ///                 Msg = "msg",
    ///                 SupportUrl = "support_url",
    ///             },
    ///             OverrideHost = "example.com",
    ///             OverrideIps = new[]
    ///             {
    ///                 "1.1.1.1",
    ///                 "2.2.2.2",
    ///             },
    ///             PayloadLog = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs
    ///             {
    ///                 Enabled = true,
    ///             },
    ///             Quarantine = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs
    ///             {
    ///                 FileTypes = new[]
    ///                 {
    ///                     "exe",
    ///                 },
    ///             },
    ///             Redirect = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsRedirectArgs
    ///             {
    ///                 TargetUri = "https://example.com",
    ///                 IncludeContext = true,
    ///                 PreservePathAndQuery = true,
    ///             },
    ///             ResolveDnsInternally = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs
    ///             {
    ///                 Fallback = "none",
    ///                 ViewId = "view_id",
    ///             },
    ///             ResolveDnsThroughCloudflare = true,
    ///             UntrustedCert = new Cloudflare.Inputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs
    ///             {
    ///                 Action = "error",
    ///             },
    ///         },
    ///         Schedule = new Cloudflare.Inputs.ZeroTrustGatewayPolicyScheduleArgs
    ///         {
    ///             Fri = "08:00-12:30,13:30-17:00",
    ///             Mon = "08:00-12:30,13:30-17:00",
    ///             Sat = "08:00-12:30,13:30-17:00",
    ///             Sun = "08:00-12:30,13:30-17:00",
    ///             Thu = "08:00-12:30,13:30-17:00",
    ///             TimeZone = "America/New York",
    ///             Tue = "08:00-12:30,13:30-17:00",
    ///             Wed = "08:00-12:30,13:30-17:00",
    ///         },
    ///         Traffic = "http.request.uri matches \".*a/partial/uri.*\" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ```sh
    /// $ pulumi import cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy example '&lt;account_id&gt;/&lt;rule_id&gt;'
    /// ```
    /// </summary>
    [CloudflareResourceType("cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy")]
    public partial class ZeroTrustGatewayPolicy : global::Pulumi.CustomResource
    {
        [Output("accountId")]
        public Output<string> AccountId { get; private set; } = null!;

        /// <summary>
        /// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `True`.
        /// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "L4Override", "egress", "resolve", "quarantine", "redirect".
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        [Output("createdAt")]
        public Output<string> CreatedAt { get; private set; } = null!;

        /// <summary>
        /// Indicate the date of deletion, if any.
        /// </summary>
        [Output("deletedAt")]
        public Output<string> DeletedAt { get; private set; } = null!;

        /// <summary>
        /// Specify the rule description.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Output("devicePosture")]
        public Output<string> DevicePosture { get; private set; } = null!;

        /// <summary>
        /// Specify whether the rule is enabled.
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `Schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `Dns` rules.
        /// </summary>
        [Output("expiration")]
        public Output<Outputs.ZeroTrustGatewayPolicyExpiration> Expiration { get; private set; } = null!;

        /// <summary>
        /// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        /// </summary>
        [Output("filters")]
        public Output<ImmutableArray<string>> Filters { get; private set; } = null!;

        /// <summary>
        /// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Output("identity")]
        public Output<string> Identity { get; private set; } = null!;

        /// <summary>
        /// Specify the rule name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
        /// </summary>
        [Output("precedence")]
        public Output<int> Precedence { get; private set; } = null!;

        /// <summary>
        /// Indicate that this rule is shared via the Orgs API and read only.
        /// </summary>
        [Output("readOnly")]
        public Output<bool> ReadOnly { get; private set; } = null!;

        /// <summary>
        /// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
        /// </summary>
        [Output("ruleSettings")]
        public Output<Outputs.ZeroTrustGatewayPolicyRuleSettings> RuleSettings { get; private set; } = null!;

        /// <summary>
        /// Defines the schedule for activating DNS policies. Settable only for `Dns` and `DnsResolver` rules.
        /// </summary>
        [Output("schedule")]
        public Output<Outputs.ZeroTrustGatewayPolicySchedule> Schedule { get; private set; } = null!;

        /// <summary>
        /// Indicate that this rule is sharable via the Orgs API.
        /// </summary>
        [Output("sharable")]
        public Output<bool> Sharable { get; private set; } = null!;

        /// <summary>
        /// Provide the account tag of the account that created the rule.
        /// </summary>
        [Output("sourceAccount")]
        public Output<string> SourceAccount { get; private set; } = null!;

        /// <summary>
        /// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Output("traffic")]
        public Output<string> Traffic { get; private set; } = null!;

        [Output("updatedAt")]
        public Output<string> UpdatedAt { get; private set; } = null!;

        /// <summary>
        /// Indicate the version number of the rule(read-only).
        /// </summary>
        [Output("version")]
        public Output<int> Version { get; private set; } = null!;

        /// <summary>
        /// Indicate a warning for a misconfigured rule, if any.
        /// </summary>
        [Output("warningStatus")]
        public Output<string> WarningStatus { get; private set; } = null!;


        /// <summary>
        /// Create a ZeroTrustGatewayPolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ZeroTrustGatewayPolicy(string name, ZeroTrustGatewayPolicyArgs args, CustomResourceOptions? options = null)
            : base("cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy", name, args ?? new ZeroTrustGatewayPolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ZeroTrustGatewayPolicy(string name, Input<string> id, ZeroTrustGatewayPolicyState? state = null, CustomResourceOptions? options = null)
            : base("cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                Aliases =
                {
                    new global::Pulumi.Alias { Type = "cloudflare:index/teamsRule:TeamsRule" },
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ZeroTrustGatewayPolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ZeroTrustGatewayPolicy Get(string name, Input<string> id, ZeroTrustGatewayPolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new ZeroTrustGatewayPolicy(name, id, state, options);
        }
    }

    public sealed class ZeroTrustGatewayPolicyArgs : global::Pulumi.ResourceArgs
    {
        [Input("accountId", required: true)]
        public Input<string> AccountId { get; set; } = null!;

        /// <summary>
        /// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `True`.
        /// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "L4Override", "egress", "resolve", "quarantine", "redirect".
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// Specify the rule description.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Input("devicePosture")]
        public Input<string>? DevicePosture { get; set; }

        /// <summary>
        /// Specify whether the rule is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `Schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `Dns` rules.
        /// </summary>
        [Input("expiration")]
        public Input<Inputs.ZeroTrustGatewayPolicyExpirationArgs>? Expiration { get; set; }

        [Input("filters")]
        private InputList<string>? _filters;

        /// <summary>
        /// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        /// </summary>
        public InputList<string> Filters
        {
            get => _filters ?? (_filters = new InputList<string>());
            set => _filters = value;
        }

        /// <summary>
        /// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Input("identity")]
        public Input<string>? Identity { get; set; }

        /// <summary>
        /// Specify the rule name.
        /// </summary>
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        /// <summary>
        /// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
        /// </summary>
        [Input("precedence")]
        public Input<int>? Precedence { get; set; }

        /// <summary>
        /// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
        /// </summary>
        [Input("ruleSettings")]
        public Input<Inputs.ZeroTrustGatewayPolicyRuleSettingsArgs>? RuleSettings { get; set; }

        /// <summary>
        /// Defines the schedule for activating DNS policies. Settable only for `Dns` and `DnsResolver` rules.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.ZeroTrustGatewayPolicyScheduleArgs>? Schedule { get; set; }

        /// <summary>
        /// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Input("traffic")]
        public Input<string>? Traffic { get; set; }

        public ZeroTrustGatewayPolicyArgs()
        {
        }
        public static new ZeroTrustGatewayPolicyArgs Empty => new ZeroTrustGatewayPolicyArgs();
    }

    public sealed class ZeroTrustGatewayPolicyState : global::Pulumi.ResourceArgs
    {
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to `True`.
        /// Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "L4Override", "egress", "resolve", "quarantine", "redirect".
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        [Input("createdAt")]
        public Input<string>? CreatedAt { get; set; }

        /// <summary>
        /// Indicate the date of deletion, if any.
        /// </summary>
        [Input("deletedAt")]
        public Input<string>? DeletedAt { get; set; }

        /// <summary>
        /// Specify the rule description.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Input("devicePosture")]
        public Input<string>? DevicePosture { get; set; }

        /// <summary>
        /// Specify whether the rule is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's `Schedule` configuration, if any. This  does not apply to HTTP or network policies. Settable only for `Dns` rules.
        /// </summary>
        [Input("expiration")]
        public Input<Inputs.ZeroTrustGatewayPolicyExpirationGetArgs>? Expiration { get; set; }

        [Input("filters")]
        private InputList<string>? _filters;

        /// <summary>
        /// Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
        /// </summary>
        public InputList<string> Filters
        {
            get => _filters ?? (_filters = new InputList<string>());
            set => _filters = value;
        }

        /// <summary>
        /// Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Input("identity")]
        public Input<string>? Identity { get; set; }

        /// <summary>
        /// Specify the rule name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
        /// </summary>
        [Input("precedence")]
        public Input<int>? Precedence { get; set; }

        /// <summary>
        /// Indicate that this rule is shared via the Orgs API and read only.
        /// </summary>
        [Input("readOnly")]
        public Input<bool>? ReadOnly { get; set; }

        /// <summary>
        /// Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift.
        /// </summary>
        [Input("ruleSettings")]
        public Input<Inputs.ZeroTrustGatewayPolicyRuleSettingsGetArgs>? RuleSettings { get; set; }

        /// <summary>
        /// Defines the schedule for activating DNS policies. Settable only for `Dns` and `DnsResolver` rules.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.ZeroTrustGatewayPolicyScheduleGetArgs>? Schedule { get; set; }

        /// <summary>
        /// Indicate that this rule is sharable via the Orgs API.
        /// </summary>
        [Input("sharable")]
        public Input<bool>? Sharable { get; set; }

        /// <summary>
        /// Provide the account tag of the account that created the rule.
        /// </summary>
        [Input("sourceAccount")]
        public Input<string>? SourceAccount { get; set; }

        /// <summary>
        /// Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
        /// </summary>
        [Input("traffic")]
        public Input<string>? Traffic { get; set; }

        [Input("updatedAt")]
        public Input<string>? UpdatedAt { get; set; }

        /// <summary>
        /// Indicate the version number of the rule(read-only).
        /// </summary>
        [Input("version")]
        public Input<int>? Version { get; set; }

        /// <summary>
        /// Indicate a warning for a misconfigured rule, if any.
        /// </summary>
        [Input("warningStatus")]
        public Input<string>? WarningStatus { get; set; }

        public ZeroTrustGatewayPolicyState()
        {
        }
        public static new ZeroTrustGatewayPolicyState Empty => new ZeroTrustGatewayPolicyState();
    }
}
