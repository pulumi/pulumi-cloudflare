// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Cloudflare
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ## Import
    /// 
    /// ```sh
    /// $ pulumi import cloudflare:index/dnsFirewall:DnsFirewall example '&lt;account_id&gt;/&lt;dns_firewall_id&gt;'
    /// ```
    /// </summary>
    [CloudflareResourceType("cloudflare:index/dnsFirewall:DnsFirewall")]
    public partial class DnsFirewall : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Identifier
        /// </summary>
        [Output("accountId")]
        public Output<string> AccountId { get; private set; } = null!;

        /// <summary>
        /// Attack mitigation settings
        /// </summary>
        [Output("attackMitigation")]
        public Output<Outputs.DnsFirewallAttackMitigation> AttackMitigation { get; private set; } = null!;

        /// <summary>
        /// Whether to refuse to answer queries for the ANY type
        /// </summary>
        [Output("deprecateAnyRequests")]
        public Output<bool?> DeprecateAnyRequests { get; private set; } = null!;

        [Output("dnsFirewallIps")]
        public Output<ImmutableArray<string>> DnsFirewallIps { get; private set; } = null!;

        /// <summary>
        /// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
        /// </summary>
        [Output("ecsFallback")]
        public Output<bool?> EcsFallback { get; private set; } = null!;

        /// <summary>
        /// Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
        /// </summary>
        [Output("maximumCacheTtl")]
        public Output<double> MaximumCacheTtl { get; private set; } = null!;

        /// <summary>
        /// Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
        /// </summary>
        [Output("minimumCacheTtl")]
        public Output<double> MinimumCacheTtl { get; private set; } = null!;

        /// <summary>
        /// Last modification of DNS Firewall cluster
        /// </summary>
        [Output("modifiedOn")]
        public Output<string> ModifiedOn { get; private set; } = null!;

        /// <summary>
        /// DNS Firewall cluster name
        /// </summary>
        [Output("name")]
<<<<<<< HEAD
        public Output<string?> Name { get; private set; } = null!;
=======
        public Output<string> Name { get; private set; } = null!;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

        /// <summary>
        /// Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
        /// </summary>
        [Output("negativeCacheTtl")]
        public Output<double?> NegativeCacheTtl { get; private set; } = null!;

        /// <summary>
        /// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
        /// </summary>
        [Output("ratelimit")]
        public Output<double?> Ratelimit { get; private set; } = null!;

        /// <summary>
        /// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
        /// </summary>
        [Output("retries")]
        public Output<double> Retries { get; private set; } = null!;

        [Output("upstreamIps")]
        public Output<ImmutableArray<string>> UpstreamIps { get; private set; } = null!;


        /// <summary>
        /// Create a DnsFirewall resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DnsFirewall(string name, DnsFirewallArgs args, CustomResourceOptions? options = null)
            : base("cloudflare:index/dnsFirewall:DnsFirewall", name, args ?? new DnsFirewallArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DnsFirewall(string name, Input<string> id, DnsFirewallState? state = null, CustomResourceOptions? options = null)
            : base("cloudflare:index/dnsFirewall:DnsFirewall", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DnsFirewall resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DnsFirewall Get(string name, Input<string> id, DnsFirewallState? state = null, CustomResourceOptions? options = null)
        {
            return new DnsFirewall(name, id, state, options);
        }
    }

    public sealed class DnsFirewallArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Identifier
        /// </summary>
        [Input("accountId", required: true)]
        public Input<string> AccountId { get; set; } = null!;

        /// <summary>
        /// Attack mitigation settings
        /// </summary>
        [Input("attackMitigation")]
        public Input<Inputs.DnsFirewallAttackMitigationArgs>? AttackMitigation { get; set; }

        /// <summary>
        /// Whether to refuse to answer queries for the ANY type
        /// </summary>
        [Input("deprecateAnyRequests")]
        public Input<bool>? DeprecateAnyRequests { get; set; }

        /// <summary>
        /// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
        /// </summary>
        [Input("ecsFallback")]
        public Input<bool>? EcsFallback { get; set; }

        /// <summary>
        /// Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
        /// </summary>
        [Input("maximumCacheTtl")]
        public Input<double>? MaximumCacheTtl { get; set; }

        /// <summary>
        /// Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
        /// </summary>
        [Input("minimumCacheTtl")]
        public Input<double>? MinimumCacheTtl { get; set; }

        /// <summary>
        /// DNS Firewall cluster name
        /// </summary>
<<<<<<< HEAD
        [Input("name")]
        public Input<string>? Name { get; set; }
=======
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580

        /// <summary>
        /// Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
        /// </summary>
        [Input("negativeCacheTtl")]
        public Input<double>? NegativeCacheTtl { get; set; }

        /// <summary>
        /// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
        /// </summary>
        [Input("ratelimit")]
        public Input<double>? Ratelimit { get; set; }

        /// <summary>
        /// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
        /// </summary>
        [Input("retries")]
        public Input<double>? Retries { get; set; }

<<<<<<< HEAD
        [Input("upstreamIps")]
=======
        [Input("upstreamIps", required: true)]
>>>>>>> 5daf78d00237b27958698f41a3d5f5b7e342d580
        private InputList<string>? _upstreamIps;
        public InputList<string> UpstreamIps
        {
            get => _upstreamIps ?? (_upstreamIps = new InputList<string>());
            set => _upstreamIps = value;
        }

        public DnsFirewallArgs()
        {
        }
        public static new DnsFirewallArgs Empty => new DnsFirewallArgs();
    }

    public sealed class DnsFirewallState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Identifier
        /// </summary>
        [Input("accountId")]
        public Input<string>? AccountId { get; set; }

        /// <summary>
        /// Attack mitigation settings
        /// </summary>
        [Input("attackMitigation")]
        public Input<Inputs.DnsFirewallAttackMitigationGetArgs>? AttackMitigation { get; set; }

        /// <summary>
        /// Whether to refuse to answer queries for the ANY type
        /// </summary>
        [Input("deprecateAnyRequests")]
        public Input<bool>? DeprecateAnyRequests { get; set; }

        [Input("dnsFirewallIps")]
        private InputList<string>? _dnsFirewallIps;
        public InputList<string> DnsFirewallIps
        {
            get => _dnsFirewallIps ?? (_dnsFirewallIps = new InputList<string>());
            set => _dnsFirewallIps = value;
        }

        /// <summary>
        /// Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
        /// </summary>
        [Input("ecsFallback")]
        public Input<bool>? EcsFallback { get; set; }

        /// <summary>
        /// Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
        /// </summary>
        [Input("maximumCacheTtl")]
        public Input<double>? MaximumCacheTtl { get; set; }

        /// <summary>
        /// Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
        /// </summary>
        [Input("minimumCacheTtl")]
        public Input<double>? MinimumCacheTtl { get; set; }

        /// <summary>
        /// Last modification of DNS Firewall cluster
        /// </summary>
        [Input("modifiedOn")]
        public Input<string>? ModifiedOn { get; set; }

        /// <summary>
        /// DNS Firewall cluster name
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
        /// </summary>
        [Input("negativeCacheTtl")]
        public Input<double>? NegativeCacheTtl { get; set; }

        /// <summary>
        /// Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
        /// </summary>
        [Input("ratelimit")]
        public Input<double>? Ratelimit { get; set; }

        /// <summary>
        /// Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
        /// </summary>
        [Input("retries")]
        public Input<double>? Retries { get; set; }

        [Input("upstreamIps")]
        private InputList<string>? _upstreamIps;
        public InputList<string> UpstreamIps
        {
            get => _upstreamIps ?? (_upstreamIps = new InputList<string>());
            set => _upstreamIps = value;
        }

        public DnsFirewallState()
        {
        }
        public static new DnsFirewallState Empty => new DnsFirewallState();
    }
}
