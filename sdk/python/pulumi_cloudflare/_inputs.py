# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessRuleConfigurationArgs',
    'AccessRuleConfigurationArgsDict',
    'AccessRuleScopeArgs',
    'AccessRuleScopeArgsDict',
    'AccountMemberPolicyArgs',
    'AccountMemberPolicyArgsDict',
    'AccountMemberPolicyPermissionGroupArgs',
    'AccountMemberPolicyPermissionGroupArgsDict',
    'AccountMemberPolicyResourceGroupArgs',
    'AccountMemberPolicyResourceGroupArgsDict',
    'AccountMemberUserArgs',
    'AccountMemberUserArgsDict',
    'AccountSettingsArgs',
    'AccountSettingsArgsDict',
    'AccountSubscriptionRatePlanArgs',
    'AccountSubscriptionRatePlanArgsDict',
    'AccountTokenConditionArgs',
    'AccountTokenConditionArgsDict',
    'AccountTokenConditionRequestIpArgs',
    'AccountTokenConditionRequestIpArgsDict',
    'AccountTokenPolicyArgs',
    'AccountTokenPolicyArgsDict',
    'AccountTokenPolicyPermissionGroupArgs',
    'AccountTokenPolicyPermissionGroupArgsDict',
    'AccountTokenPolicyPermissionGroupMetaArgs',
    'AccountTokenPolicyPermissionGroupMetaArgsDict',
    'AccountUnitArgs',
    'AccountUnitArgsDict',
    'AddressMapMembershipArgs',
    'AddressMapMembershipArgsDict',
    'ApiShieldAuthIdCharacteristicArgs',
    'ApiShieldAuthIdCharacteristicArgsDict',
    'ApiShieldErrorArgs',
    'ApiShieldErrorArgsDict',
    'ApiShieldMessageArgs',
    'ApiShieldMessageArgsDict',
    'ApiShieldOperationFeaturesArgs',
    'ApiShieldOperationFeaturesArgsDict',
    'ApiShieldOperationFeaturesApiRoutingArgs',
    'ApiShieldOperationFeaturesApiRoutingArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsArgs',
    'ApiShieldOperationFeaturesConfidenceIntervalsArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict',
    'ApiShieldOperationFeaturesParameterSchemasArgs',
    'ApiShieldOperationFeaturesParameterSchemasArgsDict',
    'ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs',
    'ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict',
    'ApiShieldOperationFeaturesSchemaInfoArgs',
    'ApiShieldOperationFeaturesSchemaInfoArgsDict',
    'ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs',
    'ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict',
    'ApiShieldOperationFeaturesThresholdsArgs',
    'ApiShieldOperationFeaturesThresholdsArgsDict',
    'ApiShieldSchemaSchemaArgs',
    'ApiShieldSchemaSchemaArgsDict',
    'ApiShieldSchemaUploadDetailsArgs',
    'ApiShieldSchemaUploadDetailsArgsDict',
    'ApiShieldSchemaUploadDetailsWarningArgs',
    'ApiShieldSchemaUploadDetailsWarningArgsDict',
    'ApiTokenConditionArgs',
    'ApiTokenConditionArgsDict',
    'ApiTokenConditionRequestIpArgs',
    'ApiTokenConditionRequestIpArgsDict',
    'ApiTokenPolicyArgs',
    'ApiTokenPolicyArgsDict',
    'ApiTokenPolicyPermissionGroupArgs',
    'ApiTokenPolicyPermissionGroupArgsDict',
    'ApiTokenPolicyPermissionGroupMetaArgs',
    'ApiTokenPolicyPermissionGroupMetaArgsDict',
    'AuthenticatedOriginPullsConfigArgs',
    'AuthenticatedOriginPullsConfigArgsDict',
    'BotManagementStaleZoneConfigurationArgs',
    'BotManagementStaleZoneConfigurationArgsDict',
    'CloudConnectorRulesParametersArgs',
    'CloudConnectorRulesParametersArgsDict',
    'CloudConnectorRulesRuleArgs',
    'CloudConnectorRulesRuleArgsDict',
    'CloudConnectorRulesRuleParametersArgs',
    'CloudConnectorRulesRuleParametersArgsDict',
    'ContentScanningExpressionBodyArgs',
    'ContentScanningExpressionBodyArgsDict',
    'CustomHostnameOwnershipVerificationArgs',
    'CustomHostnameOwnershipVerificationArgsDict',
    'CustomHostnameOwnershipVerificationHttpArgs',
    'CustomHostnameOwnershipVerificationHttpArgsDict',
    'CustomHostnameSslArgs',
    'CustomHostnameSslArgsDict',
    'CustomHostnameSslCustomCertBundleArgs',
    'CustomHostnameSslCustomCertBundleArgsDict',
    'CustomHostnameSslSettingsArgs',
    'CustomHostnameSslSettingsArgsDict',
    'CustomSslGeoRestrictionsArgs',
    'CustomSslGeoRestrictionsArgsDict',
    'CustomSslKeylessServerArgs',
    'CustomSslKeylessServerArgsDict',
    'CustomSslKeylessServerTunnelArgs',
    'CustomSslKeylessServerTunnelArgsDict',
    'DnsFirewallAttackMitigationArgs',
    'DnsFirewallAttackMitigationArgsDict',
    'DnsRecordDataArgs',
    'DnsRecordDataArgsDict',
    'DnsRecordSettingsArgs',
    'DnsRecordSettingsArgsDict',
    'DnsSettingsZoneDefaultsArgs',
    'DnsSettingsZoneDefaultsArgsDict',
    'DnsSettingsZoneDefaultsInternalDnsArgs',
    'DnsSettingsZoneDefaultsInternalDnsArgsDict',
    'DnsSettingsZoneDefaultsNameserversArgs',
    'DnsSettingsZoneDefaultsNameserversArgsDict',
    'DnsSettingsZoneDefaultsSoaArgs',
    'DnsSettingsZoneDefaultsSoaArgsDict',
    'EmailRoutingCatchAllActionArgs',
    'EmailRoutingCatchAllActionArgsDict',
    'EmailRoutingCatchAllMatcherArgs',
    'EmailRoutingCatchAllMatcherArgsDict',
    'EmailRoutingDnsErrorArgs',
    'EmailRoutingDnsErrorArgsDict',
    'EmailRoutingDnsMessageArgs',
    'EmailRoutingDnsMessageArgsDict',
    'EmailRoutingDnsResultArgs',
    'EmailRoutingDnsResultArgsDict',
    'EmailRoutingDnsResultErrorArgs',
    'EmailRoutingDnsResultErrorArgsDict',
    'EmailRoutingDnsResultErrorMissingArgs',
    'EmailRoutingDnsResultErrorMissingArgsDict',
    'EmailRoutingDnsResultInfoArgs',
    'EmailRoutingDnsResultInfoArgsDict',
    'EmailRoutingDnsResultRecordArgs',
    'EmailRoutingDnsResultRecordArgsDict',
    'EmailRoutingRuleActionArgs',
    'EmailRoutingRuleActionArgsDict',
    'EmailRoutingRuleMatcherArgs',
    'EmailRoutingRuleMatcherArgsDict',
    'EmailSecurityTrustedDomainsBodyArgs',
    'EmailSecurityTrustedDomainsBodyArgsDict',
    'FirewallRuleActionArgs',
    'FirewallRuleActionArgsDict',
    'FirewallRuleActionResponseArgs',
    'FirewallRuleActionResponseArgsDict',
    'FirewallRuleFilterArgs',
    'FirewallRuleFilterArgsDict',
    'HealthcheckHttpConfigArgs',
    'HealthcheckHttpConfigArgsDict',
    'HealthcheckTcpConfigArgs',
    'HealthcheckTcpConfigArgsDict',
    'HyperdriveConfigCachingArgs',
    'HyperdriveConfigCachingArgsDict',
    'HyperdriveConfigOriginArgs',
    'HyperdriveConfigOriginArgsDict',
    'ImageVariantOptionsArgs',
    'ImageVariantOptionsArgsDict',
    'ImageVariantVariantArgs',
    'ImageVariantVariantArgsDict',
    'ImageVariantVariantOptionsArgs',
    'ImageVariantVariantOptionsArgsDict',
    'KeylessCertificateTunnelArgs',
    'KeylessCertificateTunnelArgsDict',
    'ListItemHostnameArgs',
    'ListItemHostnameArgsDict',
    'ListItemRedirectArgs',
    'ListItemRedirectArgsDict',
    'LoadBalancerAdaptiveRoutingArgs',
    'LoadBalancerAdaptiveRoutingArgsDict',
    'LoadBalancerLocationStrategyArgs',
    'LoadBalancerLocationStrategyArgsDict',
    'LoadBalancerPoolLoadSheddingArgs',
    'LoadBalancerPoolLoadSheddingArgsDict',
    'LoadBalancerPoolNotificationFilterArgs',
    'LoadBalancerPoolNotificationFilterArgsDict',
    'LoadBalancerPoolNotificationFilterOriginArgs',
    'LoadBalancerPoolNotificationFilterOriginArgsDict',
    'LoadBalancerPoolNotificationFilterPoolArgs',
    'LoadBalancerPoolNotificationFilterPoolArgsDict',
    'LoadBalancerPoolOriginArgs',
    'LoadBalancerPoolOriginArgsDict',
    'LoadBalancerPoolOriginHeaderArgs',
    'LoadBalancerPoolOriginHeaderArgsDict',
    'LoadBalancerPoolOriginSteeringArgs',
    'LoadBalancerPoolOriginSteeringArgsDict',
    'LoadBalancerRandomSteeringArgs',
    'LoadBalancerRandomSteeringArgsDict',
    'LoadBalancerRuleArgs',
    'LoadBalancerRuleArgsDict',
    'LoadBalancerRuleFixedResponseArgs',
    'LoadBalancerRuleFixedResponseArgsDict',
    'LoadBalancerRuleOverridesArgs',
    'LoadBalancerRuleOverridesArgsDict',
    'LoadBalancerRuleOverridesAdaptiveRoutingArgs',
    'LoadBalancerRuleOverridesAdaptiveRoutingArgsDict',
    'LoadBalancerRuleOverridesLocationStrategyArgs',
    'LoadBalancerRuleOverridesLocationStrategyArgsDict',
    'LoadBalancerRuleOverridesRandomSteeringArgs',
    'LoadBalancerRuleOverridesRandomSteeringArgsDict',
    'LoadBalancerRuleOverridesSessionAffinityAttributesArgs',
    'LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict',
    'LoadBalancerSessionAffinityAttributesArgs',
    'LoadBalancerSessionAffinityAttributesArgsDict',
    'LogpushJobOutputOptionsArgs',
    'LogpushJobOutputOptionsArgsDict',
    'MagicNetworkMonitoringConfigurationWarpDeviceArgs',
    'MagicNetworkMonitoringConfigurationWarpDeviceArgsDict',
    'MagicTransitConnectorDeviceArgs',
    'MagicTransitConnectorDeviceArgsDict',
    'MagicTransitSiteAclLan1Args',
    'MagicTransitSiteAclLan1ArgsDict',
    'MagicTransitSiteAclLan2Args',
    'MagicTransitSiteAclLan2ArgsDict',
    'MagicTransitSiteLanNatArgs',
    'MagicTransitSiteLanNatArgsDict',
    'MagicTransitSiteLanRoutedSubnetArgs',
    'MagicTransitSiteLanRoutedSubnetArgsDict',
    'MagicTransitSiteLanRoutedSubnetNatArgs',
    'MagicTransitSiteLanRoutedSubnetNatArgsDict',
    'MagicTransitSiteLanStaticAddressingArgs',
    'MagicTransitSiteLanStaticAddressingArgsDict',
    'MagicTransitSiteLanStaticAddressingDhcpRelayArgs',
    'MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict',
    'MagicTransitSiteLanStaticAddressingDhcpServerArgs',
    'MagicTransitSiteLanStaticAddressingDhcpServerArgsDict',
    'MagicTransitSiteLocationArgs',
    'MagicTransitSiteLocationArgsDict',
    'MagicTransitSiteWanStaticAddressingArgs',
    'MagicTransitSiteWanStaticAddressingArgsDict',
    'MagicWanGreTunnelGreTunnelArgs',
    'MagicWanGreTunnelGreTunnelArgsDict',
    'MagicWanGreTunnelGreTunnelHealthCheckArgs',
    'MagicWanGreTunnelGreTunnelHealthCheckArgsDict',
    'MagicWanGreTunnelGreTunnelHealthCheckTargetArgs',
    'MagicWanGreTunnelGreTunnelHealthCheckTargetArgsDict',
    'MagicWanGreTunnelHealthCheckArgs',
    'MagicWanGreTunnelHealthCheckArgsDict',
    'MagicWanGreTunnelHealthCheckTargetArgs',
    'MagicWanGreTunnelHealthCheckTargetArgsDict',
    'MagicWanGreTunnelModifiedGreTunnelArgs',
    'MagicWanGreTunnelModifiedGreTunnelArgsDict',
    'MagicWanGreTunnelModifiedGreTunnelHealthCheckArgs',
    'MagicWanGreTunnelModifiedGreTunnelHealthCheckArgsDict',
    'MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs',
    'MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgsDict',
    'MagicWanIpsecTunnelHealthCheckArgs',
    'MagicWanIpsecTunnelHealthCheckArgsDict',
    'MagicWanIpsecTunnelHealthCheckTargetArgs',
    'MagicWanIpsecTunnelHealthCheckTargetArgsDict',
    'MagicWanIpsecTunnelIpsecTunnelArgs',
    'MagicWanIpsecTunnelIpsecTunnelArgsDict',
    'MagicWanIpsecTunnelIpsecTunnelHealthCheckArgs',
    'MagicWanIpsecTunnelIpsecTunnelHealthCheckArgsDict',
    'MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs',
    'MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgsDict',
    'MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs',
    'MagicWanIpsecTunnelIpsecTunnelPskMetadataArgsDict',
    'MagicWanIpsecTunnelModifiedIpsecTunnelArgs',
    'MagicWanIpsecTunnelModifiedIpsecTunnelArgsDict',
    'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgs',
    'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgsDict',
    'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs',
    'MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgsDict',
    'MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs',
    'MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgsDict',
    'MagicWanStaticRouteModifiedRouteArgs',
    'MagicWanStaticRouteModifiedRouteArgsDict',
    'MagicWanStaticRouteModifiedRouteScopeArgs',
    'MagicWanStaticRouteModifiedRouteScopeArgsDict',
    'MagicWanStaticRouteRouteArgs',
    'MagicWanStaticRouteRouteArgsDict',
    'MagicWanStaticRouteRouteScopeArgs',
    'MagicWanStaticRouteRouteScopeArgsDict',
    'MagicWanStaticRouteScopeArgs',
    'MagicWanStaticRouteScopeArgsDict',
    'ManagedTransformsManagedRequestHeaderArgs',
    'ManagedTransformsManagedRequestHeaderArgsDict',
    'ManagedTransformsManagedResponseHeaderArgs',
    'ManagedTransformsManagedResponseHeaderArgsDict',
    'NotificationPolicyFiltersArgs',
    'NotificationPolicyFiltersArgsDict',
    'NotificationPolicyMechanismsArgs',
    'NotificationPolicyMechanismsArgsDict',
    'NotificationPolicyMechanismsEmailArgs',
    'NotificationPolicyMechanismsEmailArgsDict',
    'NotificationPolicyMechanismsPagerdutyArgs',
    'NotificationPolicyMechanismsPagerdutyArgsDict',
    'NotificationPolicyMechanismsWebhookArgs',
    'NotificationPolicyMechanismsWebhookArgsDict',
    'ObservatoryScheduledTestScheduleArgs',
    'ObservatoryScheduledTestScheduleArgsDict',
    'ObservatoryScheduledTestTestArgs',
    'ObservatoryScheduledTestTestArgsDict',
    'ObservatoryScheduledTestTestDesktopReportArgs',
    'ObservatoryScheduledTestTestDesktopReportArgsDict',
    'ObservatoryScheduledTestTestDesktopReportErrorArgs',
    'ObservatoryScheduledTestTestDesktopReportErrorArgsDict',
    'ObservatoryScheduledTestTestMobileReportArgs',
    'ObservatoryScheduledTestTestMobileReportArgsDict',
    'ObservatoryScheduledTestTestMobileReportErrorArgs',
    'ObservatoryScheduledTestTestMobileReportErrorArgsDict',
    'ObservatoryScheduledTestTestRegionArgs',
    'ObservatoryScheduledTestTestRegionArgsDict',
    'PageRuleActionsArgs',
    'PageRuleActionsArgsDict',
    'PageRuleActionsCacheKeyFieldsArgs',
    'PageRuleActionsCacheKeyFieldsArgsDict',
    'PageRuleActionsCacheKeyFieldsCookieArgs',
    'PageRuleActionsCacheKeyFieldsCookieArgsDict',
    'PageRuleActionsCacheKeyFieldsHeaderArgs',
    'PageRuleActionsCacheKeyFieldsHeaderArgsDict',
    'PageRuleActionsCacheKeyFieldsHostArgs',
    'PageRuleActionsCacheKeyFieldsHostArgsDict',
    'PageRuleActionsCacheKeyFieldsQueryStringArgs',
    'PageRuleActionsCacheKeyFieldsQueryStringArgsDict',
    'PageRuleActionsCacheKeyFieldsUserArgs',
    'PageRuleActionsCacheKeyFieldsUserArgsDict',
    'PageRuleActionsForwardingUrlArgs',
    'PageRuleActionsForwardingUrlArgsDict',
    'PagesDomainValidationDataArgs',
    'PagesDomainValidationDataArgsDict',
    'PagesDomainVerificationDataArgs',
    'PagesDomainVerificationDataArgsDict',
    'PagesProjectBuildConfigArgs',
    'PagesProjectBuildConfigArgsDict',
    'PagesProjectCanonicalDeploymentArgs',
    'PagesProjectCanonicalDeploymentArgsDict',
    'PagesProjectCanonicalDeploymentBuildConfigArgs',
    'PagesProjectCanonicalDeploymentBuildConfigArgsDict',
    'PagesProjectCanonicalDeploymentDeploymentTriggerArgs',
    'PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict',
    'PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs',
    'PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict',
    'PagesProjectCanonicalDeploymentEnvVarsArgs',
    'PagesProjectCanonicalDeploymentEnvVarsArgsDict',
    'PagesProjectCanonicalDeploymentLatestStageArgs',
    'PagesProjectCanonicalDeploymentLatestStageArgsDict',
    'PagesProjectCanonicalDeploymentSourceArgs',
    'PagesProjectCanonicalDeploymentSourceArgsDict',
    'PagesProjectCanonicalDeploymentSourceConfigArgs',
    'PagesProjectCanonicalDeploymentSourceConfigArgsDict',
    'PagesProjectCanonicalDeploymentStageArgs',
    'PagesProjectCanonicalDeploymentStageArgsDict',
    'PagesProjectDeploymentConfigsArgs',
    'PagesProjectDeploymentConfigsArgsDict',
    'PagesProjectDeploymentConfigsPreviewArgs',
    'PagesProjectDeploymentConfigsPreviewArgsDict',
    'PagesProjectDeploymentConfigsPreviewAiBindingsArgs',
    'PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict',
    'PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs',
    'PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict',
    'PagesProjectDeploymentConfigsPreviewBrowsersArgs',
    'PagesProjectDeploymentConfigsPreviewBrowsersArgsDict',
    'PagesProjectDeploymentConfigsPreviewD1DatabasesArgs',
    'PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict',
    'PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs',
    'PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict',
    'PagesProjectDeploymentConfigsPreviewEnvVarsArgs',
    'PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict',
    'PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs',
    'PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict',
    'PagesProjectDeploymentConfigsPreviewKvNamespacesArgs',
    'PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict',
    'PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs',
    'PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict',
    'PagesProjectDeploymentConfigsPreviewPlacementArgs',
    'PagesProjectDeploymentConfigsPreviewPlacementArgsDict',
    'PagesProjectDeploymentConfigsPreviewQueueProducersArgs',
    'PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict',
    'PagesProjectDeploymentConfigsPreviewR2BucketsArgs',
    'PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict',
    'PagesProjectDeploymentConfigsPreviewServicesArgs',
    'PagesProjectDeploymentConfigsPreviewServicesArgsDict',
    'PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs',
    'PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict',
    'PagesProjectDeploymentConfigsProductionArgs',
    'PagesProjectDeploymentConfigsProductionArgsDict',
    'PagesProjectDeploymentConfigsProductionAiBindingsArgs',
    'PagesProjectDeploymentConfigsProductionAiBindingsArgsDict',
    'PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs',
    'PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict',
    'PagesProjectDeploymentConfigsProductionBrowsersArgs',
    'PagesProjectDeploymentConfigsProductionBrowsersArgsDict',
    'PagesProjectDeploymentConfigsProductionD1DatabasesArgs',
    'PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict',
    'PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs',
    'PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict',
    'PagesProjectDeploymentConfigsProductionEnvVarsArgs',
    'PagesProjectDeploymentConfigsProductionEnvVarsArgsDict',
    'PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs',
    'PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict',
    'PagesProjectDeploymentConfigsProductionKvNamespacesArgs',
    'PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict',
    'PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs',
    'PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict',
    'PagesProjectDeploymentConfigsProductionPlacementArgs',
    'PagesProjectDeploymentConfigsProductionPlacementArgsDict',
    'PagesProjectDeploymentConfigsProductionQueueProducersArgs',
    'PagesProjectDeploymentConfigsProductionQueueProducersArgsDict',
    'PagesProjectDeploymentConfigsProductionR2BucketsArgs',
    'PagesProjectDeploymentConfigsProductionR2BucketsArgsDict',
    'PagesProjectDeploymentConfigsProductionServicesArgs',
    'PagesProjectDeploymentConfigsProductionServicesArgsDict',
    'PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs',
    'PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict',
    'PagesProjectLatestDeploymentArgs',
    'PagesProjectLatestDeploymentArgsDict',
    'PagesProjectLatestDeploymentBuildConfigArgs',
    'PagesProjectLatestDeploymentBuildConfigArgsDict',
    'PagesProjectLatestDeploymentDeploymentTriggerArgs',
    'PagesProjectLatestDeploymentDeploymentTriggerArgsDict',
    'PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs',
    'PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict',
    'PagesProjectLatestDeploymentEnvVarsArgs',
    'PagesProjectLatestDeploymentEnvVarsArgsDict',
    'PagesProjectLatestDeploymentLatestStageArgs',
    'PagesProjectLatestDeploymentLatestStageArgsDict',
    'PagesProjectLatestDeploymentSourceArgs',
    'PagesProjectLatestDeploymentSourceArgsDict',
    'PagesProjectLatestDeploymentSourceConfigArgs',
    'PagesProjectLatestDeploymentSourceConfigArgsDict',
    'PagesProjectLatestDeploymentStageArgs',
    'PagesProjectLatestDeploymentStageArgsDict',
    'PagesProjectSourceArgs',
    'PagesProjectSourceArgsDict',
    'PagesProjectSourceConfigArgs',
    'PagesProjectSourceConfigArgsDict',
    'QueueConsumerArgs',
    'QueueConsumerArgsDict',
    'QueueConsumerSettingsArgs',
    'QueueConsumerSettingsArgsDict',
    'QueueProducerArgs',
    'QueueProducerArgsDict',
    'QueueSettingsArgs',
    'QueueSettingsArgsDict',
    'R2BucketCorsRuleArgs',
    'R2BucketCorsRuleArgsDict',
    'R2BucketCorsRuleAllowedArgs',
    'R2BucketCorsRuleAllowedArgsDict',
    'R2BucketEventNotificationQueueArgs',
    'R2BucketEventNotificationQueueArgsDict',
    'R2BucketEventNotificationQueueRuleArgs',
    'R2BucketEventNotificationQueueRuleArgsDict',
    'R2BucketEventNotificationRuleArgs',
    'R2BucketEventNotificationRuleArgsDict',
    'R2BucketLifecycleRuleArgs',
    'R2BucketLifecycleRuleArgsDict',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict',
    'R2BucketLifecycleRuleConditionsArgs',
    'R2BucketLifecycleRuleConditionsArgsDict',
    'R2BucketLifecycleRuleDeleteObjectsTransitionArgs',
    'R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict',
    'R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs',
    'R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict',
    'R2BucketLifecycleRuleStorageClassTransitionArgs',
    'R2BucketLifecycleRuleStorageClassTransitionArgsDict',
    'R2BucketLifecycleRuleStorageClassTransitionConditionArgs',
    'R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict',
    'R2BucketLockRuleArgs',
    'R2BucketLockRuleArgsDict',
    'R2BucketLockRuleConditionArgs',
    'R2BucketLockRuleConditionArgsDict',
    'R2BucketSippyDestinationArgs',
    'R2BucketSippyDestinationArgsDict',
    'R2BucketSippySourceArgs',
    'R2BucketSippySourceArgsDict',
    'R2CustomDomainStatusArgs',
    'R2CustomDomainStatusArgsDict',
    'RateLimitActionArgs',
    'RateLimitActionArgsDict',
    'RateLimitActionResponseArgs',
    'RateLimitActionResponseArgsDict',
    'RateLimitBypassArgs',
    'RateLimitBypassArgsDict',
    'RateLimitMatchArgs',
    'RateLimitMatchArgsDict',
    'RateLimitMatchHeaderArgs',
    'RateLimitMatchHeaderArgsDict',
    'RateLimitMatchRequestArgs',
    'RateLimitMatchRequestArgsDict',
    'RateLimitMatchResponseArgs',
    'RateLimitMatchResponseArgsDict',
    'RecordDataArgs',
    'RecordDataArgsDict',
    'RecordSettingsArgs',
    'RecordSettingsArgsDict',
    'RulesetRuleArgs',
    'RulesetRuleArgsDict',
    'RulesetRuleActionParametersArgs',
    'RulesetRuleActionParametersArgsDict',
    'RulesetRuleActionParametersAlgorithmArgs',
    'RulesetRuleActionParametersAlgorithmArgsDict',
    'RulesetRuleActionParametersAutominifyArgs',
    'RulesetRuleActionParametersAutominifyArgsDict',
    'RulesetRuleActionParametersBrowserTtlArgs',
    'RulesetRuleActionParametersBrowserTtlArgsDict',
    'RulesetRuleActionParametersCacheKeyArgs',
    'RulesetRuleActionParametersCacheKeyArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict',
    'RulesetRuleActionParametersCacheReserveArgs',
    'RulesetRuleActionParametersCacheReserveArgsDict',
    'RulesetRuleActionParametersCookieFieldArgs',
    'RulesetRuleActionParametersCookieFieldArgsDict',
    'RulesetRuleActionParametersEdgeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlArgsDict',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict',
    'RulesetRuleActionParametersFromListArgs',
    'RulesetRuleActionParametersFromListArgsDict',
    'RulesetRuleActionParametersFromValueArgs',
    'RulesetRuleActionParametersFromValueArgsDict',
    'RulesetRuleActionParametersFromValueTargetUrlArgs',
    'RulesetRuleActionParametersFromValueTargetUrlArgsDict',
    'RulesetRuleActionParametersHeadersArgs',
    'RulesetRuleActionParametersHeadersArgsDict',
    'RulesetRuleActionParametersMatchedDataArgs',
    'RulesetRuleActionParametersMatchedDataArgsDict',
    'RulesetRuleActionParametersOriginArgs',
    'RulesetRuleActionParametersOriginArgsDict',
    'RulesetRuleActionParametersOverridesArgs',
    'RulesetRuleActionParametersOverridesArgsDict',
    'RulesetRuleActionParametersOverridesCategoryArgs',
    'RulesetRuleActionParametersOverridesCategoryArgsDict',
    'RulesetRuleActionParametersOverridesRuleArgs',
    'RulesetRuleActionParametersOverridesRuleArgsDict',
    'RulesetRuleActionParametersRequestFieldArgs',
    'RulesetRuleActionParametersRequestFieldArgsDict',
    'RulesetRuleActionParametersResponseArgs',
    'RulesetRuleActionParametersResponseArgsDict',
    'RulesetRuleActionParametersResponseFieldArgs',
    'RulesetRuleActionParametersResponseFieldArgsDict',
    'RulesetRuleActionParametersServeStaleArgs',
    'RulesetRuleActionParametersServeStaleArgsDict',
    'RulesetRuleActionParametersSniArgs',
    'RulesetRuleActionParametersSniArgsDict',
    'RulesetRuleActionParametersUriArgs',
    'RulesetRuleActionParametersUriArgsDict',
    'RulesetRuleActionParametersUriPathArgs',
    'RulesetRuleActionParametersUriPathArgsDict',
    'RulesetRuleActionParametersUriQueryArgs',
    'RulesetRuleActionParametersUriQueryArgsDict',
    'RulesetRuleExposedCredentialCheckArgs',
    'RulesetRuleExposedCredentialCheckArgsDict',
    'RulesetRuleLoggingArgs',
    'RulesetRuleLoggingArgsDict',
    'RulesetRuleRatelimitArgs',
    'RulesetRuleRatelimitArgsDict',
    'SnippetRulesRuleArgs',
    'SnippetRulesRuleArgsDict',
    'SnippetsMetadataArgs',
    'SnippetsMetadataArgsDict',
    'SpectrumApplicationDnsArgs',
    'SpectrumApplicationDnsArgsDict',
    'SpectrumApplicationEdgeIpsArgs',
    'SpectrumApplicationEdgeIpsArgsDict',
    'SpectrumApplicationOriginDnsArgs',
    'SpectrumApplicationOriginDnsArgsDict',
    'StreamInputArgs',
    'StreamInputArgsDict',
    'StreamLiveInputRecordingArgs',
    'StreamLiveInputRecordingArgsDict',
    'StreamLiveInputRtmpsArgs',
    'StreamLiveInputRtmpsArgsDict',
    'StreamLiveInputRtmpsPlaybackArgs',
    'StreamLiveInputRtmpsPlaybackArgsDict',
    'StreamLiveInputSrtArgs',
    'StreamLiveInputSrtArgsDict',
    'StreamLiveInputSrtPlaybackArgs',
    'StreamLiveInputSrtPlaybackArgsDict',
    'StreamLiveInputWebRtcArgs',
    'StreamLiveInputWebRtcArgsDict',
    'StreamLiveInputWebRtcPlaybackArgs',
    'StreamLiveInputWebRtcPlaybackArgsDict',
    'StreamPlaybackArgs',
    'StreamPlaybackArgsDict',
    'StreamStatusArgs',
    'StreamStatusArgsDict',
    'StreamWatermarkArgs',
    'StreamWatermarkArgsDict',
    'UserAgentBlockingRuleConfigurationArgs',
    'UserAgentBlockingRuleConfigurationArgsDict',
    'WaitingRoomAdditionalRouteArgs',
    'WaitingRoomAdditionalRouteArgsDict',
    'WaitingRoomCookieAttributesArgs',
    'WaitingRoomCookieAttributesArgsDict',
    'WaitingRoomRulesRuleArgs',
    'WaitingRoomRulesRuleArgsDict',
    'WebAnalyticsSiteRuleArgs',
    'WebAnalyticsSiteRuleArgsDict',
    'WebAnalyticsSiteRulesetArgs',
    'WebAnalyticsSiteRulesetArgsDict',
    'WorkersCronTriggerScheduleArgs',
    'WorkersCronTriggerScheduleArgsDict',
    'WorkersDeploymentAnnotationsArgs',
    'WorkersDeploymentAnnotationsArgsDict',
    'WorkersDeploymentDeploymentArgs',
    'WorkersDeploymentDeploymentArgsDict',
    'WorkersDeploymentDeploymentAnnotationsArgs',
    'WorkersDeploymentDeploymentAnnotationsArgsDict',
    'WorkersDeploymentDeploymentVersionArgs',
    'WorkersDeploymentDeploymentVersionArgsDict',
    'WorkersDeploymentVersionArgs',
    'WorkersDeploymentVersionArgsDict',
    'WorkersRouteErrorArgs',
    'WorkersRouteErrorArgsDict',
    'WorkersRouteMessageArgs',
    'WorkersRouteMessageArgsDict',
    'WorkersScriptAssetsArgs',
    'WorkersScriptAssetsArgsDict',
    'WorkersScriptAssetsConfigArgs',
    'WorkersScriptAssetsConfigArgsDict',
    'WorkersScriptBindingArgs',
    'WorkersScriptBindingArgsDict',
    'WorkersScriptBindingOutboundArgs',
    'WorkersScriptBindingOutboundArgsDict',
    'WorkersScriptBindingOutboundWorkerArgs',
    'WorkersScriptBindingOutboundWorkerArgsDict',
    'WorkersScriptMigrationsArgs',
    'WorkersScriptMigrationsArgsDict',
    'WorkersScriptMigrationsRenamedClassArgs',
    'WorkersScriptMigrationsRenamedClassArgsDict',
    'WorkersScriptMigrationsStepArgs',
    'WorkersScriptMigrationsStepArgsDict',
    'WorkersScriptMigrationsStepRenamedClassArgs',
    'WorkersScriptMigrationsStepRenamedClassArgsDict',
    'WorkersScriptMigrationsStepTransferredClassArgs',
    'WorkersScriptMigrationsStepTransferredClassArgsDict',
    'WorkersScriptMigrationsTransferredClassArgs',
    'WorkersScriptMigrationsTransferredClassArgsDict',
    'WorkersScriptObservabilityArgs',
    'WorkersScriptObservabilityArgsDict',
    'WorkersScriptPlacementArgs',
    'WorkersScriptPlacementArgsDict',
    'WorkersScriptTailConsumerArgs',
    'WorkersScriptTailConsumerArgsDict',
    'ZeroTrustAccessApplicationCorsHeadersArgs',
    'ZeroTrustAccessApplicationCorsHeadersArgsDict',
    'ZeroTrustAccessApplicationDestinationArgs',
    'ZeroTrustAccessApplicationDestinationArgsDict',
    'ZeroTrustAccessApplicationFooterLinkArgs',
    'ZeroTrustAccessApplicationFooterLinkArgsDict',
    'ZeroTrustAccessApplicationLandingPageDesignArgs',
    'ZeroTrustAccessApplicationLandingPageDesignArgsDict',
    'ZeroTrustAccessApplicationPolicyArgs',
    'ZeroTrustAccessApplicationPolicyArgsDict',
    'ZeroTrustAccessApplicationPolicyConnectionRulesArgs',
    'ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict',
    'ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs',
    'ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeArgs',
    'ZeroTrustAccessApplicationPolicyExcludeArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeCertificateArgs',
    'ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs',
    'ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs',
    'ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEmailArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEmailListArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs',
    'ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGeoArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGroupArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeIpArgs',
    'ZeroTrustAccessApplicationPolicyExcludeIpArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeIpListArgs',
    'ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs',
    'ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeOktaArgs',
    'ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeSamlArgs',
    'ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeArgs',
    'ZeroTrustAccessApplicationPolicyIncludeArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeCertificateArgs',
    'ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs',
    'ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs',
    'ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEmailArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEmailListArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs',
    'ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGeoArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGroupArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeIpArgs',
    'ZeroTrustAccessApplicationPolicyIncludeIpArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeIpListArgs',
    'ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs',
    'ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeOktaArgs',
    'ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeSamlArgs',
    'ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireArgs',
    'ZeroTrustAccessApplicationPolicyRequireArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAuthContextArgs',
    'ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs',
    'ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAzureAdArgs',
    'ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireCertificateArgs',
    'ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireCommonNameArgs',
    'ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs',
    'ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEmailArgs',
    'ZeroTrustAccessApplicationPolicyRequireEmailArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs',
    'ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEmailListArgs',
    'ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEveryoneArgs',
    'ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs',
    'ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGeoArgs',
    'ZeroTrustAccessApplicationPolicyRequireGeoArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs',
    'ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGroupArgs',
    'ZeroTrustAccessApplicationPolicyRequireGroupArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGsuiteArgs',
    'ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireIpArgs',
    'ZeroTrustAccessApplicationPolicyRequireIpArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireIpListArgs',
    'ZeroTrustAccessApplicationPolicyRequireIpListArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs',
    'ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireOktaArgs',
    'ZeroTrustAccessApplicationPolicyRequireOktaArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireSamlArgs',
    'ZeroTrustAccessApplicationPolicyRequireSamlArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict',
    'ZeroTrustAccessApplicationSaasAppArgs',
    'ZeroTrustAccessApplicationSaasAppArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomClaimArgs',
    'ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict',
    'ZeroTrustAccessApplicationScimConfigArgs',
    'ZeroTrustAccessApplicationScimConfigArgsDict',
    'ZeroTrustAccessApplicationScimConfigAuthenticationArgs',
    'ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict',
    'ZeroTrustAccessApplicationScimConfigMappingArgs',
    'ZeroTrustAccessApplicationScimConfigMappingArgsDict',
    'ZeroTrustAccessApplicationScimConfigMappingOperationsArgs',
    'ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict',
    'ZeroTrustAccessApplicationTargetCriteriaArgs',
    'ZeroTrustAccessApplicationTargetCriteriaArgsDict',
    'ZeroTrustAccessGroupExcludeArgs',
    'ZeroTrustAccessGroupExcludeArgsDict',
    'ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessGroupExcludeAuthContextArgs',
    'ZeroTrustAccessGroupExcludeAuthContextArgsDict',
    'ZeroTrustAccessGroupExcludeAuthMethodArgs',
    'ZeroTrustAccessGroupExcludeAuthMethodArgsDict',
    'ZeroTrustAccessGroupExcludeAzureAdArgs',
    'ZeroTrustAccessGroupExcludeAzureAdArgsDict',
    'ZeroTrustAccessGroupExcludeCertificateArgs',
    'ZeroTrustAccessGroupExcludeCertificateArgsDict',
    'ZeroTrustAccessGroupExcludeCommonNameArgs',
    'ZeroTrustAccessGroupExcludeCommonNameArgsDict',
    'ZeroTrustAccessGroupExcludeDevicePostureArgs',
    'ZeroTrustAccessGroupExcludeDevicePostureArgsDict',
    'ZeroTrustAccessGroupExcludeEmailArgs',
    'ZeroTrustAccessGroupExcludeEmailArgsDict',
    'ZeroTrustAccessGroupExcludeEmailDomainArgs',
    'ZeroTrustAccessGroupExcludeEmailDomainArgsDict',
    'ZeroTrustAccessGroupExcludeEmailListArgs',
    'ZeroTrustAccessGroupExcludeEmailListArgsDict',
    'ZeroTrustAccessGroupExcludeEveryoneArgs',
    'ZeroTrustAccessGroupExcludeEveryoneArgsDict',
    'ZeroTrustAccessGroupExcludeExternalEvaluationArgs',
    'ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupExcludeGeoArgs',
    'ZeroTrustAccessGroupExcludeGeoArgsDict',
    'ZeroTrustAccessGroupExcludeGithubOrganizationArgs',
    'ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict',
    'ZeroTrustAccessGroupExcludeGroupArgs',
    'ZeroTrustAccessGroupExcludeGroupArgsDict',
    'ZeroTrustAccessGroupExcludeGsuiteArgs',
    'ZeroTrustAccessGroupExcludeGsuiteArgsDict',
    'ZeroTrustAccessGroupExcludeIpArgs',
    'ZeroTrustAccessGroupExcludeIpArgsDict',
    'ZeroTrustAccessGroupExcludeIpListArgs',
    'ZeroTrustAccessGroupExcludeIpListArgsDict',
    'ZeroTrustAccessGroupExcludeLoginMethodArgs',
    'ZeroTrustAccessGroupExcludeLoginMethodArgsDict',
    'ZeroTrustAccessGroupExcludeOktaArgs',
    'ZeroTrustAccessGroupExcludeOktaArgsDict',
    'ZeroTrustAccessGroupExcludeSamlArgs',
    'ZeroTrustAccessGroupExcludeSamlArgsDict',
    'ZeroTrustAccessGroupExcludeServiceTokenArgs',
    'ZeroTrustAccessGroupExcludeServiceTokenArgsDict',
    'ZeroTrustAccessGroupIncludeArgs',
    'ZeroTrustAccessGroupIncludeArgsDict',
    'ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessGroupIncludeAuthContextArgs',
    'ZeroTrustAccessGroupIncludeAuthContextArgsDict',
    'ZeroTrustAccessGroupIncludeAuthMethodArgs',
    'ZeroTrustAccessGroupIncludeAuthMethodArgsDict',
    'ZeroTrustAccessGroupIncludeAzureAdArgs',
    'ZeroTrustAccessGroupIncludeAzureAdArgsDict',
    'ZeroTrustAccessGroupIncludeCertificateArgs',
    'ZeroTrustAccessGroupIncludeCertificateArgsDict',
    'ZeroTrustAccessGroupIncludeCommonNameArgs',
    'ZeroTrustAccessGroupIncludeCommonNameArgsDict',
    'ZeroTrustAccessGroupIncludeDevicePostureArgs',
    'ZeroTrustAccessGroupIncludeDevicePostureArgsDict',
    'ZeroTrustAccessGroupIncludeEmailArgs',
    'ZeroTrustAccessGroupIncludeEmailArgsDict',
    'ZeroTrustAccessGroupIncludeEmailDomainArgs',
    'ZeroTrustAccessGroupIncludeEmailDomainArgsDict',
    'ZeroTrustAccessGroupIncludeEmailListArgs',
    'ZeroTrustAccessGroupIncludeEmailListArgsDict',
    'ZeroTrustAccessGroupIncludeEveryoneArgs',
    'ZeroTrustAccessGroupIncludeEveryoneArgsDict',
    'ZeroTrustAccessGroupIncludeExternalEvaluationArgs',
    'ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupIncludeGeoArgs',
    'ZeroTrustAccessGroupIncludeGeoArgsDict',
    'ZeroTrustAccessGroupIncludeGithubOrganizationArgs',
    'ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict',
    'ZeroTrustAccessGroupIncludeGroupArgs',
    'ZeroTrustAccessGroupIncludeGroupArgsDict',
    'ZeroTrustAccessGroupIncludeGsuiteArgs',
    'ZeroTrustAccessGroupIncludeGsuiteArgsDict',
    'ZeroTrustAccessGroupIncludeIpArgs',
    'ZeroTrustAccessGroupIncludeIpArgsDict',
    'ZeroTrustAccessGroupIncludeIpListArgs',
    'ZeroTrustAccessGroupIncludeIpListArgsDict',
    'ZeroTrustAccessGroupIncludeLoginMethodArgs',
    'ZeroTrustAccessGroupIncludeLoginMethodArgsDict',
    'ZeroTrustAccessGroupIncludeOktaArgs',
    'ZeroTrustAccessGroupIncludeOktaArgsDict',
    'ZeroTrustAccessGroupIncludeSamlArgs',
    'ZeroTrustAccessGroupIncludeSamlArgsDict',
    'ZeroTrustAccessGroupIncludeServiceTokenArgs',
    'ZeroTrustAccessGroupIncludeServiceTokenArgsDict',
    'ZeroTrustAccessGroupRequireArgs',
    'ZeroTrustAccessGroupRequireArgsDict',
    'ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs',
    'ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessGroupRequireAuthContextArgs',
    'ZeroTrustAccessGroupRequireAuthContextArgsDict',
    'ZeroTrustAccessGroupRequireAuthMethodArgs',
    'ZeroTrustAccessGroupRequireAuthMethodArgsDict',
    'ZeroTrustAccessGroupRequireAzureAdArgs',
    'ZeroTrustAccessGroupRequireAzureAdArgsDict',
    'ZeroTrustAccessGroupRequireCertificateArgs',
    'ZeroTrustAccessGroupRequireCertificateArgsDict',
    'ZeroTrustAccessGroupRequireCommonNameArgs',
    'ZeroTrustAccessGroupRequireCommonNameArgsDict',
    'ZeroTrustAccessGroupRequireDevicePostureArgs',
    'ZeroTrustAccessGroupRequireDevicePostureArgsDict',
    'ZeroTrustAccessGroupRequireEmailArgs',
    'ZeroTrustAccessGroupRequireEmailArgsDict',
    'ZeroTrustAccessGroupRequireEmailDomainArgs',
    'ZeroTrustAccessGroupRequireEmailDomainArgsDict',
    'ZeroTrustAccessGroupRequireEmailListArgs',
    'ZeroTrustAccessGroupRequireEmailListArgsDict',
    'ZeroTrustAccessGroupRequireEveryoneArgs',
    'ZeroTrustAccessGroupRequireEveryoneArgsDict',
    'ZeroTrustAccessGroupRequireExternalEvaluationArgs',
    'ZeroTrustAccessGroupRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupRequireGeoArgs',
    'ZeroTrustAccessGroupRequireGeoArgsDict',
    'ZeroTrustAccessGroupRequireGithubOrganizationArgs',
    'ZeroTrustAccessGroupRequireGithubOrganizationArgsDict',
    'ZeroTrustAccessGroupRequireGroupArgs',
    'ZeroTrustAccessGroupRequireGroupArgsDict',
    'ZeroTrustAccessGroupRequireGsuiteArgs',
    'ZeroTrustAccessGroupRequireGsuiteArgsDict',
    'ZeroTrustAccessGroupRequireIpArgs',
    'ZeroTrustAccessGroupRequireIpArgsDict',
    'ZeroTrustAccessGroupRequireIpListArgs',
    'ZeroTrustAccessGroupRequireIpListArgsDict',
    'ZeroTrustAccessGroupRequireLoginMethodArgs',
    'ZeroTrustAccessGroupRequireLoginMethodArgsDict',
    'ZeroTrustAccessGroupRequireOktaArgs',
    'ZeroTrustAccessGroupRequireOktaArgsDict',
    'ZeroTrustAccessGroupRequireSamlArgs',
    'ZeroTrustAccessGroupRequireSamlArgsDict',
    'ZeroTrustAccessGroupRequireServiceTokenArgs',
    'ZeroTrustAccessGroupRequireServiceTokenArgsDict',
    'ZeroTrustAccessIdentityProviderConfigArgs',
    'ZeroTrustAccessIdentityProviderConfigArgsDict',
    'ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs',
    'ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict',
    'ZeroTrustAccessIdentityProviderScimConfigArgs',
    'ZeroTrustAccessIdentityProviderScimConfigArgsDict',
    'ZeroTrustAccessInfrastructureTargetIpArgs',
    'ZeroTrustAccessInfrastructureTargetIpArgsDict',
    'ZeroTrustAccessInfrastructureTargetIpIpv4Args',
    'ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict',
    'ZeroTrustAccessInfrastructureTargetIpIpv6Args',
    'ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict',
    'ZeroTrustAccessMtlsHostnameSettingsSettingArgs',
    'ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict',
    'ZeroTrustAccessPolicyApprovalGroupArgs',
    'ZeroTrustAccessPolicyApprovalGroupArgsDict',
    'ZeroTrustAccessPolicyExcludeArgs',
    'ZeroTrustAccessPolicyExcludeArgsDict',
    'ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessPolicyExcludeAuthContextArgs',
    'ZeroTrustAccessPolicyExcludeAuthContextArgsDict',
    'ZeroTrustAccessPolicyExcludeAuthMethodArgs',
    'ZeroTrustAccessPolicyExcludeAuthMethodArgsDict',
    'ZeroTrustAccessPolicyExcludeAzureAdArgs',
    'ZeroTrustAccessPolicyExcludeAzureAdArgsDict',
    'ZeroTrustAccessPolicyExcludeCertificateArgs',
    'ZeroTrustAccessPolicyExcludeCertificateArgsDict',
    'ZeroTrustAccessPolicyExcludeCommonNameArgs',
    'ZeroTrustAccessPolicyExcludeCommonNameArgsDict',
    'ZeroTrustAccessPolicyExcludeDevicePostureArgs',
    'ZeroTrustAccessPolicyExcludeDevicePostureArgsDict',
    'ZeroTrustAccessPolicyExcludeEmailArgs',
    'ZeroTrustAccessPolicyExcludeEmailArgsDict',
    'ZeroTrustAccessPolicyExcludeEmailDomainArgs',
    'ZeroTrustAccessPolicyExcludeEmailDomainArgsDict',
    'ZeroTrustAccessPolicyExcludeEmailListArgs',
    'ZeroTrustAccessPolicyExcludeEmailListArgsDict',
    'ZeroTrustAccessPolicyExcludeEveryoneArgs',
    'ZeroTrustAccessPolicyExcludeEveryoneArgsDict',
    'ZeroTrustAccessPolicyExcludeExternalEvaluationArgs',
    'ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyExcludeGeoArgs',
    'ZeroTrustAccessPolicyExcludeGeoArgsDict',
    'ZeroTrustAccessPolicyExcludeGithubOrganizationArgs',
    'ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict',
    'ZeroTrustAccessPolicyExcludeGroupArgs',
    'ZeroTrustAccessPolicyExcludeGroupArgsDict',
    'ZeroTrustAccessPolicyExcludeGsuiteArgs',
    'ZeroTrustAccessPolicyExcludeGsuiteArgsDict',
    'ZeroTrustAccessPolicyExcludeIpArgs',
    'ZeroTrustAccessPolicyExcludeIpArgsDict',
    'ZeroTrustAccessPolicyExcludeIpListArgs',
    'ZeroTrustAccessPolicyExcludeIpListArgsDict',
    'ZeroTrustAccessPolicyExcludeLoginMethodArgs',
    'ZeroTrustAccessPolicyExcludeLoginMethodArgsDict',
    'ZeroTrustAccessPolicyExcludeOktaArgs',
    'ZeroTrustAccessPolicyExcludeOktaArgsDict',
    'ZeroTrustAccessPolicyExcludeSamlArgs',
    'ZeroTrustAccessPolicyExcludeSamlArgsDict',
    'ZeroTrustAccessPolicyExcludeServiceTokenArgs',
    'ZeroTrustAccessPolicyExcludeServiceTokenArgsDict',
    'ZeroTrustAccessPolicyIncludeArgs',
    'ZeroTrustAccessPolicyIncludeArgsDict',
    'ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessPolicyIncludeAuthContextArgs',
    'ZeroTrustAccessPolicyIncludeAuthContextArgsDict',
    'ZeroTrustAccessPolicyIncludeAuthMethodArgs',
    'ZeroTrustAccessPolicyIncludeAuthMethodArgsDict',
    'ZeroTrustAccessPolicyIncludeAzureAdArgs',
    'ZeroTrustAccessPolicyIncludeAzureAdArgsDict',
    'ZeroTrustAccessPolicyIncludeCertificateArgs',
    'ZeroTrustAccessPolicyIncludeCertificateArgsDict',
    'ZeroTrustAccessPolicyIncludeCommonNameArgs',
    'ZeroTrustAccessPolicyIncludeCommonNameArgsDict',
    'ZeroTrustAccessPolicyIncludeDevicePostureArgs',
    'ZeroTrustAccessPolicyIncludeDevicePostureArgsDict',
    'ZeroTrustAccessPolicyIncludeEmailArgs',
    'ZeroTrustAccessPolicyIncludeEmailArgsDict',
    'ZeroTrustAccessPolicyIncludeEmailDomainArgs',
    'ZeroTrustAccessPolicyIncludeEmailDomainArgsDict',
    'ZeroTrustAccessPolicyIncludeEmailListArgs',
    'ZeroTrustAccessPolicyIncludeEmailListArgsDict',
    'ZeroTrustAccessPolicyIncludeEveryoneArgs',
    'ZeroTrustAccessPolicyIncludeEveryoneArgsDict',
    'ZeroTrustAccessPolicyIncludeExternalEvaluationArgs',
    'ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyIncludeGeoArgs',
    'ZeroTrustAccessPolicyIncludeGeoArgsDict',
    'ZeroTrustAccessPolicyIncludeGithubOrganizationArgs',
    'ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict',
    'ZeroTrustAccessPolicyIncludeGroupArgs',
    'ZeroTrustAccessPolicyIncludeGroupArgsDict',
    'ZeroTrustAccessPolicyIncludeGsuiteArgs',
    'ZeroTrustAccessPolicyIncludeGsuiteArgsDict',
    'ZeroTrustAccessPolicyIncludeIpArgs',
    'ZeroTrustAccessPolicyIncludeIpArgsDict',
    'ZeroTrustAccessPolicyIncludeIpListArgs',
    'ZeroTrustAccessPolicyIncludeIpListArgsDict',
    'ZeroTrustAccessPolicyIncludeLoginMethodArgs',
    'ZeroTrustAccessPolicyIncludeLoginMethodArgsDict',
    'ZeroTrustAccessPolicyIncludeOktaArgs',
    'ZeroTrustAccessPolicyIncludeOktaArgsDict',
    'ZeroTrustAccessPolicyIncludeSamlArgs',
    'ZeroTrustAccessPolicyIncludeSamlArgsDict',
    'ZeroTrustAccessPolicyIncludeServiceTokenArgs',
    'ZeroTrustAccessPolicyIncludeServiceTokenArgsDict',
    'ZeroTrustAccessPolicyRequireArgs',
    'ZeroTrustAccessPolicyRequireArgsDict',
    'ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs',
    'ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessPolicyRequireAuthContextArgs',
    'ZeroTrustAccessPolicyRequireAuthContextArgsDict',
    'ZeroTrustAccessPolicyRequireAuthMethodArgs',
    'ZeroTrustAccessPolicyRequireAuthMethodArgsDict',
    'ZeroTrustAccessPolicyRequireAzureAdArgs',
    'ZeroTrustAccessPolicyRequireAzureAdArgsDict',
    'ZeroTrustAccessPolicyRequireCertificateArgs',
    'ZeroTrustAccessPolicyRequireCertificateArgsDict',
    'ZeroTrustAccessPolicyRequireCommonNameArgs',
    'ZeroTrustAccessPolicyRequireCommonNameArgsDict',
    'ZeroTrustAccessPolicyRequireDevicePostureArgs',
    'ZeroTrustAccessPolicyRequireDevicePostureArgsDict',
    'ZeroTrustAccessPolicyRequireEmailArgs',
    'ZeroTrustAccessPolicyRequireEmailArgsDict',
    'ZeroTrustAccessPolicyRequireEmailDomainArgs',
    'ZeroTrustAccessPolicyRequireEmailDomainArgsDict',
    'ZeroTrustAccessPolicyRequireEmailListArgs',
    'ZeroTrustAccessPolicyRequireEmailListArgsDict',
    'ZeroTrustAccessPolicyRequireEveryoneArgs',
    'ZeroTrustAccessPolicyRequireEveryoneArgsDict',
    'ZeroTrustAccessPolicyRequireExternalEvaluationArgs',
    'ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyRequireGeoArgs',
    'ZeroTrustAccessPolicyRequireGeoArgsDict',
    'ZeroTrustAccessPolicyRequireGithubOrganizationArgs',
    'ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict',
    'ZeroTrustAccessPolicyRequireGroupArgs',
    'ZeroTrustAccessPolicyRequireGroupArgsDict',
    'ZeroTrustAccessPolicyRequireGsuiteArgs',
    'ZeroTrustAccessPolicyRequireGsuiteArgsDict',
    'ZeroTrustAccessPolicyRequireIpArgs',
    'ZeroTrustAccessPolicyRequireIpArgsDict',
    'ZeroTrustAccessPolicyRequireIpListArgs',
    'ZeroTrustAccessPolicyRequireIpListArgsDict',
    'ZeroTrustAccessPolicyRequireLoginMethodArgs',
    'ZeroTrustAccessPolicyRequireLoginMethodArgsDict',
    'ZeroTrustAccessPolicyRequireOktaArgs',
    'ZeroTrustAccessPolicyRequireOktaArgsDict',
    'ZeroTrustAccessPolicyRequireSamlArgs',
    'ZeroTrustAccessPolicyRequireSamlArgsDict',
    'ZeroTrustAccessPolicyRequireServiceTokenArgs',
    'ZeroTrustAccessPolicyRequireServiceTokenArgsDict',
    'ZeroTrustDeviceCustomProfileExcludeArgs',
    'ZeroTrustDeviceCustomProfileExcludeArgsDict',
    'ZeroTrustDeviceCustomProfileFallbackDomainArgs',
    'ZeroTrustDeviceCustomProfileFallbackDomainArgsDict',
    'ZeroTrustDeviceCustomProfileIncludeArgs',
    'ZeroTrustDeviceCustomProfileIncludeArgsDict',
    'ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgs',
    'ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgsDict',
    'ZeroTrustDeviceCustomProfileServiceModeV2Args',
    'ZeroTrustDeviceCustomProfileServiceModeV2ArgsDict',
    'ZeroTrustDeviceCustomProfileTargetTestArgs',
    'ZeroTrustDeviceCustomProfileTargetTestArgsDict',
    'ZeroTrustDeviceDefaultProfileExcludeArgs',
    'ZeroTrustDeviceDefaultProfileExcludeArgsDict',
    'ZeroTrustDeviceDefaultProfileFallbackDomainArgs',
    'ZeroTrustDeviceDefaultProfileFallbackDomainArgsDict',
    'ZeroTrustDeviceDefaultProfileIncludeArgs',
    'ZeroTrustDeviceDefaultProfileIncludeArgsDict',
    'ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgs',
    'ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgsDict',
    'ZeroTrustDeviceDefaultProfileServiceModeV2Args',
    'ZeroTrustDeviceDefaultProfileServiceModeV2ArgsDict',
    'ZeroTrustDeviceManagedNetworksConfigArgs',
    'ZeroTrustDeviceManagedNetworksConfigArgsDict',
    'ZeroTrustDevicePostureIntegrationConfigArgs',
    'ZeroTrustDevicePostureIntegrationConfigArgsDict',
    'ZeroTrustDevicePostureRuleInputArgs',
    'ZeroTrustDevicePostureRuleInputArgsDict',
    'ZeroTrustDevicePostureRuleInputLocationsArgs',
    'ZeroTrustDevicePostureRuleInputLocationsArgsDict',
    'ZeroTrustDevicePostureRuleMatchArgs',
    'ZeroTrustDevicePostureRuleMatchArgsDict',
    'ZeroTrustDexTestDataArgs',
    'ZeroTrustDexTestDataArgsDict',
    'ZeroTrustDexTestTargetPolicyArgs',
    'ZeroTrustDexTestTargetPolicyArgsDict',
    'ZeroTrustDlpCustomProfileContextAwarenessArgs',
    'ZeroTrustDlpCustomProfileContextAwarenessArgsDict',
    'ZeroTrustDlpCustomProfileContextAwarenessSkipArgs',
    'ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict',
    'ZeroTrustDlpCustomProfileEntryArgs',
    'ZeroTrustDlpCustomProfileEntryArgsDict',
    'ZeroTrustDlpCustomProfileEntryPatternArgs',
    'ZeroTrustDlpCustomProfileEntryPatternArgsDict',
    'ZeroTrustDlpCustomProfileProfileArgs',
    'ZeroTrustDlpCustomProfileProfileArgsDict',
    'ZeroTrustDlpCustomProfileProfileContextAwarenessArgs',
    'ZeroTrustDlpCustomProfileProfileContextAwarenessArgsDict',
    'ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs',
    'ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgsDict',
    'ZeroTrustDlpCustomProfileProfileEntryArgs',
    'ZeroTrustDlpCustomProfileProfileEntryArgsDict',
    'ZeroTrustDlpCustomProfileProfileEntryPatternArgs',
    'ZeroTrustDlpCustomProfileProfileEntryPatternArgsDict',
    'ZeroTrustDlpCustomProfileProfileSharedEntryArgs',
    'ZeroTrustDlpCustomProfileProfileSharedEntryArgsDict',
    'ZeroTrustDlpCustomProfileSharedEntryArgs',
    'ZeroTrustDlpCustomProfileSharedEntryArgsDict',
    'ZeroTrustDlpDatasetColumnArgs',
    'ZeroTrustDlpDatasetColumnArgsDict',
    'ZeroTrustDlpDatasetDatasetArgs',
    'ZeroTrustDlpDatasetDatasetArgsDict',
    'ZeroTrustDlpDatasetDatasetColumnArgs',
    'ZeroTrustDlpDatasetDatasetColumnArgsDict',
    'ZeroTrustDlpDatasetDatasetUploadArgs',
    'ZeroTrustDlpDatasetDatasetUploadArgsDict',
    'ZeroTrustDlpDatasetUploadArgs',
    'ZeroTrustDlpDatasetUploadArgsDict',
    'ZeroTrustDlpEntryConfidenceArgs',
    'ZeroTrustDlpEntryConfidenceArgsDict',
    'ZeroTrustDlpEntryPatternArgs',
    'ZeroTrustDlpEntryPatternArgsDict',
    'ZeroTrustDlpPredefinedProfileContextAwarenessArgs',
    'ZeroTrustDlpPredefinedProfileContextAwarenessArgsDict',
    'ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs',
    'ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict',
    'ZeroTrustDlpPredefinedProfileEntryArgs',
    'ZeroTrustDlpPredefinedProfileEntryArgsDict',
    'ZeroTrustDnsLocationEndpointsArgs',
    'ZeroTrustDnsLocationEndpointsArgsDict',
    'ZeroTrustDnsLocationEndpointsDohArgs',
    'ZeroTrustDnsLocationEndpointsDohArgsDict',
    'ZeroTrustDnsLocationEndpointsDohNetworkArgs',
    'ZeroTrustDnsLocationEndpointsDohNetworkArgsDict',
    'ZeroTrustDnsLocationEndpointsDotArgs',
    'ZeroTrustDnsLocationEndpointsDotArgsDict',
    'ZeroTrustDnsLocationEndpointsDotNetworkArgs',
    'ZeroTrustDnsLocationEndpointsDotNetworkArgsDict',
    'ZeroTrustDnsLocationEndpointsIpv4Args',
    'ZeroTrustDnsLocationEndpointsIpv4ArgsDict',
    'ZeroTrustDnsLocationEndpointsIpv6Args',
    'ZeroTrustDnsLocationEndpointsIpv6ArgsDict',
    'ZeroTrustDnsLocationEndpointsIpv6NetworkArgs',
    'ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict',
    'ZeroTrustDnsLocationNetworkArgs',
    'ZeroTrustDnsLocationNetworkArgsDict',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeArgs',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeArgsDict',
    'ZeroTrustGatewayPolicyExpirationArgs',
    'ZeroTrustGatewayPolicyExpirationArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsEgressArgs',
    'ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs',
    'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs',
    'ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs',
    'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict',
    'ZeroTrustGatewayPolicyScheduleArgs',
    'ZeroTrustGatewayPolicyScheduleArgsDict',
    'ZeroTrustGatewaySettingsSettingsArgs',
    'ZeroTrustGatewaySettingsSettingsArgsDict',
    'ZeroTrustGatewaySettingsSettingsActivityLogArgs',
    'ZeroTrustGatewaySettingsSettingsActivityLogArgsDict',
    'ZeroTrustGatewaySettingsSettingsAntivirusArgs',
    'ZeroTrustGatewaySettingsSettingsAntivirusArgsDict',
    'ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs',
    'ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict',
    'ZeroTrustGatewaySettingsSettingsBlockPageArgs',
    'ZeroTrustGatewaySettingsSettingsBlockPageArgsDict',
    'ZeroTrustGatewaySettingsSettingsBodyScanningArgs',
    'ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict',
    'ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs',
    'ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict',
    'ZeroTrustGatewaySettingsSettingsCertificateArgs',
    'ZeroTrustGatewaySettingsSettingsCertificateArgsDict',
    'ZeroTrustGatewaySettingsSettingsCustomCertificateArgs',
    'ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict',
    'ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs',
    'ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict',
    'ZeroTrustGatewaySettingsSettingsFipsArgs',
    'ZeroTrustGatewaySettingsSettingsFipsArgsDict',
    'ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs',
    'ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict',
    'ZeroTrustGatewaySettingsSettingsSandboxArgs',
    'ZeroTrustGatewaySettingsSettingsSandboxArgsDict',
    'ZeroTrustGatewaySettingsSettingsTlsDecryptArgs',
    'ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict',
    'ZeroTrustListItemArgs',
    'ZeroTrustListItemArgsDict',
    'ZeroTrustOrganizationCustomPagesArgs',
    'ZeroTrustOrganizationCustomPagesArgsDict',
    'ZeroTrustOrganizationLoginDesignArgs',
    'ZeroTrustOrganizationLoginDesignArgsDict',
    'ZeroTrustRiskBehaviorBehaviorsArgs',
    'ZeroTrustRiskBehaviorBehaviorsArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict',
    'ZeroTrustTunnelCloudflaredConnectionArgs',
    'ZeroTrustTunnelCloudflaredConnectionArgsDict',
    'ZoneAccountArgs',
    'ZoneAccountArgsDict',
    'ZoneCacheVariantsValueArgs',
    'ZoneCacheVariantsValueArgsDict',
    'ZoneLockdownConfigurationArgs',
    'ZoneLockdownConfigurationArgsDict',
    'ZoneMetaArgs',
    'ZoneMetaArgsDict',
    'ZoneOwnerArgs',
    'ZoneOwnerArgsDict',
    'ZoneSubscriptionRatePlanArgs',
    'ZoneSubscriptionRatePlanArgsDict',
    'GetAccessRuleFilterArgs',
    'GetAccessRuleFilterArgsDict',
    'GetAccessRuleFilterConfigurationArgs',
    'GetAccessRuleFilterConfigurationArgsDict',
    'GetAccessRulesConfigurationArgs',
    'GetAccessRulesConfigurationArgsDict',
    'GetAccountFilterArgs',
    'GetAccountFilterArgsDict',
    'GetAccountMemberFilterArgs',
    'GetAccountMemberFilterArgsDict',
    'GetAccountTokenFilterArgs',
    'GetAccountTokenFilterArgsDict',
    'GetApiShieldOperationFilterArgs',
    'GetApiShieldOperationFilterArgsDict',
    'GetApiTokenFilterArgs',
    'GetApiTokenFilterArgsDict',
    'GetCustomHostnameFilterArgs',
    'GetCustomHostnameFilterArgsDict',
    'GetCustomSslFilterArgs',
    'GetCustomSslFilterArgsDict',
    'GetD1DatabaseFilterArgs',
    'GetD1DatabaseFilterArgsDict',
    'GetDnsRecordFilterArgs',
    'GetDnsRecordFilterArgsDict',
    'GetDnsRecordFilterCommentArgs',
    'GetDnsRecordFilterCommentArgsDict',
    'GetDnsRecordFilterContentArgs',
    'GetDnsRecordFilterContentArgsDict',
    'GetDnsRecordFilterNameArgs',
    'GetDnsRecordFilterNameArgsDict',
    'GetDnsRecordFilterTagArgs',
    'GetDnsRecordFilterTagArgsDict',
    'GetDnsRecordsCommentArgs',
    'GetDnsRecordsCommentArgsDict',
    'GetDnsRecordsContentArgs',
    'GetDnsRecordsContentArgsDict',
    'GetDnsRecordsNameArgs',
    'GetDnsRecordsNameArgsDict',
    'GetDnsRecordsTagArgs',
    'GetDnsRecordsTagArgsDict',
    'GetDnsSettingsInternalViewFilterArgs',
    'GetDnsSettingsInternalViewFilterArgsDict',
    'GetDnsSettingsInternalViewFilterNameArgs',
    'GetDnsSettingsInternalViewFilterNameArgsDict',
    'GetDnsSettingsInternalViewsNameArgs',
    'GetDnsSettingsInternalViewsNameArgsDict',
    'GetEmailRoutingAddressFilterArgs',
    'GetEmailRoutingAddressFilterArgsDict',
    'GetEmailRoutingRuleFilterArgs',
    'GetEmailRoutingRuleFilterArgsDict',
    'GetEmailSecurityBlockSenderFilterArgs',
    'GetEmailSecurityBlockSenderFilterArgsDict',
    'GetEmailSecurityImpersonationRegistryFilterArgs',
    'GetEmailSecurityImpersonationRegistryFilterArgsDict',
    'GetEmailSecurityTrustedDomainsFilterArgs',
    'GetEmailSecurityTrustedDomainsFilterArgsDict',
    'GetFilterFilterArgs',
    'GetFilterFilterArgsDict',
    'GetLoadBalancerPoolFilterArgs',
    'GetLoadBalancerPoolFilterArgsDict',
    'GetMagicTransitSiteFilterArgs',
    'GetMagicTransitSiteFilterArgsDict',
    'GetOriginCaCertificateFilterArgs',
    'GetOriginCaCertificateFilterArgsDict',
    'GetTurnstileWidgetFilterArgs',
    'GetTurnstileWidgetFilterArgsDict',
    'GetWebAnalyticsSiteFilterArgs',
    'GetWebAnalyticsSiteFilterArgsDict',
    'GetWorkersCustomDomainFilterArgs',
    'GetWorkersCustomDomainFilterArgsDict',
    'GetWorkersKvNamespaceFilterArgs',
    'GetWorkersKvNamespaceFilterArgsDict',
    'GetZeroTrustAccessApplicationFilterArgs',
    'GetZeroTrustAccessApplicationFilterArgsDict',
    'GetZeroTrustAccessGroupFilterArgs',
    'GetZeroTrustAccessGroupFilterArgsDict',
    'GetZeroTrustAccessIdentityProviderFilterArgs',
    'GetZeroTrustAccessIdentityProviderFilterArgsDict',
    'GetZeroTrustAccessInfrastructureTargetFilterArgs',
    'GetZeroTrustAccessInfrastructureTargetFilterArgsDict',
    'GetZeroTrustAccessServiceTokenFilterArgs',
    'GetZeroTrustAccessServiceTokenFilterArgsDict',
    'GetZeroTrustListFilterArgs',
    'GetZeroTrustListFilterArgsDict',
    'GetZeroTrustTunnelCloudflaredFilterArgs',
    'GetZeroTrustTunnelCloudflaredFilterArgsDict',
    'GetZeroTrustTunnelCloudflaredRouteFilterArgs',
    'GetZeroTrustTunnelCloudflaredRouteFilterArgsDict',
    'GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgs',
    'GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgsDict',
    'GetZoneFilterArgs',
    'GetZoneFilterArgsDict',
    'GetZoneFilterAccountArgs',
    'GetZoneFilterAccountArgsDict',
    'GetZoneLockdownFilterArgs',
    'GetZoneLockdownFilterArgsDict',
    'GetZonesAccountArgs',
    'GetZonesAccountArgsDict',
]

MYPY = False

if not MYPY:
    class AccessRuleConfigurationArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[str]]
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
elif False:
    AccessRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        :param pulumi.Input[str] value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AccessRuleScopeArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        The contact email address of the user.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The scope of the rule.
        """
elif False:
    AccessRuleScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleScopeArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: The contact email address of the user.
        :param pulumi.Input[str] id: Identifier
        :param pulumi.Input[str] type: The scope of the rule.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The scope of the rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AccountMemberPolicyArgsDict(TypedDict):
        access: pulumi.Input[str]
        """
        Allow or deny operations against the resources.
        """
        permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgsDict']]]
        """
        A set of permission groups that are specified to the policy.
        """
        resource_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgsDict']]]
        """
        A list of resource groups that the policy applies to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Policy identifier.
        """
elif False:
    AccountMemberPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberPolicyArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[str],
                 permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]],
                 resource_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access: Allow or deny operations against the resources.
        :param pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]] permission_groups: A set of permission groups that are specified to the policy.
        :param pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]] resource_groups: A list of resource groups that the policy applies to.
        :param pulumi.Input[str] id: Policy identifier.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resource_groups", resource_groups)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def access(self) -> pulumi.Input[str]:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[str]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]]:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]]):
        pulumi.set(self, "permission_groups", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]]:
        """
        A list of resource groups that the policy applies to.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]]):
        pulumi.set(self, "resource_groups", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountMemberPolicyPermissionGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Identifier of the group.
        """
elif False:
    AccountMemberPolicyPermissionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberPolicyPermissionGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Identifier of the group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountMemberPolicyResourceGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Identifier of the group.
        """
elif False:
    AccountMemberPolicyResourceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberPolicyResourceGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Identifier of the group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountMemberUserArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        The contact email address of the user.
        """
        first_name: NotRequired[pulumi.Input[str]]
        """
        User's first name
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier
        """
        last_name: NotRequired[pulumi.Input[str]]
        """
        User's last name
        """
        two_factor_authentication_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
elif False:
    AccountMemberUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberUserArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 two_factor_authentication_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] email: The contact email address of the user.
        :param pulumi.Input[str] first_name: User's first name
        :param pulumi.Input[str] id: Identifier
        :param pulumi.Input[str] last_name: User's last name
        :param pulumi.Input[bool] two_factor_authentication_enabled: Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if two_factor_authentication_enabled is not None:
            pulumi.set(__self__, "two_factor_authentication_enabled", two_factor_authentication_enabled)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        """
        User's first name
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        """
        User's last name
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter(name="twoFactorAuthenticationEnabled")
    def two_factor_authentication_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        return pulumi.get(self, "two_factor_authentication_enabled")

    @two_factor_authentication_enabled.setter
    def two_factor_authentication_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "two_factor_authentication_enabled", value)


if not MYPY:
    class AccountSettingsArgsDict(TypedDict):
        abuse_contact_email: NotRequired[pulumi.Input[str]]
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        default_nameservers: NotRequired[pulumi.Input[str]]
        """
        Specifies the default nameservers to be used for new zones added to this account.
        """
        enforce_twofactor: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
        use_account_custom_ns_by_default: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether new zones should use the account-level custom
        nameservers by default.

        Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
elif False:
    AccountSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountSettingsArgs:
    def __init__(__self__, *,
                 abuse_contact_email: Optional[pulumi.Input[str]] = None,
                 default_nameservers: Optional[pulumi.Input[str]] = None,
                 enforce_twofactor: Optional[pulumi.Input[bool]] = None,
                 use_account_custom_ns_by_default: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] abuse_contact_email: Sets an abuse contact email to notify for abuse reports.
        :param pulumi.Input[str] default_nameservers: Specifies the default nameservers to be used for new zones added to this account.
        :param pulumi.Input[bool] enforce_twofactor: Indicates whether membership in this account requires that
               Two-Factor Authentication is enabled
        :param pulumi.Input[bool] use_account_custom_ns_by_default: Indicates whether new zones should use the account-level custom
               nameservers by default.
               
               Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        if abuse_contact_email is not None:
            pulumi.set(__self__, "abuse_contact_email", abuse_contact_email)
        if default_nameservers is not None:
            pulumi.set(__self__, "default_nameservers", default_nameservers)
        if enforce_twofactor is not None:
            pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)
        if use_account_custom_ns_by_default is not None:
            pulumi.set(__self__, "use_account_custom_ns_by_default", use_account_custom_ns_by_default)

    @property
    @pulumi.getter(name="abuseContactEmail")
    def abuse_contact_email(self) -> Optional[pulumi.Input[str]]:
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        return pulumi.get(self, "abuse_contact_email")

    @abuse_contact_email.setter
    def abuse_contact_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "abuse_contact_email", value)

    @property
    @pulumi.getter(name="defaultNameservers")
    def default_nameservers(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the default nameservers to be used for new zones added to this account.
        """
        return pulumi.get(self, "default_nameservers")

    @default_nameservers.setter
    def default_nameservers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_nameservers", value)

    @property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
        return pulumi.get(self, "enforce_twofactor")

    @enforce_twofactor.setter
    def enforce_twofactor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce_twofactor", value)

    @property
    @pulumi.getter(name="useAccountCustomNsByDefault")
    def use_account_custom_ns_by_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether new zones should use the account-level custom
        nameservers by default.

        Deprecated in favor of [DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-an-account-update-dns-settings).
        """
        return pulumi.get(self, "use_account_custom_ns_by_default")

    @use_account_custom_ns_by_default.setter
    def use_account_custom_ns_by_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_account_custom_ns_by_default", value)


if not MYPY:
    class AccountSubscriptionRatePlanArgsDict(TypedDict):
        currency: NotRequired[pulumi.Input[str]]
        """
        The currency applied to the rate plan subscription.
        """
        externally_managed: NotRequired[pulumi.Input[bool]]
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the rate plan.
        """
        is_contract: NotRequired[pulumi.Input[bool]]
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        public_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the rate plan.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The scope that this rate plan applies to.
        """
        sets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of sets this rate plan applies to.
        """
elif False:
    AccountSubscriptionRatePlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountSubscriptionRatePlanArgs:
    def __init__(__self__, *,
                 currency: Optional[pulumi.Input[str]] = None,
                 externally_managed: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_contract: Optional[pulumi.Input[bool]] = None,
                 public_name: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] currency: The currency applied to the rate plan subscription.
        :param pulumi.Input[bool] externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param pulumi.Input[str] id: The ID of the rate plan.
        :param pulumi.Input[bool] is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param pulumi.Input[str] public_name: The full name of the rate plan.
        :param pulumi.Input[str] scope: The scope that this rate plan applies to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sets: The list of sets this rate plan applies to.
        """
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_contract is not None:
            pulumi.set(__self__, "is_contract", is_contract)
        if public_name is not None:
            pulumi.set(__self__, "public_name", public_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[str]]:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @externally_managed.setter
    def externally_managed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "externally_managed", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the rate plan.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @is_contract.setter
    def is_contract(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contract", value)

    @property
    @pulumi.getter(name="publicName")
    def public_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @public_name.setter
    def public_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_name", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")

    @sets.setter
    def sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sets", value)


if not MYPY:
    class AccountTokenConditionArgsDict(TypedDict):
        request_ip: NotRequired[pulumi.Input['AccountTokenConditionRequestIpArgsDict']]
        """
        Client IP restrictions.
        """
elif False:
    AccountTokenConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenConditionArgs:
    def __init__(__self__, *,
                 request_ip: Optional[pulumi.Input['AccountTokenConditionRequestIpArgs']] = None):
        """
        :param pulumi.Input['AccountTokenConditionRequestIpArgs'] request_ip: Client IP restrictions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input['AccountTokenConditionRequestIpArgs']]:
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input['AccountTokenConditionRequestIpArgs']]):
        pulumi.set(self, "request_ip", value)


if not MYPY:
    class AccountTokenConditionRequestIpArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
elif False:
    AccountTokenConditionRequestIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenConditionRequestIpArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ins: List of IPv4/IPv6 CIDR addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class AccountTokenPolicyArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        Allow or deny operations against the resources.
        """
        permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgsDict']]]
        """
        A set of permission groups that are specified to the policy.
        """
        resources: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        A list of resource names that the policy applies to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Policy identifier.
        """
elif False:
    AccountTokenPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenPolicyArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]],
                 resources: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Allow or deny operations against the resources.
        :param pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]] permission_groups: A set of permission groups that are specified to the policy.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resources: A list of resource names that the policy applies to.
        :param pulumi.Input[str] id: Policy identifier.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]]:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]]):
        pulumi.set(self, "permission_groups", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountTokenPolicyPermissionGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Identifier of the group.
        """
        meta: NotRequired[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgsDict']]
        """
        Attributes associated to the permission group.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the group.
        """
elif False:
    AccountTokenPolicyPermissionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenPolicyPermissionGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 meta: Optional[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Identifier of the group.
        :param pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs'] meta: Attributes associated to the permission group.
        :param pulumi.Input[str] name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def meta(self) -> Optional[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs']]:
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @meta.setter
    def meta(self, value: Optional[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs']]):
        pulumi.set(self, "meta", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccountTokenPolicyPermissionGroupMetaArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    AccountTokenPolicyPermissionGroupMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenPolicyPermissionGroupMetaArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AccountUnitArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Tenant unit ID
        """
elif False:
    AccountUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountUnitArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Tenant unit ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Tenant unit ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AddressMapMembershipArgsDict(TypedDict):
        can_delete: NotRequired[pulumi.Input[bool]]
        """
        Controls whether the membership can be deleted via the API or not.
        """
        created_at: NotRequired[pulumi.Input[str]]
        identifier: NotRequired[pulumi.Input[str]]
        """
        The identifier for the membership (eg. a zone or account tag).
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        The type of the membership.
        """
elif False:
    AddressMapMembershipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressMapMembershipArgs:
    def __init__(__self__, *,
                 can_delete: Optional[pulumi.Input[bool]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 identifier: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] can_delete: Controls whether the membership can be deleted via the API or not.
        :param pulumi.Input[str] identifier: The identifier for the membership (eg. a zone or account tag).
        :param pulumi.Input[str] kind: The type of the membership.
        """
        if can_delete is not None:
            pulumi.set(__self__, "can_delete", can_delete)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")

    @can_delete.setter
    def can_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_delete", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the membership (eg. a zone or account tag).
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the membership.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class ApiShieldAuthIdCharacteristicArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the characteristic field, i.e., the header or cookie name.
        """
        type: pulumi.Input[str]
        """
        The type of characteristic.
        """
elif False:
    ApiShieldAuthIdCharacteristicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldAuthIdCharacteristicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the characteristic field, i.e., the header or cookie name.
        :param pulumi.Input[str] type: The type of characteristic.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the characteristic field, i.e., the header or cookie name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of characteristic.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiShieldErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        message: NotRequired[pulumi.Input[str]]
elif False:
    ApiShieldErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class ApiShieldMessageArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        message: NotRequired[pulumi.Input[str]]
elif False:
    ApiShieldMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldMessageArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class ApiShieldOperationFeaturesArgsDict(TypedDict):
        api_routing: NotRequired[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgsDict']]
        """
        API Routing settings on endpoint.
        """
        confidence_intervals: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgsDict']]
        parameter_schemas: NotRequired[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgsDict']]
        schema_info: NotRequired[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgsDict']]
        thresholds: NotRequired[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgsDict']]
elif False:
    ApiShieldOperationFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesArgs:
    def __init__(__self__, *,
                 api_routing: Optional[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs']] = None,
                 confidence_intervals: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgs']] = None,
                 parameter_schemas: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgs']] = None,
                 schema_info: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgs']] = None,
                 thresholds: Optional[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgs']] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs'] api_routing: API Routing settings on endpoint.
        """
        if api_routing is not None:
            pulumi.set(__self__, "api_routing", api_routing)
        if confidence_intervals is not None:
            pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        if parameter_schemas is not None:
            pulumi.set(__self__, "parameter_schemas", parameter_schemas)
        if schema_info is not None:
            pulumi.set(__self__, "schema_info", schema_info)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @property
    @pulumi.getter(name="apiRouting")
    def api_routing(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs']]:
        """
        API Routing settings on endpoint.
        """
        return pulumi.get(self, "api_routing")

    @api_routing.setter
    def api_routing(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs']]):
        pulumi.set(self, "api_routing", value)

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgs']]:
        return pulumi.get(self, "confidence_intervals")

    @confidence_intervals.setter
    def confidence_intervals(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgs']]):
        pulumi.set(self, "confidence_intervals", value)

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgs']]:
        return pulumi.get(self, "parameter_schemas")

    @parameter_schemas.setter
    def parameter_schemas(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgs']]):
        pulumi.set(self, "parameter_schemas", value)

    @property
    @pulumi.getter(name="schemaInfo")
    def schema_info(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgs']]:
        return pulumi.get(self, "schema_info")

    @schema_info.setter
    def schema_info(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgs']]):
        pulumi.set(self, "schema_info", value)

    @property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgs']]:
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgs']]):
        pulumi.set(self, "thresholds", value)


if not MYPY:
    class ApiShieldOperationFeaturesApiRoutingArgsDict(TypedDict):
        last_updated: NotRequired[pulumi.Input[str]]
        route: NotRequired[pulumi.Input[str]]
        """
        Target route.
        """
elif False:
    ApiShieldOperationFeaturesApiRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesApiRoutingArgs:
    def __init__(__self__, *,
                 last_updated: Optional[pulumi.Input[str]] = None,
                 route: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] route: Target route.
        """
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[str]]:
        """
        Target route.
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsArgsDict(TypedDict):
        last_updated: NotRequired[pulumi.Input[str]]
        suggested_threshold: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict']]
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsArgs:
    def __init__(__self__, *,
                 last_updated: Optional[pulumi.Input[str]] = None,
                 suggested_threshold: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs']] = None):
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if suggested_threshold is not None:
            pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated", value)

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs']]:
        return pulumi.get(self, "suggested_threshold")

    @suggested_threshold.setter
    def suggested_threshold(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs']]):
        pulumi.set(self, "suggested_threshold", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict(TypedDict):
        confidence_intervals: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict']]
        mean: NotRequired[pulumi.Input[float]]
        """
        Suggested threshold.
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs:
    def __init__(__self__, *,
                 confidence_intervals: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs']] = None,
                 mean: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] mean: Suggested threshold.
        """
        if confidence_intervals is not None:
            pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        if mean is not None:
            pulumi.set(__self__, "mean", mean)

    @property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs']]:
        return pulumi.get(self, "confidence_intervals")

    @confidence_intervals.setter
    def confidence_intervals(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs']]):
        pulumi.set(self, "confidence_intervals", value)

    @property
    @pulumi.getter
    def mean(self) -> Optional[pulumi.Input[float]]:
        """
        Suggested threshold.
        """
        return pulumi.get(self, "mean")

    @mean.setter
    def mean(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "mean", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict(TypedDict):
        p90: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict']]
        """
        Upper and lower bound for percentile estimate
        """
        p95: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict']]
        """
        Upper and lower bound for percentile estimate
        """
        p99: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict']]
        """
        Upper and lower bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs:
    def __init__(__self__, *,
                 p90: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args']] = None,
                 p95: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args']] = None,
                 p99: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args']] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args'] p90: Upper and lower bound for percentile estimate
        :param pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args'] p95: Upper and lower bound for percentile estimate
        :param pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args'] p99: Upper and lower bound for percentile estimate
        """
        if p90 is not None:
            pulumi.set(__self__, "p90", p90)
        if p95 is not None:
            pulumi.set(__self__, "p95", p95)
        if p99 is not None:
            pulumi.set(__self__, "p99", p99)

    @property
    @pulumi.getter
    def p90(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args']]:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p90")

    @p90.setter
    def p90(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args']]):
        pulumi.set(self, "p90", value)

    @property
    @pulumi.getter
    def p95(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args']]:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p95")

    @p95.setter
    def p95(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args']]):
        pulumi.set(self, "p95", value)

    @property
    @pulumi.getter
    def p99(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args']]:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p99")

    @p99.setter
    def p99(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args']]):
        pulumi.set(self, "p99", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[float]]
        """
        Lower bound for percentile estimate
        """
        upper: NotRequired[pulumi.Input[float]]
        """
        Upper bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[float]] = None,
                 upper: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] lower: Lower bound for percentile estimate
        :param pulumi.Input[float] upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[float]]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lower", value)

    @property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[float]]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[float]]
        """
        Lower bound for percentile estimate
        """
        upper: NotRequired[pulumi.Input[float]]
        """
        Upper bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[float]] = None,
                 upper: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] lower: Lower bound for percentile estimate
        :param pulumi.Input[float] upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[float]]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lower", value)

    @property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[float]]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[float]]
        """
        Lower bound for percentile estimate
        """
        upper: NotRequired[pulumi.Input[float]]
        """
        Upper bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[float]] = None,
                 upper: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] lower: Lower bound for percentile estimate
        :param pulumi.Input[float] upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[float]]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lower", value)

    @property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[float]]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ApiShieldOperationFeaturesParameterSchemasArgsDict(TypedDict):
        last_updated: NotRequired[pulumi.Input[str]]
        parameter_schemas: NotRequired[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict']]
        """
        An operation schema object containing a response.
        """
elif False:
    ApiShieldOperationFeaturesParameterSchemasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesParameterSchemasArgs:
    def __init__(__self__, *,
                 last_updated: Optional[pulumi.Input[str]] = None,
                 parameter_schemas: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs']] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs'] parameter_schemas: An operation schema object containing a response.
        """
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if parameter_schemas is not None:
            pulumi.set(__self__, "parameter_schemas", parameter_schemas)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated", value)

    @property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs']]:
        """
        An operation schema object containing a response.
        """
        return pulumi.get(self, "parameter_schemas")

    @parameter_schemas.setter
    def parameter_schemas(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs']]):
        pulumi.set(self, "parameter_schemas", value)


if not MYPY:
    class ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the learned parameter schemas.
        """
        responses: NotRequired[pulumi.Input[str]]
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
elif False:
    ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responses: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: An array containing the learned parameter schemas.
        :param pulumi.Input[str] responses: An empty response object. This field is required to yield a valid operation schema.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the learned parameter schemas.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[str]]:
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class ApiShieldOperationFeaturesSchemaInfoArgsDict(TypedDict):
        active_schema: NotRequired[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict']]
        """
        Schema active on endpoint.
        """
        learned_available: NotRequired[pulumi.Input[bool]]
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        mitigation_action: NotRequired[pulumi.Input[str]]
        """
        Action taken on requests failing validation.
        """
elif False:
    ApiShieldOperationFeaturesSchemaInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesSchemaInfoArgs:
    def __init__(__self__, *,
                 active_schema: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs']] = None,
                 learned_available: Optional[pulumi.Input[bool]] = None,
                 mitigation_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs'] active_schema: Schema active on endpoint.
        :param pulumi.Input[bool] learned_available: True if a Cloudflare-provided learned schema is available for this endpoint.
        :param pulumi.Input[str] mitigation_action: Action taken on requests failing validation.
        """
        if active_schema is not None:
            pulumi.set(__self__, "active_schema", active_schema)
        if learned_available is not None:
            pulumi.set(__self__, "learned_available", learned_available)
        if mitigation_action is not None:
            pulumi.set(__self__, "mitigation_action", mitigation_action)

    @property
    @pulumi.getter(name="activeSchema")
    def active_schema(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs']]:
        """
        Schema active on endpoint.
        """
        return pulumi.get(self, "active_schema")

    @active_schema.setter
    def active_schema(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs']]):
        pulumi.set(self, "active_schema", value)

    @property
    @pulumi.getter(name="learnedAvailable")
    def learned_available(self) -> Optional[pulumi.Input[bool]]:
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        return pulumi.get(self, "learned_available")

    @learned_available.setter
    def learned_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "learned_available", value)

    @property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action taken on requests failing validation.
        """
        return pulumi.get(self, "mitigation_action")

    @mitigation_action.setter
    def mitigation_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mitigation_action", value)


if not MYPY:
    class ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        """
        UUID
        """
        is_learned: NotRequired[pulumi.Input[bool]]
        """
        True if schema is Cloudflare-provided.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Schema file name.
        """
elif False:
    ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_learned: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: UUID
        :param pulumi.Input[bool] is_learned: True if schema is Cloudflare-provided.
        :param pulumi.Input[str] name: Schema file name.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_learned is not None:
            pulumi.set(__self__, "is_learned", is_learned)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isLearned")
    def is_learned(self) -> Optional[pulumi.Input[bool]]:
        """
        True if schema is Cloudflare-provided.
        """
        return pulumi.get(self, "is_learned")

    @is_learned.setter
    def is_learned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_learned", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Schema file name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApiShieldOperationFeaturesThresholdsArgsDict(TypedDict):
        auth_id_tokens: NotRequired[pulumi.Input[int]]
        """
        The total number of auth-ids seen across this calculation.
        """
        data_points: NotRequired[pulumi.Input[int]]
        """
        The number of data points used for the threshold suggestion calculation.
        """
        last_updated: NotRequired[pulumi.Input[str]]
        p50: NotRequired[pulumi.Input[int]]
        """
        The p50 quantile of requests (in period_seconds).
        """
        p90: NotRequired[pulumi.Input[int]]
        """
        The p90 quantile of requests (in period_seconds).
        """
        p99: NotRequired[pulumi.Input[int]]
        """
        The p99 quantile of requests (in period_seconds).
        """
        period_seconds: NotRequired[pulumi.Input[int]]
        """
        The period over which this threshold is suggested.
        """
        requests: NotRequired[pulumi.Input[int]]
        """
        The estimated number of requests covered by these calculations.
        """
        suggested_threshold: NotRequired[pulumi.Input[int]]
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
elif False:
    ApiShieldOperationFeaturesThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesThresholdsArgs:
    def __init__(__self__, *,
                 auth_id_tokens: Optional[pulumi.Input[int]] = None,
                 data_points: Optional[pulumi.Input[int]] = None,
                 last_updated: Optional[pulumi.Input[str]] = None,
                 p50: Optional[pulumi.Input[int]] = None,
                 p90: Optional[pulumi.Input[int]] = None,
                 p99: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 requests: Optional[pulumi.Input[int]] = None,
                 suggested_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] auth_id_tokens: The total number of auth-ids seen across this calculation.
        :param pulumi.Input[int] data_points: The number of data points used for the threshold suggestion calculation.
        :param pulumi.Input[int] p50: The p50 quantile of requests (in period_seconds).
        :param pulumi.Input[int] p90: The p90 quantile of requests (in period_seconds).
        :param pulumi.Input[int] p99: The p99 quantile of requests (in period_seconds).
        :param pulumi.Input[int] period_seconds: The period over which this threshold is suggested.
        :param pulumi.Input[int] requests: The estimated number of requests covered by these calculations.
        :param pulumi.Input[int] suggested_threshold: The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        if auth_id_tokens is not None:
            pulumi.set(__self__, "auth_id_tokens", auth_id_tokens)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if p50 is not None:
            pulumi.set(__self__, "p50", p50)
        if p90 is not None:
            pulumi.set(__self__, "p90", p90)
        if p99 is not None:
            pulumi.set(__self__, "p99", p99)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if suggested_threshold is not None:
            pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @property
    @pulumi.getter(name="authIdTokens")
    def auth_id_tokens(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of auth-ids seen across this calculation.
        """
        return pulumi.get(self, "auth_id_tokens")

    @auth_id_tokens.setter
    def auth_id_tokens(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_id_tokens", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[int]]:
        """
        The number of data points used for the threshold suggestion calculation.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated", value)

    @property
    @pulumi.getter
    def p50(self) -> Optional[pulumi.Input[int]]:
        """
        The p50 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p50")

    @p50.setter
    def p50(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "p50", value)

    @property
    @pulumi.getter
    def p90(self) -> Optional[pulumi.Input[int]]:
        """
        The p90 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p90")

    @p90.setter
    def p90(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "p90", value)

    @property
    @pulumi.getter
    def p99(self) -> Optional[pulumi.Input[int]]:
        """
        The p99 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p99")

    @p99.setter
    def p99(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "p99", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The period over which this threshold is suggested.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[int]]:
        """
        The estimated number of requests covered by these calculations.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        return pulumi.get(self, "suggested_threshold")

    @suggested_threshold.setter
    def suggested_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suggested_threshold", value)


if not MYPY:
    class ApiShieldSchemaSchemaArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        kind: NotRequired[pulumi.Input[str]]
        """
        Kind of schema
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the schema
        """
        schema_id: NotRequired[pulumi.Input[str]]
        """
        UUID
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Source of the schema
        """
        validation_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag whether schema is enabled for validation.
        """
elif False:
    ApiShieldSchemaSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldSchemaSchemaArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 schema_id: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 validation_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] kind: Kind of schema
        :param pulumi.Input[str] name: Name of the schema
        :param pulumi.Input[str] schema_id: UUID
        :param pulumi.Input[str] source: Source of the schema
        :param pulumi.Input[bool] validation_enabled: Flag whether schema is enabled for validation.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if validation_enabled is not None:
            pulumi.set(__self__, "validation_enabled", validation_enabled)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of schema
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID
        """
        return pulumi.get(self, "schema_id")

    @schema_id.setter
    def schema_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_id", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Source of the schema
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="validationEnabled")
    def validation_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag whether schema is enabled for validation.
        """
        return pulumi.get(self, "validation_enabled")

    @validation_enabled.setter
    def validation_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validation_enabled", value)


if not MYPY:
    class ApiShieldSchemaUploadDetailsArgsDict(TypedDict):
        warnings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgsDict']]]]
        """
        Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
elif False:
    ApiShieldSchemaUploadDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldSchemaUploadDetailsArgs:
    def __init__(__self__, *,
                 warnings: Optional[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]] warnings: Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter
    def warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]]]:
        """
        Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
        return pulumi.get(self, "warnings")

    @warnings.setter
    def warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]]]):
        pulumi.set(self, "warnings", value)


if not MYPY:
    class ApiShieldSchemaUploadDetailsWarningArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        Code that identifies the event that occurred.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Diagnostic message that describes the event.
        """
elif False:
    ApiShieldSchemaUploadDetailsWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldSchemaUploadDetailsWarningArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: Code that identifies the event that occurred.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        :param pulumi.Input[str] message: Diagnostic message that describes the event.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        Code that identifies the event that occurred.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Diagnostic message that describes the event.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class ApiTokenConditionArgsDict(TypedDict):
        request_ip: NotRequired[pulumi.Input['ApiTokenConditionRequestIpArgsDict']]
        """
        Client IP restrictions.
        """
elif False:
    ApiTokenConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenConditionArgs:
    def __init__(__self__, *,
                 request_ip: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']] = None):
        """
        :param pulumi.Input['ApiTokenConditionRequestIpArgs'] request_ip: Client IP restrictions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]:
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]):
        pulumi.set(self, "request_ip", value)


if not MYPY:
    class ApiTokenConditionRequestIpArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
elif False:
    ApiTokenConditionRequestIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenConditionRequestIpArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ins: List of IPv4/IPv6 CIDR addresses.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ApiTokenPolicyArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        Allow or deny operations against the resources.
        """
        permission_groups: pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgsDict']]]
        """
        A set of permission groups that are specified to the policy.
        """
        resources: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        A list of resource names that the policy applies to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Policy identifier.
        """
elif False:
    ApiTokenPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 permission_groups: pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]],
                 resources: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Allow or deny operations against the resources.
        :param pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]] permission_groups: A set of permission groups that are specified to the policy.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resources: A list of resource names that the policy applies to.
        :param pulumi.Input[str] id: Policy identifier.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Allow or deny operations against the resources.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]]:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]]):
        pulumi.set(self, "permission_groups", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ApiTokenPolicyPermissionGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Identifier of the group.
        """
        meta: NotRequired[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgsDict']]
        """
        Attributes associated to the permission group.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the group.
        """
elif False:
    ApiTokenPolicyPermissionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyPermissionGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 meta: Optional[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Identifier of the group.
        :param pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs'] meta: Attributes associated to the permission group.
        :param pulumi.Input[str] name: Name of the group.
        """
        pulumi.set(__self__, "id", id)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def meta(self) -> Optional[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs']]:
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @meta.setter
    def meta(self, value: Optional[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs']]):
        pulumi.set(self, "meta", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApiTokenPolicyPermissionGroupMetaArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ApiTokenPolicyPermissionGroupMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyPermissionGroupMetaArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AuthenticatedOriginPullsConfigArgsDict(TypedDict):
        cert_id: NotRequired[pulumi.Input[str]]
        """
        Certificate identifier tag.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        The hostname on the origin for which the client certificate uploaded will be used.
        """
elif False:
    AuthenticatedOriginPullsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticatedOriginPullsConfigArgs:
    def __init__(__self__, *,
                 cert_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cert_id: Certificate identifier tag.
        :param pulumi.Input[bool] enabled: Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        :param pulumi.Input[str] hostname: The hostname on the origin for which the client certificate uploaded will be used.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate identifier tag.
        """
        return pulumi.get(self, "cert_id")

    @cert_id.setter
    def cert_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname on the origin for which the client certificate uploaded will be used.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class BotManagementStaleZoneConfigurationArgsDict(TypedDict):
        fight_mode: NotRequired[pulumi.Input[bool]]
        """
        Indicates that the zone's Bot Fight Mode is turned on.
        """
        optimize_wordpress: NotRequired[pulumi.Input[bool]]
        """
        Indicates that the zone's wordpress optimization for SBFM is turned on.
        """
        sbfm_definitely_automated: NotRequired[pulumi.Input[str]]
        """
        Indicates that the zone's definitely automated requests are being blocked or challenged.
        """
        sbfm_likely_automated: NotRequired[pulumi.Input[str]]
        """
        Indicates that the zone's likely automated requests are being blocked or challenged.
        """
        sbfm_static_resource_protection: NotRequired[pulumi.Input[str]]
        """
        Indicates that the zone's static resource protection is turned on.
        """
        sbfm_verified_bots: NotRequired[pulumi.Input[str]]
        """
        Indicates that the zone's verified bot requests are being blocked.
        """
        suppress_session_score: NotRequired[pulumi.Input[bool]]
        """
        Indicates that the zone's session score tracking is disabled.
        """
elif False:
    BotManagementStaleZoneConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotManagementStaleZoneConfigurationArgs:
    def __init__(__self__, *,
                 fight_mode: Optional[pulumi.Input[bool]] = None,
                 optimize_wordpress: Optional[pulumi.Input[bool]] = None,
                 sbfm_definitely_automated: Optional[pulumi.Input[str]] = None,
                 sbfm_likely_automated: Optional[pulumi.Input[str]] = None,
                 sbfm_static_resource_protection: Optional[pulumi.Input[str]] = None,
                 sbfm_verified_bots: Optional[pulumi.Input[str]] = None,
                 suppress_session_score: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] fight_mode: Indicates that the zone's Bot Fight Mode is turned on.
        :param pulumi.Input[bool] optimize_wordpress: Indicates that the zone's wordpress optimization for SBFM is turned on.
        :param pulumi.Input[str] sbfm_definitely_automated: Indicates that the zone's definitely automated requests are being blocked or challenged.
        :param pulumi.Input[str] sbfm_likely_automated: Indicates that the zone's likely automated requests are being blocked or challenged.
        :param pulumi.Input[str] sbfm_static_resource_protection: Indicates that the zone's static resource protection is turned on.
        :param pulumi.Input[str] sbfm_verified_bots: Indicates that the zone's verified bot requests are being blocked.
        :param pulumi.Input[bool] suppress_session_score: Indicates that the zone's session score tracking is disabled.
        """
        if fight_mode is not None:
            pulumi.set(__self__, "fight_mode", fight_mode)
        if optimize_wordpress is not None:
            pulumi.set(__self__, "optimize_wordpress", optimize_wordpress)
        if sbfm_definitely_automated is not None:
            pulumi.set(__self__, "sbfm_definitely_automated", sbfm_definitely_automated)
        if sbfm_likely_automated is not None:
            pulumi.set(__self__, "sbfm_likely_automated", sbfm_likely_automated)
        if sbfm_static_resource_protection is not None:
            pulumi.set(__self__, "sbfm_static_resource_protection", sbfm_static_resource_protection)
        if sbfm_verified_bots is not None:
            pulumi.set(__self__, "sbfm_verified_bots", sbfm_verified_bots)
        if suppress_session_score is not None:
            pulumi.set(__self__, "suppress_session_score", suppress_session_score)

    @property
    @pulumi.getter(name="fightMode")
    def fight_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the zone's Bot Fight Mode is turned on.
        """
        return pulumi.get(self, "fight_mode")

    @fight_mode.setter
    def fight_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fight_mode", value)

    @property
    @pulumi.getter(name="optimizeWordpress")
    def optimize_wordpress(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the zone's wordpress optimization for SBFM is turned on.
        """
        return pulumi.get(self, "optimize_wordpress")

    @optimize_wordpress.setter
    def optimize_wordpress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optimize_wordpress", value)

    @property
    @pulumi.getter(name="sbfmDefinitelyAutomated")
    def sbfm_definitely_automated(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates that the zone's definitely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_definitely_automated")

    @sbfm_definitely_automated.setter
    def sbfm_definitely_automated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sbfm_definitely_automated", value)

    @property
    @pulumi.getter(name="sbfmLikelyAutomated")
    def sbfm_likely_automated(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates that the zone's likely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_likely_automated")

    @sbfm_likely_automated.setter
    def sbfm_likely_automated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sbfm_likely_automated", value)

    @property
    @pulumi.getter(name="sbfmStaticResourceProtection")
    def sbfm_static_resource_protection(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates that the zone's static resource protection is turned on.
        """
        return pulumi.get(self, "sbfm_static_resource_protection")

    @sbfm_static_resource_protection.setter
    def sbfm_static_resource_protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sbfm_static_resource_protection", value)

    @property
    @pulumi.getter(name="sbfmVerifiedBots")
    def sbfm_verified_bots(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates that the zone's verified bot requests are being blocked.
        """
        return pulumi.get(self, "sbfm_verified_bots")

    @sbfm_verified_bots.setter
    def sbfm_verified_bots(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sbfm_verified_bots", value)

    @property
    @pulumi.getter(name="suppressSessionScore")
    def suppress_session_score(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the zone's session score tracking is disabled.
        """
        return pulumi.get(self, "suppress_session_score")

    @suppress_session_score.setter
    def suppress_session_score(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress_session_score", value)


if not MYPY:
    class CloudConnectorRulesParametersArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        Host to perform Cloud Connection to
        """
elif False:
    CloudConnectorRulesParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesParametersArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: Host to perform Cloud Connection to
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host to perform Cloud Connection to
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class CloudConnectorRulesRuleArgsDict(TypedDict):
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        Cloud Provider type
        """
        description: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        expression: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        parameters: NotRequired[pulumi.Input['CloudConnectorRulesRuleParametersArgsDict']]
        """
        Parameters of Cloud Connector Rule
        """
elif False:
    CloudConnectorRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesRuleArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']] = None):
        """
        :param pulumi.Input[str] cloud_provider: Cloud Provider type
        :param pulumi.Input['CloudConnectorRulesRuleParametersArgs'] parameters: Parameters of Cloud Connector Rule
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Provider type
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']]:
        """
        Parameters of Cloud Connector Rule
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class CloudConnectorRulesRuleParametersArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        Host to perform Cloud Connection to
        """
elif False:
    CloudConnectorRulesRuleParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesRuleParametersArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: Host to perform Cloud Connection to
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host to perform Cloud Connection to
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ContentScanningExpressionBodyArgsDict(TypedDict):
        payload: pulumi.Input[str]
        """
        Ruleset expression to use in matching content objects
        """
elif False:
    ContentScanningExpressionBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContentScanningExpressionBodyArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[str]):
        """
        :param pulumi.Input[str] payload: Ruleset expression to use in matching content objects
        """
        pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter
    def payload(self) -> pulumi.Input[str]:
        """
        Ruleset expression to use in matching content objects
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class CustomHostnameOwnershipVerificationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        DNS Name for record.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        DNS Record type.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Content for the record.
        """
elif False:
    CustomHostnameOwnershipVerificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameOwnershipVerificationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: DNS Name for record.
        :param pulumi.Input[str] type: DNS Record type.
        :param pulumi.Input[str] value: Content for the record.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS Name for record.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        DNS Record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Content for the record.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomHostnameOwnershipVerificationHttpArgsDict(TypedDict):
        http_body: NotRequired[pulumi.Input[str]]
        """
        Token to be served.
        """
        http_url: NotRequired[pulumi.Input[str]]
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
elif False:
    CustomHostnameOwnershipVerificationHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameOwnershipVerificationHttpArgs:
    def __init__(__self__, *,
                 http_body: Optional[pulumi.Input[str]] = None,
                 http_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_body: Token to be served.
        :param pulumi.Input[str] http_url: The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)

    @property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[str]]:
        """
        Token to be served.
        """
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_body", value)

    @property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_url", value)


if not MYPY:
    class CustomHostnameSslArgsDict(TypedDict):
        bundle_method: NotRequired[pulumi.Input[str]]
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        """
        certificate_authority: NotRequired[pulumi.Input[str]]
        """
        The Certificate Authority that will issue the certificate
        """
        cloudflare_branding: NotRequired[pulumi.Input[bool]]
        """
        Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        """
        custom_cert_bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgsDict']]]]
        """
        Array of custom certificate and key pairs (1 or 2 pairs allowed)
        """
        custom_certificate: NotRequired[pulumi.Input[str]]
        """
        If a custom uploaded certificate is used.
        """
        custom_key: NotRequired[pulumi.Input[str]]
        """
        The key for a custom uploaded certificate.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        Domain control validation (DCV) method used for this hostname.
        """
        settings: NotRequired[pulumi.Input['CustomHostnameSslSettingsArgsDict']]
        """
        SSL specific settings.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the certificate covers a wildcard.
        """
elif False:
    CustomHostnameSslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslArgs:
    def __init__(__self__, *,
                 bundle_method: Optional[pulumi.Input[str]] = None,
                 certificate_authority: Optional[pulumi.Input[str]] = None,
                 cloudflare_branding: Optional[pulumi.Input[bool]] = None,
                 custom_cert_bundles: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]]] = None,
                 custom_certificate: Optional[pulumi.Input[str]] = None,
                 custom_key: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input['CustomHostnameSslSettingsArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        :param pulumi.Input[str] certificate_authority: The Certificate Authority that will issue the certificate
        :param pulumi.Input[bool] cloudflare_branding: Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        :param pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]] custom_cert_bundles: Array of custom certificate and key pairs (1 or 2 pairs allowed)
        :param pulumi.Input[str] custom_certificate: If a custom uploaded certificate is used.
        :param pulumi.Input[str] custom_key: The key for a custom uploaded certificate.
        :param pulumi.Input[str] method: Domain control validation (DCV) method used for this hostname.
        :param pulumi.Input['CustomHostnameSslSettingsArgs'] settings: SSL specific settings.
        :param pulumi.Input[str] type: Level of validation to be used for this hostname. Domain validation (dv) must be used.
        :param pulumi.Input[bool] wildcard: Indicates whether the certificate covers a wildcard.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cloudflare_branding is not None:
            pulumi.set(__self__, "cloudflare_branding", cloudflare_branding)
        if custom_cert_bundles is not None:
            pulumi.set(__self__, "custom_cert_bundles", custom_cert_bundles)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[pulumi.Input[str]]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        """
        return pulumi.get(self, "bundle_method")

    @bundle_method.setter
    def bundle_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bundle_method", value)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[str]]:
        """
        The Certificate Authority that will issue the certificate
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_authority", value)

    @property
    @pulumi.getter(name="cloudflareBranding")
    def cloudflare_branding(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        """
        return pulumi.get(self, "cloudflare_branding")

    @cloudflare_branding.setter
    def cloudflare_branding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloudflare_branding", value)

    @property
    @pulumi.getter(name="customCertBundles")
    def custom_cert_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]]]:
        """
        Array of custom certificate and key pairs (1 or 2 pairs allowed)
        """
        return pulumi.get(self, "custom_cert_bundles")

    @custom_cert_bundles.setter
    def custom_cert_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]]]):
        pulumi.set(self, "custom_cert_bundles", value)

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_certificate", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_key", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Domain control validation (DCV) method used for this hostname.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['CustomHostnameSslSettingsArgs']]:
        """
        SSL specific settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['CustomHostnameSslSettingsArgs']]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class CustomHostnameSslCustomCertBundleArgsDict(TypedDict):
        custom_certificate: pulumi.Input[str]
        """
        If a custom uploaded certificate is used.
        """
        custom_key: pulumi.Input[str]
        """
        The key for a custom uploaded certificate.
        """
elif False:
    CustomHostnameSslCustomCertBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslCustomCertBundleArgs:
    def __init__(__self__, *,
                 custom_certificate: pulumi.Input[str],
                 custom_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] custom_certificate: If a custom uploaded certificate is used.
        :param pulumi.Input[str] custom_key: The key for a custom uploaded certificate.
        """
        pulumi.set(__self__, "custom_certificate", custom_certificate)
        pulumi.set(__self__, "custom_key", custom_key)

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> pulumi.Input[str]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "custom_certificate", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> pulumi.Input[str]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "custom_key", value)


if not MYPY:
    class CustomHostnameSslSettingsArgsDict(TypedDict):
        ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        early_hints: NotRequired[pulumi.Input[str]]
        """
        Whether or not Early Hints is enabled.
        """
        http2: NotRequired[pulumi.Input[str]]
        """
        Whether or not HTTP2 is enabled.
        """
        min_tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimum TLS version supported.
        """
        tls13: NotRequired[pulumi.Input[str]]
        """
        Whether or not TLS 1.3 is enabled.
        """
elif False:
    CustomHostnameSslSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslSettingsArgs:
    def __init__(__self__, *,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 early_hints: Optional[pulumi.Input[str]] = None,
                 http2: Optional[pulumi.Input[str]] = None,
                 min_tls_version: Optional[pulumi.Input[str]] = None,
                 tls13: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param pulumi.Input[str] early_hints: Whether or not Early Hints is enabled.
        :param pulumi.Input[str] http2: Whether or not HTTP2 is enabled.
        :param pulumi.Input[str] min_tls_version: The minimum TLS version supported.
        :param pulumi.Input[str] tls13: Whether or not TLS 1.3 is enabled.
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ciphers", value)

    @property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not Early Hints is enabled.
        """
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "early_hints", value)

    @property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not HTTP2 is enabled.
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http2", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum TLS version supported.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not TLS 1.3 is enabled.
        """
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls13", value)


if not MYPY:
    class CustomSslGeoRestrictionsArgsDict(TypedDict):
        label: NotRequired[pulumi.Input[str]]
elif False:
    CustomSslGeoRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslGeoRestrictionsArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[str]] = None):
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class CustomSslKeylessServerArgsDict(TypedDict):
        created_on: NotRequired[pulumi.Input[str]]
        """
        When the Keyless SSL was created.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the Keyless SSL is on or off.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The keyless SSL name.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Keyless certificate identifier tag.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        When the Keyless SSL was last modified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The keyless SSL name.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        port: NotRequired[pulumi.Input[float]]
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Status of the Keyless SSL.
        """
        tunnel: NotRequired[pulumi.Input['CustomSslKeylessServerTunnelArgsDict']]
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
elif False:
    CustomSslKeylessServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslKeylessServerArgs:
    def __init__(__self__, *,
                 created_on: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[float]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tunnel: Optional[pulumi.Input['CustomSslKeylessServerTunnelArgs']] = None):
        """
        :param pulumi.Input[str] created_on: When the Keyless SSL was created.
        :param pulumi.Input[bool] enabled: Whether or not the Keyless SSL is on or off.
        :param pulumi.Input[str] host: The keyless SSL name.
        :param pulumi.Input[str] id: Keyless certificate identifier tag.
        :param pulumi.Input[str] modified_on: When the Keyless SSL was last modified.
        :param pulumi.Input[str] name: The keyless SSL name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permissions: Available permissions for the Keyless SSL for the current user requesting the item.
        :param pulumi.Input[float] port: The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        :param pulumi.Input[str] status: Status of the Keyless SSL.
        :param pulumi.Input['CustomSslKeylessServerTunnelArgs'] tunnel: Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the Keyless SSL was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the Keyless SSL is on or off.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Keyless certificate identifier tag.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the Keyless SSL was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the Keyless SSL.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input['CustomSslKeylessServerTunnelArgs']]:
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input['CustomSslKeylessServerTunnelArgs']]):
        pulumi.set(self, "tunnel", value)


if not MYPY:
    class CustomSslKeylessServerTunnelArgsDict(TypedDict):
        private_ip: NotRequired[pulumi.Input[str]]
        """
        Private IP of the Key Server Host
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        Cloudflare Tunnel Virtual Network ID
        """
elif False:
    CustomSslKeylessServerTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslKeylessServerTunnelArgs:
    def __init__(__self__, *,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_ip: Private IP of the Key Server Host
        :param pulumi.Input[str] vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class DnsFirewallAttackMitigationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        only_when_upstream_unhealthy: NotRequired[pulumi.Input[bool]]
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
elif False:
    DnsFirewallAttackMitigationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsFirewallAttackMitigationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 only_when_upstream_unhealthy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        :param pulumi.Input[bool] only_when_upstream_unhealthy: Only mitigate attacks when upstream servers seem unhealthy
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if only_when_upstream_unhealthy is not None:
            pulumi.set(__self__, "only_when_upstream_unhealthy", only_when_upstream_unhealthy)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="onlyWhenUpstreamUnhealthy")
    def only_when_upstream_unhealthy(self) -> Optional[pulumi.Input[bool]]:
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
        return pulumi.get(self, "only_when_upstream_unhealthy")

    @only_when_upstream_unhealthy.setter
    def only_when_upstream_unhealthy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "only_when_upstream_unhealthy", value)


if not MYPY:
    class DnsRecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[float]]
        """
        Algorithm.
        """
        altitude: NotRequired[pulumi.Input[float]]
        """
        Altitude of location in meters.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        Certificate.
        """
        digest: NotRequired[pulumi.Input[str]]
        """
        Digest.
        """
        digest_type: NotRequired[pulumi.Input[float]]
        """
        Digest Type.
        """
        fingerprint: NotRequired[pulumi.Input[str]]
        """
        fingerprint.
        """
        flags: NotRequired[pulumi.Input[float]]
        """
        Flags for the CAA record.
        """
        key_tag: NotRequired[pulumi.Input[float]]
        """
        Key Tag.
        """
        lat_degrees: NotRequired[pulumi.Input[float]]
        """
        Degrees of latitude.
        """
        lat_direction: NotRequired[pulumi.Input[str]]
        """
        Latitude direction.
        """
        lat_minutes: NotRequired[pulumi.Input[float]]
        """
        Minutes of latitude.
        """
        lat_seconds: NotRequired[pulumi.Input[float]]
        """
        Seconds of latitude.
        """
        long_degrees: NotRequired[pulumi.Input[float]]
        """
        Degrees of longitude.
        """
        long_direction: NotRequired[pulumi.Input[str]]
        """
        Longitude direction.
        """
        long_minutes: NotRequired[pulumi.Input[float]]
        """
        Minutes of longitude.
        """
        long_seconds: NotRequired[pulumi.Input[float]]
        """
        Seconds of longitude.
        """
        matching_type: NotRequired[pulumi.Input[float]]
        """
        Matching Type.
        """
        order: NotRequired[pulumi.Input[float]]
        """
        Order.
        """
        port: NotRequired[pulumi.Input[float]]
        """
        The port of the service.
        """
        precision_horz: NotRequired[pulumi.Input[float]]
        """
        Horizontal precision of location.
        """
        precision_vert: NotRequired[pulumi.Input[float]]
        """
        Vertical precision of location.
        """
        preference: NotRequired[pulumi.Input[float]]
        """
        Preference.
        """
        priority: NotRequired[pulumi.Input[float]]
        """
        priority.
        """
        protocol: NotRequired[pulumi.Input[float]]
        """
        Protocol.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        Public Key.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Regex.
        """
        replacement: NotRequired[pulumi.Input[str]]
        """
        Replacement.
        """
        selector: NotRequired[pulumi.Input[float]]
        """
        Selector.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Service.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Size of location in meters.
        """
        tag: NotRequired[pulumi.Input[str]]
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        target: NotRequired[pulumi.Input[str]]
        """
        target.
        """
        type: NotRequired[pulumi.Input[float]]
        """
        Type.
        """
        usage: NotRequired[pulumi.Input[float]]
        """
        Usage.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        weight: NotRequired[pulumi.Input[float]]
        """
        The record weight.
        """
elif False:
    DnsRecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsRecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[float]] = None,
                 altitude: Optional[pulumi.Input[float]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 digest: Optional[pulumi.Input[str]] = None,
                 digest_type: Optional[pulumi.Input[float]] = None,
                 fingerprint: Optional[pulumi.Input[str]] = None,
                 flags: Optional[pulumi.Input[float]] = None,
                 key_tag: Optional[pulumi.Input[float]] = None,
                 lat_degrees: Optional[pulumi.Input[float]] = None,
                 lat_direction: Optional[pulumi.Input[str]] = None,
                 lat_minutes: Optional[pulumi.Input[float]] = None,
                 lat_seconds: Optional[pulumi.Input[float]] = None,
                 long_degrees: Optional[pulumi.Input[float]] = None,
                 long_direction: Optional[pulumi.Input[str]] = None,
                 long_minutes: Optional[pulumi.Input[float]] = None,
                 long_seconds: Optional[pulumi.Input[float]] = None,
                 matching_type: Optional[pulumi.Input[float]] = None,
                 order: Optional[pulumi.Input[float]] = None,
                 port: Optional[pulumi.Input[float]] = None,
                 precision_horz: Optional[pulumi.Input[float]] = None,
                 precision_vert: Optional[pulumi.Input[float]] = None,
                 preference: Optional[pulumi.Input[float]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 protocol: Optional[pulumi.Input[float]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None,
                 selector: Optional[pulumi.Input[float]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[float]] = None,
                 tag: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[float]] = None,
                 usage: Optional[pulumi.Input[float]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] algorithm: Algorithm.
        :param pulumi.Input[float] altitude: Altitude of location in meters.
        :param pulumi.Input[str] certificate: Certificate.
        :param pulumi.Input[str] digest: Digest.
        :param pulumi.Input[float] digest_type: Digest Type.
        :param pulumi.Input[str] fingerprint: fingerprint.
        :param pulumi.Input[float] flags: Flags for the CAA record.
        :param pulumi.Input[float] key_tag: Key Tag.
        :param pulumi.Input[float] lat_degrees: Degrees of latitude.
        :param pulumi.Input[str] lat_direction: Latitude direction.
        :param pulumi.Input[float] lat_minutes: Minutes of latitude.
        :param pulumi.Input[float] lat_seconds: Seconds of latitude.
        :param pulumi.Input[float] long_degrees: Degrees of longitude.
        :param pulumi.Input[str] long_direction: Longitude direction.
        :param pulumi.Input[float] long_minutes: Minutes of longitude.
        :param pulumi.Input[float] long_seconds: Seconds of longitude.
        :param pulumi.Input[float] matching_type: Matching Type.
        :param pulumi.Input[float] order: Order.
        :param pulumi.Input[float] port: The port of the service.
        :param pulumi.Input[float] precision_horz: Horizontal precision of location.
        :param pulumi.Input[float] precision_vert: Vertical precision of location.
        :param pulumi.Input[float] preference: Preference.
        :param pulumi.Input[float] priority: priority.
        :param pulumi.Input[float] protocol: Protocol.
        :param pulumi.Input[str] public_key: Public Key.
        :param pulumi.Input[str] regex: Regex.
        :param pulumi.Input[str] replacement: Replacement.
        :param pulumi.Input[float] selector: Selector.
        :param pulumi.Input[str] service: Service.
        :param pulumi.Input[float] size: Size of location in meters.
        :param pulumi.Input[str] tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param pulumi.Input[str] target: target.
        :param pulumi.Input[float] type: Type.
        :param pulumi.Input[float] usage: Usage.
        :param pulumi.Input[str] value: Value of the record. This field's semantics depend on the chosen tag.
        :param pulumi.Input[float] weight: The record weight.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[float]]:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def altitude(self) -> Optional[pulumi.Input[float]]:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @altitude.setter
    def altitude(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "altitude", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[str]]:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[pulumi.Input[float]]:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @digest_type.setter
    def digest_type(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "digest_type", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[str]]:
        """
        fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[float]]:
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[float]]:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "key_tag", value)

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[pulumi.Input[float]]:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @lat_degrees.setter
    def lat_degrees(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_degrees", value)

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[pulumi.Input[str]]:
        """
        Latitude direction.
        """
        return pulumi.get(self, "lat_direction")

    @lat_direction.setter
    def lat_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lat_direction", value)

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @lat_minutes.setter
    def lat_minutes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_minutes", value)

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @lat_seconds.setter
    def lat_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_seconds", value)

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[pulumi.Input[float]]:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @long_degrees.setter
    def long_degrees(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_degrees", value)

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[pulumi.Input[str]]:
        """
        Longitude direction.
        """
        return pulumi.get(self, "long_direction")

    @long_direction.setter
    def long_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_direction", value)

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @long_minutes.setter
    def long_minutes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_minutes", value)

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @long_seconds.setter
    def long_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_seconds", value)

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[float]]:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "matching_type", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[float]]:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[pulumi.Input[float]]:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @precision_horz.setter
    def precision_horz(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_horz", value)

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[pulumi.Input[float]]:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @precision_vert.setter
    def precision_vert(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_vert", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[float]]:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[float]]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[float]]:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        target.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[float]]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[float]]:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class DnsRecordSettingsArgsDict(TypedDict):
        flatten_cname: NotRequired[pulumi.Input[bool]]
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        ipv4_only: NotRequired[pulumi.Input[bool]]
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        ipv6_only: NotRequired[pulumi.Input[bool]]
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
elif False:
    DnsRecordSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsRecordSettingsArgs:
    def __init__(__self__, *,
                 flatten_cname: Optional[pulumi.Input[bool]] = None,
                 ipv4_only: Optional[pulumi.Input[bool]] = None,
                 ipv6_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param pulumi.Input[bool] ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param pulumi.Input[bool] ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        if flatten_cname is not None:
            pulumi.set(__self__, "flatten_cname", flatten_cname)
        if ipv4_only is not None:
            pulumi.set(__self__, "ipv4_only", ipv4_only)
        if ipv6_only is not None:
            pulumi.set(__self__, "ipv6_only", ipv6_only)

    @property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @flatten_cname.setter
    def flatten_cname(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "flatten_cname", value)

    @property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @ipv4_only.setter
    def ipv4_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4_only", value)

    @property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")

    @ipv6_only.setter
    def ipv6_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6_only", value)


if not MYPY:
    class DnsSettingsZoneDefaultsArgsDict(TypedDict):
        flatten_all_cnames: NotRequired[pulumi.Input[bool]]
        """
        Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        """
        foundation_dns: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable Foundation DNS Advanced Nameservers on the zone.
        """
        internal_dns: NotRequired[pulumi.Input['DnsSettingsZoneDefaultsInternalDnsArgsDict']]
        """
        Settings for this internal zone.
        """
        multi_provider: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        """
        nameservers: NotRequired[pulumi.Input['DnsSettingsZoneDefaultsNameserversArgsDict']]
        """
        Settings determining the nameservers through which the zone should be available.
        """
        ns_ttl: NotRequired[pulumi.Input[float]]
        """
        The time to live (TTL) of the zone's nameserver (NS) records.
        """
        secondary_overrides: NotRequired[pulumi.Input[bool]]
        """
        Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        """
        soa: NotRequired[pulumi.Input['DnsSettingsZoneDefaultsSoaArgsDict']]
        """
        Components of the zone's SOA record.
        """
        zone_mode: NotRequired[pulumi.Input[str]]
        """
        Whether the zone mode is a regular or CDN/DNS only zone.
        """
elif False:
    DnsSettingsZoneDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSettingsZoneDefaultsArgs:
    def __init__(__self__, *,
                 flatten_all_cnames: Optional[pulumi.Input[bool]] = None,
                 foundation_dns: Optional[pulumi.Input[bool]] = None,
                 internal_dns: Optional[pulumi.Input['DnsSettingsZoneDefaultsInternalDnsArgs']] = None,
                 multi_provider: Optional[pulumi.Input[bool]] = None,
                 nameservers: Optional[pulumi.Input['DnsSettingsZoneDefaultsNameserversArgs']] = None,
                 ns_ttl: Optional[pulumi.Input[float]] = None,
                 secondary_overrides: Optional[pulumi.Input[bool]] = None,
                 soa: Optional[pulumi.Input['DnsSettingsZoneDefaultsSoaArgs']] = None,
                 zone_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] flatten_all_cnames: Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        :param pulumi.Input[bool] foundation_dns: Whether to enable Foundation DNS Advanced Nameservers on the zone.
        :param pulumi.Input['DnsSettingsZoneDefaultsInternalDnsArgs'] internal_dns: Settings for this internal zone.
        :param pulumi.Input[bool] multi_provider: Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        :param pulumi.Input['DnsSettingsZoneDefaultsNameserversArgs'] nameservers: Settings determining the nameservers through which the zone should be available.
        :param pulumi.Input[float] ns_ttl: The time to live (TTL) of the zone's nameserver (NS) records.
        :param pulumi.Input[bool] secondary_overrides: Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        :param pulumi.Input['DnsSettingsZoneDefaultsSoaArgs'] soa: Components of the zone's SOA record.
        :param pulumi.Input[str] zone_mode: Whether the zone mode is a regular or CDN/DNS only zone.
        """
        if flatten_all_cnames is not None:
            pulumi.set(__self__, "flatten_all_cnames", flatten_all_cnames)
        if foundation_dns is not None:
            pulumi.set(__self__, "foundation_dns", foundation_dns)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if multi_provider is not None:
            pulumi.set(__self__, "multi_provider", multi_provider)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if ns_ttl is not None:
            pulumi.set(__self__, "ns_ttl", ns_ttl)
        if secondary_overrides is not None:
            pulumi.set(__self__, "secondary_overrides", secondary_overrides)
        if soa is not None:
            pulumi.set(__self__, "soa", soa)
        if zone_mode is not None:
            pulumi.set(__self__, "zone_mode", zone_mode)

    @property
    @pulumi.getter(name="flattenAllCnames")
    def flatten_all_cnames(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        """
        return pulumi.get(self, "flatten_all_cnames")

    @flatten_all_cnames.setter
    def flatten_all_cnames(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "flatten_all_cnames", value)

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable Foundation DNS Advanced Nameservers on the zone.
        """
        return pulumi.get(self, "foundation_dns")

    @foundation_dns.setter
    def foundation_dns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "foundation_dns", value)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input['DnsSettingsZoneDefaultsInternalDnsArgs']]:
        """
        Settings for this internal zone.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input['DnsSettingsZoneDefaultsInternalDnsArgs']]):
        pulumi.set(self, "internal_dns", value)

    @property
    @pulumi.getter(name="multiProvider")
    def multi_provider(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        """
        return pulumi.get(self, "multi_provider")

    @multi_provider.setter
    def multi_provider(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multi_provider", value)

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['DnsSettingsZoneDefaultsNameserversArgs']]:
        """
        Settings determining the nameservers through which the zone should be available.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['DnsSettingsZoneDefaultsNameserversArgs']]):
        pulumi.set(self, "nameservers", value)

    @property
    @pulumi.getter(name="nsTtl")
    def ns_ttl(self) -> Optional[pulumi.Input[float]]:
        """
        The time to live (TTL) of the zone's nameserver (NS) records.
        """
        return pulumi.get(self, "ns_ttl")

    @ns_ttl.setter
    def ns_ttl(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ns_ttl", value)

    @property
    @pulumi.getter(name="secondaryOverrides")
    def secondary_overrides(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        """
        return pulumi.get(self, "secondary_overrides")

    @secondary_overrides.setter
    def secondary_overrides(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secondary_overrides", value)

    @property
    @pulumi.getter
    def soa(self) -> Optional[pulumi.Input['DnsSettingsZoneDefaultsSoaArgs']]:
        """
        Components of the zone's SOA record.
        """
        return pulumi.get(self, "soa")

    @soa.setter
    def soa(self, value: Optional[pulumi.Input['DnsSettingsZoneDefaultsSoaArgs']]):
        pulumi.set(self, "soa", value)

    @property
    @pulumi.getter(name="zoneMode")
    def zone_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the zone mode is a regular or CDN/DNS only zone.
        """
        return pulumi.get(self, "zone_mode")

    @zone_mode.setter
    def zone_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_mode", value)


if not MYPY:
    class DnsSettingsZoneDefaultsInternalDnsArgsDict(TypedDict):
        reference_zone_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the zone to fallback to.
        """
elif False:
    DnsSettingsZoneDefaultsInternalDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSettingsZoneDefaultsInternalDnsArgs:
    def __init__(__self__, *,
                 reference_zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] reference_zone_id: The ID of the zone to fallback to.
        """
        if reference_zone_id is not None:
            pulumi.set(__self__, "reference_zone_id", reference_zone_id)

    @property
    @pulumi.getter(name="referenceZoneId")
    def reference_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the zone to fallback to.
        """
        return pulumi.get(self, "reference_zone_id")

    @reference_zone_id.setter
    def reference_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_zone_id", value)


if not MYPY:
    class DnsSettingsZoneDefaultsNameserversArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Nameserver type
        """
elif False:
    DnsSettingsZoneDefaultsNameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSettingsZoneDefaultsNameserversArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Nameserver type
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Nameserver type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DnsSettingsZoneDefaultsSoaArgsDict(TypedDict):
        expire: pulumi.Input[float]
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        min_ttl: pulumi.Input[float]
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        mname: pulumi.Input[str]
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        refresh: pulumi.Input[float]
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        retry: pulumi.Input[float]
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        rname: pulumi.Input[str]
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        ttl: pulumi.Input[float]
        """
        The time to live (TTL) of the SOA record itself.
        """
elif False:
    DnsSettingsZoneDefaultsSoaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSettingsZoneDefaultsSoaArgs:
    def __init__(__self__, *,
                 expire: pulumi.Input[float],
                 min_ttl: pulumi.Input[float],
                 mname: pulumi.Input[str],
                 refresh: pulumi.Input[float],
                 retry: pulumi.Input[float],
                 rname: pulumi.Input[str],
                 ttl: pulumi.Input[float]):
        """
        :param pulumi.Input[float] expire: Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        :param pulumi.Input[float] min_ttl: The time to live (TTL) for negative caching of records within the zone.
        :param pulumi.Input[str] mname: The primary nameserver, which may be used for outbound zone transfers.
        :param pulumi.Input[float] refresh: Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        :param pulumi.Input[float] retry: Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        :param pulumi.Input[str] rname: The email address of the zone administrator, with the first label representing the local part of the email address.
        :param pulumi.Input[float] ttl: The time to live (TTL) of the SOA record itself.
        """
        pulumi.set(__self__, "expire", expire)
        pulumi.set(__self__, "min_ttl", min_ttl)
        pulumi.set(__self__, "mname", mname)
        pulumi.set(__self__, "refresh", refresh)
        pulumi.set(__self__, "retry", retry)
        pulumi.set(__self__, "rname", rname)
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def expire(self) -> pulumi.Input[float]:
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: pulumi.Input[float]):
        pulumi.set(self, "expire", value)

    @property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> pulumi.Input[float]:
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        return pulumi.get(self, "min_ttl")

    @min_ttl.setter
    def min_ttl(self, value: pulumi.Input[float]):
        pulumi.set(self, "min_ttl", value)

    @property
    @pulumi.getter
    def mname(self) -> pulumi.Input[str]:
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        return pulumi.get(self, "mname")

    @mname.setter
    def mname(self, value: pulumi.Input[str]):
        pulumi.set(self, "mname", value)

    @property
    @pulumi.getter
    def refresh(self) -> pulumi.Input[float]:
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        return pulumi.get(self, "refresh")

    @refresh.setter
    def refresh(self, value: pulumi.Input[float]):
        pulumi.set(self, "refresh", value)

    @property
    @pulumi.getter
    def retry(self) -> pulumi.Input[float]:
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: pulumi.Input[float]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def rname(self) -> pulumi.Input[str]:
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        return pulumi.get(self, "rname")

    @rname.setter
    def rname(self, value: pulumi.Input[str]):
        pulumi.set(self, "rname", value)

    @property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[float]:
        """
        The time to live (TTL) of the SOA record itself.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[float]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class EmailRoutingCatchAllActionArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of action for catch-all rule.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    EmailRoutingCatchAllActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingCatchAllActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Type of action for catch-all rule.
        """
        pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of action for catch-all rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EmailRoutingCatchAllMatcherArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of matcher. Default is 'all'.
        """
elif False:
    EmailRoutingCatchAllMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingCatchAllMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Type of matcher. Default is 'all'.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher. Default is 'all'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingDnsErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        message: NotRequired[pulumi.Input[str]]
elif False:
    EmailRoutingDnsErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class EmailRoutingDnsMessageArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        message: NotRequired[pulumi.Input[str]]
elif False:
    EmailRoutingDnsMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsMessageArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class EmailRoutingDnsResultArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[str]]
        """
        DNS record content.
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        DNS record name (or @ for the zone apex).
        """
        priority: NotRequired[pulumi.Input[float]]
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        records: NotRequired[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgsDict']]]]
        ttl: NotRequired[pulumi.Input[float]]
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        DNS record type.
        """
elif False:
    EmailRoutingDnsResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 records: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgs']]]] = None,
                 ttl: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: DNS record content.
        :param pulumi.Input[str] name: DNS record name (or @ for the zone apex).
        :param pulumi.Input[float] priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param pulumi.Input[float] ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param pulumi.Input[str] type: DNS record type.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgs']]]]:
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgs']]]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgs']]]]:
        return pulumi.get(self, "records")

    @records.setter
    def records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgs']]]]):
        pulumi.set(self, "records", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[float]]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingDnsResultErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        missing: NotRequired[pulumi.Input['EmailRoutingDnsResultErrorMissingArgsDict']]
        """
        List of records needed to enable an Email Routing zone.
        """
elif False:
    EmailRoutingDnsResultErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 missing: Optional[pulumi.Input['EmailRoutingDnsResultErrorMissingArgs']] = None):
        """
        :param pulumi.Input['EmailRoutingDnsResultErrorMissingArgs'] missing: List of records needed to enable an Email Routing zone.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if missing is not None:
            pulumi.set(__self__, "missing", missing)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def missing(self) -> Optional[pulumi.Input['EmailRoutingDnsResultErrorMissingArgs']]:
        """
        List of records needed to enable an Email Routing zone.
        """
        return pulumi.get(self, "missing")

    @missing.setter
    def missing(self, value: Optional[pulumi.Input['EmailRoutingDnsResultErrorMissingArgs']]):
        pulumi.set(self, "missing", value)


if not MYPY:
    class EmailRoutingDnsResultErrorMissingArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[str]]
        """
        DNS record content.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        DNS record name (or @ for the zone apex).
        """
        priority: NotRequired[pulumi.Input[float]]
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        ttl: NotRequired[pulumi.Input[float]]
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        DNS record type.
        """
elif False:
    EmailRoutingDnsResultErrorMissingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultErrorMissingArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 ttl: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: DNS record content.
        :param pulumi.Input[str] name: DNS record name (or @ for the zone apex).
        :param pulumi.Input[float] priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param pulumi.Input[float] ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param pulumi.Input[str] type: DNS record type.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[float]]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingDnsResultInfoArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        """
        Total number of results for the requested service
        """
        page: NotRequired[pulumi.Input[float]]
        """
        Current page within paginated list of results
        """
        per_page: NotRequired[pulumi.Input[float]]
        """
        Number of results per page of results
        """
        total_count: NotRequired[pulumi.Input[float]]
        """
        Total results available without any search parameters
        """
elif False:
    EmailRoutingDnsResultInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultInfoArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 page: Optional[pulumi.Input[float]] = None,
                 per_page: Optional[pulumi.Input[float]] = None,
                 total_count: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] count: Total number of results for the requested service
        :param pulumi.Input[float] page: Current page within paginated list of results
        :param pulumi.Input[float] per_page: Number of results per page of results
        :param pulumi.Input[float] total_count: Total results available without any search parameters
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if page is not None:
            pulumi.set(__self__, "page", page)
        if per_page is not None:
            pulumi.set(__self__, "per_page", per_page)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of results for the requested service
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def page(self) -> Optional[pulumi.Input[float]]:
        """
        Current page within paginated list of results
        """
        return pulumi.get(self, "page")

    @page.setter
    def page(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "page", value)

    @property
    @pulumi.getter(name="perPage")
    def per_page(self) -> Optional[pulumi.Input[float]]:
        """
        Number of results per page of results
        """
        return pulumi.get(self, "per_page")

    @per_page.setter
    def per_page(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "per_page", value)

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total results available without any search parameters
        """
        return pulumi.get(self, "total_count")

    @total_count.setter
    def total_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "total_count", value)


if not MYPY:
    class EmailRoutingDnsResultRecordArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[str]]
        """
        DNS record content.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        DNS record name (or @ for the zone apex).
        """
        priority: NotRequired[pulumi.Input[float]]
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        ttl: NotRequired[pulumi.Input[float]]
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        DNS record type.
        """
elif False:
    EmailRoutingDnsResultRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultRecordArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 ttl: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: DNS record content.
        :param pulumi.Input[str] name: DNS record name (or @ for the zone apex).
        :param pulumi.Input[float] priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param pulumi.Input[float] ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param pulumi.Input[str] type: DNS record type.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[float]]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        DNS record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingRuleActionArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of supported action.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    EmailRoutingRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] type: Type of supported action.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of supported action.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EmailRoutingRuleMatcherArgsDict(TypedDict):
        field: pulumi.Input[str]
        """
        Field for type matcher.
        """
        type: pulumi.Input[str]
        """
        Type of matcher.
        """
        value: pulumi.Input[str]
        """
        Value for matcher.
        """
elif False:
    EmailRoutingRuleMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingRuleMatcherArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] field: Field for type matcher.
        :param pulumi.Input[str] type: Type of matcher.
        :param pulumi.Input[str] value: Value for matcher.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Field for type matcher.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of matcher.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EmailSecurityTrustedDomainsBodyArgsDict(TypedDict):
        is_recent: pulumi.Input[bool]
        """
        Select to prevent recently registered domains from triggering a
        Suspicious or Malicious disposition.
        """
        is_regex: pulumi.Input[bool]
        is_similarity: pulumi.Input[bool]
        """
        Select for partner or other approved domains that have similar
        spelling to your connected domains. Prevents listed domains from
        triggering a Spoof disposition.
        """
        pattern: pulumi.Input[str]
        comments: NotRequired[pulumi.Input[str]]
elif False:
    EmailSecurityTrustedDomainsBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailSecurityTrustedDomainsBodyArgs:
    def __init__(__self__, *,
                 is_recent: pulumi.Input[bool],
                 is_regex: pulumi.Input[bool],
                 is_similarity: pulumi.Input[bool],
                 pattern: pulumi.Input[str],
                 comments: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_recent: Select to prevent recently registered domains from triggering a
               Suspicious or Malicious disposition.
        :param pulumi.Input[bool] is_similarity: Select for partner or other approved domains that have similar
               spelling to your connected domains. Prevents listed domains from
               triggering a Spoof disposition.
        """
        pulumi.set(__self__, "is_recent", is_recent)
        pulumi.set(__self__, "is_regex", is_regex)
        pulumi.set(__self__, "is_similarity", is_similarity)
        pulumi.set(__self__, "pattern", pattern)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)

    @property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> pulumi.Input[bool]:
        """
        Select to prevent recently registered domains from triggering a
        Suspicious or Malicious disposition.
        """
        return pulumi.get(self, "is_recent")

    @is_recent.setter
    def is_recent(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_recent", value)

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_regex")

    @is_regex.setter
    def is_regex(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_regex", value)

    @property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> pulumi.Input[bool]:
        """
        Select for partner or other approved domains that have similar
        spelling to your connected domains. Prevents listed domains from
        triggering a Spoof disposition.
        """
        return pulumi.get(self, "is_similarity")

    @is_similarity.setter
    def is_similarity(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_similarity", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comments", value)


if not MYPY:
    class FirewallRuleActionArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        The action to perform.
        """
        response: NotRequired[pulumi.Input['FirewallRuleActionResponseArgsDict']]
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        timeout: NotRequired[pulumi.Input[float]]
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
elif False:
    FirewallRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleActionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 response: Optional[pulumi.Input['FirewallRuleActionResponseArgs']] = None,
                 timeout: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] mode: The action to perform.
        :param pulumi.Input['FirewallRuleActionResponseArgs'] response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param pulumi.Input[float] timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The action to perform.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['FirewallRuleActionResponseArgs']]:
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['FirewallRuleActionResponseArgs']]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[float]]:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class FirewallRuleActionResponseArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[str]]
        """
        The response body to return. The value must conform to the configured content type.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
elif False:
    FirewallRuleActionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleActionResponseArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body: The response body to return. The value must conform to the configured content type.
        :param pulumi.Input[str] content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class FirewallRuleFilterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        An informative summary of the filter.
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier of the filter.
        """
        paused: NotRequired[pulumi.Input[bool]]
        """
        When true, indicates that the filter is currently paused.
        """
        ref: NotRequired[pulumi.Input[str]]
        """
        A short reference tag. Allows you to select related filters.
        """
elif False:
    FirewallRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleFilterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: An informative summary of the filter.
        :param pulumi.Input[str] expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param pulumi.Input[str] id: The unique identifier of the filter.
        :param pulumi.Input[bool] paused: When true, indicates that the filter is currently paused.
        :param pulumi.Input[str] ref: A short reference tag. Allows you to select related filters.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class HealthcheckHttpConfigArgsDict(TypedDict):
        allow_insecure: NotRequired[pulumi.Input[bool]]
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        expected_body: NotRequired[pulumi.Input[str]]
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        expected_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        follow_redirects: NotRequired[pulumi.Input[bool]]
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The HTTP method to use for the health check.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The endpoint path to health check against.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
elif False:
    HealthcheckHttpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthcheckHttpConfigArgs:
    def __init__(__self__, *,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 expected_body: Optional[pulumi.Input[str]] = None,
                 expected_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 follow_redirects: Optional[pulumi.Input[bool]] = None,
                 header: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] allow_insecure: Do not validate the certificate when the health check uses HTTPS.
        :param pulumi.Input[str] expected_body: A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expected_codes: The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        :param pulumi.Input[bool] follow_redirects: Follow redirects if the origin returns a 3xx status code.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] header: The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        :param pulumi.Input[str] method: The HTTP method to use for the health check.
        :param pulumi.Input[str] path: The endpoint path to health check against.
        :param pulumi.Input[int] port: Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if expected_body is not None:
            pulumi.set(__self__, "expected_body", expected_body)
        if expected_codes is not None:
            pulumi.set(__self__, "expected_codes", expected_codes)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter(name="expectedBody")
    def expected_body(self) -> Optional[pulumi.Input[str]]:
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        return pulumi.get(self, "expected_body")

    @expected_body.setter
    def expected_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_body", value)

    @property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        return pulumi.get(self, "expected_codes")

    @expected_codes.setter
    def expected_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expected_codes", value)

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "follow_redirects", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use for the health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint path to health check against.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HealthcheckTcpConfigArgsDict(TypedDict):
        method: NotRequired[pulumi.Input[str]]
        """
        The TCP connection method to use for the health check.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number to connect to for the health check. Defaults to 80.
        """
elif False:
    HealthcheckTcpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthcheckTcpConfigArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] method: The TCP connection method to use for the health check.
        :param pulumi.Input[int] port: Port number to connect to for the health check. Defaults to 80.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The TCP connection method to use for the health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number to connect to for the health check. Defaults to 80.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HyperdriveConfigCachingArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[bool]]
        """
        When set to true, disables the caching of SQL responses. (Default: false)
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        """
        stale_while_revalidate: NotRequired[pulumi.Input[int]]
        """
        When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
elif False:
    HyperdriveConfigCachingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigCachingArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 stale_while_revalidate: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] disabled: When set to true, disables the caching of SQL responses. (Default: false)
        :param pulumi.Input[int] max_age: When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        :param pulumi.Input[int] stale_while_revalidate: When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if stale_while_revalidate is not None:
            pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, disables the caching of SQL responses. (Default: false)
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        When present, specifies max duration for which items should persist in the cache. Not returned if set to default. (Default: 60)
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> Optional[pulumi.Input[int]]:
        """
        When present, indicates the number of seconds cache may serve the response after it becomes stale. Not returned if set to default. (Default: 15)
        """
        return pulumi.get(self, "stale_while_revalidate")

    @stale_while_revalidate.setter
    def stale_while_revalidate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stale_while_revalidate", value)


if not MYPY:
    class HyperdriveConfigOriginArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        The name of your origin database.
        """
        host: pulumi.Input[str]
        """
        The host (hostname or IP) of your origin database.
        """
        password: pulumi.Input[str]
        """
        The password required to access your origin database. This value is write-only and never returned by the API.
        """
        scheme: pulumi.Input[str]
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        user: pulumi.Input[str]
        """
        The user of your origin database.
        """
        access_client_id: NotRequired[pulumi.Input[str]]
        """
        The Client ID of the Access token to use when connecting to the origin database.
        """
        access_client_secret: NotRequired[pulumi.Input[str]]
        """
        The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
elif False:
    HyperdriveConfigOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigOriginArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 scheme: pulumi.Input[str],
                 user: pulumi.Input[str],
                 access_client_id: Optional[pulumi.Input[str]] = None,
                 access_client_secret: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: The name of your origin database.
        :param pulumi.Input[str] host: The host (hostname or IP) of your origin database.
        :param pulumi.Input[str] password: The password required to access your origin database. This value is write-only and never returned by the API.
        :param pulumi.Input[str] scheme: Specifies the URL scheme used to connect to your origin database.
        :param pulumi.Input[str] user: The user of your origin database.
        :param pulumi.Input[str] access_client_id: The Client ID of the Access token to use when connecting to the origin database.
        :param pulumi.Input[str] access_client_secret: The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        :param pulumi.Input[int] port: The port (default: 5432 for Postgres) of your origin database.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of your origin database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password required to access your origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        Specifies the URL scheme used to connect to your origin database.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        The user of your origin database.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Access token to use when connecting to the origin database.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_id", value)

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the Access token to use when connecting to the origin database. This value is write-only and never returned by the API.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_secret", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ImageVariantOptionsArgsDict(TypedDict):
        fit: pulumi.Input[str]
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        height: pulumi.Input[float]
        """
        Maximum height in image pixels.
        """
        metadata: pulumi.Input[str]
        """
        What EXIF data should be preserved in the output image.
        """
        width: pulumi.Input[float]
        """
        Maximum width in image pixels.
        """
elif False:
    ImageVariantOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageVariantOptionsArgs:
    def __init__(__self__, *,
                 fit: pulumi.Input[str],
                 height: pulumi.Input[float],
                 metadata: pulumi.Input[str],
                 width: pulumi.Input[float]):
        """
        :param pulumi.Input[str] fit: The fit property describes how the width and height dimensions should be interpreted.
        :param pulumi.Input[float] height: Maximum height in image pixels.
        :param pulumi.Input[str] metadata: What EXIF data should be preserved in the output image.
        :param pulumi.Input[float] width: Maximum width in image pixels.
        """
        pulumi.set(__self__, "fit", fit)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def fit(self) -> pulumi.Input[str]:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        return pulumi.get(self, "fit")

    @fit.setter
    def fit(self, value: pulumi.Input[str]):
        pulumi.set(self, "fit", value)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[float]:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[float]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def metadata(self) -> pulumi.Input[str]:
        """
        What EXIF data should be preserved in the output image.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[float]:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[float]):
        pulumi.set(self, "width", value)


if not MYPY:
    class ImageVariantVariantArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        never_require_signed_urls: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the variant can access an image without a signature, regardless of image access control.
        """
        options: NotRequired[pulumi.Input['ImageVariantVariantOptionsArgsDict']]
        """
        Allows you to define image resizing sizes for different use cases.
        """
elif False:
    ImageVariantVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageVariantVariantArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 never_require_signed_urls: Optional[pulumi.Input[bool]] = None,
                 options: Optional[pulumi.Input['ImageVariantVariantOptionsArgs']] = None):
        """
        :param pulumi.Input[bool] never_require_signed_urls: Indicates whether the variant can access an image without a signature, regardless of image access control.
        :param pulumi.Input['ImageVariantVariantOptionsArgs'] options: Allows you to define image resizing sizes for different use cases.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if never_require_signed_urls is not None:
            pulumi.set(__self__, "never_require_signed_urls", never_require_signed_urls)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="neverRequireSignedUrls")
    def never_require_signed_urls(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the variant can access an image without a signature, regardless of image access control.
        """
        return pulumi.get(self, "never_require_signed_urls")

    @never_require_signed_urls.setter
    def never_require_signed_urls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "never_require_signed_urls", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input['ImageVariantVariantOptionsArgs']]:
        """
        Allows you to define image resizing sizes for different use cases.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input['ImageVariantVariantOptionsArgs']]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ImageVariantVariantOptionsArgsDict(TypedDict):
        fit: NotRequired[pulumi.Input[str]]
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        height: NotRequired[pulumi.Input[float]]
        """
        Maximum height in image pixels.
        """
        metadata: NotRequired[pulumi.Input[str]]
        """
        What EXIF data should be preserved in the output image.
        """
        width: NotRequired[pulumi.Input[float]]
        """
        Maximum width in image pixels.
        """
elif False:
    ImageVariantVariantOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageVariantVariantOptionsArgs:
    def __init__(__self__, *,
                 fit: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[float]] = None,
                 metadata: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] fit: The fit property describes how the width and height dimensions should be interpreted.
        :param pulumi.Input[float] height: Maximum height in image pixels.
        :param pulumi.Input[str] metadata: What EXIF data should be preserved in the output image.
        :param pulumi.Input[float] width: Maximum width in image pixels.
        """
        if fit is not None:
            pulumi.set(__self__, "fit", fit)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def fit(self) -> Optional[pulumi.Input[str]]:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        """
        return pulumi.get(self, "fit")

    @fit.setter
    def fit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fit", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        """
        What EXIF data should be preserved in the output image.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class KeylessCertificateTunnelArgsDict(TypedDict):
        private_ip: pulumi.Input[str]
        """
        Private IP of the Key Server Host
        """
        vnet_id: pulumi.Input[str]
        """
        Cloudflare Tunnel Virtual Network ID
        """
elif False:
    KeylessCertificateTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeylessCertificateTunnelArgs:
    def __init__(__self__, *,
                 private_ip: pulumi.Input[str],
                 vnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] private_ip: Private IP of the Key Server Host
        :param pulumi.Input[str] vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> pulumi.Input[str]:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> pulumi.Input[str]:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ListItemHostnameArgsDict(TypedDict):
        url_hostname: pulumi.Input[str]
elif False:
    ListItemHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemHostnameArgs:
    def __init__(__self__, *,
                 url_hostname: pulumi.Input[str]):
        pulumi.set(__self__, "url_hostname", url_hostname)

    @property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url_hostname")

    @url_hostname.setter
    def url_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "url_hostname", value)


if not MYPY:
    class ListItemRedirectArgsDict(TypedDict):
        source_url: pulumi.Input[str]
        target_url: pulumi.Input[str]
        include_subdomains: NotRequired[pulumi.Input[bool]]
        preserve_path_suffix: NotRequired[pulumi.Input[bool]]
        preserve_query_string: NotRequired[pulumi.Input[bool]]
        status_code: NotRequired[pulumi.Input[int]]
        subpath_matching: NotRequired[pulumi.Input[bool]]
elif False:
    ListItemRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemRedirectArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[str],
                 target_url: pulumi.Input[str],
                 include_subdomains: Optional[pulumi.Input[bool]] = None,
                 preserve_path_suffix: Optional[pulumi.Input[bool]] = None,
                 preserve_query_string: Optional[pulumi.Input[bool]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 subpath_matching: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_url", value)

    @property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_subdomains", value)

    @property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preserve_path_suffix")

    @preserve_path_suffix.setter
    def preserve_path_suffix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_path_suffix", value)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "subpath_matching")

    @subpath_matching.setter
    def subpath_matching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "subpath_matching", value)


if not MYPY:
    class LoadBalancerAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[bool]]
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
elif False:
    LoadBalancerAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerLocationStrategyArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        prefer_ecs: NotRequired[pulumi.Input[str]]
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
elif False:
    LoadBalancerLocationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 prefer_ecs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param pulumi.Input[str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_ecs", value)


if not MYPY:
    class LoadBalancerPoolLoadSheddingArgsDict(TypedDict):
        default_percent: NotRequired[pulumi.Input[float]]
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        default_policy: NotRequired[pulumi.Input[str]]
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        """
        session_percent: NotRequired[pulumi.Input[float]]
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        session_policy: NotRequired[pulumi.Input[str]]
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
elif False:
    LoadBalancerPoolLoadSheddingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolLoadSheddingArgs:
    def __init__(__self__, *,
                 default_percent: Optional[pulumi.Input[float]] = None,
                 default_policy: Optional[pulumi.Input[str]] = None,
                 session_percent: Optional[pulumi.Input[float]] = None,
                 session_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] default_percent: The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        :param pulumi.Input[str] default_policy: The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        :param pulumi.Input[float] session_percent: The percent of existing sessions to shed from the pool, according to the session policy.
        :param pulumi.Input[str] session_policy: Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        return pulumi.get(self, "default_percent")

    @default_percent.setter
    def default_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_percent", value)

    @property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        """
        return pulumi.get(self, "default_policy")

    @default_policy.setter
    def default_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_policy", value)

    @property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[pulumi.Input[float]]:
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        return pulumi.get(self, "session_percent")

    @session_percent.setter
    def session_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "session_percent", value)

    @property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        """
        return pulumi.get(self, "session_policy")

    @session_policy.setter
    def session_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_policy", value)


if not MYPY:
    class LoadBalancerPoolNotificationFilterArgsDict(TypedDict):
        origin: NotRequired[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgsDict']]
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        pool: NotRequired[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgsDict']]
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
elif False:
    LoadBalancerPoolNotificationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolNotificationFilterArgs:
    def __init__(__self__, *,
                 origin: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs']] = None,
                 pool: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs']] = None):
        """
        :param pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs'] origin: Filter options for a particular resource type (pool or origin). Use null to reset.
        :param pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs'] pool: Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs']]:
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs']]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter
    def pool(self) -> Optional[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs']]:
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs']]):
        pulumi.set(self, "pool", value)


if not MYPY:
    class LoadBalancerPoolNotificationFilterOriginArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        healthy: NotRequired[pulumi.Input[bool]]
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
elif False:
    LoadBalancerPoolNotificationFilterOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolNotificationFilterOriginArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 healthy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable: If set true, disable notifications for this type of resource (pool or origin).
        :param pulumi.Input[bool] healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[pulumi.Input[bool]]:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")

    @healthy.setter
    def healthy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "healthy", value)


if not MYPY:
    class LoadBalancerPoolNotificationFilterPoolArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[bool]]
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        healthy: NotRequired[pulumi.Input[bool]]
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
elif False:
    LoadBalancerPoolNotificationFilterPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolNotificationFilterPoolArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[bool]] = None,
                 healthy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disable: If set true, disable notifications for this type of resource (pool or origin).
        :param pulumi.Input[bool] healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[bool]]:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def healthy(self) -> Optional[pulumi.Input[bool]]:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")

    @healthy.setter
    def healthy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "healthy", value)


if not MYPY:
    class LoadBalancerPoolOriginArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        disabled_at: NotRequired[pulumi.Input[str]]
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        header: NotRequired[pulumi.Input['LoadBalancerPoolOriginHeaderArgsDict']]
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A human-identifiable name for the origin.
        """
        virtual_network_id: NotRequired[pulumi.Input[str]]
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        weight: NotRequired[pulumi.Input[float]]
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
elif False:
    LoadBalancerPoolOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 disabled_at: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 header: Optional[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 virtual_network_id: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] address: The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        :param pulumi.Input[str] disabled_at: This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        :param pulumi.Input[bool] enabled: Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        :param pulumi.Input['LoadBalancerPoolOriginHeaderArgs'] header: The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        :param pulumi.Input[str] name: A human-identifiable name for the origin.
        :param pulumi.Input[str] virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param pulumi.Input[float] weight: The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if disabled_at is not None:
            pulumi.set(__self__, "disabled_at", disabled_at)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="disabledAt")
    def disabled_at(self) -> Optional[pulumi.Input[str]]:
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        return pulumi.get(self, "disabled_at")

    @disabled_at.setter
    def disabled_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disabled_at", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]:
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LoadBalancerPoolOriginHeaderArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
elif False:
    LoadBalancerPoolOriginHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginHeaderArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)


if not MYPY:
    class LoadBalancerPoolOriginSteeringArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[str]]
        """
        The type of origin steering policy to use.
        """
elif False:
    LoadBalancerPoolOriginSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginSteeringArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy: The type of origin steering policy to use.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        The type of origin steering policy to use.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class LoadBalancerRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[float]]
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[float]]]]
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
elif False:
    LoadBalancerRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[float] default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[float]]:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_weight", value)

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRuleArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        fixed_response: NotRequired[pulumi.Input['LoadBalancerRuleFixedResponseArgsDict']]
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of this rule. Only used for human readability.
        """
        overrides: NotRequired[pulumi.Input['LoadBalancerRuleOverridesArgsDict']]
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        terminates: NotRequired[pulumi.Input[bool]]
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
elif False:
    LoadBalancerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 fixed_response: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 overrides: Optional[pulumi.Input['LoadBalancerRuleOverridesArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 terminates: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] condition: The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        :param pulumi.Input[bool] disabled: Disable this specific rule. It will no longer be evaluated by this load balancer.
        :param pulumi.Input['LoadBalancerRuleFixedResponseArgs'] fixed_response: A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        :param pulumi.Input[str] name: Name of this rule. Only used for human readability.
        :param pulumi.Input['LoadBalancerRuleOverridesArgs'] overrides: A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        :param pulumi.Input[int] priority: The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        :param pulumi.Input[bool] terminates: If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]:
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of this rule. Only used for human readability.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesArgs']]:
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def terminates(self) -> Optional[pulumi.Input[bool]]:
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        return pulumi.get(self, "terminates")

    @terminates.setter
    def terminates(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "terminates", value)


if not MYPY:
    class LoadBalancerRuleFixedResponseArgsDict(TypedDict):
        content_type: NotRequired[pulumi.Input[str]]
        """
        The http 'Content-Type' header to include in the response.
        """
        location: NotRequired[pulumi.Input[str]]
        """
        The http 'Location' header to include in the response.
        """
        message_body: NotRequired[pulumi.Input[str]]
        """
        Text to include as the http body.
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        The http status code to respond with.
        """
elif False:
    LoadBalancerRuleFixedResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleFixedResponseArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 message_body: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] content_type: The http 'Content-Type' header to include in the response.
        :param pulumi.Input[str] location: The http 'Location' header to include in the response.
        :param pulumi.Input[str] message_body: Text to include as the http body.
        :param pulumi.Input[int] status_code: The http status code to respond with.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The http 'Content-Type' header to include in the response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The http 'Location' header to include in the response.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[str]]:
        """
        Text to include as the http body.
        """
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_body", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        The http status code to respond with.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class LoadBalancerRuleOverridesArgsDict(TypedDict):
        adaptive_routing: NotRequired[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgsDict']]
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        country_pools: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        default_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        fallback_pool: NotRequired[pulumi.Input[str]]
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        location_strategy: NotRequired[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgsDict']]
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        pop_pools: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        random_steering: NotRequired[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgsDict']]
        """
        Configures pool weights.
        """
        region_pools: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        session_affinity: NotRequired[pulumi.Input[str]]
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        """
        session_affinity_attributes: NotRequired[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict']]
        """
        Configures attributes for session affinity.
        """
        session_affinity_ttl: NotRequired[pulumi.Input[float]]
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        """
        steering_policy: NotRequired[pulumi.Input[str]]
        """
        Steering Policy for this load balancer.
        """
        ttl: NotRequired[pulumi.Input[float]]
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
elif False:
    LoadBalancerRuleOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesArgs:
    def __init__(__self__, *,
                 adaptive_routing: Optional[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs']] = None,
                 country_pools: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 default_pools: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fallback_pool: Optional[pulumi.Input[str]] = None,
                 location_strategy: Optional[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs']] = None,
                 pop_pools: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 random_steering: Optional[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs']] = None,
                 region_pools: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 session_affinity: Optional[pulumi.Input[str]] = None,
                 session_affinity_attributes: Optional[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs']] = None,
                 session_affinity_ttl: Optional[pulumi.Input[float]] = None,
                 steering_policy: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs'] adaptive_routing: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] country_pools: A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_pools: A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        :param pulumi.Input[str] fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs'] location_strategy: Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] pop_pools: (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        :param pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs'] random_steering: Configures pool weights.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] region_pools: A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        :param pulumi.Input[str] session_affinity: Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        :param pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs'] session_affinity_attributes: Configures attributes for session affinity.
        :param pulumi.Input[float] session_affinity_ttl: Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        :param pulumi.Input[str] steering_policy: Steering Policy for this load balancer.
        :param pulumi.Input[float] ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        if adaptive_routing is not None:
            pulumi.set(__self__, "adaptive_routing", adaptive_routing)
        if country_pools is not None:
            pulumi.set(__self__, "country_pools", country_pools)
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if location_strategy is not None:
            pulumi.set(__self__, "location_strategy", location_strategy)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if random_steering is not None:
            pulumi.set(__self__, "random_steering", random_steering)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="adaptiveRouting")
    def adaptive_routing(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs']]:
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        return pulumi.get(self, "adaptive_routing")

    @adaptive_routing.setter
    def adaptive_routing(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs']]):
        pulumi.set(self, "adaptive_routing", value)

    @property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        return pulumi.get(self, "country_pools")

    @country_pools.setter
    def country_pools(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "country_pools", value)

    @property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        return pulumi.get(self, "default_pools")

    @default_pools.setter
    def default_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_pools", value)

    @property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @fallback_pool.setter
    def fallback_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_pool", value)

    @property
    @pulumi.getter(name="locationStrategy")
    def location_strategy(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs']]:
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        return pulumi.get(self, "location_strategy")

    @location_strategy.setter
    def location_strategy(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs']]):
        pulumi.set(self, "location_strategy", value)

    @property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        return pulumi.get(self, "pop_pools")

    @pop_pools.setter
    def pop_pools(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "pop_pools", value)

    @property
    @pulumi.getter(name="randomSteering")
    def random_steering(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs']]:
        """
        Configures pool weights.
        """
        return pulumi.get(self, "random_steering")

    @random_steering.setter
    def random_steering(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs']]):
        pulumi.set(self, "random_steering", value)

    @property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        return pulumi.get(self, "region_pools")

    @region_pools.setter
    def region_pools(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "region_pools", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_affinity", value)

    @property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs']]:
        """
        Configures attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @session_affinity_attributes.setter
    def session_affinity_attributes(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs']]):
        pulumi.set(self, "session_affinity_attributes", value)

    @property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[pulumi.Input[float]]:
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
        """
        return pulumi.get(self, "session_affinity_ttl")

    @session_affinity_ttl.setter
    def session_affinity_ttl(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "session_affinity_ttl", value)

    @property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Steering Policy for this load balancer.
        """
        return pulumi.get(self, "steering_policy")

    @steering_policy.setter
    def steering_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "steering_policy", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[float]]:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class LoadBalancerRuleOverridesAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[bool]]
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
elif False:
    LoadBalancerRuleOverridesAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerRuleOverridesLocationStrategyArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        prefer_ecs: NotRequired[pulumi.Input[str]]
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
elif False:
    LoadBalancerRuleOverridesLocationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 prefer_ecs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param pulumi.Input[str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_ecs", value)


if not MYPY:
    class LoadBalancerRuleOverridesRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[float]]
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[float]]]]
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
elif False:
    LoadBalancerRuleOverridesRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]] = None):
        """
        :param pulumi.Input[float] default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param pulumi.Input[Mapping[str, pulumi.Input[float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[float]]:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_weight", value)

    @property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[float]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict(TypedDict):
        drain_duration: NotRequired[pulumi.Input[float]]
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        require_all_headers: NotRequired[pulumi.Input[bool]]
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        samesite: NotRequired[pulumi.Input[str]]
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        secure: NotRequired[pulumi.Input[str]]
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        zero_downtime_failover: NotRequired[pulumi.Input[str]]
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
elif False:
    LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesSessionAffinityAttributesArgs:
    def __init__(__self__, *,
                 drain_duration: Optional[pulumi.Input[float]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[bool]] = None,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param pulumi.Input[bool] require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param pulumi.Input[str] secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param pulumi.Input[str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[pulumi.Input[float]]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @drain_duration.setter
    def drain_duration(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "drain_duration", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all_headers", value)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_downtime_failover", value)


if not MYPY:
    class LoadBalancerSessionAffinityAttributesArgsDict(TypedDict):
        drain_duration: NotRequired[pulumi.Input[float]]
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        require_all_headers: NotRequired[pulumi.Input[bool]]
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        samesite: NotRequired[pulumi.Input[str]]
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        secure: NotRequired[pulumi.Input[str]]
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        zero_downtime_failover: NotRequired[pulumi.Input[str]]
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
elif False:
    LoadBalancerSessionAffinityAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerSessionAffinityAttributesArgs:
    def __init__(__self__, *,
                 drain_duration: Optional[pulumi.Input[float]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[bool]] = None,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param pulumi.Input[bool] require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        :param pulumi.Input[str] secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        :param pulumi.Input[str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[pulumi.Input[float]]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @drain_duration.setter
    def drain_duration(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "drain_duration", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all_headers", value)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zero_downtime_failover", value)


if not MYPY:
    class LogpushJobOutputOptionsArgsDict(TypedDict):
        batch_prefix: NotRequired[pulumi.Input[str]]
        """
        String to be prepended before each batch.
        """
        batch_suffix: NotRequired[pulumi.Input[str]]
        """
        String to be appended after each batch.
        """
        cve20214428: NotRequired[pulumi.Input[bool]]
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        field_delimiter: NotRequired[pulumi.Input[str]]
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        field_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        output_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        """
        record_delimiter: NotRequired[pulumi.Input[str]]
        """
        String to be inserted in-between the records as separator.
        """
        record_prefix: NotRequired[pulumi.Input[str]]
        """
        String to be prepended before each record.
        """
        record_suffix: NotRequired[pulumi.Input[str]]
        """
        String to be appended after each record.
        """
        record_template: NotRequired[pulumi.Input[str]]
        """
        String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        sample_rate: NotRequired[pulumi.Input[float]]
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        timestamp_format: NotRequired[pulumi.Input[str]]
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
elif False:
    LogpushJobOutputOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogpushJobOutputOptionsArgs:
    def __init__(__self__, *,
                 batch_prefix: Optional[pulumi.Input[str]] = None,
                 batch_suffix: Optional[pulumi.Input[str]] = None,
                 cve20214428: Optional[pulumi.Input[bool]] = None,
                 field_delimiter: Optional[pulumi.Input[str]] = None,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 output_type: Optional[pulumi.Input[str]] = None,
                 record_delimiter: Optional[pulumi.Input[str]] = None,
                 record_prefix: Optional[pulumi.Input[str]] = None,
                 record_suffix: Optional[pulumi.Input[str]] = None,
                 record_template: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None,
                 timestamp_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] batch_prefix: String to be prepended before each batch.
        :param pulumi.Input[str] batch_suffix: String to be appended after each batch.
        :param pulumi.Input[bool] cve20214428: If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        :param pulumi.Input[str] field_delimiter: String to join fields. This field be ignored when `record_template` is set.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        :param pulumi.Input[str] output_type: Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        :param pulumi.Input[str] record_delimiter: String to be inserted in-between the records as separator.
        :param pulumi.Input[str] record_prefix: String to be prepended before each record.
        :param pulumi.Input[str] record_suffix: String to be appended after each record.
        :param pulumi.Input[str] record_template: String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        :param pulumi.Input[float] sample_rate: Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        :param pulumi.Input[str] timestamp_format: String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        if batch_prefix is not None:
            pulumi.set(__self__, "batch_prefix", batch_prefix)
        if batch_suffix is not None:
            pulumi.set(__self__, "batch_suffix", batch_suffix)
        if cve20214428 is not None:
            pulumi.set(__self__, "cve20214428", cve20214428)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if output_type is not None:
            pulumi.set(__self__, "output_type", output_type)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if record_prefix is not None:
            pulumi.set(__self__, "record_prefix", record_prefix)
        if record_suffix is not None:
            pulumi.set(__self__, "record_suffix", record_suffix)
        if record_template is not None:
            pulumi.set(__self__, "record_template", record_template)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @batch_prefix.setter
    def batch_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_prefix", value)

    @property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @batch_suffix.setter
    def batch_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_suffix", value)

    @property
    @pulumi.getter
    def cve20214428(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        return pulumi.get(self, "cve20214428")

    @cve20214428.setter
    def cve20214428(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cve20214428", value)

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_delimiter", value)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        """
        return pulumi.get(self, "output_type")

    @output_type.setter
    def output_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_type", value)

    @property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @record_delimiter.setter
    def record_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_delimiter", value)

    @property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be prepended before each record.
        """
        return pulumi.get(self, "record_prefix")

    @record_prefix.setter
    def record_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_prefix", value)

    @property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        String to be appended after each record.
        """
        return pulumi.get(self, "record_suffix")

    @record_suffix.setter
    def record_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_suffix", value)

    @property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> Optional[pulumi.Input[str]]:
        """
        String to use as template for each record instead of the default comma-separated list. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        return pulumi.get(self, "record_template")

    @record_template.setter
    def record_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_template", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)

    @property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[str]]:
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class MagicNetworkMonitoringConfigurationWarpDeviceArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Unique identifier for the warp device.
        """
        name: pulumi.Input[str]
        """
        Name of the warp device.
        """
        router_ip: pulumi.Input[str]
        """
        IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
elif False:
    MagicNetworkMonitoringConfigurationWarpDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicNetworkMonitoringConfigurationWarpDeviceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 router_ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Unique identifier for the warp device.
        :param pulumi.Input[str] name: Name of the warp device.
        :param pulumi.Input[str] router_ip: IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "router_ip", router_ip)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for the warp device.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the warp device.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routerIp")
    def router_ip(self) -> pulumi.Input[str]:
        """
        IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        return pulumi.get(self, "router_ip")

    @router_ip.setter
    def router_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "router_ip", value)


if not MYPY:
    class MagicTransitConnectorDeviceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        serial_number: NotRequired[pulumi.Input[str]]
elif False:
    MagicTransitConnectorDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitConnectorDeviceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 serial_number: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial_number", value)


if not MYPY:
    class MagicTransitSiteAclLan1ArgsDict(TypedDict):
        lan_id: pulumi.Input[str]
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        lan_name: NotRequired[pulumi.Input[str]]
        """
        The name of the LAN based on the provided lan_id.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
elif False:
    MagicTransitSiteAclLan1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteAclLan1Args:
    def __init__(__self__, *,
                 lan_id: pulumi.Input[str],
                 lan_name: Optional[pulumi.Input[str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param pulumi.Input[str] lan_name: The name of the LAN based on the provided lan_id.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @lan_name.setter
    def lan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lan_name", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class MagicTransitSiteAclLan2ArgsDict(TypedDict):
        lan_id: pulumi.Input[str]
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        lan_name: NotRequired[pulumi.Input[str]]
        """
        The name of the LAN based on the provided lan_id.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
elif False:
    MagicTransitSiteAclLan2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteAclLan2Args:
    def __init__(__self__, *,
                 lan_id: pulumi.Input[str],
                 lan_name: Optional[pulumi.Input[str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param pulumi.Input[str] lan_name: The name of the LAN based on the provided lan_id.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[str]:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lan_id", value)

    @property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @lan_name.setter
    def lan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lan_name", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class MagicTransitSiteLanNatArgsDict(TypedDict):
        static_prefix: NotRequired[pulumi.Input[str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteLanNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanNatArgs:
    def __init__(__self__, *,
                 static_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] static_prefix: A valid CIDR notation representing an IP range.
        """
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")

    @static_prefix.setter
    def static_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static_prefix", value)


if not MYPY:
    class MagicTransitSiteLanRoutedSubnetArgsDict(TypedDict):
        next_hop: pulumi.Input[str]
        """
        A valid IPv4 address.
        """
        prefix: pulumi.Input[str]
        """
        A valid CIDR notation representing an IP range.
        """
        nat: NotRequired[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgsDict']]
elif False:
    MagicTransitSiteLanRoutedSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanRoutedSubnetArgs:
    def __init__(__self__, *,
                 next_hop: pulumi.Input[str],
                 prefix: pulumi.Input[str],
                 nat: Optional[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgs']] = None):
        """
        :param pulumi.Input[str] next_hop: A valid IPv4 address.
        :param pulumi.Input[str] prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)

    @property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> pulumi.Input[str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: pulumi.Input[str]):
        pulumi.set(self, "next_hop", value)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgs']]:
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgs']]):
        pulumi.set(self, "nat", value)


if not MYPY:
    class MagicTransitSiteLanRoutedSubnetNatArgsDict(TypedDict):
        static_prefix: NotRequired[pulumi.Input[str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteLanRoutedSubnetNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanRoutedSubnetNatArgs:
    def __init__(__self__, *,
                 static_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] static_prefix: A valid CIDR notation representing an IP range.
        """
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")

    @static_prefix.setter
    def static_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static_prefix", value)


if not MYPY:
    class MagicTransitSiteLanStaticAddressingArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        A valid CIDR notation representing an IP range.
        """
        dhcp_relay: NotRequired[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict']]
        dhcp_server: NotRequired[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgsDict']]
        secondary_address: NotRequired[pulumi.Input[str]]
        """
        A valid CIDR notation representing an IP range.
        """
        virtual_address: NotRequired[pulumi.Input[str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteLanStaticAddressingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanStaticAddressingArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 dhcp_relay: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgs']] = None,
                 dhcp_server: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgs']] = None,
                 secondary_address: Optional[pulumi.Input[str]] = None,
                 virtual_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: A valid CIDR notation representing an IP range.
        :param pulumi.Input[str] secondary_address: A valid CIDR notation representing an IP range.
        :param pulumi.Input[str] virtual_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        if dhcp_relay is not None:
            pulumi.set(__self__, "dhcp_relay", dhcp_relay)
        if dhcp_server is not None:
            pulumi.set(__self__, "dhcp_server", dhcp_server)
        if secondary_address is not None:
            pulumi.set(__self__, "secondary_address", secondary_address)
        if virtual_address is not None:
            pulumi.set(__self__, "virtual_address", virtual_address)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="dhcpRelay")
    def dhcp_relay(self) -> Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgs']]:
        return pulumi.get(self, "dhcp_relay")

    @dhcp_relay.setter
    def dhcp_relay(self, value: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgs']]):
        pulumi.set(self, "dhcp_relay", value)

    @property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgs']]:
        return pulumi.get(self, "dhcp_server")

    @dhcp_server.setter
    def dhcp_server(self, value: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgs']]):
        pulumi.set(self, "dhcp_server", value)

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @secondary_address.setter
    def secondary_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_address", value)

    @property
    @pulumi.getter(name="virtualAddress")
    def virtual_address(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "virtual_address")

    @virtual_address.setter
    def virtual_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_address", value)


if not MYPY:
    class MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict(TypedDict):
        server_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of DHCP server IPs.
        """
elif False:
    MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanStaticAddressingDhcpRelayArgs:
    def __init__(__self__, *,
                 server_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_addresses: List of DHCP server IPs.
        """
        if server_addresses is not None:
            pulumi.set(__self__, "server_addresses", server_addresses)

    @property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of DHCP server IPs.
        """
        return pulumi.get(self, "server_addresses")

    @server_addresses.setter
    def server_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "server_addresses", value)


if not MYPY:
    class MagicTransitSiteLanStaticAddressingDhcpServerArgsDict(TypedDict):
        dhcp_pool_end: NotRequired[pulumi.Input[str]]
        """
        A valid IPv4 address.
        """
        dhcp_pool_start: NotRequired[pulumi.Input[str]]
        """
        A valid IPv4 address.
        """
        dns_server: NotRequired[pulumi.Input[str]]
        """
        A valid IPv4 address.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        reservations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Mapping of MAC addresses to IP addresses
        """
elif False:
    MagicTransitSiteLanStaticAddressingDhcpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanStaticAddressingDhcpServerArgs:
    def __init__(__self__, *,
                 dhcp_pool_end: Optional[pulumi.Input[str]] = None,
                 dhcp_pool_start: Optional[pulumi.Input[str]] = None,
                 dns_server: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 reservations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] dhcp_pool_end: A valid IPv4 address.
        :param pulumi.Input[str] dhcp_pool_start: A valid IPv4 address.
        :param pulumi.Input[str] dns_server: A valid IPv4 address.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] reservations: Mapping of MAC addresses to IP addresses
        """
        if dhcp_pool_end is not None:
            pulumi.set(__self__, "dhcp_pool_end", dhcp_pool_end)
        if dhcp_pool_start is not None:
            pulumi.set(__self__, "dhcp_pool_start", dhcp_pool_start)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)

    @property
    @pulumi.getter(name="dhcpPoolEnd")
    def dhcp_pool_end(self) -> Optional[pulumi.Input[str]]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_end")

    @dhcp_pool_end.setter
    def dhcp_pool_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dhcp_pool_end", value)

    @property
    @pulumi.getter(name="dhcpPoolStart")
    def dhcp_pool_start(self) -> Optional[pulumi.Input[str]]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_start")

    @dhcp_pool_start.setter
    def dhcp_pool_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dhcp_pool_start", value)

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[pulumi.Input[str]]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dns_server")

    @dns_server.setter
    def dns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_server", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def reservations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Mapping of MAC addresses to IP addresses
        """
        return pulumi.get(self, "reservations")

    @reservations.setter
    def reservations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "reservations", value)


if not MYPY:
    class MagicTransitSiteLocationArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[str]]
        """
        Latitude
        """
        lon: NotRequired[pulumi.Input[str]]
        """
        Longitude
        """
elif False:
    MagicTransitSiteLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLocationArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[str]] = None,
                 lon: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lat: Latitude
        :param pulumi.Input[str] lon: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)

    @property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[str]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lat", value)

    @property
    @pulumi.getter
    def lon(self) -> Optional[pulumi.Input[str]]:
        """
        Longitude
        """
        return pulumi.get(self, "lon")

    @lon.setter
    def lon(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lon", value)


if not MYPY:
    class MagicTransitSiteWanStaticAddressingArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        A valid CIDR notation representing an IP range.
        """
        gateway_address: pulumi.Input[str]
        """
        A valid IPv4 address.
        """
        secondary_address: NotRequired[pulumi.Input[str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteWanStaticAddressingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteWanStaticAddressingArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 gateway_address: pulumi.Input[str],
                 secondary_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: A valid CIDR notation representing an IP range.
        :param pulumi.Input[str] gateway_address: A valid IPv4 address.
        :param pulumi.Input[str] secondary_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway_address", gateway_address)
        if secondary_address is not None:
            pulumi.set(__self__, "secondary_address", secondary_address)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> pulumi.Input[str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "gateway_address")

    @gateway_address.setter
    def gateway_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_address", value)

    @property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @secondary_address.setter
    def secondary_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_address", value)


if not MYPY:
    class MagicWanGreTunnelGreTunnelArgsDict(TypedDict):
        cloudflare_gre_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        created_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was created.
        """
        customer_gre_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An optional description of the GRE tunnel.
        """
        health_check: NotRequired[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckArgsDict']]
        id: NotRequired[pulumi.Input[str]]
        """
        Tunnel identifier tag.
        """
        interface_address: NotRequired[pulumi.Input[str]]
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was last modified.
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
elif False:
    MagicWanGreTunnelGreTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelGreTunnelArgs:
    def __init__(__self__, *,
                 cloudflare_gre_endpoint: Optional[pulumi.Input[str]] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 customer_gre_endpoint: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 health_check: Optional[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 interface_address: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cloudflare_gre_endpoint: The IP address assigned to the Cloudflare side of the GRE tunnel.
        :param pulumi.Input[str] created_on: The date and time the tunnel was created.
        :param pulumi.Input[str] customer_gre_endpoint: The IP address assigned to the customer side of the GRE tunnel.
        :param pulumi.Input[str] description: An optional description of the GRE tunnel.
        :param pulumi.Input[str] id: Tunnel identifier tag.
        :param pulumi.Input[str] interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        :param pulumi.Input[str] modified_on: The date and time the tunnel was last modified.
        :param pulumi.Input[int] mtu: Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        :param pulumi.Input[str] name: The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        :param pulumi.Input[int] ttl: Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        if cloudflare_gre_endpoint is not None:
            pulumi.set(__self__, "cloudflare_gre_endpoint", cloudflare_gre_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_gre_endpoint is not None:
            pulumi.set(__self__, "customer_gre_endpoint", customer_gre_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="cloudflareGreEndpoint")
    def cloudflare_gre_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        return pulumi.get(self, "cloudflare_gre_endpoint")

    @cloudflare_gre_endpoint.setter
    def cloudflare_gre_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudflare_gre_endpoint", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="customerGreEndpoint")
    def customer_gre_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        return pulumi.get(self, "customer_gre_endpoint")

    @customer_gre_endpoint.setter
    def customer_gre_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_gre_endpoint", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An optional description of the GRE tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckArgs']]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[pulumi.Input[str]]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @interface_address.setter
    def interface_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_address", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class MagicWanGreTunnelGreTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[str]]
        """
        How frequent the health check is run. The default value is `mid`.
        """
        target: NotRequired[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
elif False:
    MagicWanGreTunnelGreTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelGreTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rate: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param pulumi.Input[bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[str] rate: How frequent the health check is run. The default value is `mid`.
        :param pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanGreTunnelGreTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanGreTunnelGreTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanGreTunnelGreTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelGreTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[str]] = None,
                 saved: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective", value)

    @property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanGreTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[str]]
        """
        How frequent the health check is run. The default value is `mid`.
        """
        target: NotRequired[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
elif False:
    MagicWanGreTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rate: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param pulumi.Input[bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[str] rate: How frequent the health check is run. The default value is `mid`.
        :param pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanGreTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanGreTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[str]] = None,
                 saved: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective", value)

    @property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanGreTunnelModifiedGreTunnelArgsDict(TypedDict):
        cloudflare_gre_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        created_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was created.
        """
        customer_gre_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An optional description of the GRE tunnel.
        """
        health_check: NotRequired[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckArgsDict']]
        id: NotRequired[pulumi.Input[str]]
        """
        Tunnel identifier tag.
        """
        interface_address: NotRequired[pulumi.Input[str]]
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was last modified.
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
elif False:
    MagicWanGreTunnelModifiedGreTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelModifiedGreTunnelArgs:
    def __init__(__self__, *,
                 cloudflare_gre_endpoint: Optional[pulumi.Input[str]] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 customer_gre_endpoint: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 health_check: Optional[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 interface_address: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cloudflare_gre_endpoint: The IP address assigned to the Cloudflare side of the GRE tunnel.
        :param pulumi.Input[str] created_on: The date and time the tunnel was created.
        :param pulumi.Input[str] customer_gre_endpoint: The IP address assigned to the customer side of the GRE tunnel.
        :param pulumi.Input[str] description: An optional description of the GRE tunnel.
        :param pulumi.Input[str] id: Tunnel identifier tag.
        :param pulumi.Input[str] interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        :param pulumi.Input[str] modified_on: The date and time the tunnel was last modified.
        :param pulumi.Input[int] mtu: Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        :param pulumi.Input[str] name: The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        :param pulumi.Input[int] ttl: Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        if cloudflare_gre_endpoint is not None:
            pulumi.set(__self__, "cloudflare_gre_endpoint", cloudflare_gre_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_gre_endpoint is not None:
            pulumi.set(__self__, "customer_gre_endpoint", customer_gre_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="cloudflareGreEndpoint")
    def cloudflare_gre_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the Cloudflare side of the GRE tunnel.
        """
        return pulumi.get(self, "cloudflare_gre_endpoint")

    @cloudflare_gre_endpoint.setter
    def cloudflare_gre_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudflare_gre_endpoint", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="customerGreEndpoint")
    def customer_gre_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the customer side of the GRE tunnel.
        """
        return pulumi.get(self, "customer_gre_endpoint")

    @customer_gre_endpoint.setter
    def customer_gre_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_gre_endpoint", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An optional description of the GRE tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckArgs']]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[pulumi.Input[str]]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @interface_address.setter
    def interface_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_address", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time To Live (TTL) in number of hops of the GRE tunnel.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class MagicWanGreTunnelModifiedGreTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[str]]
        """
        How frequent the health check is run. The default value is `mid`.
        """
        target: NotRequired[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
elif False:
    MagicWanGreTunnelModifiedGreTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelModifiedGreTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rate: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param pulumi.Input[bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[str] rate: How frequent the health check is run. The default value is `mid`.
        :param pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelModifiedGreTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[str]] = None,
                 saved: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective", value)

    @property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanIpsecTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[str]]
        """
        How frequent the health check is run. The default value is `mid`.
        """
        target: NotRequired[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
elif False:
    MagicWanIpsecTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rate: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param pulumi.Input[bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[str] rate: How frequent the health check is run. The default value is `mid`.
        :param pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanIpsecTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanIpsecTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[str]] = None,
                 saved: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective", value)

    @property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanIpsecTunnelIpsecTunnelArgsDict(TypedDict):
        allow_null_cipher: NotRequired[pulumi.Input[bool]]
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        cloudflare_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        created_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was created.
        """
        customer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An optional description forthe IPsec tunnel.
        """
        health_check: NotRequired[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckArgsDict']]
        id: NotRequired[pulumi.Input[str]]
        """
        Tunnel identifier tag.
        """
        interface_address: NotRequired[pulumi.Input[str]]
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was last modified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        psk_metadata: NotRequired[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelPskMetadataArgsDict']]
        """
        The PSK metadata that includes when the PSK was generated.
        """
        replay_protection: NotRequired[pulumi.Input[bool]]
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
elif False:
    MagicWanIpsecTunnelIpsecTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelIpsecTunnelArgs:
    def __init__(__self__, *,
                 allow_null_cipher: Optional[pulumi.Input[bool]] = None,
                 cloudflare_endpoint: Optional[pulumi.Input[str]] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 customer_endpoint: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 health_check: Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 interface_address: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 psk_metadata: Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs']] = None,
                 replay_protection: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_null_cipher: When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        :param pulumi.Input[str] cloudflare_endpoint: The IP address assigned to the Cloudflare side of the IPsec tunnel.
        :param pulumi.Input[str] created_on: The date and time the tunnel was created.
        :param pulumi.Input[str] customer_endpoint: The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        :param pulumi.Input[str] description: An optional description forthe IPsec tunnel.
        :param pulumi.Input[str] id: Tunnel identifier tag.
        :param pulumi.Input[str] interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        :param pulumi.Input[str] modified_on: The date and time the tunnel was last modified.
        :param pulumi.Input[str] name: The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        :param pulumi.Input['MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs'] psk_metadata: The PSK metadata that includes when the PSK was generated.
        :param pulumi.Input[bool] replay_protection: If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        if allow_null_cipher is not None:
            pulumi.set(__self__, "allow_null_cipher", allow_null_cipher)
        if cloudflare_endpoint is not None:
            pulumi.set(__self__, "cloudflare_endpoint", cloudflare_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_endpoint is not None:
            pulumi.set(__self__, "customer_endpoint", customer_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if psk_metadata is not None:
            pulumi.set(__self__, "psk_metadata", psk_metadata)
        if replay_protection is not None:
            pulumi.set(__self__, "replay_protection", replay_protection)

    @property
    @pulumi.getter(name="allowNullCipher")
    def allow_null_cipher(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        return pulumi.get(self, "allow_null_cipher")

    @allow_null_cipher.setter
    def allow_null_cipher(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_null_cipher", value)

    @property
    @pulumi.getter(name="cloudflareEndpoint")
    def cloudflare_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        return pulumi.get(self, "cloudflare_endpoint")

    @cloudflare_endpoint.setter
    def cloudflare_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudflare_endpoint", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="customerEndpoint")
    def customer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        return pulumi.get(self, "customer_endpoint")

    @customer_endpoint.setter
    def customer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_endpoint", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An optional description forthe IPsec tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckArgs']]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[pulumi.Input[str]]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @interface_address.setter
    def interface_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_address", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pskMetadata")
    def psk_metadata(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs']]:
        """
        The PSK metadata that includes when the PSK was generated.
        """
        return pulumi.get(self, "psk_metadata")

    @psk_metadata.setter
    def psk_metadata(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs']]):
        pulumi.set(self, "psk_metadata", value)

    @property
    @pulumi.getter(name="replayProtection")
    def replay_protection(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        return pulumi.get(self, "replay_protection")

    @replay_protection.setter
    def replay_protection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replay_protection", value)


if not MYPY:
    class MagicWanIpsecTunnelIpsecTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[str]]
        """
        How frequent the health check is run. The default value is `mid`.
        """
        target: NotRequired[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
elif False:
    MagicWanIpsecTunnelIpsecTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelIpsecTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rate: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param pulumi.Input[bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[str] rate: How frequent the health check is run. The default value is `mid`.
        :param pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelIpsecTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[str]] = None,
                 saved: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective", value)

    @property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanIpsecTunnelIpsecTunnelPskMetadataArgsDict(TypedDict):
        last_generated_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was last modified.
        """
elif False:
    MagicWanIpsecTunnelIpsecTunnelPskMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelIpsecTunnelPskMetadataArgs:
    def __init__(__self__, *,
                 last_generated_on: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_generated_on: The date and time the tunnel was last modified.
        """
        if last_generated_on is not None:
            pulumi.set(__self__, "last_generated_on", last_generated_on)

    @property
    @pulumi.getter(name="lastGeneratedOn")
    def last_generated_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "last_generated_on")

    @last_generated_on.setter
    def last_generated_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_generated_on", value)


if not MYPY:
    class MagicWanIpsecTunnelModifiedIpsecTunnelArgsDict(TypedDict):
        allow_null_cipher: NotRequired[pulumi.Input[bool]]
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        cloudflare_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        created_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was created.
        """
        customer_endpoint: NotRequired[pulumi.Input[str]]
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An optional description forthe IPsec tunnel.
        """
        health_check: NotRequired[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgsDict']]
        id: NotRequired[pulumi.Input[str]]
        """
        Tunnel identifier tag.
        """
        interface_address: NotRequired[pulumi.Input[str]]
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was last modified.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        psk_metadata: NotRequired[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgsDict']]
        """
        The PSK metadata that includes when the PSK was generated.
        """
        replay_protection: NotRequired[pulumi.Input[bool]]
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
elif False:
    MagicWanIpsecTunnelModifiedIpsecTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelModifiedIpsecTunnelArgs:
    def __init__(__self__, *,
                 allow_null_cipher: Optional[pulumi.Input[bool]] = None,
                 cloudflare_endpoint: Optional[pulumi.Input[str]] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 customer_endpoint: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 health_check: Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 interface_address: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 psk_metadata: Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs']] = None,
                 replay_protection: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] allow_null_cipher: When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        :param pulumi.Input[str] cloudflare_endpoint: The IP address assigned to the Cloudflare side of the IPsec tunnel.
        :param pulumi.Input[str] created_on: The date and time the tunnel was created.
        :param pulumi.Input[str] customer_endpoint: The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        :param pulumi.Input[str] description: An optional description forthe IPsec tunnel.
        :param pulumi.Input[str] id: Tunnel identifier tag.
        :param pulumi.Input[str] interface_address: A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        :param pulumi.Input[str] modified_on: The date and time the tunnel was last modified.
        :param pulumi.Input[str] name: The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        :param pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs'] psk_metadata: The PSK metadata that includes when the PSK was generated.
        :param pulumi.Input[bool] replay_protection: If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        if allow_null_cipher is not None:
            pulumi.set(__self__, "allow_null_cipher", allow_null_cipher)
        if cloudflare_endpoint is not None:
            pulumi.set(__self__, "cloudflare_endpoint", cloudflare_endpoint)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if customer_endpoint is not None:
            pulumi.set(__self__, "customer_endpoint", customer_endpoint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_address is not None:
            pulumi.set(__self__, "interface_address", interface_address)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if psk_metadata is not None:
            pulumi.set(__self__, "psk_metadata", psk_metadata)
        if replay_protection is not None:
            pulumi.set(__self__, "replay_protection", replay_protection)

    @property
    @pulumi.getter(name="allowNullCipher")
    def allow_null_cipher(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
        """
        return pulumi.get(self, "allow_null_cipher")

    @allow_null_cipher.setter
    def allow_null_cipher(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_null_cipher", value)

    @property
    @pulumi.getter(name="cloudflareEndpoint")
    def cloudflare_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the Cloudflare side of the IPsec tunnel.
        """
        return pulumi.get(self, "cloudflare_endpoint")

    @cloudflare_endpoint.setter
    def cloudflare_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudflare_endpoint", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="customerEndpoint")
    def customer_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
        """
        return pulumi.get(self, "customer_endpoint")

    @customer_endpoint.setter
    def customer_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_endpoint", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An optional description forthe IPsec tunnel.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgs']]:
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel identifier tag.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="interfaceAddress")
    def interface_address(self) -> Optional[pulumi.Input[str]]:
        """
        A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.
        """
        return pulumi.get(self, "interface_address")

    @interface_address.setter
    def interface_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_address", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the IPsec tunnel. The name cannot share a name with other tunnels.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pskMetadata")
    def psk_metadata(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs']]:
        """
        The PSK metadata that includes when the PSK was generated.
        """
        return pulumi.get(self, "psk_metadata")

    @psk_metadata.setter
    def psk_metadata(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs']]):
        pulumi.set(self, "psk_metadata", value)

    @property
    @pulumi.getter(name="replayProtection")
    def replay_protection(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
        """
        return pulumi.get(self, "replay_protection")

    @replay_protection.setter
    def replay_protection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replay_protection", value)


if not MYPY:
    class MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[str]]
        """
        How frequent the health check is run. The default value is `mid`.
        """
        target: NotRequired[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
elif False:
    MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rate: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        :param pulumi.Input[bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[str] rate: How frequent the health check is run. The default value is `mid`.
        :param pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelModifiedIpsecTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[str]] = None,
                 saved: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective", value)

    @property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgsDict(TypedDict):
        last_generated_on: NotRequired[pulumi.Input[str]]
        """
        The date and time the tunnel was last modified.
        """
elif False:
    MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelModifiedIpsecTunnelPskMetadataArgs:
    def __init__(__self__, *,
                 last_generated_on: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_generated_on: The date and time the tunnel was last modified.
        """
        if last_generated_on is not None:
            pulumi.set(__self__, "last_generated_on", last_generated_on)

    @property
    @pulumi.getter(name="lastGeneratedOn")
    def last_generated_on(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "last_generated_on")

    @last_generated_on.setter
    def last_generated_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_generated_on", value)


if not MYPY:
    class MagicWanStaticRouteModifiedRouteArgsDict(TypedDict):
        created_on: NotRequired[pulumi.Input[str]]
        """
        When the route was created.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An optional human provided description of the static route.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        When the route was last modified.
        """
        nexthop: NotRequired[pulumi.Input[str]]
        """
        The next-hop IP Address for the static route.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority of the static route.
        """
        scope: NotRequired[pulumi.Input['MagicWanStaticRouteModifiedRouteScopeArgsDict']]
        """
        Used only for ECMP routes.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Optional weight of the ECMP scope - if provided.
        """
elif False:
    MagicWanStaticRouteModifiedRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanStaticRouteModifiedRouteArgs:
    def __init__(__self__, *,
                 created_on: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 nexthop: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 scope: Optional[pulumi.Input['MagicWanStaticRouteModifiedRouteScopeArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] created_on: When the route was created.
        :param pulumi.Input[str] description: An optional human provided description of the static route.
        :param pulumi.Input[str] id: Identifier
        :param pulumi.Input[str] modified_on: When the route was last modified.
        :param pulumi.Input[str] nexthop: The next-hop IP Address for the static route.
        :param pulumi.Input[str] prefix: IP Prefix in Classless Inter-Domain Routing format.
        :param pulumi.Input[int] priority: Priority of the static route.
        :param pulumi.Input['MagicWanStaticRouteModifiedRouteScopeArgs'] scope: Used only for ECMP routes.
        :param pulumi.Input[int] weight: Optional weight of the ECMP scope - if provided.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the route was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An optional human provided description of the static route.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the route was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[str]]:
        """
        The next-hop IP Address for the static route.
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nexthop", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of the static route.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['MagicWanStaticRouteModifiedRouteScopeArgs']]:
        """
        Used only for ECMP routes.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['MagicWanStaticRouteModifiedRouteScopeArgs']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Optional weight of the ECMP scope - if provided.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class MagicWanStaticRouteModifiedRouteScopeArgsDict(TypedDict):
        colo_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of colo names for the ECMP scope.
        """
        colo_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of colo regions for the ECMP scope.
        """
elif False:
    MagicWanStaticRouteModifiedRouteScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanStaticRouteModifiedRouteScopeArgs:
    def __init__(__self__, *,
                 colo_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 colo_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] colo_names: List of colo names for the ECMP scope.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @colo_names.setter
    def colo_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "colo_names", value)

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")

    @colo_regions.setter
    def colo_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "colo_regions", value)


if not MYPY:
    class MagicWanStaticRouteRouteArgsDict(TypedDict):
        created_on: NotRequired[pulumi.Input[str]]
        """
        When the route was created.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An optional human provided description of the static route.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        When the route was last modified.
        """
        nexthop: NotRequired[pulumi.Input[str]]
        """
        The next-hop IP Address for the static route.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority of the static route.
        """
        scope: NotRequired[pulumi.Input['MagicWanStaticRouteRouteScopeArgsDict']]
        """
        Used only for ECMP routes.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        Optional weight of the ECMP scope - if provided.
        """
elif False:
    MagicWanStaticRouteRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanStaticRouteRouteArgs:
    def __init__(__self__, *,
                 created_on: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 nexthop: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 scope: Optional[pulumi.Input['MagicWanStaticRouteRouteScopeArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] created_on: When the route was created.
        :param pulumi.Input[str] description: An optional human provided description of the static route.
        :param pulumi.Input[str] id: Identifier
        :param pulumi.Input[str] modified_on: When the route was last modified.
        :param pulumi.Input[str] nexthop: The next-hop IP Address for the static route.
        :param pulumi.Input[str] prefix: IP Prefix in Classless Inter-Domain Routing format.
        :param pulumi.Input[int] priority: Priority of the static route.
        :param pulumi.Input['MagicWanStaticRouteRouteScopeArgs'] scope: Used only for ECMP routes.
        :param pulumi.Input[int] weight: Optional weight of the ECMP scope - if provided.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the route was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An optional human provided description of the static route.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the route was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[str]]:
        """
        The next-hop IP Address for the static route.
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nexthop", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        IP Prefix in Classless Inter-Domain Routing format.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of the static route.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['MagicWanStaticRouteRouteScopeArgs']]:
        """
        Used only for ECMP routes.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['MagicWanStaticRouteRouteScopeArgs']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Optional weight of the ECMP scope - if provided.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class MagicWanStaticRouteRouteScopeArgsDict(TypedDict):
        colo_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of colo names for the ECMP scope.
        """
        colo_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of colo regions for the ECMP scope.
        """
elif False:
    MagicWanStaticRouteRouteScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanStaticRouteRouteScopeArgs:
    def __init__(__self__, *,
                 colo_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 colo_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] colo_names: List of colo names for the ECMP scope.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @colo_names.setter
    def colo_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "colo_names", value)

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")

    @colo_regions.setter
    def colo_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "colo_regions", value)


if not MYPY:
    class MagicWanStaticRouteScopeArgsDict(TypedDict):
        colo_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of colo names for the ECMP scope.
        """
        colo_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of colo regions for the ECMP scope.
        """
elif False:
    MagicWanStaticRouteScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanStaticRouteScopeArgs:
    def __init__(__self__, *,
                 colo_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 colo_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] colo_names: List of colo names for the ECMP scope.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @colo_names.setter
    def colo_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "colo_names", value)

    @property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")

    @colo_regions.setter
    def colo_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "colo_regions", value)


if not MYPY:
    class ManagedTransformsManagedRequestHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether the Managed Transform is enabled.
        """
        id: pulumi.Input[str]
        """
        The human-readable identifier of the Managed Transform.
        """
        conflicts_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        has_conflict: NotRequired[pulumi.Input[bool]]
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
elif False:
    ManagedTransformsManagedRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedTransformsManagedRequestHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str],
                 conflicts_withs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 has_conflict: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether the Managed Transform is enabled.
        :param pulumi.Input[str] id: The human-readable identifier of the Managed Transform.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] conflicts_withs: The Managed Transforms that this Managed Transform conflicts with.
        :param pulumi.Input[bool] has_conflict: Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if conflicts_withs is not None:
            pulumi.set(__self__, "conflicts_withs", conflicts_withs)
        if has_conflict is not None:
            pulumi.set(__self__, "has_conflict", has_conflict)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="conflictsWiths")
    def conflicts_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        return pulumi.get(self, "conflicts_withs")

    @conflicts_withs.setter
    def conflicts_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conflicts_withs", value)

    @property
    @pulumi.getter(name="hasConflict")
    def has_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        return pulumi.get(self, "has_conflict")

    @has_conflict.setter
    def has_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_conflict", value)


if not MYPY:
    class ManagedTransformsManagedResponseHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether the Managed Transform is enabled.
        """
        id: pulumi.Input[str]
        """
        The human-readable identifier of the Managed Transform.
        """
        conflicts_withs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        has_conflict: NotRequired[pulumi.Input[bool]]
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
elif False:
    ManagedTransformsManagedResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedTransformsManagedResponseHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str],
                 conflicts_withs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 has_conflict: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether the Managed Transform is enabled.
        :param pulumi.Input[str] id: The human-readable identifier of the Managed Transform.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] conflicts_withs: The Managed Transforms that this Managed Transform conflicts with.
        :param pulumi.Input[bool] has_conflict: Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if conflicts_withs is not None:
            pulumi.set(__self__, "conflicts_withs", conflicts_withs)
        if has_conflict is not None:
            pulumi.set(__self__, "has_conflict", has_conflict)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="conflictsWiths")
    def conflicts_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Managed Transforms that this Managed Transform conflicts with.
        """
        return pulumi.get(self, "conflicts_withs")

    @conflicts_withs.setter
    def conflicts_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conflicts_withs", value)

    @property
    @pulumi.getter(name="hasConflict")
    def has_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
        """
        return pulumi.get(self, "has_conflict")

    @has_conflict.setter
    def has_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_conflict", value)


if not MYPY:
    class NotificationPolicyFiltersArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        affected_asns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring radar_notification
        """
        affected_components: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring incident_alert
        """
        affected_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring radar_notification
        """
        airport_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring maintenance*event*notification
        """
        alert_trigger_preferences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        alert_trigger_preferences_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring pages*event*alert
        """
        event_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring load*balancing*health_alert
        """
        event_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring pages*event*alert
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        health_check_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring health*check*status_notification
        """
        incident_impacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring incident_alert
        """
        input_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring stream*live*notifications
        """
        insight_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring security*insights*alert
        """
        limits: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring billing*usage*alert
        """
        logo_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring logo*match*alert
        """
        megabits_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        new_healths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring load*balancing*health_alert
        """
        new_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring tunnel*health*event
        """
        packets_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        pool_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        pop_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring billing*usage*alert
        """
        project_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring pages*event*alert
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        query_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        requests_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        slos: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring health*check*status_notification
        """
        target_hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        target_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        target_zone_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        traffic_exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring traffic*anomalies*alert
        """
        tunnel_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Used for configuring tunnel*health*event
        """
        tunnel_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        wheres: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
        zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Usage depends on specific alert type
        """
elif False:
    NotificationPolicyFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyFiltersArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 affected_asns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 affected_components: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 affected_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 airport_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alert_trigger_preferences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alert_trigger_preferences_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 event_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 event_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 health_check_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 incident_impacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insight_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 logo_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 megabits_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_healths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 packets_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pop_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 requests_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 slos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_zone_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 traffic_exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wheres: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] affected_asns: Used for configuring radar_notification
        :param pulumi.Input[Sequence[pulumi.Input[str]]] affected_components: Used for configuring incident_alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] affected_locations: Used for configuring radar_notification
        :param pulumi.Input[Sequence[pulumi.Input[str]]] airport_codes: Used for configuring maintenance*event*notification
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alert_trigger_preferences: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alert_trigger_preferences_values: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] enableds: Used for configuring load*balancing*pool*enablement*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] environments: Used for configuring pages*event*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] event_sources: Used for configuring load*balancing*health_alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] event_types: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: Used for configuring pages*event*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] health_check_ids: Used for configuring health*check*status_notification
        :param pulumi.Input[Sequence[pulumi.Input[str]]] incident_impacts: Used for configuring incident_alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_ids: Used for configuring stream*live*notifications
        :param pulumi.Input[Sequence[pulumi.Input[str]]] insight_classes: Used for configuring security*insights*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limits: Used for configuring billing*usage*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] logo_tags: Used for configuring logo*match*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] megabits_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_healths: Used for configuring load*balancing*health_alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_statuses: Used for configuring tunnel*health*event
        :param pulumi.Input[Sequence[pulumi.Input[str]]] packets_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pool_ids: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pop_names: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: Used for configuring billing*usage*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_ids: Used for configuring pages*event*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] query_tags: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] requests_per_seconds: Used for configuring advanced*ddos*attack*l7*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selectors: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: Used for configuring clickhouse*alert*fw*ent*anomaly
        :param pulumi.Input[Sequence[pulumi.Input[str]]] slos: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statuses: Used for configuring health*check*status_notification
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_hostnames: Used for configuring advanced*ddos*attack*l7*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_ips: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_zone_names: Used for configuring advanced*ddos*attack*l7*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] traffic_exclusions: Used for configuring traffic*anomalies*alert
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_ids: Used for configuring tunnel*health*event
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_names: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wheres: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: Usage depends on specific alert type
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if affected_asns is not None:
            pulumi.set(__self__, "affected_asns", affected_asns)
        if affected_components is not None:
            pulumi.set(__self__, "affected_components", affected_components)
        if affected_locations is not None:
            pulumi.set(__self__, "affected_locations", affected_locations)
        if airport_codes is not None:
            pulumi.set(__self__, "airport_codes", airport_codes)
        if alert_trigger_preferences is not None:
            pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        if alert_trigger_preferences_values is not None:
            pulumi.set(__self__, "alert_trigger_preferences_values", alert_trigger_preferences_values)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if event_sources is not None:
            pulumi.set(__self__, "event_sources", event_sources)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if incident_impacts is not None:
            pulumi.set(__self__, "incident_impacts", incident_impacts)
        if input_ids is not None:
            pulumi.set(__self__, "input_ids", input_ids)
        if insight_classes is not None:
            pulumi.set(__self__, "insight_classes", insight_classes)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if logo_tags is not None:
            pulumi.set(__self__, "logo_tags", logo_tags)
        if megabits_per_seconds is not None:
            pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            pulumi.set(__self__, "new_healths", new_healths)
        if new_statuses is not None:
            pulumi.set(__self__, "new_statuses", new_statuses)
        if packets_per_seconds is not None:
            pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if pop_names is not None:
            pulumi.set(__self__, "pop_names", pop_names)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if query_tags is not None:
            pulumi.set(__self__, "query_tags", query_tags)
        if requests_per_seconds is not None:
            pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if slos is not None:
            pulumi.set(__self__, "slos", slos)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if target_hostnames is not None:
            pulumi.set(__self__, "target_hostnames", target_hostnames)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if target_zone_names is not None:
            pulumi.set(__self__, "target_zone_names", target_zone_names)
        if traffic_exclusions is not None:
            pulumi.set(__self__, "traffic_exclusions", traffic_exclusions)
        if tunnel_ids is not None:
            pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        if tunnel_names is not None:
            pulumi.set(__self__, "tunnel_names", tunnel_names)
        if wheres is not None:
            pulumi.set(__self__, "wheres", wheres)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="affectedAsns")
    def affected_asns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_asns")

    @affected_asns.setter
    def affected_asns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "affected_asns", value)

    @property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "affected_components")

    @affected_components.setter
    def affected_components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "affected_components", value)

    @property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_locations")

    @affected_locations.setter
    def affected_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "affected_locations", value)

    @property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring maintenance*event*notification
        """
        return pulumi.get(self, "airport_codes")

    @airport_codes.setter
    def airport_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "airport_codes", value)

    @property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @alert_trigger_preferences.setter
    def alert_trigger_preferences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alert_trigger_preferences", value)

    @property
    @pulumi.getter(name="alertTriggerPreferencesValues")
    def alert_trigger_preferences_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences_values")

    @alert_trigger_preferences_values.setter
    def alert_trigger_preferences_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alert_trigger_preferences_values", value)

    @property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enableds", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "event_sources")

    @event_sources.setter
    def event_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "event_sources", value)

    @property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "event_types")

    @event_types.setter
    def event_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "event_types", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "health_check_ids")

    @health_check_ids.setter
    def health_check_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "health_check_ids", value)

    @property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "incident_impacts")

    @incident_impacts.setter
    def incident_impacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "incident_impacts", value)

    @property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring stream*live*notifications
        """
        return pulumi.get(self, "input_ids")

    @input_ids.setter
    def input_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "input_ids", value)

    @property
    @pulumi.getter(name="insightClasses")
    def insight_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring security*insights*alert
        """
        return pulumi.get(self, "insight_classes")

    @insight_classes.setter
    def insight_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "insight_classes", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="logoTags")
    def logo_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring logo*match*alert
        """
        return pulumi.get(self, "logo_tags")

    @logo_tags.setter
    def logo_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "logo_tags", value)

    @property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "megabits_per_seconds")

    @megabits_per_seconds.setter
    def megabits_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "megabits_per_seconds", value)

    @property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "new_healths")

    @new_healths.setter
    def new_healths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_healths", value)

    @property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "new_statuses")

    @new_statuses.setter
    def new_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_statuses", value)

    @property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "packets_per_seconds")

    @packets_per_seconds.setter
    def packets_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "packets_per_seconds", value)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter(name="popNames")
    def pop_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pop_names")

    @pop_names.setter
    def pop_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pop_names", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "project_ids", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="queryTags")
    def query_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "query_tags")

    @query_tags.setter
    def query_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "query_tags", value)

    @property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "requests_per_seconds")

    @requests_per_seconds.setter
    def requests_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "requests_per_seconds", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "selectors", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def slos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "slos")

    @slos.setter
    def slos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "slos", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statuses", value)

    @property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_hostnames")

    @target_hostnames.setter
    def target_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_hostnames", value)

    @property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "target_ips")

    @target_ips.setter
    def target_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_ips", value)

    @property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_zone_names")

    @target_zone_names.setter
    def target_zone_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_zone_names", value)

    @property
    @pulumi.getter(name="trafficExclusions")
    def traffic_exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring traffic*anomalies*alert
        """
        return pulumi.get(self, "traffic_exclusions")

    @traffic_exclusions.setter
    def traffic_exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "traffic_exclusions", value)

    @property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "tunnel_ids")

    @tunnel_ids.setter
    def tunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tunnel_ids", value)

    @property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "tunnel_names")

    @tunnel_names.setter
    def tunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tunnel_names", value)

    @property
    @pulumi.getter
    def wheres(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "wheres")

    @wheres.setter
    def wheres(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wheres", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class NotificationPolicyMechanismsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgsDict']]]]
        pagerduties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgsDict']]]]
        webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgsDict']]]]
elif False:
    NotificationPolicyMechanismsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgs']]]] = None,
                 pagerduties: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgs']]]] = None,
                 webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgs']]]] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if pagerduties is not None:
            pulumi.set(__self__, "pagerduties", pagerduties)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgs']]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgs']]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def pagerduties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgs']]]]:
        return pulumi.get(self, "pagerduties")

    @pagerduties.setter
    def pagerduties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgs']]]]):
        pulumi.set(self, "pagerduties", value)

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgs']]]]:
        return pulumi.get(self, "webhooks")

    @webhooks.setter
    def webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgs']]]]):
        pulumi.set(self, "webhooks", value)


if not MYPY:
    class NotificationPolicyMechanismsEmailArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The email address
        """
elif False:
    NotificationPolicyMechanismsEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsEmailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The email address
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The email address
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NotificationPolicyMechanismsPagerdutyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        UUID
        """
elif False:
    NotificationPolicyMechanismsPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsPagerdutyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: UUID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NotificationPolicyMechanismsWebhookArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        UUID
        """
elif False:
    NotificationPolicyMechanismsWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsWebhookArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: UUID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ObservatoryScheduledTestScheduleArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[str]]
        """
        The frequency of the test.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        A test region.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        A URL.
        """
elif False:
    ObservatoryScheduledTestScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestScheduleArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] frequency: The frequency of the test.
        :param pulumi.Input[str] region: A test region.
        :param pulumi.Input[str] url: A URL.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        The frequency of the test.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        A test region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ObservatoryScheduledTestTestArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[str]]
        desktop_report: NotRequired[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgsDict']]
        """
        The Lighthouse report.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        UUID
        """
        mobile_report: NotRequired[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgsDict']]
        """
        The Lighthouse report.
        """
        region: NotRequired[pulumi.Input['ObservatoryScheduledTestTestRegionArgsDict']]
        """
        A test region with a label.
        """
        schedule_frequency: NotRequired[pulumi.Input[str]]
        """
        The frequency of the test.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        A URL.
        """
elif False:
    ObservatoryScheduledTestTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[str]] = None,
                 desktop_report: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 mobile_report: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs']] = None,
                 region: Optional[pulumi.Input['ObservatoryScheduledTestTestRegionArgs']] = None,
                 schedule_frequency: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs'] desktop_report: The Lighthouse report.
        :param pulumi.Input[str] id: UUID
        :param pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs'] mobile_report: The Lighthouse report.
        :param pulumi.Input['ObservatoryScheduledTestTestRegionArgs'] region: A test region with a label.
        :param pulumi.Input[str] schedule_frequency: The frequency of the test.
        :param pulumi.Input[str] url: A URL.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if desktop_report is not None:
            pulumi.set(__self__, "desktop_report", desktop_report)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mobile_report is not None:
            pulumi.set(__self__, "mobile_report", mobile_report)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if schedule_frequency is not None:
            pulumi.set(__self__, "schedule_frequency", schedule_frequency)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="desktopReport")
    def desktop_report(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs']]:
        """
        The Lighthouse report.
        """
        return pulumi.get(self, "desktop_report")

    @desktop_report.setter
    def desktop_report(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs']]):
        pulumi.set(self, "desktop_report", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="mobileReport")
    def mobile_report(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs']]:
        """
        The Lighthouse report.
        """
        return pulumi.get(self, "mobile_report")

    @mobile_report.setter
    def mobile_report(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs']]):
        pulumi.set(self, "mobile_report", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestRegionArgs']]:
        """
        A test region with a label.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestRegionArgs']]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        The frequency of the test.
        """
        return pulumi.get(self, "schedule_frequency")

    @schedule_frequency.setter
    def schedule_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_frequency", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ObservatoryScheduledTestTestDesktopReportArgsDict(TypedDict):
        cls: NotRequired[pulumi.Input[float]]
        """
        Cumulative Layout Shift.
        """
        device_type: NotRequired[pulumi.Input[str]]
        """
        The type of device.
        """
        error: NotRequired[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgsDict']]
        fcp: NotRequired[pulumi.Input[float]]
        """
        First Contentful Paint.
        """
        json_report_url: NotRequired[pulumi.Input[str]]
        """
        The URL to the full Lighthouse JSON report.
        """
        lcp: NotRequired[pulumi.Input[float]]
        """
        Largest Contentful Paint.
        """
        performance_score: NotRequired[pulumi.Input[float]]
        """
        The Lighthouse performance score.
        """
        si: NotRequired[pulumi.Input[float]]
        """
        Speed Index.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The state of the Lighthouse report.
        """
        tbt: NotRequired[pulumi.Input[float]]
        """
        Total Blocking Time.
        """
        ttfb: NotRequired[pulumi.Input[float]]
        """
        Time To First Byte.
        """
        tti: NotRequired[pulumi.Input[float]]
        """
        Time To Interactive.
        """
elif False:
    ObservatoryScheduledTestTestDesktopReportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestDesktopReportArgs:
    def __init__(__self__, *,
                 cls: Optional[pulumi.Input[float]] = None,
                 device_type: Optional[pulumi.Input[str]] = None,
                 error: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgs']] = None,
                 fcp: Optional[pulumi.Input[float]] = None,
                 json_report_url: Optional[pulumi.Input[str]] = None,
                 lcp: Optional[pulumi.Input[float]] = None,
                 performance_score: Optional[pulumi.Input[float]] = None,
                 si: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tbt: Optional[pulumi.Input[float]] = None,
                 ttfb: Optional[pulumi.Input[float]] = None,
                 tti: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] cls: Cumulative Layout Shift.
        :param pulumi.Input[str] device_type: The type of device.
        :param pulumi.Input[float] fcp: First Contentful Paint.
        :param pulumi.Input[str] json_report_url: The URL to the full Lighthouse JSON report.
        :param pulumi.Input[float] lcp: Largest Contentful Paint.
        :param pulumi.Input[float] performance_score: The Lighthouse performance score.
        :param pulumi.Input[float] si: Speed Index.
        :param pulumi.Input[str] state: The state of the Lighthouse report.
        :param pulumi.Input[float] tbt: Total Blocking Time.
        :param pulumi.Input[float] ttfb: Time To First Byte.
        :param pulumi.Input[float] tti: Time To Interactive.
        """
        if cls is not None:
            pulumi.set(__self__, "cls", cls)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fcp is not None:
            pulumi.set(__self__, "fcp", fcp)
        if json_report_url is not None:
            pulumi.set(__self__, "json_report_url", json_report_url)
        if lcp is not None:
            pulumi.set(__self__, "lcp", lcp)
        if performance_score is not None:
            pulumi.set(__self__, "performance_score", performance_score)
        if si is not None:
            pulumi.set(__self__, "si", si)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tbt is not None:
            pulumi.set(__self__, "tbt", tbt)
        if ttfb is not None:
            pulumi.set(__self__, "ttfb", ttfb)
        if tti is not None:
            pulumi.set(__self__, "tti", tti)

    @property
    @pulumi.getter
    def cls(self) -> Optional[pulumi.Input[float]]:
        """
        Cumulative Layout Shift.
        """
        return pulumi.get(self, "cls")

    @cls.setter
    def cls(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cls", value)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of device.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgs']]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgs']]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter
    def fcp(self) -> Optional[pulumi.Input[float]]:
        """
        First Contentful Paint.
        """
        return pulumi.get(self, "fcp")

    @fcp.setter
    def fcp(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "fcp", value)

    @property
    @pulumi.getter(name="jsonReportUrl")
    def json_report_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the full Lighthouse JSON report.
        """
        return pulumi.get(self, "json_report_url")

    @json_report_url.setter
    def json_report_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_report_url", value)

    @property
    @pulumi.getter
    def lcp(self) -> Optional[pulumi.Input[float]]:
        """
        Largest Contentful Paint.
        """
        return pulumi.get(self, "lcp")

    @lcp.setter
    def lcp(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lcp", value)

    @property
    @pulumi.getter(name="performanceScore")
    def performance_score(self) -> Optional[pulumi.Input[float]]:
        """
        The Lighthouse performance score.
        """
        return pulumi.get(self, "performance_score")

    @performance_score.setter
    def performance_score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "performance_score", value)

    @property
    @pulumi.getter
    def si(self) -> Optional[pulumi.Input[float]]:
        """
        Speed Index.
        """
        return pulumi.get(self, "si")

    @si.setter
    def si(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "si", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the Lighthouse report.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def tbt(self) -> Optional[pulumi.Input[float]]:
        """
        Total Blocking Time.
        """
        return pulumi.get(self, "tbt")

    @tbt.setter
    def tbt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "tbt", value)

    @property
    @pulumi.getter
    def ttfb(self) -> Optional[pulumi.Input[float]]:
        """
        Time To First Byte.
        """
        return pulumi.get(self, "ttfb")

    @ttfb.setter
    def ttfb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ttfb", value)

    @property
    @pulumi.getter
    def tti(self) -> Optional[pulumi.Input[float]]:
        """
        Time To Interactive.
        """
        return pulumi.get(self, "tti")

    @tti.setter
    def tti(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "tti", value)


if not MYPY:
    class ObservatoryScheduledTestTestDesktopReportErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        """
        The error code of the Lighthouse result.
        """
        detail: NotRequired[pulumi.Input[str]]
        """
        Detailed error message.
        """
        final_displayed_url: NotRequired[pulumi.Input[str]]
        """
        The final URL displayed to the user.
        """
elif False:
    ObservatoryScheduledTestTestDesktopReportErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestDesktopReportErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 detail: Optional[pulumi.Input[str]] = None,
                 final_displayed_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] code: The error code of the Lighthouse result.
        :param pulumi.Input[str] detail: Detailed error message.
        :param pulumi.Input[str] final_displayed_url: The final URL displayed to the user.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if final_displayed_url is not None:
            pulumi.set(__self__, "final_displayed_url", final_displayed_url)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        The error code of the Lighthouse result.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[str]]:
        """
        Detailed error message.
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail", value)

    @property
    @pulumi.getter(name="finalDisplayedUrl")
    def final_displayed_url(self) -> Optional[pulumi.Input[str]]:
        """
        The final URL displayed to the user.
        """
        return pulumi.get(self, "final_displayed_url")

    @final_displayed_url.setter
    def final_displayed_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "final_displayed_url", value)


if not MYPY:
    class ObservatoryScheduledTestTestMobileReportArgsDict(TypedDict):
        cls: NotRequired[pulumi.Input[float]]
        """
        Cumulative Layout Shift.
        """
        device_type: NotRequired[pulumi.Input[str]]
        """
        The type of device.
        """
        error: NotRequired[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgsDict']]
        fcp: NotRequired[pulumi.Input[float]]
        """
        First Contentful Paint.
        """
        json_report_url: NotRequired[pulumi.Input[str]]
        """
        The URL to the full Lighthouse JSON report.
        """
        lcp: NotRequired[pulumi.Input[float]]
        """
        Largest Contentful Paint.
        """
        performance_score: NotRequired[pulumi.Input[float]]
        """
        The Lighthouse performance score.
        """
        si: NotRequired[pulumi.Input[float]]
        """
        Speed Index.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        The state of the Lighthouse report.
        """
        tbt: NotRequired[pulumi.Input[float]]
        """
        Total Blocking Time.
        """
        ttfb: NotRequired[pulumi.Input[float]]
        """
        Time To First Byte.
        """
        tti: NotRequired[pulumi.Input[float]]
        """
        Time To Interactive.
        """
elif False:
    ObservatoryScheduledTestTestMobileReportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestMobileReportArgs:
    def __init__(__self__, *,
                 cls: Optional[pulumi.Input[float]] = None,
                 device_type: Optional[pulumi.Input[str]] = None,
                 error: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgs']] = None,
                 fcp: Optional[pulumi.Input[float]] = None,
                 json_report_url: Optional[pulumi.Input[str]] = None,
                 lcp: Optional[pulumi.Input[float]] = None,
                 performance_score: Optional[pulumi.Input[float]] = None,
                 si: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tbt: Optional[pulumi.Input[float]] = None,
                 ttfb: Optional[pulumi.Input[float]] = None,
                 tti: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] cls: Cumulative Layout Shift.
        :param pulumi.Input[str] device_type: The type of device.
        :param pulumi.Input[float] fcp: First Contentful Paint.
        :param pulumi.Input[str] json_report_url: The URL to the full Lighthouse JSON report.
        :param pulumi.Input[float] lcp: Largest Contentful Paint.
        :param pulumi.Input[float] performance_score: The Lighthouse performance score.
        :param pulumi.Input[float] si: Speed Index.
        :param pulumi.Input[str] state: The state of the Lighthouse report.
        :param pulumi.Input[float] tbt: Total Blocking Time.
        :param pulumi.Input[float] ttfb: Time To First Byte.
        :param pulumi.Input[float] tti: Time To Interactive.
        """
        if cls is not None:
            pulumi.set(__self__, "cls", cls)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fcp is not None:
            pulumi.set(__self__, "fcp", fcp)
        if json_report_url is not None:
            pulumi.set(__self__, "json_report_url", json_report_url)
        if lcp is not None:
            pulumi.set(__self__, "lcp", lcp)
        if performance_score is not None:
            pulumi.set(__self__, "performance_score", performance_score)
        if si is not None:
            pulumi.set(__self__, "si", si)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tbt is not None:
            pulumi.set(__self__, "tbt", tbt)
        if ttfb is not None:
            pulumi.set(__self__, "ttfb", ttfb)
        if tti is not None:
            pulumi.set(__self__, "tti", tti)

    @property
    @pulumi.getter
    def cls(self) -> Optional[pulumi.Input[float]]:
        """
        Cumulative Layout Shift.
        """
        return pulumi.get(self, "cls")

    @cls.setter
    def cls(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cls", value)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of device.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgs']]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgs']]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter
    def fcp(self) -> Optional[pulumi.Input[float]]:
        """
        First Contentful Paint.
        """
        return pulumi.get(self, "fcp")

    @fcp.setter
    def fcp(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "fcp", value)

    @property
    @pulumi.getter(name="jsonReportUrl")
    def json_report_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the full Lighthouse JSON report.
        """
        return pulumi.get(self, "json_report_url")

    @json_report_url.setter
    def json_report_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_report_url", value)

    @property
    @pulumi.getter
    def lcp(self) -> Optional[pulumi.Input[float]]:
        """
        Largest Contentful Paint.
        """
        return pulumi.get(self, "lcp")

    @lcp.setter
    def lcp(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lcp", value)

    @property
    @pulumi.getter(name="performanceScore")
    def performance_score(self) -> Optional[pulumi.Input[float]]:
        """
        The Lighthouse performance score.
        """
        return pulumi.get(self, "performance_score")

    @performance_score.setter
    def performance_score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "performance_score", value)

    @property
    @pulumi.getter
    def si(self) -> Optional[pulumi.Input[float]]:
        """
        Speed Index.
        """
        return pulumi.get(self, "si")

    @si.setter
    def si(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "si", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the Lighthouse report.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def tbt(self) -> Optional[pulumi.Input[float]]:
        """
        Total Blocking Time.
        """
        return pulumi.get(self, "tbt")

    @tbt.setter
    def tbt(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "tbt", value)

    @property
    @pulumi.getter
    def ttfb(self) -> Optional[pulumi.Input[float]]:
        """
        Time To First Byte.
        """
        return pulumi.get(self, "ttfb")

    @ttfb.setter
    def ttfb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ttfb", value)

    @property
    @pulumi.getter
    def tti(self) -> Optional[pulumi.Input[float]]:
        """
        Time To Interactive.
        """
        return pulumi.get(self, "tti")

    @tti.setter
    def tti(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "tti", value)


if not MYPY:
    class ObservatoryScheduledTestTestMobileReportErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        """
        The error code of the Lighthouse result.
        """
        detail: NotRequired[pulumi.Input[str]]
        """
        Detailed error message.
        """
        final_displayed_url: NotRequired[pulumi.Input[str]]
        """
        The final URL displayed to the user.
        """
elif False:
    ObservatoryScheduledTestTestMobileReportErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestMobileReportErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 detail: Optional[pulumi.Input[str]] = None,
                 final_displayed_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] code: The error code of the Lighthouse result.
        :param pulumi.Input[str] detail: Detailed error message.
        :param pulumi.Input[str] final_displayed_url: The final URL displayed to the user.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if final_displayed_url is not None:
            pulumi.set(__self__, "final_displayed_url", final_displayed_url)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        The error code of the Lighthouse result.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[str]]:
        """
        Detailed error message.
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail", value)

    @property
    @pulumi.getter(name="finalDisplayedUrl")
    def final_displayed_url(self) -> Optional[pulumi.Input[str]]:
        """
        The final URL displayed to the user.
        """
        return pulumi.get(self, "final_displayed_url")

    @final_displayed_url.setter
    def final_displayed_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "final_displayed_url", value)


if not MYPY:
    class ObservatoryScheduledTestTestRegionArgsDict(TypedDict):
        label: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        A test region.
        """
elif False:
    ObservatoryScheduledTestTestRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestRegionArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: A test region.
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        A test region.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PageRuleActionsArgsDict(TypedDict):
        always_use_https: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        automatic_https_rewrites: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        browser_cache_ttl: NotRequired[pulumi.Input[int]]
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        browser_check: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        bypass_cache_on_cookie: NotRequired[pulumi.Input[str]]
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        cache_by_device_type: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        cache_deception_armor: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        cache_key_fields: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsArgsDict']]
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        cache_level: NotRequired[pulumi.Input[str]]
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        cache_on_cookie: NotRequired[pulumi.Input[str]]
        """
        String value of cookie name to conditionally cache the page.
        """
        cache_ttl_by_status: NotRequired[Any]
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        disable_apps: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_performance: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_security: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        disable_zaraz: NotRequired[pulumi.Input[bool]]
        """
        Boolean of whether this action is enabled. Default: false.
        """
        edge_cache_ttl: NotRequired[pulumi.Input[int]]
        """
        The Time To Live for the edge cache.
        """
        email_obfuscation: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        explicit_cache_control: NotRequired[pulumi.Input[str]]
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        forwarding_url: NotRequired[pulumi.Input['PageRuleActionsForwardingUrlArgsDict']]
        """
        The URL to forward to, and with what status. See below.
        """
        host_header_override: NotRequired[pulumi.Input[str]]
        """
        Value of the Host header to send.
        """
        ip_geolocation: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        mirage: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        opportunistic_encryption: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        origin_error_page_pass_thru: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        polish: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        resolve_override: NotRequired[pulumi.Input[str]]
        """
        Overridden origin server name.
        """
        respect_strong_etag: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        response_buffering: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        rocket_loader: NotRequired[pulumi.Input[str]]
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        security_level: NotRequired[pulumi.Input[str]]
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        sort_query_string_for_cache: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        ssl: NotRequired[pulumi.Input[str]]
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        true_client_ip_header: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
        waf: NotRequired[pulumi.Input[str]]
        """
        Whether this action is `"on"` or `"off"`.
        """
elif False:
    PageRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsArgs:
    def __init__(__self__, *,
                 always_use_https: Optional[pulumi.Input[bool]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[int]] = None,
                 browser_check: Optional[pulumi.Input[str]] = None,
                 bypass_cache_on_cookie: Optional[pulumi.Input[str]] = None,
                 cache_by_device_type: Optional[pulumi.Input[str]] = None,
                 cache_deception_armor: Optional[pulumi.Input[str]] = None,
                 cache_key_fields: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']] = None,
                 cache_level: Optional[pulumi.Input[str]] = None,
                 cache_on_cookie: Optional[pulumi.Input[str]] = None,
                 cache_ttl_by_status: Optional[Any] = None,
                 disable_apps: Optional[pulumi.Input[bool]] = None,
                 disable_performance: Optional[pulumi.Input[bool]] = None,
                 disable_security: Optional[pulumi.Input[bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[bool]] = None,
                 edge_cache_ttl: Optional[pulumi.Input[int]] = None,
                 email_obfuscation: Optional[pulumi.Input[str]] = None,
                 explicit_cache_control: Optional[pulumi.Input[str]] = None,
                 forwarding_url: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']] = None,
                 host_header_override: Optional[pulumi.Input[str]] = None,
                 ip_geolocation: Optional[pulumi.Input[str]] = None,
                 mirage: Optional[pulumi.Input[str]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[str]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 resolve_override: Optional[pulumi.Input[str]] = None,
                 respect_strong_etag: Optional[pulumi.Input[str]] = None,
                 response_buffering: Optional[pulumi.Input[str]] = None,
                 rocket_loader: Optional[pulumi.Input[str]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[str]] = None,
                 waf: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] always_use_https: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[str] automatic_https_rewrites: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[int] browser_cache_ttl: The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        :param pulumi.Input[str] browser_check: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] bypass_cache_on_cookie: String value of cookie name to conditionally bypass cache the page.
        :param pulumi.Input[str] cache_by_device_type: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] cache_deception_armor: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsArgs'] cache_key_fields: Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        :param pulumi.Input[str] cache_level: Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        :param pulumi.Input[str] cache_on_cookie: String value of cookie name to conditionally cache the page.
        :param Any cache_ttl_by_status: Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        :param pulumi.Input[bool] disable_apps: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_performance: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_security: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[bool] disable_zaraz: Boolean of whether this action is enabled. Default: false.
        :param pulumi.Input[int] edge_cache_ttl: The Time To Live for the edge cache.
        :param pulumi.Input[str] email_obfuscation: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] explicit_cache_control: Whether origin Cache-Control action is `"on"` or `"off"`.
        :param pulumi.Input['PageRuleActionsForwardingUrlArgs'] forwarding_url: The URL to forward to, and with what status. See below.
        :param pulumi.Input[str] host_header_override: Value of the Host header to send.
        :param pulumi.Input[str] ip_geolocation: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] mirage: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] opportunistic_encryption: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] origin_error_page_pass_thru: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] polish: Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        :param pulumi.Input[str] resolve_override: Overridden origin server name.
        :param pulumi.Input[str] respect_strong_etag: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] response_buffering: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] rocket_loader: Whether to set the rocket loader to `"on"`, `"off"`.
        :param pulumi.Input[str] security_level: Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        :param pulumi.Input[str] sort_query_string_for_cache: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] ssl: Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        :param pulumi.Input[str] true_client_ip_header: Whether this action is `"on"` or `"off"`.
        :param pulumi.Input[str] waf: Whether this action is `"on"` or `"off"`.
        """
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_status is not None:
            pulumi.set(__self__, "cache_ttl_by_status", cache_ttl_by_status)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_use_https", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The Time To Live for the browser cache. `0` means 'Respect Existing Headers'
        """
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "browser_check", value)

    @property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        String value of cookie name to conditionally bypass cache the page.
        """
        return pulumi.get(self, "bypass_cache_on_cookie")

    @bypass_cache_on_cookie.setter
    def bypass_cache_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bypass_cache_on_cookie", value)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_by_device_type", value)

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_deception_armor", value)

    @property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]:
        """
        Controls how Cloudflare creates Cache Keys used to identify files in cache. See below for full description.
        """
        return pulumi.get(self, "cache_key_fields")

    @cache_key_fields.setter
    def cache_key_fields(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]):
        pulumi.set(self, "cache_key_fields", value)

    @property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the cache level to `"bypass"`, `"basic"`, `"simplified"`, `"aggressive"`, or `"cache_everything"`.
        """
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_level", value)

    @property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[pulumi.Input[str]]:
        """
        String value of cookie name to conditionally cache the page.
        """
        return pulumi.get(self, "cache_on_cookie")

    @cache_on_cookie.setter
    def cache_on_cookie(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_on_cookie", value)

    @property
    @pulumi.getter(name="cacheTtlByStatus")
    def cache_ttl_by_status(self) -> Optional[Any]:
        """
        Set cache TTL based on the response status from the origin web server. Can be specified multiple times. See below for full description.
        """
        return pulumi.get(self, "cache_ttl_by_status")

    @cache_ttl_by_status.setter
    def cache_ttl_by_status(self, value: Optional[Any]):
        pulumi.set(self, "cache_ttl_by_status", value)

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_apps", value)

    @property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_performance")

    @disable_performance.setter
    def disable_performance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_performance", value)

    @property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_security")

    @disable_security.setter
    def disable_security(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_security", value)

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean of whether this action is enabled. Default: false.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The Time To Live for the edge cache.
        """
        return pulumi.get(self, "edge_cache_ttl")

    @edge_cache_ttl.setter
    def edge_cache_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "edge_cache_ttl", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[pulumi.Input[str]]:
        """
        Whether origin Cache-Control action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "explicit_cache_control")

    @explicit_cache_control.setter
    def explicit_cache_control(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "explicit_cache_control", value)

    @property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]:
        """
        The URL to forward to, and with what status. See below.
        """
        return pulumi.get(self, "forwarding_url")

    @forwarding_url.setter
    def forwarding_url(self, value: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]):
        pulumi.set(self, "forwarding_url", value)

    @property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the Host header to send.
        """
        return pulumi.get(self, "host_header_override")

    @host_header_override.setter
    def host_header_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header_override", value)

    @property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_geolocation", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"off"`, `"lossless"` or `"lossy"`.
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[pulumi.Input[str]]:
        """
        Overridden origin server name.
        """
        return pulumi.get(self, "resolve_override")

    @resolve_override.setter
    def resolve_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolve_override", value)

    @property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "respect_strong_etag")

    @respect_strong_etag.setter
    def respect_strong_etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "respect_strong_etag", value)

    @property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_buffering", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the rocket loader to `"on"`, `"off"`.
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the security level to `"off"`, `"essentially_off"`, `"low"`, `"medium"`, `"high"`, or `"under_attack"`.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to set the SSL mode to `"off"`, `"flexible"`, `"full"`, `"strict"`, or `"origin_pull"`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this action is `"on"` or `"off"`.
        """
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "waf", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgsDict']]
        """
        Controls what cookies go into Cache Key:
        """
        header: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgsDict']]
        """
        Controls what HTTP headers go into Cache Key:
        """
        host: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgsDict']]
        """
        Controls which Host header goes into Cache Key:
        """
        query_string: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgsDict']]
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        user: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgsDict']]
        """
        Controls which end user-related features go into the Cache Key.
        """
elif False:
    PageRuleActionsCacheKeyFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']] = None,
                 header: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']] = None,
                 host: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']] = None,
                 query_string: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']] = None,
                 user: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']] = None):
        """
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs'] cookie: Controls what cookies go into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs'] header: Controls what HTTP headers go into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs'] host: Controls which Host header goes into Cache Key:
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs'] query_string: Controls which URL query string parameters go into the Cache Key.
        :param pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs'] user: Controls which end user-related features go into the Cache Key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]:
        """
        Controls what cookies go into Cache Key:
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]:
        """
        Controls what HTTP headers go into Cache Key:
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']]:
        """
        Controls which Host header goes into Cache Key:
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']]:
        """
        Controls which URL query string parameters go into the Cache Key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']]:
        """
        Controls which end user-related features go into the Cache Key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']]):
        pulumi.set(self, "user", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsCookieArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Check for presence of specified cookies, without including their actual values.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Use values of specified cookies in Cache Key.
        """
elif False:
    PageRuleActionsCacheKeyFieldsCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Check for presence of specified cookies, without including their actual values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Use values of specified cookies in Cache Key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Check for presence of specified cookies, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Use values of specified cookies in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsHeaderArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
elif False:
    PageRuleActionsCacheKeyFieldsHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Check for presence of specified HTTP headers, without including their actual values.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Check for presence of specified HTTP headers, without including their actual values.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Exclude these HTTP headers from Cache Key. Currently, only the `Origin` header can be excluded.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Use values of specified HTTP headers in Cache Key. Please refer to [Support article](https://support.cloudflare.com/hc/en-us/articles/115004290387-Creating-Cache-Keys) for the list of HTTP headers that cannot be included. The `Origin` header is always included unless explicitly excluded.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsHostArgsDict(TypedDict):
        resolved: NotRequired[pulumi.Input[bool]]
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
elif False:
    PageRuleActionsCacheKeyFieldsHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] resolved: `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        `false` (default) - includes the Host header in the HTTP request sent to the origin; `true` - includes the Host header that was resolved to get the origin IP for the request (e.g. changed with Resolve Override Page Rule).
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolved", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsQueryStringArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Exclude these query string parameters from Cache Key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only use values of specified query string parameters in Cache Key.
        """
elif False:
    PageRuleActionsCacheKeyFieldsQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsQueryStringArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Exclude these query string parameters from Cache Key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Only use values of specified query string parameters in Cache Key.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Exclude these query string parameters from Cache Key.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only use values of specified query string parameters in Cache Key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsUserArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[bool]]
        """
        `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        """
        geo: NotRequired[pulumi.Input[bool]]
        """
        `true` - includes the clients country, derived from the IP address; defaults to `false`.
        """
        lang: NotRequired[pulumi.Input[bool]]
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:
        """
elif False:
    PageRuleActionsCacheKeyFieldsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[bool]] = None,
                 geo: Optional[pulumi.Input[bool]] = None,
                 lang: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] device_type: `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        :param pulumi.Input[bool] geo: `true` - includes the clients country, derived from the IP address; defaults to `false`.
        :param pulumi.Input[bool] lang: `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.
               
               Example:
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - classifies a request as mobile, desktop, or tablet based on the User Agent; defaults to `false`.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - includes the clients country, derived from the IP address; defaults to `false`.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[bool]]:
        """
        `true` - includes the first language code contained in the `Accept-Language` header sent by the client; defaults to `false`.

        Example:
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class PageRuleActionsForwardingUrlArgsDict(TypedDict):
        status_code: pulumi.Input[int]
        """
        The status code to use for the redirection.
        """
        url: pulumi.Input[str]
        """
        The URL to which the page rule should forward.
        """
elif False:
    PageRuleActionsForwardingUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsForwardingUrlArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[int],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[int] status_code: The status code to use for the redirection.
        :param pulumi.Input[str] url: The URL to which the page rule should forward.
        """
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        The status code to use for the redirection.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to which the page rule should forward.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesDomainValidationDataArgsDict(TypedDict):
        error_message: NotRequired[pulumi.Input[str]]
        method: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        txt_name: NotRequired[pulumi.Input[str]]
        txt_value: NotRequired[pulumi.Input[str]]
elif False:
    PagesDomainValidationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesDomainValidationDataArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 txt_name: Optional[pulumi.Input[str]] = None,
                 txt_value: Optional[pulumi.Input[str]] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_name", value)

    @property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "txt_value", value)


if not MYPY:
    class PagesDomainVerificationDataArgsDict(TypedDict):
        error_message: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    PagesDomainVerificationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesDomainVerificationDataArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[str]]
        """
        Directory to run the command.
        """
        web_analytics_tag: NotRequired[pulumi.Input[str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[bool]] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 destination_dir: Optional[pulumi.Input[str]] = None,
                 root_dir: Optional[pulumi.Input[str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[str]] = None,
                 web_analytics_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[str] build_command: Command used to build project.
        :param pulumi.Input[str] destination_dir: Output directory of the build.
        :param pulumi.Input[str] root_dir: Directory to run the command.
        :param pulumi.Input[str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "build_caching", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_dir", value)

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_dir", value)

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentArgsDict(TypedDict):
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alias URLs pointing to this deployment.
        """
        build_config: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgsDict']]
        """
        Configs for the project build process.
        """
        created_on: NotRequired[pulumi.Input[str]]
        """
        When the deployment was created.
        """
        deployment_trigger: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict']]
        """
        Info about what caused the deployment.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgsDict']]]]
        """
        A dict of env variables to build this deploy.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        Type of deploy.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Id of the deployment.
        """
        is_skipped: NotRequired[pulumi.Input[bool]]
        """
        If the deployment has been skipped.
        """
        latest_stage: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgsDict']]
        """
        The status of the deployment.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        When the deployment was last modified.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        Id of the project.
        """
        project_name: NotRequired[pulumi.Input[str]]
        """
        Name of the project.
        """
        short_id: NotRequired[pulumi.Input[str]]
        """
        Short Id (8 character) of the deployment.
        """
        source: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgsDict']]
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgsDict']]]]
        """
        List of past stages.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The live URL to view this deployment.
        """
elif False:
    PagesProjectCanonicalDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentArgs:
    def __init__(__self__, *,
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 build_config: Optional[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs']] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 deployment_trigger: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs']] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_skipped: Optional[pulumi.Input[bool]] = None,
                 latest_stage: Optional[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs']] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgs']] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aliases: A list of alias URLs pointing to this deployment.
        :param pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs'] build_config: Configs for the project build process.
        :param pulumi.Input[str] created_on: When the deployment was created.
        :param pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs'] deployment_trigger: Info about what caused the deployment.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]] env_vars: A dict of env variables to build this deploy.
        :param pulumi.Input[str] environment: Type of deploy.
        :param pulumi.Input[str] id: Id of the deployment.
        :param pulumi.Input[bool] is_skipped: If the deployment has been skipped.
        :param pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs'] latest_stage: The status of the deployment.
        :param pulumi.Input[str] modified_on: When the deployment was last modified.
        :param pulumi.Input[str] project_id: Id of the project.
        :param pulumi.Input[str] project_name: Name of the project.
        :param pulumi.Input[str] short_id: Short Id (8 character) of the deployment.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]] stages: List of past stages.
        :param pulumi.Input[str] url: The live URL to view this deployment.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if build_config is not None:
            pulumi.set(__self__, "build_config", build_config)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if deployment_trigger is not None:
            pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_skipped is not None:
            pulumi.set(__self__, "is_skipped", is_skipped)
        if latest_stage is not None:
            pulumi.set(__self__, "latest_stage", latest_stage)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs']]:
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @build_config.setter
    def build_config(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs']]):
        pulumi.set(self, "build_config", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs']]:
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @deployment_trigger.setter
    def deployment_trigger(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs']]):
        pulumi.set(self, "deployment_trigger", value)

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]]]:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> Optional[pulumi.Input[bool]]:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @is_skipped.setter
    def is_skipped(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_skipped", value)

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs']]:
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @latest_stage.setter
    def latest_stage(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs']]):
        pulumi.set(self, "latest_stage", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]]]:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]]]):
        pulumi.set(self, "stages", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[str]]
        """
        Directory to run the command.
        """
        web_analytics_tag: NotRequired[pulumi.Input[str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectCanonicalDeploymentBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[bool]] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 destination_dir: Optional[pulumi.Input[str]] = None,
                 root_dir: Optional[pulumi.Input[str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[str]] = None,
                 web_analytics_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[str] build_command: Command used to build project.
        :param pulumi.Input[str] destination_dir: Output directory of the build.
        :param pulumi.Input[str] root_dir: Directory to run the command.
        :param pulumi.Input[str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "build_caching", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_dir", value)

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_dir", value)

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict']]
        """
        Additional info about the trigger.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        What caused the deployment.
        """
elif False:
    PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentDeploymentTriggerArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs'] metadata: Additional info about the trigger.
        :param pulumi.Input[str] type: What caused the deployment.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs']]:
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        Where the trigger happened.
        """
        commit_hash: NotRequired[pulumi.Input[str]]
        """
        Hash of the deployment trigger commit.
        """
        commit_message: NotRequired[pulumi.Input[str]]
        """
        Message of the deployment trigger commit.
        """
elif False:
    PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 commit_hash: Optional[pulumi.Input[str]] = None,
                 commit_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: Where the trigger happened.
        :param pulumi.Input[str] commit_hash: Hash of the deployment trigger commit.
        :param pulumi.Input[str] commit_message: Message of the deployment trigger commit.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[pulumi.Input[str]]:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @commit_hash.setter
    def commit_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_hash", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[str]]:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentEnvVarsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The type of environment variable.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Environment variable value.
        """
elif False:
    PagesProjectCanonicalDeploymentEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentEnvVarsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of environment variable.
        :param pulumi.Input[str] value: Environment variable value.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentLatestStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The current build stage.
        """
        started_on: NotRequired[pulumi.Input[str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        State of the current stage.
        """
elif False:
    PagesProjectCanonicalDeploymentLatestStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentLatestStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 started_on: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ended_on: When the stage ended.
        :param pulumi.Input[str] name: The current build stage.
        :param pulumi.Input[str] started_on: When the stage started.
        :param pulumi.Input[str] status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ended_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "started_on", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgsDict']]
        type: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectCanonicalDeploymentSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentSourceConfigArgsDict(TypedDict):
        deployments_enabled: NotRequired[pulumi.Input[bool]]
        owner: NotRequired[pulumi.Input[str]]
        path_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        path_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        pr_comments_enabled: NotRequired[pulumi.Input[bool]]
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preview_deployment_setting: NotRequired[pulumi.Input[str]]
        production_branch: NotRequired[pulumi.Input[str]]
        production_deployments_enabled: NotRequired[pulumi.Input[bool]]
        repo_name: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectCanonicalDeploymentSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentSourceConfigArgs:
    def __init__(__self__, *,
                 deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 path_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[str]] = None,
                 production_branch: Optional[pulumi.Input[str]] = None,
                 production_deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 repo_name: Optional[pulumi.Input[str]] = None):
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "path_excludes")

    @path_excludes.setter
    def path_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_excludes", value)

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "path_includes")

    @path_includes.setter
    def path_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_includes", value)

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "production_branch", value)

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "production_deployments_enabled")

    @production_deployments_enabled.setter
    def production_deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "production_deployments_enabled", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The current build stage.
        """
        started_on: NotRequired[pulumi.Input[str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        State of the current stage.
        """
elif False:
    PagesProjectCanonicalDeploymentStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 started_on: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ended_on: When the stage ended.
        :param pulumi.Input[str] name: The current build stage.
        :param pulumi.Input[str] started_on: When the stage started.
        :param pulumi.Input[str] status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ended_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "started_on", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectDeploymentConfigsArgsDict(TypedDict):
        preview: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgsDict']]
        """
        Configs for preview deploys.
        """
        production: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsProductionArgsDict']]
        """
        Configs for production deploys.
        """
elif False:
    PagesProjectDeploymentConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsArgs:
    def __init__(__self__, *,
                 preview: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']] = None,
                 production: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']] = None):
        """
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs'] preview: Configs for preview deploys.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionArgs'] production: Configs for production deploys.
        """
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if production is not None:
            pulumi.set(__self__, "production", production)

    @property
    @pulumi.getter
    def preview(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]:
        """
        Configs for preview deploys.
        """
        return pulumi.get(self, "preview")

    @preview.setter
    def preview(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]):
        pulumi.set(self, "preview", value)

    @property
    @pulumi.getter
    def production(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]:
        """
        Configs for production deploys.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]):
        pulumi.set(self, "production", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewArgsDict(TypedDict):
        ai_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict']]]]
        """
        Constellation bindings used for Pages Functions.
        """
        analytics_engine_datasets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict']]]]
        """
        Analytics Engine bindings used for Pages Functions.
        """
        browsers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgsDict']]]]
        """
        Browser bindings used for Pages Functions.
        """
        compatibility_date: NotRequired[pulumi.Input[str]]
        """
        Compatibility date used for Pages Functions.
        """
        compatibility_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Compatibility flags used for Pages Functions.
        """
        d1_databases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict']]]]
        """
        D1 databases used for Pages Functions.
        """
        durable_object_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict']]]]
        """
        Durabble Object namespaces used for Pages Functions.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict']]]]
        """
        Environment variables for build configs.
        """
        hyperdrive_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict']]]]
        """
        Hyperdrive bindings used for Pages Functions.
        """
        kv_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict']]]]
        """
        KV namespaces used for Pages Functions.
        """
        mtls_certificates: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict']]]]
        """
        mTLS bindings used for Pages Functions.
        """
        placement: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgsDict']]
        """
        Placement setting used for Pages Functions.
        """
        queue_producers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict']]]]
        """
        Queue Producer bindings used for Pages Functions.
        """
        r2_buckets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict']]]]
        """
        R2 buckets used for Pages Functions.
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgsDict']]]]
        """
        Services used for Pages Functions.
        """
        vectorize_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict']]]]
        """
        Vectorize bindings used for Pages Functions.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewArgs:
    def __init__(__self__, *,
                 ai_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]]] = None,
                 analytics_engine_datasets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]]] = None,
                 browsers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]]] = None,
                 compatibility_date: Optional[pulumi.Input[str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]]] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]]] = None,
                 hyperdrive_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]]] = None,
                 mtls_certificates: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']] = None,
                 queue_producers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]]] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]]] = None,
                 vectorize_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]] ai_bindings: Constellation bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]] browsers: Browser bindings used for Pages Functions.
        :param pulumi.Input[str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]] d1_databases: D1 databases used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]] durable_object_namespaces: Durabble Object namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]] env_vars: Environment variables for build configs.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]] kv_namespaces: KV namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]] mtls_certificates: mTLS bindings used for Pages Functions.
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs'] placement: Placement setting used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]] queue_producers: Queue Producer bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]] r2_buckets: R2 buckets used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]] services: Services used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        if ai_bindings is not None:
            pulumi.set(__self__, "ai_bindings", ai_bindings)
        if analytics_engine_datasets is not None:
            pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        if browsers is not None:
            pulumi.set(__self__, "browsers", browsers)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if hyperdrive_bindings is not None:
            pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if mtls_certificates is not None:
            pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if queue_producers is not None:
            pulumi.set(__self__, "queue_producers", queue_producers)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vectorize_bindings is not None:
            pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]]]:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @ai_bindings.setter
    def ai_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]]]):
        pulumi.set(self, "ai_bindings", value)

    @property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]]]:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @analytics_engine_datasets.setter
    def analytics_engine_datasets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]]]):
        pulumi.set(self, "analytics_engine_datasets", value)

    @property
    @pulumi.getter
    def browsers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]]]:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @browsers.setter
    def browsers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]]]):
        pulumi.set(self, "browsers", value)

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]]]:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]]]):
        pulumi.set(self, "d1_databases", value)

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]]]:
        """
        Durabble Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]]]:
        """
        Environment variables for build configs.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]]]:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @hyperdrive_bindings.setter
    def hyperdrive_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]]]):
        pulumi.set(self, "hyperdrive_bindings", value)

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]]]:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]]]):
        pulumi.set(self, "kv_namespaces", value)

    @property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]]]:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @mtls_certificates.setter
    def mtls_certificates(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]]]):
        pulumi.set(self, "mtls_certificates", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]:
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]]]:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @queue_producers.setter
    def queue_producers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]]]):
        pulumi.set(self, "queue_producers", value)

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]]]:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]]]):
        pulumi.set(self, "r2_buckets", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]]]:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")

    @vectorize_bindings.setter
    def vectorize_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]]]):
        pulumi.set(self, "vectorize_bindings", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict(TypedDict):
        project_id: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewAiBindingsArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[str]] = None):
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[str]]
        """
        Name of the dataset.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset: Name of the dataset.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewBrowsersArgsDict(TypedDict):
        pass
elif False:
    PagesProjectDeploymentConfigsPreviewBrowsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewBrowsersArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        UUID of the D1 database.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewD1DatabasesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: UUID of the D1 database.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Durabble Object namespace.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace_id: ID of the Durabble Object namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Durabble Object namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        Environment variable value.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of environment variable.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewEnvVarsArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Environment variable value.
        :param pulumi.Input[str] type: The type of environment variable.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        ID of the KV namespace.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewKvNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace_id: ID of the KV namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[str]] = None):
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Placement mode.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Placement mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Queue.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewQueueProducersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Queue.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict(TypedDict):
        jurisdiction: NotRequired[pulumi.Input[str]]
        """
        Jurisdiction of the R2 bucket.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the R2 bucket.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewR2BucketsArgs:
    def __init__(__self__, *,
                 jurisdiction: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] jurisdiction: Jurisdiction of the R2 bucket.
        :param pulumi.Input[str] name: Name of the R2 bucket.
        """
        if jurisdiction is not None:
            pulumi.set(__self__, "jurisdiction", jurisdiction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def jurisdiction(self) -> Optional[pulumi.Input[str]]:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @jurisdiction.setter
    def jurisdiction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jurisdiction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewServicesArgsDict(TypedDict):
        entrypoint: NotRequired[pulumi.Input[str]]
        """
        The entrypoint to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The Service environment.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        The Service name.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewServicesArgs:
    def __init__(__self__, *,
                 entrypoint: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entrypoint: The entrypoint to bind to.
        :param pulumi.Input[str] environment: The Service environment.
        :param pulumi.Input[str] service: The Service name.
        """
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[pulumi.Input[str]]:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @entrypoint.setter
    def entrypoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entrypoint", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        The Service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict(TypedDict):
        index_name: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs:
    def __init__(__self__, *,
                 index_name: Optional[pulumi.Input[str]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionArgsDict(TypedDict):
        ai_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgsDict']]]]
        """
        Constellation bindings used for Pages Functions.
        """
        analytics_engine_datasets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict']]]]
        """
        Analytics Engine bindings used for Pages Functions.
        """
        browsers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgsDict']]]]
        """
        Browser bindings used for Pages Functions.
        """
        compatibility_date: NotRequired[pulumi.Input[str]]
        """
        Compatibility date used for Pages Functions.
        """
        compatibility_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Compatibility flags used for Pages Functions.
        """
        d1_databases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict']]]]
        """
        D1 databases used for Pages Functions.
        """
        durable_object_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict']]]]
        """
        Durabble Object namespaces used for Pages Functions.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgsDict']]]]
        """
        Environment variables for build configs.
        """
        hyperdrive_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict']]]]
        """
        Hyperdrive bindings used for Pages Functions.
        """
        kv_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict']]]]
        """
        KV namespaces used for Pages Functions.
        """
        mtls_certificates: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict']]]]
        """
        mTLS bindings used for Pages Functions.
        """
        placement: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgsDict']]
        """
        Placement setting used for Pages Functions.
        """
        queue_producers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgsDict']]]]
        """
        Queue Producer bindings used for Pages Functions.
        """
        r2_buckets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgsDict']]]]
        """
        R2 buckets used for Pages Functions.
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgsDict']]]]
        """
        Services used for Pages Functions.
        """
        vectorize_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict']]]]
        """
        Vectorize bindings used for Pages Functions.
        """
elif False:
    PagesProjectDeploymentConfigsProductionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionArgs:
    def __init__(__self__, *,
                 ai_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]]] = None,
                 analytics_engine_datasets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]]] = None,
                 browsers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]]] = None,
                 compatibility_date: Optional[pulumi.Input[str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]]] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]]] = None,
                 hyperdrive_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]]] = None,
                 mtls_certificates: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']] = None,
                 queue_producers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]]] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]]] = None,
                 vectorize_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]] ai_bindings: Constellation bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]] browsers: Browser bindings used for Pages Functions.
        :param pulumi.Input[str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]] d1_databases: D1 databases used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]] durable_object_namespaces: Durabble Object namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]] env_vars: Environment variables for build configs.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]] kv_namespaces: KV namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]] mtls_certificates: mTLS bindings used for Pages Functions.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs'] placement: Placement setting used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]] queue_producers: Queue Producer bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]] r2_buckets: R2 buckets used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]] services: Services used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        if ai_bindings is not None:
            pulumi.set(__self__, "ai_bindings", ai_bindings)
        if analytics_engine_datasets is not None:
            pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        if browsers is not None:
            pulumi.set(__self__, "browsers", browsers)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if hyperdrive_bindings is not None:
            pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if mtls_certificates is not None:
            pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if queue_producers is not None:
            pulumi.set(__self__, "queue_producers", queue_producers)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vectorize_bindings is not None:
            pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]]]:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @ai_bindings.setter
    def ai_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]]]):
        pulumi.set(self, "ai_bindings", value)

    @property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]]]:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @analytics_engine_datasets.setter
    def analytics_engine_datasets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]]]):
        pulumi.set(self, "analytics_engine_datasets", value)

    @property
    @pulumi.getter
    def browsers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]]]:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @browsers.setter
    def browsers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]]]):
        pulumi.set(self, "browsers", value)

    @property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compatibility_date", value)

    @property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]]]:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]]]):
        pulumi.set(self, "d1_databases", value)

    @property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]]]:
        """
        Durabble Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]]]:
        """
        Environment variables for build configs.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]]]:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @hyperdrive_bindings.setter
    def hyperdrive_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]]]):
        pulumi.set(self, "hyperdrive_bindings", value)

    @property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]]]:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]]]):
        pulumi.set(self, "kv_namespaces", value)

    @property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]]]:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @mtls_certificates.setter
    def mtls_certificates(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]]]):
        pulumi.set(self, "mtls_certificates", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]:
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]]]:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @queue_producers.setter
    def queue_producers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]]]):
        pulumi.set(self, "queue_producers", value)

    @property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]]]:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]]]):
        pulumi.set(self, "r2_buckets", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]]]:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")

    @vectorize_bindings.setter
    def vectorize_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]]]):
        pulumi.set(self, "vectorize_bindings", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionAiBindingsArgsDict(TypedDict):
        project_id: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsProductionAiBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionAiBindingsArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[str]] = None):
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[str]]
        """
        Name of the dataset.
        """
elif False:
    PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset: Name of the dataset.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionBrowsersArgsDict(TypedDict):
        pass
elif False:
    PagesProjectDeploymentConfigsProductionBrowsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionBrowsersArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        UUID of the D1 database.
        """
elif False:
    PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionD1DatabasesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: UUID of the D1 database.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Durabble Object namespace.
        """
elif False:
    PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace_id: ID of the Durabble Object namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Durabble Object namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionEnvVarsArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        Environment variable value.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of environment variable.
        """
elif False:
    PagesProjectDeploymentConfigsProductionEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionEnvVarsArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Environment variable value.
        :param pulumi.Input[str] type: The type of environment variable.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        ID of the KV namespace.
        """
elif False:
    PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionKvNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace_id: ID of the KV namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[str]] = None):
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Placement mode.
        """
elif False:
    PagesProjectDeploymentConfigsProductionPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Placement mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionQueueProducersArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Queue.
        """
elif False:
    PagesProjectDeploymentConfigsProductionQueueProducersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionQueueProducersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Queue.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionR2BucketsArgsDict(TypedDict):
        jurisdiction: NotRequired[pulumi.Input[str]]
        """
        Jurisdiction of the R2 bucket.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the R2 bucket.
        """
elif False:
    PagesProjectDeploymentConfigsProductionR2BucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionR2BucketsArgs:
    def __init__(__self__, *,
                 jurisdiction: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] jurisdiction: Jurisdiction of the R2 bucket.
        :param pulumi.Input[str] name: Name of the R2 bucket.
        """
        if jurisdiction is not None:
            pulumi.set(__self__, "jurisdiction", jurisdiction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def jurisdiction(self) -> Optional[pulumi.Input[str]]:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @jurisdiction.setter
    def jurisdiction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jurisdiction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionServicesArgsDict(TypedDict):
        entrypoint: NotRequired[pulumi.Input[str]]
        """
        The entrypoint to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The Service environment.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        The Service name.
        """
elif False:
    PagesProjectDeploymentConfigsProductionServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionServicesArgs:
    def __init__(__self__, *,
                 entrypoint: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entrypoint: The entrypoint to bind to.
        :param pulumi.Input[str] environment: The Service environment.
        :param pulumi.Input[str] service: The Service name.
        """
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[pulumi.Input[str]]:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @entrypoint.setter
    def entrypoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entrypoint", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        The Service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict(TypedDict):
        index_name: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs:
    def __init__(__self__, *,
                 index_name: Optional[pulumi.Input[str]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class PagesProjectLatestDeploymentArgsDict(TypedDict):
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of alias URLs pointing to this deployment.
        """
        build_config: NotRequired[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgsDict']]
        """
        Configs for the project build process.
        """
        created_on: NotRequired[pulumi.Input[str]]
        """
        When the deployment was created.
        """
        deployment_trigger: NotRequired[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgsDict']]
        """
        Info about what caused the deployment.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgsDict']]]]
        """
        A dict of env variables to build this deploy.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        Type of deploy.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Id of the deployment.
        """
        is_skipped: NotRequired[pulumi.Input[bool]]
        """
        If the deployment has been skipped.
        """
        latest_stage: NotRequired[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgsDict']]
        """
        The status of the deployment.
        """
        modified_on: NotRequired[pulumi.Input[str]]
        """
        When the deployment was last modified.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        Id of the project.
        """
        project_name: NotRequired[pulumi.Input[str]]
        """
        Name of the project.
        """
        short_id: NotRequired[pulumi.Input[str]]
        """
        Short Id (8 character) of the deployment.
        """
        source: NotRequired[pulumi.Input['PagesProjectLatestDeploymentSourceArgsDict']]
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgsDict']]]]
        """
        List of past stages.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The live URL to view this deployment.
        """
elif False:
    PagesProjectLatestDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentArgs:
    def __init__(__self__, *,
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 build_config: Optional[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs']] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 deployment_trigger: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs']] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_skipped: Optional[pulumi.Input[bool]] = None,
                 latest_stage: Optional[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs']] = None,
                 modified_on: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 short_id: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceArgs']] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aliases: A list of alias URLs pointing to this deployment.
        :param pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs'] build_config: Configs for the project build process.
        :param pulumi.Input[str] created_on: When the deployment was created.
        :param pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs'] deployment_trigger: Info about what caused the deployment.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]] env_vars: A dict of env variables to build this deploy.
        :param pulumi.Input[str] environment: Type of deploy.
        :param pulumi.Input[str] id: Id of the deployment.
        :param pulumi.Input[bool] is_skipped: If the deployment has been skipped.
        :param pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs'] latest_stage: The status of the deployment.
        :param pulumi.Input[str] modified_on: When the deployment was last modified.
        :param pulumi.Input[str] project_id: Id of the project.
        :param pulumi.Input[str] project_name: Name of the project.
        :param pulumi.Input[str] short_id: Short Id (8 character) of the deployment.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]] stages: List of past stages.
        :param pulumi.Input[str] url: The live URL to view this deployment.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if build_config is not None:
            pulumi.set(__self__, "build_config", build_config)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if deployment_trigger is not None:
            pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_skipped is not None:
            pulumi.set(__self__, "is_skipped", is_skipped)
        if latest_stage is not None:
            pulumi.set(__self__, "latest_stage", latest_stage)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs']]:
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @build_config.setter
    def build_config(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs']]):
        pulumi.set(self, "build_config", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs']]:
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @deployment_trigger.setter
    def deployment_trigger(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs']]):
        pulumi.set(self, "deployment_trigger", value)

    @property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]]]:
        """
        A dict of env variables to build this deploy.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Type of deploy.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> Optional[pulumi.Input[bool]]:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @is_skipped.setter
    def is_skipped(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_skipped", value)

    @property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs']]:
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @latest_stage.setter
    def latest_stage(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs']]):
        pulumi.set(self, "latest_stage", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[str]]:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_id", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]]]:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]]]):
        pulumi.set(self, "stages", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesProjectLatestDeploymentBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[str]]
        """
        Directory to run the command.
        """
        web_analytics_tag: NotRequired[pulumi.Input[str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectLatestDeploymentBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[bool]] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 destination_dir: Optional[pulumi.Input[str]] = None,
                 root_dir: Optional[pulumi.Input[str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[str]] = None,
                 web_analytics_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[str] build_command: Command used to build project.
        :param pulumi.Input[str] destination_dir: Output directory of the build.
        :param pulumi.Input[str] root_dir: Directory to run the command.
        :param pulumi.Input[str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "build_caching", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_dir", value)

    @property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_dir", value)

    @property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectLatestDeploymentDeploymentTriggerArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict']]
        """
        Additional info about the trigger.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        What caused the deployment.
        """
elif False:
    PagesProjectLatestDeploymentDeploymentTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentDeploymentTriggerArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs'] metadata: Additional info about the trigger.
        :param pulumi.Input[str] type: What caused the deployment.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs']]:
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        What caused the deployment.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        Where the trigger happened.
        """
        commit_hash: NotRequired[pulumi.Input[str]]
        """
        Hash of the deployment trigger commit.
        """
        commit_message: NotRequired[pulumi.Input[str]]
        """
        Message of the deployment trigger commit.
        """
elif False:
    PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 commit_hash: Optional[pulumi.Input[str]] = None,
                 commit_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: Where the trigger happened.
        :param pulumi.Input[str] commit_hash: Hash of the deployment trigger commit.
        :param pulumi.Input[str] commit_message: Message of the deployment trigger commit.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[pulumi.Input[str]]:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @commit_hash.setter
    def commit_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_hash", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[str]]:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_message", value)


if not MYPY:
    class PagesProjectLatestDeploymentEnvVarsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The type of environment variable.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Environment variable value.
        """
elif False:
    PagesProjectLatestDeploymentEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentEnvVarsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of environment variable.
        :param pulumi.Input[str] value: Environment variable value.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of environment variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PagesProjectLatestDeploymentLatestStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The current build stage.
        """
        started_on: NotRequired[pulumi.Input[str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        State of the current stage.
        """
elif False:
    PagesProjectLatestDeploymentLatestStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentLatestStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 started_on: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ended_on: When the stage ended.
        :param pulumi.Input[str] name: The current build stage.
        :param pulumi.Input[str] started_on: When the stage started.
        :param pulumi.Input[str] status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ended_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "started_on", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectLatestDeploymentSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgsDict']]
        type: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectLatestDeploymentSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectLatestDeploymentSourceConfigArgsDict(TypedDict):
        deployments_enabled: NotRequired[pulumi.Input[bool]]
        owner: NotRequired[pulumi.Input[str]]
        path_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        path_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        pr_comments_enabled: NotRequired[pulumi.Input[bool]]
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preview_deployment_setting: NotRequired[pulumi.Input[str]]
        production_branch: NotRequired[pulumi.Input[str]]
        production_deployments_enabled: NotRequired[pulumi.Input[bool]]
        repo_name: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectLatestDeploymentSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentSourceConfigArgs:
    def __init__(__self__, *,
                 deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 path_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[str]] = None,
                 production_branch: Optional[pulumi.Input[str]] = None,
                 production_deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 repo_name: Optional[pulumi.Input[str]] = None):
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "path_excludes")

    @path_excludes.setter
    def path_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_excludes", value)

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "path_includes")

    @path_includes.setter
    def path_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_includes", value)

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "production_branch", value)

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "production_deployments_enabled")

    @production_deployments_enabled.setter
    def production_deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "production_deployments_enabled", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class PagesProjectLatestDeploymentStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The current build stage.
        """
        started_on: NotRequired[pulumi.Input[str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        State of the current stage.
        """
elif False:
    PagesProjectLatestDeploymentStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 started_on: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ended_on: When the stage ended.
        :param pulumi.Input[str] name: The current build stage.
        :param pulumi.Input[str] started_on: When the stage started.
        :param pulumi.Input[str] status: State of the current stage.
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ended_on", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The current build stage.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "started_on", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        State of the current stage.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectSourceConfigArgsDict']]
        type: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectSourceConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectSourceConfigArgsDict(TypedDict):
        deployments_enabled: NotRequired[pulumi.Input[bool]]
        owner: NotRequired[pulumi.Input[str]]
        path_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        path_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        pr_comments_enabled: NotRequired[pulumi.Input[bool]]
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preview_deployment_setting: NotRequired[pulumi.Input[str]]
        production_branch: NotRequired[pulumi.Input[str]]
        production_deployments_enabled: NotRequired[pulumi.Input[bool]]
        repo_name: NotRequired[pulumi.Input[str]]
elif False:
    PagesProjectSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectSourceConfigArgs:
    def __init__(__self__, *,
                 deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 path_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[str]] = None,
                 production_branch: Optional[pulumi.Input[str]] = None,
                 production_deployments_enabled: Optional[pulumi.Input[bool]] = None,
                 repo_name: Optional[pulumi.Input[str]] = None):
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "path_excludes")

    @path_excludes.setter
    def path_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_excludes", value)

    @property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "path_includes")

    @path_includes.setter
    def path_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "path_includes", value)

    @property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "production_branch", value)

    @property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "production_deployments_enabled")

    @production_deployments_enabled.setter
    def production_deployments_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "production_deployments_enabled", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class QueueConsumerArgsDict(TypedDict):
        consumer_id: NotRequired[pulumi.Input[str]]
        """
        A Resource identifier.
        """
        created_on: NotRequired[pulumi.Input[str]]
        queue_id: NotRequired[pulumi.Input[str]]
        """
        A Resource identifier.
        """
        script: NotRequired[pulumi.Input[str]]
        """
        Name of a Worker
        """
        script_name: NotRequired[pulumi.Input[str]]
        """
        Name of a Worker
        """
        settings: NotRequired[pulumi.Input['QueueConsumerSettingsArgsDict']]
        type: NotRequired[pulumi.Input[str]]
elif False:
    QueueConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueConsumerArgs:
    def __init__(__self__, *,
                 consumer_id: Optional[pulumi.Input[str]] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 queue_id: Optional[pulumi.Input[str]] = None,
                 script: Optional[pulumi.Input[str]] = None,
                 script_name: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input['QueueConsumerSettingsArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] consumer_id: A Resource identifier.
        :param pulumi.Input[str] queue_id: A Resource identifier.
        :param pulumi.Input[str] script: Name of a Worker
        :param pulumi.Input[str] script_name: Name of a Worker
        """
        if consumer_id is not None:
            pulumi.set(__self__, "consumer_id", consumer_id)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if queue_id is not None:
            pulumi.set(__self__, "queue_id", queue_id)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="consumerId")
    def consumer_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "consumer_id")

    @consumer_id.setter
    def consumer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_id", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "queue_id")

    @queue_id.setter
    def queue_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_id", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script_name")

    @script_name.setter
    def script_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_name", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['QueueConsumerSettingsArgs']]:
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['QueueConsumerSettingsArgs']]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class QueueConsumerSettingsArgsDict(TypedDict):
        batch_size: NotRequired[pulumi.Input[float]]
        """
        The maximum number of messages to include in a batch.
        """
        max_concurrency: NotRequired[pulumi.Input[float]]
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        max_retries: NotRequired[pulumi.Input[float]]
        """
        The maximum number of retries
        """
        max_wait_time_ms: NotRequired[pulumi.Input[float]]
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        retry_delay: NotRequired[pulumi.Input[float]]
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        visibility_timeout_ms: NotRequired[pulumi.Input[float]]
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
elif False:
    QueueConsumerSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueConsumerSettingsArgs:
    def __init__(__self__, *,
                 batch_size: Optional[pulumi.Input[float]] = None,
                 max_concurrency: Optional[pulumi.Input[float]] = None,
                 max_retries: Optional[pulumi.Input[float]] = None,
                 max_wait_time_ms: Optional[pulumi.Input[float]] = None,
                 retry_delay: Optional[pulumi.Input[float]] = None,
                 visibility_timeout_ms: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] batch_size: The maximum number of messages to include in a batch.
        :param pulumi.Input[float] max_concurrency: Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        :param pulumi.Input[float] max_retries: The maximum number of retries
        :param pulumi.Input[float] max_wait_time_ms: The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        :param pulumi.Input[float] retry_delay: The number of seconds to delay before making the message available for another attempt.
        :param pulumi.Input[float] visibility_timeout_ms: The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if max_wait_time_ms is not None:
            pulumi.set(__self__, "max_wait_time_ms", max_wait_time_ms)
        if retry_delay is not None:
            pulumi.set(__self__, "retry_delay", retry_delay)
        if visibility_timeout_ms is not None:
            pulumi.set(__self__, "visibility_timeout_ms", visibility_timeout_ms)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum number of messages to include in a batch.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_concurrency", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="maxWaitTimeMs")
    def max_wait_time_ms(self) -> Optional[pulumi.Input[float]]:
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        return pulumi.get(self, "max_wait_time_ms")

    @max_wait_time_ms.setter
    def max_wait_time_ms(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_wait_time_ms", value)

    @property
    @pulumi.getter(name="retryDelay")
    def retry_delay(self) -> Optional[pulumi.Input[float]]:
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        return pulumi.get(self, "retry_delay")

    @retry_delay.setter
    def retry_delay(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "retry_delay", value)

    @property
    @pulumi.getter(name="visibilityTimeoutMs")
    def visibility_timeout_ms(self) -> Optional[pulumi.Input[float]]:
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        return pulumi.get(self, "visibility_timeout_ms")

    @visibility_timeout_ms.setter
    def visibility_timeout_ms(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "visibility_timeout_ms", value)


if not MYPY:
    class QueueProducerArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        script: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    QueueProducerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueProducerArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 script: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class QueueSettingsArgsDict(TypedDict):
        delivery_delay: NotRequired[pulumi.Input[float]]
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        message_retention_period: NotRequired[pulumi.Input[float]]
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
elif False:
    QueueSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueSettingsArgs:
    def __init__(__self__, *,
                 delivery_delay: Optional[pulumi.Input[float]] = None,
                 message_retention_period: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] delivery_delay: Number of seconds to delay delivery of all messages to consumers.
        :param pulumi.Input[float] message_retention_period: Number of seconds after which an unconsumed message will be delayed.
        """
        if delivery_delay is not None:
            pulumi.set(__self__, "delivery_delay", delivery_delay)
        if message_retention_period is not None:
            pulumi.set(__self__, "message_retention_period", message_retention_period)

    @property
    @pulumi.getter(name="deliveryDelay")
    def delivery_delay(self) -> Optional[pulumi.Input[float]]:
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        return pulumi.get(self, "delivery_delay")

    @delivery_delay.setter
    def delivery_delay(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "delivery_delay", value)

    @property
    @pulumi.getter(name="messageRetentionPeriod")
    def message_retention_period(self) -> Optional[pulumi.Input[float]]:
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
        return pulumi.get(self, "message_retention_period")

    @message_retention_period.setter
    def message_retention_period(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "message_retention_period", value)


if not MYPY:
    class R2BucketCorsRuleArgsDict(TypedDict):
        allowed: pulumi.Input['R2BucketCorsRuleAllowedArgsDict']
        """
        Object specifying allowed origins, methods and headers for this CORS rule.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier for this rule
        """
        max_age_seconds: NotRequired[pulumi.Input[float]]
        """
        Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
elif False:
    R2BucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed: pulumi.Input['R2BucketCorsRuleAllowedArgs'],
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 max_age_seconds: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input['R2BucketCorsRuleAllowedArgs'] allowed: Object specifying allowed origins, methods and headers for this CORS rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        :param pulumi.Input[str] id: Identifier for this rule
        :param pulumi.Input[float] max_age_seconds: Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        pulumi.set(__self__, "allowed", allowed)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter
    def allowed(self) -> pulumi.Input['R2BucketCorsRuleAllowedArgs']:
        """
        Object specifying allowed origins, methods and headers for this CORS rule.
        """
        return pulumi.get(self, "allowed")

    @allowed.setter
    def allowed(self, value: pulumi.Input['R2BucketCorsRuleAllowedArgs']):
        pulumi.set(self, "allowed", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for this rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class R2BucketCorsRuleAllowedArgsDict(TypedDict):
        methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        """
        origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
elif False:
    R2BucketCorsRuleAllowedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketCorsRuleAllowedArgs:
    def __init__(__self__, *,
                 methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] origins: Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "origins", origins)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "origins", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class R2BucketEventNotificationQueueArgsDict(TypedDict):
        queue_id: NotRequired[pulumi.Input[str]]
        """
        Queue ID
        """
        queue_name: NotRequired[pulumi.Input[str]]
        """
        Name of the queue
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['R2BucketEventNotificationQueueRuleArgsDict']]]]
elif False:
    R2BucketEventNotificationQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketEventNotificationQueueArgs:
    def __init__(__self__, *,
                 queue_id: Optional[pulumi.Input[str]] = None,
                 queue_name: Optional[pulumi.Input[str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketEventNotificationQueueRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] queue_id: Queue ID
        :param pulumi.Input[str] queue_name: Name of the queue
        """
        if queue_id is not None:
            pulumi.set(__self__, "queue_id", queue_id)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> Optional[pulumi.Input[str]]:
        """
        Queue ID
        """
        return pulumi.get(self, "queue_id")

    @queue_id.setter
    def queue_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_id", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketEventNotificationQueueRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketEventNotificationQueueRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class R2BucketEventNotificationQueueRuleArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of R2 object actions that will trigger notifications
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        Timestamp when the rule was created
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description that can be used to identify the event notification rule after creation
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Notifications will be sent only for objects with this prefix
        """
        rule_id: NotRequired[pulumi.Input[str]]
        """
        Rule ID
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Notifications will be sent only for objects with this suffix
        """
elif False:
    R2BucketEventNotificationQueueRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketEventNotificationQueueRuleArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 rule_id: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Array of R2 object actions that will trigger notifications
        :param pulumi.Input[str] created_at: Timestamp when the rule was created
        :param pulumi.Input[str] description: A description that can be used to identify the event notification rule after creation
        :param pulumi.Input[str] prefix: Notifications will be sent only for objects with this prefix
        :param pulumi.Input[str] rule_id: Rule ID
        :param pulumi.Input[str] suffix: Notifications will be sent only for objects with this suffix
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of R2 object actions that will trigger notifications
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp when the rule was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description that can be used to identify the event notification rule after creation
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Notifications will be sent only for objects with this prefix
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        Rule ID
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Notifications will be sent only for objects with this suffix
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class R2BucketEventNotificationRuleArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of R2 object actions that will trigger notifications
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description that can be used to identify the event notification rule after creation
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Notifications will be sent only for objects with this prefix
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Notifications will be sent only for objects with this suffix
        """
elif False:
    R2BucketEventNotificationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketEventNotificationRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 description: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Array of R2 object actions that will trigger notifications
        :param pulumi.Input[str] description: A description that can be used to identify the event notification rule after creation
        :param pulumi.Input[str] prefix: Notifications will be sent only for objects with this prefix
        :param pulumi.Input[str] suffix: Notifications will be sent only for objects with this suffix
        """
        pulumi.set(__self__, "actions", actions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of R2 object actions that will trigger notifications
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description that can be used to identify the event notification rule after creation
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Notifications will be sent only for objects with this prefix
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Notifications will be sent only for objects with this suffix
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class R2BucketLifecycleRuleArgsDict(TypedDict):
        conditions: pulumi.Input['R2BucketLifecycleRuleConditionsArgsDict']
        """
        Conditions that apply to all transitions of this rule
        """
        enabled: pulumi.Input[bool]
        """
        Whether or not this rule is in effect
        """
        id: pulumi.Input[str]
        """
        Unique identifier for this rule
        """
        abort_multipart_uploads_transition: NotRequired[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict']]
        """
        Transition to abort ongoing multipart uploads
        """
        delete_objects_transition: NotRequired[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict']]
        """
        Transition to delete objects
        """
        storage_class_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgsDict']]]]
        """
        Transitions to change the storage class of objects
        """
elif False:
    R2BucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input['R2BucketLifecycleRuleConditionsArgs'],
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str],
                 abort_multipart_uploads_transition: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs']] = None,
                 delete_objects_transition: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs']] = None,
                 storage_class_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]]] = None):
        """
        :param pulumi.Input['R2BucketLifecycleRuleConditionsArgs'] conditions: Conditions that apply to all transitions of this rule
        :param pulumi.Input[bool] enabled: Whether or not this rule is in effect
        :param pulumi.Input[str] id: Unique identifier for this rule
        :param pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs'] abort_multipart_uploads_transition: Transition to abort ongoing multipart uploads
        :param pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs'] delete_objects_transition: Transition to delete objects
        :param pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]] storage_class_transitions: Transitions to change the storage class of objects
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if abort_multipart_uploads_transition is not None:
            pulumi.set(__self__, "abort_multipart_uploads_transition", abort_multipart_uploads_transition)
        if delete_objects_transition is not None:
            pulumi.set(__self__, "delete_objects_transition", delete_objects_transition)
        if storage_class_transitions is not None:
            pulumi.set(__self__, "storage_class_transitions", storage_class_transitions)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input['R2BucketLifecycleRuleConditionsArgs']:
        """
        Conditions that apply to all transitions of this rule
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input['R2BucketLifecycleRuleConditionsArgs']):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether or not this rule is in effect
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for this rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="abortMultipartUploadsTransition")
    def abort_multipart_uploads_transition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs']]:
        """
        Transition to abort ongoing multipart uploads
        """
        return pulumi.get(self, "abort_multipart_uploads_transition")

    @abort_multipart_uploads_transition.setter
    def abort_multipart_uploads_transition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs']]):
        pulumi.set(self, "abort_multipart_uploads_transition", value)

    @property
    @pulumi.getter(name="deleteObjectsTransition")
    def delete_objects_transition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs']]:
        """
        Transition to delete objects
        """
        return pulumi.get(self, "delete_objects_transition")

    @delete_objects_transition.setter
    def delete_objects_transition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs']]):
        pulumi.set(self, "delete_objects_transition", value)

    @property
    @pulumi.getter(name="storageClassTransitions")
    def storage_class_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]]]:
        """
        Transitions to change the storage class of objects
        """
        return pulumi.get(self, "storage_class_transitions")

    @storage_class_transitions.setter
    def storage_class_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]]]):
        pulumi.set(self, "storage_class_transitions", value)


if not MYPY:
    class R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict']]
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
elif False:
    R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs']] = None):
        """
        :param pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs'] condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs']]:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict(TypedDict):
        max_age: pulumi.Input[int]
        type: pulumi.Input[str]
elif False:
    R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs:
    def __init__(__self__, *,
                 max_age: pulumi.Input[int],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class R2BucketLifecycleRuleConditionsArgsDict(TypedDict):
        prefix: pulumi.Input[str]
        """
        Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
elif False:
    R2BucketLifecycleRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleConditionsArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[str]):
        """
        :param pulumi.Input[str] prefix: Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        """
        Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict']]
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
elif False:
    R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleDeleteObjectsTransitionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs']] = None):
        """
        :param pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs'] condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs']]:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict(TypedDict):
        type: pulumi.Input[str]
        date: NotRequired[pulumi.Input[str]]
        max_age: NotRequired[pulumi.Input[int]]
elif False:
    R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date: Optional[pulumi.Input[str]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class R2BucketLifecycleRuleStorageClassTransitionArgsDict(TypedDict):
        condition: pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict']
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        storage_class: pulumi.Input[str]
elif False:
    R2BucketLifecycleRuleStorageClassTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleStorageClassTransitionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs'],
                 storage_class: pulumi.Input[str]):
        """
        :param pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs'] condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs']:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs']):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict(TypedDict):
        type: pulumi.Input[str]
        date: NotRequired[pulumi.Input[str]]
        max_age: NotRequired[pulumi.Input[int]]
elif False:
    R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleStorageClassTransitionConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date: Optional[pulumi.Input[str]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class R2BucketLockRuleArgsDict(TypedDict):
        condition: pulumi.Input['R2BucketLockRuleConditionArgsDict']
        """
        Condition to apply a lock rule to an object for how long in seconds
        """
        enabled: pulumi.Input[bool]
        """
        Whether or not this rule is in effect
        """
        id: pulumi.Input[str]
        """
        Unique identifier for this rule
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
elif False:
    R2BucketLockRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLockRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['R2BucketLockRuleConditionArgs'],
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['R2BucketLockRuleConditionArgs'] condition: Condition to apply a lock rule to an object for how long in seconds
        :param pulumi.Input[bool] enabled: Whether or not this rule is in effect
        :param pulumi.Input[str] id: Unique identifier for this rule
        :param pulumi.Input[str] prefix: Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['R2BucketLockRuleConditionArgs']:
        """
        Condition to apply a lock rule to an object for how long in seconds
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['R2BucketLockRuleConditionArgs']):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether or not this rule is in effect
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for this rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class R2BucketLockRuleConditionArgsDict(TypedDict):
        type: pulumi.Input[str]
        date: NotRequired[pulumi.Input[str]]
        max_age_seconds: NotRequired[pulumi.Input[int]]
elif False:
    R2BucketLockRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLockRuleConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date: Optional[pulumi.Input[str]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class R2BucketSippyDestinationArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[str]]
        """
        ID of a Cloudflare API token.
        This is the value labelled "Access Key ID" when creating an API
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        """
        provider: NotRequired[pulumi.Input[str]]
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        Value of a Cloudflare API token.
        This is the value labelled "Secret Access Key" when creating an API
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).

        Sippy will use this token when writing objects to R2, so it is
        best to scope this token to the bucket you're enabling Sippy for.
        """
elif False:
    R2BucketSippyDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketSippyDestinationArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: ID of a Cloudflare API token.
               This is the value labelled "Access Key ID" when creating an API
               token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        :param pulumi.Input[str] secret_access_key: Value of a Cloudflare API token.
               This is the value labelled "Secret Access Key" when creating an API
               token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
               
               Sippy will use this token when writing objects to R2, so it is
               best to scope this token to the bucket you're enabling Sippy for.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of a Cloudflare API token.
        This is the value labelled "Access Key ID" when creating an API
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Value of a Cloudflare API token.
        This is the value labelled "Secret Access Key" when creating an API
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).

        Sippy will use this token when writing objects to R2, so it is
        best to scope this token to the bucket you're enabling Sippy for.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class R2BucketSippySourceArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[str]]
        """
        Access Key ID of an IAM credential (ideally scoped to a single S3 bucket)
        """
        bucket: NotRequired[pulumi.Input[str]]
        """
        Name of the AWS S3 bucket
        """
        client_email: NotRequired[pulumi.Input[str]]
        """
        Client email of an IAM credential (ideally scoped to a single GCS bucket)
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        Private Key of an IAM credential (ideally scoped to a single GCS bucket)
        """
        provider: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Name of the AWS availability zone
        """
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket)
        """
elif False:
    R2BucketSippySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketSippySourceArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: Access Key ID of an IAM credential (ideally scoped to a single S3 bucket)
        :param pulumi.Input[str] bucket: Name of the AWS S3 bucket
        :param pulumi.Input[str] client_email: Client email of an IAM credential (ideally scoped to a single GCS bucket)
        :param pulumi.Input[str] private_key: Private Key of an IAM credential (ideally scoped to a single GCS bucket)
        :param pulumi.Input[str] region: Name of the AWS availability zone
        :param pulumi.Input[str] secret_access_key: Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket)
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Access Key ID of an IAM credential (ideally scoped to a single S3 bucket)
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the AWS S3 bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        """
        Client email of an IAM credential (ideally scoped to a single GCS bucket)
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private Key of an IAM credential (ideally scoped to a single GCS bucket)
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the AWS availability zone
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket)
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class R2CustomDomainStatusArgsDict(TypedDict):
        ownership: NotRequired[pulumi.Input[str]]
        """
        Ownership status of the domain
        """
        ssl: NotRequired[pulumi.Input[str]]
        """
        SSL certificate status
        """
elif False:
    R2CustomDomainStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2CustomDomainStatusArgs:
    def __init__(__self__, *,
                 ownership: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ownership: Ownership status of the domain
        :param pulumi.Input[str] ssl: SSL certificate status
        """
        if ownership is not None:
            pulumi.set(__self__, "ownership", ownership)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)

    @property
    @pulumi.getter
    def ownership(self) -> Optional[pulumi.Input[str]]:
        """
        Ownership status of the domain
        """
        return pulumi.get(self, "ownership")

    @ownership.setter
    def ownership(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ownership", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        SSL certificate status
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)


if not MYPY:
    class RateLimitActionArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        The action to perform.
        """
        response: NotRequired[pulumi.Input['RateLimitActionResponseArgsDict']]
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        timeout: NotRequired[pulumi.Input[float]]
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
elif False:
    RateLimitActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitActionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 response: Optional[pulumi.Input['RateLimitActionResponseArgs']] = None,
                 timeout: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] mode: The action to perform.
        :param pulumi.Input['RateLimitActionResponseArgs'] response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param pulumi.Input[float] timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The action to perform.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitActionResponseArgs']]:
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitActionResponseArgs']]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[float]]:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RateLimitActionResponseArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[str]]
        """
        The response body to return. The value must conform to the configured content type.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
elif False:
    RateLimitActionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitActionResponseArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body: The response body to return. The value must conform to the configured content type.
        :param pulumi.Input[str] content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class RateLimitBypassArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        The URL to bypass.
        """
elif False:
    RateLimitBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitBypassArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The URL to bypass.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to bypass.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RateLimitMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgsDict']]]]
        request: NotRequired[pulumi.Input['RateLimitMatchRequestArgsDict']]
        response: NotRequired[pulumi.Input['RateLimitMatchResponseArgsDict']]
elif False:
    RateLimitMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgs']]]] = None,
                 request: Optional[pulumi.Input['RateLimitMatchRequestArgs']] = None,
                 response: Optional[pulumi.Input['RateLimitMatchResponseArgs']] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['RateLimitMatchRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['RateLimitMatchRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitMatchResponseArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitMatchResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class RateLimitMatchHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the response header to match.
        """
        op: NotRequired[pulumi.Input[str]]
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the response header, which must match exactly.
        """
elif False:
    RateLimitMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 op: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the response header to match.
        :param pulumi.Input[str] op: The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        :param pulumi.Input[str] value: The value of the response header, which must match exactly.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the response header to match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[str]]:
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the response header, which must match exactly.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RateLimitMatchRequestArgsDict(TypedDict):
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        schemes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
elif False:
    RateLimitMatchRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchRequestArgs:
    def __init__(__self__, *,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 schemes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemes: The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        :param pulumi.Input[str] url: The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def schemes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        return pulumi.get(self, "schemes")

    @schemes.setter
    def schemes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemes", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class RateLimitMatchResponseArgsDict(TypedDict):
        origin_traffic: NotRequired[pulumi.Input[bool]]
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
elif False:
    RateLimitMatchResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchResponseArgs:
    def __init__(__self__, *,
                 origin_traffic: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] origin_traffic: When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
               Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)

    @property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        return pulumi.get(self, "origin_traffic")

    @origin_traffic.setter
    def origin_traffic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_traffic", value)


if not MYPY:
    class RecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[float]]
        """
        Algorithm.
        """
        altitude: NotRequired[pulumi.Input[float]]
        """
        Altitude of location in meters.
        """
        certificate: NotRequired[pulumi.Input[str]]
        """
        Certificate.
        """
        digest: NotRequired[pulumi.Input[str]]
        """
        Digest.
        """
        digest_type: NotRequired[pulumi.Input[float]]
        """
        Digest Type.
        """
        fingerprint: NotRequired[pulumi.Input[str]]
        """
        fingerprint.
        """
        flags: NotRequired[pulumi.Input[float]]
        """
        Flags for the CAA record.
        """
        key_tag: NotRequired[pulumi.Input[float]]
        """
        Key Tag.
        """
        lat_degrees: NotRequired[pulumi.Input[float]]
        """
        Degrees of latitude.
        """
        lat_direction: NotRequired[pulumi.Input[str]]
        """
        Latitude direction.
        """
        lat_minutes: NotRequired[pulumi.Input[float]]
        """
        Minutes of latitude.
        """
        lat_seconds: NotRequired[pulumi.Input[float]]
        """
        Seconds of latitude.
        """
        long_degrees: NotRequired[pulumi.Input[float]]
        """
        Degrees of longitude.
        """
        long_direction: NotRequired[pulumi.Input[str]]
        """
        Longitude direction.
        """
        long_minutes: NotRequired[pulumi.Input[float]]
        """
        Minutes of longitude.
        """
        long_seconds: NotRequired[pulumi.Input[float]]
        """
        Seconds of longitude.
        """
        matching_type: NotRequired[pulumi.Input[float]]
        """
        Matching Type.
        """
        order: NotRequired[pulumi.Input[float]]
        """
        Order.
        """
        port: NotRequired[pulumi.Input[float]]
        """
        The port of the service.
        """
        precision_horz: NotRequired[pulumi.Input[float]]
        """
        Horizontal precision of location.
        """
        precision_vert: NotRequired[pulumi.Input[float]]
        """
        Vertical precision of location.
        """
        preference: NotRequired[pulumi.Input[float]]
        """
        Preference.
        """
        priority: NotRequired[pulumi.Input[float]]
        """
        priority.
        """
        protocol: NotRequired[pulumi.Input[float]]
        """
        Protocol.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        Public Key.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        Regex.
        """
        replacement: NotRequired[pulumi.Input[str]]
        """
        Replacement.
        """
        selector: NotRequired[pulumi.Input[float]]
        """
        Selector.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Service.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        Size of location in meters.
        """
        tag: NotRequired[pulumi.Input[str]]
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        target: NotRequired[pulumi.Input[str]]
        """
        target.
        """
        type: NotRequired[pulumi.Input[float]]
        """
        Type.
        """
        usage: NotRequired[pulumi.Input[float]]
        """
        Usage.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        weight: NotRequired[pulumi.Input[float]]
        """
        The record weight.
        """
elif False:
    RecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[float]] = None,
                 altitude: Optional[pulumi.Input[float]] = None,
                 certificate: Optional[pulumi.Input[str]] = None,
                 digest: Optional[pulumi.Input[str]] = None,
                 digest_type: Optional[pulumi.Input[float]] = None,
                 fingerprint: Optional[pulumi.Input[str]] = None,
                 flags: Optional[pulumi.Input[float]] = None,
                 key_tag: Optional[pulumi.Input[float]] = None,
                 lat_degrees: Optional[pulumi.Input[float]] = None,
                 lat_direction: Optional[pulumi.Input[str]] = None,
                 lat_minutes: Optional[pulumi.Input[float]] = None,
                 lat_seconds: Optional[pulumi.Input[float]] = None,
                 long_degrees: Optional[pulumi.Input[float]] = None,
                 long_direction: Optional[pulumi.Input[str]] = None,
                 long_minutes: Optional[pulumi.Input[float]] = None,
                 long_seconds: Optional[pulumi.Input[float]] = None,
                 matching_type: Optional[pulumi.Input[float]] = None,
                 order: Optional[pulumi.Input[float]] = None,
                 port: Optional[pulumi.Input[float]] = None,
                 precision_horz: Optional[pulumi.Input[float]] = None,
                 precision_vert: Optional[pulumi.Input[float]] = None,
                 preference: Optional[pulumi.Input[float]] = None,
                 priority: Optional[pulumi.Input[float]] = None,
                 protocol: Optional[pulumi.Input[float]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 replacement: Optional[pulumi.Input[str]] = None,
                 selector: Optional[pulumi.Input[float]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[float]] = None,
                 tag: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[float]] = None,
                 usage: Optional[pulumi.Input[float]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] algorithm: Algorithm.
        :param pulumi.Input[float] altitude: Altitude of location in meters.
        :param pulumi.Input[str] certificate: Certificate.
        :param pulumi.Input[str] digest: Digest.
        :param pulumi.Input[float] digest_type: Digest Type.
        :param pulumi.Input[str] fingerprint: fingerprint.
        :param pulumi.Input[float] flags: Flags for the CAA record.
        :param pulumi.Input[float] key_tag: Key Tag.
        :param pulumi.Input[float] lat_degrees: Degrees of latitude.
        :param pulumi.Input[str] lat_direction: Latitude direction.
        :param pulumi.Input[float] lat_minutes: Minutes of latitude.
        :param pulumi.Input[float] lat_seconds: Seconds of latitude.
        :param pulumi.Input[float] long_degrees: Degrees of longitude.
        :param pulumi.Input[str] long_direction: Longitude direction.
        :param pulumi.Input[float] long_minutes: Minutes of longitude.
        :param pulumi.Input[float] long_seconds: Seconds of longitude.
        :param pulumi.Input[float] matching_type: Matching Type.
        :param pulumi.Input[float] order: Order.
        :param pulumi.Input[float] port: The port of the service.
        :param pulumi.Input[float] precision_horz: Horizontal precision of location.
        :param pulumi.Input[float] precision_vert: Vertical precision of location.
        :param pulumi.Input[float] preference: Preference.
        :param pulumi.Input[float] priority: priority.
        :param pulumi.Input[float] protocol: Protocol.
        :param pulumi.Input[str] public_key: Public Key.
        :param pulumi.Input[str] regex: Regex.
        :param pulumi.Input[str] replacement: Replacement.
        :param pulumi.Input[float] selector: Selector.
        :param pulumi.Input[str] service: Service.
        :param pulumi.Input[float] size: Size of location in meters.
        :param pulumi.Input[str] tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param pulumi.Input[str] target: target.
        :param pulumi.Input[float] type: Type.
        :param pulumi.Input[float] usage: Usage.
        :param pulumi.Input[str] value: Value of the record. This field's semantics depend on the chosen tag.
        :param pulumi.Input[float] weight: The record weight.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[float]]:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def altitude(self) -> Optional[pulumi.Input[float]]:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @altitude.setter
    def altitude(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "altitude", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[str]]:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "digest", value)

    @property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[pulumi.Input[float]]:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @digest_type.setter
    def digest_type(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "digest_type", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[str]]:
        """
        fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[float]]:
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[float]]:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "key_tag", value)

    @property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[pulumi.Input[float]]:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @lat_degrees.setter
    def lat_degrees(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_degrees", value)

    @property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[pulumi.Input[str]]:
        """
        Latitude direction.
        """
        return pulumi.get(self, "lat_direction")

    @lat_direction.setter
    def lat_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lat_direction", value)

    @property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @lat_minutes.setter
    def lat_minutes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_minutes", value)

    @property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @lat_seconds.setter
    def lat_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "lat_seconds", value)

    @property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[pulumi.Input[float]]:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @long_degrees.setter
    def long_degrees(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_degrees", value)

    @property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[pulumi.Input[str]]:
        """
        Longitude direction.
        """
        return pulumi.get(self, "long_direction")

    @long_direction.setter
    def long_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "long_direction", value)

    @property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @long_minutes.setter
    def long_minutes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_minutes", value)

    @property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @long_seconds.setter
    def long_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "long_seconds", value)

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[float]]:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "matching_type", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[float]]:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[pulumi.Input[float]]:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @precision_horz.setter
    def precision_horz(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_horz", value)

    @property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[pulumi.Input[float]]:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @precision_vert.setter
    def precision_vert(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "precision_vert", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[float]]:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        """
        priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[float]]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[str]]:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[float]]:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        target.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[float]]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[float]]:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "usage", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RecordSettingsArgsDict(TypedDict):
        flatten_cname: NotRequired[pulumi.Input[bool]]
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        ipv4_only: NotRequired[pulumi.Input[bool]]
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        ipv6_only: NotRequired[pulumi.Input[bool]]
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
elif False:
    RecordSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordSettingsArgs:
    def __init__(__self__, *,
                 flatten_cname: Optional[pulumi.Input[bool]] = None,
                 ipv4_only: Optional[pulumi.Input[bool]] = None,
                 ipv6_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param pulumi.Input[bool] ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param pulumi.Input[bool] ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        if flatten_cname is not None:
            pulumi.set(__self__, "flatten_cname", flatten_cname)
        if ipv4_only is not None:
            pulumi.set(__self__, "ipv4_only", ipv4_only)
        if ipv6_only is not None:
            pulumi.set(__self__, "ipv6_only", ipv6_only)

    @property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @flatten_cname.setter
    def flatten_cname(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "flatten_cname", value)

    @property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @ipv4_only.setter
    def ipv4_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv4_only", value)

    @property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")

    @ipv6_only.setter
    def ipv6_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6_only", value)


if not MYPY:
    class RulesetRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action to perform when the rule matches.
        """
        action_parameters: NotRequired[pulumi.Input['RulesetRuleActionParametersArgsDict']]
        """
        The parameters configuring the rule's action.
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The categories of the rule.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        An informative description of the rule.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the rule should be executed.
        """
        exposed_credential_check: NotRequired[pulumi.Input['RulesetRuleExposedCredentialCheckArgsDict']]
        """
        Configure checks for exposed credentials.
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        The expression defining which traffic will match the rule.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The unique ID of the rule.
        """
        logging: NotRequired[pulumi.Input['RulesetRuleLoggingArgsDict']]
        """
        An object configuring the rule's logging behavior.
        """
        ratelimit: NotRequired[pulumi.Input['RulesetRuleRatelimitArgsDict']]
        """
        An object configuring the rule's ratelimit behavior.
        """
        ref: NotRequired[pulumi.Input[str]]
        """
        The reference of the rule (the rule ID by default).
        """
elif False:
    RulesetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 action_parameters: Optional[pulumi.Input['RulesetRuleActionParametersArgs']] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exposed_credential_check: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 logging: Optional[pulumi.Input['RulesetRuleLoggingArgs']] = None,
                 ratelimit: Optional[pulumi.Input['RulesetRuleRatelimitArgs']] = None,
                 ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to perform when the rule matches.
        :param pulumi.Input['RulesetRuleActionParametersArgs'] action_parameters: The parameters configuring the rule's action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] categories: The categories of the rule.
        :param pulumi.Input[str] description: An informative description of the rule.
        :param pulumi.Input[bool] enabled: Whether the rule should be executed.
        :param pulumi.Input['RulesetRuleExposedCredentialCheckArgs'] exposed_credential_check: Configure checks for exposed credentials.
        :param pulumi.Input[str] expression: The expression defining which traffic will match the rule.
        :param pulumi.Input[str] id: The unique ID of the rule.
        :param pulumi.Input['RulesetRuleLoggingArgs'] logging: An object configuring the rule's logging behavior.
        :param pulumi.Input['RulesetRuleRatelimitArgs'] ratelimit: An object configuring the rule's ratelimit behavior.
        :param pulumi.Input[str] ref: The reference of the rule (the rule ID by default).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to perform when the rule matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional[pulumi.Input['RulesetRuleActionParametersArgs']]:
        """
        The parameters configuring the rule's action.
        """
        return pulumi.get(self, "action_parameters")

    @action_parameters.setter
    def action_parameters(self, value: Optional[pulumi.Input['RulesetRuleActionParametersArgs']]):
        pulumi.set(self, "action_parameters", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The categories of the rule.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        An informative description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule should be executed.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]:
        """
        Configure checks for exposed credentials.
        """
        return pulumi.get(self, "exposed_credential_check")

    @exposed_credential_check.setter
    def exposed_credential_check(self, value: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]):
        pulumi.set(self, "exposed_credential_check", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression defining which traffic will match the rule.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['RulesetRuleLoggingArgs']]:
        """
        An object configuring the rule's logging behavior.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['RulesetRuleLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def ratelimit(self) -> Optional[pulumi.Input['RulesetRuleRatelimitArgs']]:
        """
        An object configuring the rule's ratelimit behavior.
        """
        return pulumi.get(self, "ratelimit")

    @ratelimit.setter
    def ratelimit(self, value: Optional[pulumi.Input['RulesetRuleRatelimitArgs']]):
        pulumi.set(self, "ratelimit", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        The reference of the rule (the rule ID by default).
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class RulesetRuleActionParametersArgsDict(TypedDict):
        additional_cacheable_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        List of additional ports that caching can be enabled on.
        """
        algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgsDict']]]]
        """
        Custom order for compression algorithms.
        """
        automatic_https_rewrites: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Automatic HTTPS Rewrites.
        """
        autominify: NotRequired[pulumi.Input['RulesetRuleActionParametersAutominifyArgsDict']]
        """
        Select which file extensions to minify automatically.
        """
        bic: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Browser Integrity Check.
        """
        browser_ttl: NotRequired[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgsDict']]
        """
        Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        """
        cache: NotRequired[pulumi.Input[bool]]
        """
        Mark whether the requests response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        """
        cache_key: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyArgsDict']]
        """
        Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        """
        cache_reserve: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheReserveArgsDict']]
        """
        Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Error response content.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        Content-type header to set with the response.
        """
        cookie_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgsDict']]]]
        """
        The cookie fields to log.
        """
        disable_apps: NotRequired[pulumi.Input[bool]]
        """
        Turn off all active Cloudflare Apps.
        """
        disable_rum: NotRequired[pulumi.Input[bool]]
        """
        Turn off Real User Monitoring (RUM).
        """
        disable_zaraz: NotRequired[pulumi.Input[bool]]
        """
        Turn off Zaraz.
        """
        edge_ttl: NotRequired[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgsDict']]
        """
        TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        """
        email_obfuscation: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Email Obfuscation.
        """
        fonts: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Cloudflare Fonts.
        """
        from_list: NotRequired[pulumi.Input['RulesetRuleActionParametersFromListArgsDict']]
        """
        Serve a redirect based on a bulk list lookup.
        """
        from_value: NotRequired[pulumi.Input['RulesetRuleActionParametersFromValueArgsDict']]
        """
        Serve a redirect based on the request properties.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgsDict']]]]
        """
        Map of request headers to modify.
        """
        host_header: NotRequired[pulumi.Input[str]]
        """
        Rewrite the HTTP Host header.
        """
        hotlink_protection: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off the Hotlink Protection.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the ruleset to execute.
        """
        increment: NotRequired[pulumi.Input[int]]
        """
        Increment contains the delta to change the score and can be either positive or negative.
        """
        matched_data: NotRequired[pulumi.Input['RulesetRuleActionParametersMatchedDataArgsDict']]
        """
        The configuration to use for matched data logging.
        """
        mirage: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Mirage.
        """
        opportunistic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Opportunistic Encryption.
        """
        origin: NotRequired[pulumi.Input['RulesetRuleActionParametersOriginArgsDict']]
        """
        Override the IP/TCP destination.
        """
        origin_cache_control: NotRequired[pulumi.Input[bool]]
        """
        When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        """
        origin_error_page_passthru: NotRequired[pulumi.Input[bool]]
        """
        Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        """
        overrides: NotRequired[pulumi.Input['RulesetRuleActionParametersOverridesArgsDict']]
        """
        A set of overrides to apply to the target ruleset.
        """
        phases: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        """
        polish: NotRequired[pulumi.Input[str]]
        """
        Configure the Polish level.
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of legacy security products to skip the execution of.
        """
        read_timeout: NotRequired[pulumi.Input[int]]
        """
        Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        """
        request_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgsDict']]]]
        """
        The request fields to log.
        """
        respect_strong_etags: NotRequired[pulumi.Input[bool]]
        """
        Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        """
        response: NotRequired[pulumi.Input['RulesetRuleActionParametersResponseArgsDict']]
        """
        The response to show when the block is applied.
        """
        response_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgsDict']]]]
        """
        The response fields to log.
        """
        rocket_loader: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Rocket Loader
        """
        rules: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        """
        ruleset: NotRequired[pulumi.Input[str]]
        """
        A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        """
        rulesets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        """
        security_level: NotRequired[pulumi.Input[str]]
        """
        Configure the Security Level.
        """
        serve_stale: NotRequired[pulumi.Input['RulesetRuleActionParametersServeStaleArgsDict']]
        """
        Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        server_side_excludes: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Server Side Excludes.
        """
        sni: NotRequired[pulumi.Input['RulesetRuleActionParametersSniArgsDict']]
        """
        Override the Server Name Indication (SNI).
        """
        ssl: NotRequired[pulumi.Input[str]]
        """
        Configure the SSL level.
        """
        status_code: NotRequired[pulumi.Input[float]]
        """
        The status code to use for the error.
        """
        sxg: NotRequired[pulumi.Input[bool]]
        """
        Turn on or off Signed Exchanges (SXG).
        """
        uri: NotRequired[pulumi.Input['RulesetRuleActionParametersUriArgsDict']]
        """
        URI to rewrite the request to.
        """
elif False:
    RulesetRuleActionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersArgs:
    def __init__(__self__, *,
                 additional_cacheable_ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[bool]] = None,
                 autominify: Optional[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']] = None,
                 bic: Optional[pulumi.Input[bool]] = None,
                 browser_ttl: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']] = None,
                 cache: Optional[pulumi.Input[bool]] = None,
                 cache_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']] = None,
                 cache_reserve: Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 cookie_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]]] = None,
                 disable_apps: Optional[pulumi.Input[bool]] = None,
                 disable_rum: Optional[pulumi.Input[bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[bool]] = None,
                 edge_ttl: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']] = None,
                 email_obfuscation: Optional[pulumi.Input[bool]] = None,
                 fonts: Optional[pulumi.Input[bool]] = None,
                 from_list: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']] = None,
                 from_value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 hotlink_protection: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 increment: Optional[pulumi.Input[int]] = None,
                 matched_data: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']] = None,
                 mirage: Optional[pulumi.Input[bool]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[bool]] = None,
                 origin: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']] = None,
                 origin_cache_control: Optional[pulumi.Input[bool]] = None,
                 origin_error_page_passthru: Optional[pulumi.Input[bool]] = None,
                 overrides: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']] = None,
                 phases: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 polish: Optional[pulumi.Input[str]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_timeout: Optional[pulumi.Input[int]] = None,
                 request_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]]] = None,
                 respect_strong_etags: Optional[pulumi.Input[bool]] = None,
                 response: Optional[pulumi.Input['RulesetRuleActionParametersResponseArgs']] = None,
                 response_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]]] = None,
                 rocket_loader: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 ruleset: Optional[pulumi.Input[str]] = None,
                 rulesets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_level: Optional[pulumi.Input[str]] = None,
                 serve_stale: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']] = None,
                 server_side_excludes: Optional[pulumi.Input[bool]] = None,
                 sni: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 status_code: Optional[pulumi.Input[float]] = None,
                 sxg: Optional[pulumi.Input[bool]] = None,
                 uri: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] additional_cacheable_ports: List of additional ports that caching can be enabled on.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]] algorithms: Custom order for compression algorithms.
        :param pulumi.Input[bool] automatic_https_rewrites: Turn on or off Automatic HTTPS Rewrites.
        :param pulumi.Input['RulesetRuleActionParametersAutominifyArgs'] autominify: Select which file extensions to minify automatically.
        :param pulumi.Input[bool] bic: Turn on or off Browser Integrity Check.
        :param pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs'] browser_ttl: Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        :param pulumi.Input[bool] cache: Mark whether the requests response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyArgs'] cache_key: Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        :param pulumi.Input['RulesetRuleActionParametersCacheReserveArgs'] cache_reserve: Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        :param pulumi.Input[str] content: Error response content.
        :param pulumi.Input[str] content_type: Content-type header to set with the response.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]] cookie_fields: The cookie fields to log.
        :param pulumi.Input[bool] disable_apps: Turn off all active Cloudflare Apps.
        :param pulumi.Input[bool] disable_rum: Turn off Real User Monitoring (RUM).
        :param pulumi.Input[bool] disable_zaraz: Turn off Zaraz.
        :param pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs'] edge_ttl: TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        :param pulumi.Input[bool] email_obfuscation: Turn on or off Email Obfuscation.
        :param pulumi.Input[bool] fonts: Turn on or off Cloudflare Fonts.
        :param pulumi.Input['RulesetRuleActionParametersFromListArgs'] from_list: Serve a redirect based on a bulk list lookup.
        :param pulumi.Input['RulesetRuleActionParametersFromValueArgs'] from_value: Serve a redirect based on the request properties.
        :param pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]] headers: Map of request headers to modify.
        :param pulumi.Input[str] host_header: Rewrite the HTTP Host header.
        :param pulumi.Input[bool] hotlink_protection: Turn on or off the Hotlink Protection.
        :param pulumi.Input[str] id: The ID of the ruleset to execute.
        :param pulumi.Input[int] increment: Increment contains the delta to change the score and can be either positive or negative.
        :param pulumi.Input['RulesetRuleActionParametersMatchedDataArgs'] matched_data: The configuration to use for matched data logging.
        :param pulumi.Input[bool] mirage: Turn on or off Mirage.
        :param pulumi.Input[bool] opportunistic_encryption: Turn on or off Opportunistic Encryption.
        :param pulumi.Input['RulesetRuleActionParametersOriginArgs'] origin: Override the IP/TCP destination.
        :param pulumi.Input[bool] origin_cache_control: When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        :param pulumi.Input[bool] origin_error_page_passthru: Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        :param pulumi.Input['RulesetRuleActionParametersOverridesArgs'] overrides: A set of overrides to apply to the target ruleset.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phases: A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        :param pulumi.Input[str] polish: Configure the Polish level.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] products: A list of legacy security products to skip the execution of.
        :param pulumi.Input[int] read_timeout: Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]] request_fields: The request fields to log.
        :param pulumi.Input[bool] respect_strong_etags: Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        :param pulumi.Input['RulesetRuleActionParametersResponseArgs'] response: The response to show when the block is applied.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]] response_fields: The response fields to log.
        :param pulumi.Input[bool] rocket_loader: Turn on or off Rocket Loader
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] rules: A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        :param pulumi.Input[str] ruleset: A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] rulesets: A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        :param pulumi.Input[str] security_level: Configure the Security Level.
        :param pulumi.Input['RulesetRuleActionParametersServeStaleArgs'] serve_stale: Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        :param pulumi.Input[bool] server_side_excludes: Turn on or off Server Side Excludes.
        :param pulumi.Input['RulesetRuleActionParametersSniArgs'] sni: Override the Server Name Indication (SNI).
        :param pulumi.Input[str] ssl: Configure the SSL level.
        :param pulumi.Input[float] status_code: The status code to use for the error.
        :param pulumi.Input[bool] sxg: Turn on or off Signed Exchanges (SXG).
        :param pulumi.Input['RulesetRuleActionParametersUriArgs'] uri: URI to rewrite the request to.
        """
        if additional_cacheable_ports is not None:
            pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        if algorithms is not None:
            pulumi.set(__self__, "algorithms", algorithms)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominify is not None:
            pulumi.set(__self__, "autominify", autominify)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if cache_reserve is not None:
            pulumi.set(__self__, "cache_reserve", cache_reserve)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_rum is not None:
            pulumi.set(__self__, "disable_rum", disable_rum)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_cache_control is not None:
            pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of additional ports that caching can be enabled on.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @additional_cacheable_ports.setter
    def additional_cacheable_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "additional_cacheable_ports", value)

    @property
    @pulumi.getter
    def algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]:
        """
        Custom order for compression algorithms.
        """
        return pulumi.get(self, "algorithms")

    @algorithms.setter
    def algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]):
        pulumi.set(self, "algorithms", value)

    @property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Automatic HTTPS Rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @property
    @pulumi.getter
    def autominify(self) -> Optional[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]:
        """
        Select which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominify")

    @autominify.setter
    def autominify(self, value: Optional[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]):
        pulumi.set(self, "autominify", value)

    @property
    @pulumi.getter
    def bic(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Browser Integrity Check.
        """
        return pulumi.get(self, "bic")

    @bic.setter
    def bic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bic", value)

    @property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]:
        """
        Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        """
        return pulumi.get(self, "browser_ttl")

    @browser_ttl.setter
    def browser_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]):
        pulumi.set(self, "browser_ttl", value)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Mark whether the requests response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]:
        """
        Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
        """
        return pulumi.get(self, "cache_key")

    @cache_key.setter
    def cache_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]):
        pulumi.set(self, "cache_key", value)

    @property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']]:
        """
        Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        """
        return pulumi.get(self, "cache_reserve")

    @cache_reserve.setter
    def cache_reserve(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']]):
        pulumi.set(self, "cache_reserve", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Error response content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        Content-type header to set with the response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]]]:
        """
        The cookie fields to log.
        """
        return pulumi.get(self, "cookie_fields")

    @cookie_fields.setter
    def cookie_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]]]):
        pulumi.set(self, "cookie_fields", value)

    @property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off all active Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_apps", value)

    @property
    @pulumi.getter(name="disableRum")
    def disable_rum(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off Real User Monitoring (RUM).
        """
        return pulumi.get(self, "disable_rum")

    @disable_rum.setter
    def disable_rum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_rum", value)

    @property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn off Zaraz.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]:
        """
        TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
        """
        return pulumi.get(self, "edge_ttl")

    @edge_ttl.setter
    def edge_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]):
        pulumi.set(self, "edge_ttl", value)

    @property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Email Obfuscation.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_obfuscation", value)

    @property
    @pulumi.getter
    def fonts(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Cloudflare Fonts.
        """
        return pulumi.get(self, "fonts")

    @fonts.setter
    def fonts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fonts", value)

    @property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]:
        """
        Serve a redirect based on a bulk list lookup.
        """
        return pulumi.get(self, "from_list")

    @from_list.setter
    def from_list(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]):
        pulumi.set(self, "from_list", value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]:
        """
        Serve a redirect based on the request properties.
        """
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]]]:
        """
        Map of request headers to modify.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Rewrite the HTTP Host header.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off the Hotlink Protection.
        """
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hotlink_protection", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the ruleset to execute.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[int]]:
        """
        Increment contains the delta to change the score and can be either positive or negative.
        """
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]:
        """
        The configuration to use for matched data logging.
        """
        return pulumi.get(self, "matched_data")

    @matched_data.setter
    def matched_data(self, value: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]):
        pulumi.set(self, "matched_data", value)

    @property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Mirage.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mirage", value)

    @property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Opportunistic Encryption.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]:
        """
        Override the IP/TCP destination.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
        """
        return pulumi.get(self, "origin_cache_control")

    @origin_cache_control.setter
    def origin_cache_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_cache_control", value)

    @property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[pulumi.Input[bool]]:
        """
        Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @origin_error_page_passthru.setter
    def origin_error_page_passthru(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "origin_error_page_passthru", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]:
        """
        A set of overrides to apply to the target ruleset.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of phases to skip the execution of. This option is incompatible with the ruleset and rulesets options.
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phases", value)

    @property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[str]]:
        """
        Configure the Polish level.
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "polish", value)

    @property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of legacy security products to skip the execution of.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        """
        return pulumi.get(self, "read_timeout")

    @read_timeout.setter
    def read_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_timeout", value)

    @property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]]]:
        """
        The request fields to log.
        """
        return pulumi.get(self, "request_fields")

    @request_fields.setter
    def request_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]]]):
        pulumi.set(self, "request_fields", value)

    @property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
        """
        return pulumi.get(self, "respect_strong_etags")

    @respect_strong_etags.setter
    def respect_strong_etags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_strong_etags", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RulesetRuleActionParametersResponseArgs']]:
        """
        The response to show when the block is applied.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RulesetRuleActionParametersResponseArgs']]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]]]:
        """
        The response fields to log.
        """
        return pulumi.get(self, "response_fields")

    @response_fields.setter
    def response_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]]]):
        pulumi.set(self, "response_fields", value)

    @property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Rocket Loader
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rocket_loader", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def ruleset(self) -> Optional[pulumi.Input[str]]:
        """
        A ruleset to skip the execution of. This option is incompatible with the rulesets, rules and phases options.
        """
        return pulumi.get(self, "ruleset")

    @ruleset.setter
    def ruleset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ruleset", value)

    @property
    @pulumi.getter
    def rulesets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        """
        return pulumi.get(self, "rulesets")

    @rulesets.setter
    def rulesets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "rulesets", value)

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[str]]:
        """
        Configure the Security Level.
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_level", value)

    @property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]:
        """
        Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "serve_stale")

    @serve_stale.setter
    def serve_stale(self, value: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]):
        pulumi.set(self, "serve_stale", value)

    @property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Server Side Excludes.
        """
        return pulumi.get(self, "server_side_excludes")

    @server_side_excludes.setter
    def server_side_excludes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_side_excludes", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]:
        """
        Override the Server Name Indication (SNI).
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Configure the SSL level.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[float]]:
        """
        The status code to use for the error.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def sxg(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on or off Signed Exchanges (SXG).
        """
        return pulumi.get(self, "sxg")

    @sxg.setter
    def sxg(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sxg", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]:
        """
        URI to rewrite the request to.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class RulesetRuleActionParametersAlgorithmArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of compression algorithm to enable.
        """
elif False:
    RulesetRuleActionParametersAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersAlgorithmArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of compression algorithm to enable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of compression algorithm to enable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersAutominifyArgsDict(TypedDict):
        css: NotRequired[pulumi.Input[bool]]
        """
        Minify CSS files.
        """
        html: NotRequired[pulumi.Input[bool]]
        """
        Minify HTML files.
        """
        js: NotRequired[pulumi.Input[bool]]
        """
        Minify JS files.
        """
elif False:
    RulesetRuleActionParametersAutominifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersAutominifyArgs:
    def __init__(__self__, *,
                 css: Optional[pulumi.Input[bool]] = None,
                 html: Optional[pulumi.Input[bool]] = None,
                 js: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] css: Minify CSS files.
        :param pulumi.Input[bool] html: Minify HTML files.
        :param pulumi.Input[bool] js: Minify JS files.
        """
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @property
    @pulumi.getter
    def css(self) -> Optional[pulumi.Input[bool]]:
        """
        Minify CSS files.
        """
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "css", value)

    @property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[bool]]:
        """
        Minify HTML files.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "html", value)

    @property
    @pulumi.getter
    def js(self) -> Optional[pulumi.Input[bool]]:
        """
        Minify JS files.
        """
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "js", value)


if not MYPY:
    class RulesetRuleActionParametersBrowserTtlArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        Determines which browser ttl mode to use.
        """
        default: NotRequired[pulumi.Input[int]]
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
elif False:
    RulesetRuleActionParametersBrowserTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersBrowserTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mode: Determines which browser ttl mode to use.
        :param pulumi.Input[int] default: The TTL (in seconds) if you choose override_origin mode.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Determines which browser ttl mode to use.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyArgsDict(TypedDict):
        cache_by_device_type: NotRequired[pulumi.Input[bool]]
        """
        Separate cached content based on the visitors device type
        """
        cache_deception_armor: NotRequired[pulumi.Input[bool]]
        """
        Protect from web cache deception attacks while allowing static assets to be cached
        """
        custom_key: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgsDict']]
        """
        Customize which components of the request are included or excluded from the cache key.
        """
        ignore_query_strings_order: NotRequired[pulumi.Input[bool]]
        """
        Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
elif False:
    RulesetRuleActionParametersCacheKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyArgs:
    def __init__(__self__, *,
                 cache_by_device_type: Optional[pulumi.Input[bool]] = None,
                 cache_deception_armor: Optional[pulumi.Input[bool]] = None,
                 custom_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']] = None,
                 ignore_query_strings_order: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] cache_by_device_type: Separate cached content based on the visitors device type
        :param pulumi.Input[bool] cache_deception_armor: Protect from web cache deception attacks while allowing static assets to be cached
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs'] custom_key: Customize which components of the request are included or excluded from the cache key.
        :param pulumi.Input[bool] ignore_query_strings_order: Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Separate cached content based on the visitors device type
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_by_device_type", value)

    @property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[bool]]:
        """
        Protect from web cache deception attacks while allowing static assets to be cached
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cache_deception_armor", value)

    @property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]:
        """
        Customize which components of the request are included or excluded from the cache key.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]):
        pulumi.set(self, "custom_key", value)

    @property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
        """
        return pulumi.get(self, "ignore_query_strings_order")

    @ignore_query_strings_order.setter
    def ignore_query_strings_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_query_strings_order", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict']]
        """
        The cookies to include in building the cache key.
        """
        header: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict']]
        """
        The header names and values to include in building the cache key.
        """
        host: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict']]
        """
        Whether to use the original host or the resolved host in the cache key.
        """
        query_string: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict']]
        """
        Use the presence of parameters in the query string to build the cache key.
        """
        user: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict']]
        """
        Characteristics of the request user agent used in building the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']] = None,
                 header: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']] = None,
                 host: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']] = None,
                 query_string: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']] = None,
                 user: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs'] cookie: The cookies to include in building the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs'] header: The header names and values to include in building the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs'] host: Whether to use the original host or the resolved host in the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs'] query_string: Use the presence of parameters in the query string to build the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs'] user: Characteristics of the request user agent used in building the cache key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]:
        """
        The cookies to include in building the cache key.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]:
        """
        The header names and values to include in building the cache key.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]:
        """
        Whether to use the original host or the resolved host in the cache key.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]:
        """
        Use the presence of parameters in the query string to build the cache key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]:
        """
        Characteristics of the request user agent used in building the cache key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]):
        pulumi.set(self, "user", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Include these cookies' names and their values.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Include these cookies' names and their values.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Include these cookies' names and their values.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        """
        contains: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        """
        exclude_origin: NotRequired[pulumi.Input[bool]]
        """
        Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Include these headers' names and their values.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contains: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 exclude_origin: Optional[pulumi.Input[bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_presences: Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] contains: For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        :param pulumi.Input[bool] exclude_origin: Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Include these headers' names and their values.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Checks for the presence of these header names. The presence of these headers is used in building the cache key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_presences", value)

    @property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
        """
        return pulumi.get(self, "exclude_origin")

    @exclude_origin.setter
    def exclude_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_origin", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Include these headers' names and their values.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict(TypedDict):
        resolved: NotRequired[pulumi.Input[bool]]
        """
        Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] resolved: Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolved", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict(TypedDict):
        exclude: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict']]
        """
        A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        """
        include: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict']]
        """
        A list of query string parameters used to build the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs']] = None,
                 include: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs'] exclude: A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs'] include: A list of query string parameters used to build the cache key.
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs']]:
        """
        A list of query string parameters NOT used to build the cache key. All parameters present in the request but missing in this list will be used to build the cache key.
        """
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs']]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs']]:
        """
        A list of query string parameters used to build the cache key.
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs']]):
        pulumi.set(self, "include", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to exclude all query string parameters from the cache key.
        """
        lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[bool]] = None,
                 lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] all: Determines whether to exclude all query string parameters from the cache key.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to exclude all query string parameters from the cache key.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter
    def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "lists")

    @lists.setter
    def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lists", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to include all query string parameters in the cache key.
        """
        lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[bool]] = None,
                 lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] all: Determines whether to include all query string parameters in the cache key.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to include all query string parameters in the cache key.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter
    def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "lists")

    @lists.setter
    def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lists", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[bool]]
        """
        Use the user agent's device type in the cache key.
        """
        geo: NotRequired[pulumi.Input[bool]]
        """
        Use the user agents's country in the cache key.
        """
        lang: NotRequired[pulumi.Input[bool]]
        """
        Use the user agent's language in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[bool]] = None,
                 geo: Optional[pulumi.Input[bool]] = None,
                 lang: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] device_type: Use the user agent's device type in the cache key.
        :param pulumi.Input[bool] geo: Use the user agents's country in the cache key.
        :param pulumi.Input[bool] lang: Use the user agent's language in the cache key.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the user agent's device type in the cache key.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the user agents's country in the cache key.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the user agent's language in the cache key.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class RulesetRuleActionParametersCacheReserveArgsDict(TypedDict):
        eligible: pulumi.Input[bool]
        """
        Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        """
        minimum_file_size: pulumi.Input[int]
        """
        The minimum file size eligible for store in cache reserve.
        """
elif False:
    RulesetRuleActionParametersCacheReserveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheReserveArgs:
    def __init__(__self__, *,
                 eligible: pulumi.Input[bool],
                 minimum_file_size: pulumi.Input[int]):
        """
        :param pulumi.Input[bool] eligible: Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        :param pulumi.Input[int] minimum_file_size: The minimum file size eligible for store in cache reserve.
        """
        pulumi.set(__self__, "eligible", eligible)
        pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @property
    @pulumi.getter
    def eligible(self) -> pulumi.Input[bool]:
        """
        Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
        """
        return pulumi.get(self, "eligible")

    @eligible.setter
    def eligible(self, value: pulumi.Input[bool]):
        pulumi.set(self, "eligible", value)

    @property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> pulumi.Input[int]:
        """
        The minimum file size eligible for store in cache reserve.
        """
        return pulumi.get(self, "minimum_file_size")

    @minimum_file_size.setter
    def minimum_file_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum_file_size", value)


if not MYPY:
    class RulesetRuleActionParametersCookieFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the field.
        """
elif False:
    RulesetRuleActionParametersCookieFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCookieFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlArgsDict(TypedDict):
        mode: pulumi.Input[str]
        """
        edge ttl options
        """
        default: NotRequired[pulumi.Input[int]]
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        status_code_ttls: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict']]]]
        """
        List of single status codes, or status code ranges to apply the selected mode
        """
elif False:
    RulesetRuleActionParametersEdgeTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None,
                 status_code_ttls: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]] = None):
        """
        :param pulumi.Input[str] mode: edge ttl options
        :param pulumi.Input[int] default: The TTL (in seconds) if you choose override_origin mode.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]] status_code_ttls: List of single status codes, or status code ranges to apply the selected mode
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        edge ttl options
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        The TTL (in seconds) if you choose override_origin mode.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]:
        """
        List of single status codes, or status code ranges to apply the selected mode
        """
        return pulumi.get(self, "status_code_ttls")

    @status_code_ttls.setter
    def status_code_ttls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]):
        pulumi.set(self, "status_code_ttls", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict(TypedDict):
        value: pulumi.Input[int]
        """
        Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        """
        status_code: NotRequired[pulumi.Input[int]]
        """
        Set the ttl for responses with this specific status code
        """
        status_code_range: NotRequired[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict']]
        """
        The range of status codes used to apply the selected mode.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[int],
                 status_code: Optional[pulumi.Input[int]] = None,
                 status_code_range: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']] = None):
        """
        :param pulumi.Input[int] value: Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        :param pulumi.Input[int] status_code: Set the ttl for responses with this specific status code
        :param pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs'] status_code_range: The range of status codes used to apply the selected mode.
        """
        pulumi.set(__self__, "value", value)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_range is not None:
            pulumi.set(__self__, "status_code_range", status_code_range)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        Set the ttl for responses with this specific status code
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]:
        """
        The range of status codes used to apply the selected mode.
        """
        return pulumi.get(self, "status_code_range")

    @status_code_range.setter
    def status_code_range(self, value: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]):
        pulumi.set(self, "status_code_range", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[int]]
        """
        response status code lower bound
        """
        to: NotRequired[pulumi.Input[int]]
        """
        response status code upper bound
        """
elif False:
    RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[int]] = None,
                 to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] from_: response status code lower bound
        :param pulumi.Input[int] to: response status code upper bound
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[int]]:
        """
        response status code lower bound
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[int]]:
        """
        response status code upper bound
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RulesetRuleActionParametersFromListArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Expression that evaluates to the list lookup key.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the list to match against.
        """
elif False:
    RulesetRuleActionParametersFromListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Expression that evaluates to the list lookup key.
        :param pulumi.Input[str] name: The name of the list to match against.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Expression that evaluates to the list lookup key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the list to match against.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersFromValueArgsDict(TypedDict):
        preserve_query_string: NotRequired[pulumi.Input[bool]]
        """
        Keep the query string of the original request.
        """
        status_code: NotRequired[pulumi.Input[float]]
        """
        The status code to be used for the redirect.
        """
        target_url: NotRequired[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgsDict']]
        """
        The URL to redirect the request to.
        """
elif False:
    RulesetRuleActionParametersFromValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromValueArgs:
    def __init__(__self__, *,
                 preserve_query_string: Optional[pulumi.Input[bool]] = None,
                 status_code: Optional[pulumi.Input[float]] = None,
                 target_url: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']] = None):
        """
        :param pulumi.Input[bool] preserve_query_string: Keep the query string of the original request.
        :param pulumi.Input[float] status_code: The status code to be used for the redirect.
        :param pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs'] target_url: The URL to redirect the request to.
        """
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Keep the query string of the original request.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[float]]:
        """
        The status code to be used for the redirect.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']]:
        """
        The URL to redirect the request to.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']]):
        pulumi.set(self, "target_url", value)


if not MYPY:
    class RulesetRuleActionParametersFromValueTargetUrlArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        An expression to evaluate to get the URL to redirect the request to.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The URL to redirect the request to.
        """
elif False:
    RulesetRuleActionParametersFromValueTargetUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromValueTargetUrlArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: An expression to evaluate to get the URL to redirect the request to.
        :param pulumi.Input[str] value: The URL to redirect the request to.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        An expression to evaluate to get the URL to redirect the request to.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to redirect the request to.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersHeadersArgsDict(TypedDict):
        operation: pulumi.Input[str]
        expression: NotRequired[pulumi.Input[str]]
        """
        Expression for the header value.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Static value for the header.
        """
elif False:
    RulesetRuleActionParametersHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersHeadersArgs:
    def __init__(__self__, *,
                 operation: pulumi.Input[str],
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Expression for the header value.
        :param pulumi.Input[str] value: Static value for the header.
        """
        pulumi.set(__self__, "operation", operation)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Expression for the header value.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Static value for the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersMatchedDataArgsDict(TypedDict):
        public_key: pulumi.Input[str]
        """
        The public key to encrypt matched data logs with.
        """
elif False:
    RulesetRuleActionParametersMatchedDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersMatchedDataArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key: The public key to encrypt matched data logs with.
        """
        pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        The public key to encrypt matched data logs with.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class RulesetRuleActionParametersOriginArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        Override the resolved hostname.
        """
        port: NotRequired[pulumi.Input[float]]
        """
        Override the destination port.
        """
elif False:
    RulesetRuleActionParametersOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOriginArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] host: Override the resolved hostname.
        :param pulumi.Input[float] port: Override the destination port.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Override the resolved hostname.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        Override the destination port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        An action to override all rules with. This option has lower precedence than rule and category overrides.
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgsDict']]]]
        """
        A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgsDict']]]]
        """
        A list of rule-level overrides. This option has the highest precedence.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
elif False:
    RulesetRuleActionParametersOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: An action to override all rules with. This option has lower precedence than rule and category overrides.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]] categories: A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        :param pulumi.Input[bool] enabled: Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]] rules: A list of rule-level overrides. This option has the highest precedence.
        :param pulumi.Input[str] sensitivity_level: A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        An action to override all rules with. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]:
        """
        A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]:
        """
        A list of rule-level overrides. This option has the highest precedence.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesCategoryArgsDict(TypedDict):
        category: pulumi.Input[str]
        """
        The name of the category to override.
        """
        action: NotRequired[pulumi.Input[str]]
        """
        The action to override rules in the category with.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable execution of rules in the category.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        The sensitivity level to use for rules in the category.
        """
elif False:
    RulesetRuleActionParametersOverridesCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesCategoryArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: The name of the category to override.
        :param pulumi.Input[str] action: The action to override rules in the category with.
        :param pulumi.Input[bool] enabled: Whether to enable execution of rules in the category.
        :param pulumi.Input[str] sensitivity_level: The sensitivity level to use for rules in the category.
        """
        pulumi.set(__self__, "category", category)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        The name of the category to override.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to override rules in the category with.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable execution of rules in the category.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        The sensitivity level to use for rules in the category.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesRuleArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of the rule to override.
        """
        action: NotRequired[pulumi.Input[str]]
        """
        The action to override the rule with.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable execution of the rule.
        """
        score_threshold: NotRequired[pulumi.Input[int]]
        """
        The score threshold to use for the rule.
        """
        sensitivity_level: NotRequired[pulumi.Input[str]]
        """
        The sensitivity level to use for the rule.
        """
elif False:
    RulesetRuleActionParametersOverridesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 action: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 score_threshold: Optional[pulumi.Input[int]] = None,
                 sensitivity_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the rule to override.
        :param pulumi.Input[str] action: The action to override the rule with.
        :param pulumi.Input[bool] enabled: Whether to enable execution of the rule.
        :param pulumi.Input[int] score_threshold: The score threshold to use for the rule.
        :param pulumi.Input[str] sensitivity_level: The sensitivity level to use for the rule.
        """
        pulumi.set(__self__, "id", id)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the rule to override.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action to override the rule with.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable execution of the rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The score threshold to use for the rule.
        """
        return pulumi.get(self, "score_threshold")

    @score_threshold.setter
    def score_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score_threshold", value)

    @property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[str]]:
        """
        The sensitivity level to use for the rule.
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersRequestFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the field.
        """
elif False:
    RulesetRuleActionParametersRequestFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersRequestFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersResponseArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        The content to return.
        """
        content_type: pulumi.Input[str]
        """
        The type of the content to return.
        """
        status_code: pulumi.Input[int]
        """
        The status code to return.
        """
elif False:
    RulesetRuleActionParametersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersResponseArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 content_type: pulumi.Input[str],
                 status_code: pulumi.Input[int]):
        """
        :param pulumi.Input[str] content: The content to return.
        :param pulumi.Input[str] content_type: The type of the content to return.
        :param pulumi.Input[int] status_code: The status code to return.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content to return.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        The type of the content to return.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        The status code to return.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class RulesetRuleActionParametersResponseFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the field.
        """
elif False:
    RulesetRuleActionParametersResponseFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersResponseFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersServeStaleArgsDict(TypedDict):
        disable_stale_while_updating: pulumi.Input[bool]
        """
        Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
elif False:
    RulesetRuleActionParametersServeStaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersServeStaleArgs:
    def __init__(__self__, *,
                 disable_stale_while_updating: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] disable_stale_while_updating: Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> pulumi.Input[bool]:
        """
        Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "disable_stale_while_updating")

    @disable_stale_while_updating.setter
    def disable_stale_while_updating(self, value: pulumi.Input[bool]):
        pulumi.set(self, "disable_stale_while_updating", value)


if not MYPY:
    class RulesetRuleActionParametersSniArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The SNI override.
        """
elif False:
    RulesetRuleActionParametersSniArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersSniArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The SNI override.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The SNI override.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['RulesetRuleActionParametersUriPathArgsDict']]
        """
        Path portion rewrite.
        """
        query: NotRequired[pulumi.Input['RulesetRuleActionParametersUriQueryArgsDict']]
        """
        Query portion rewrite.
        """
elif False:
    RulesetRuleActionParametersUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']] = None,
                 query: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersUriPathArgs'] path: Path portion rewrite.
        :param pulumi.Input['RulesetRuleActionParametersUriQueryArgs'] query: Query portion rewrite.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]:
        """
        Path portion rewrite.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]:
        """
        Query portion rewrite.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]):
        pulumi.set(self, "query", value)


if not MYPY:
    class RulesetRuleActionParametersUriPathArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Expression to evaluate for the replacement value.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Predefined replacement value.
        """
elif False:
    RulesetRuleActionParametersUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriPathArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Expression to evaluate for the replacement value.
        :param pulumi.Input[str] value: Predefined replacement value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Expression to evaluate for the replacement value.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Predefined replacement value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersUriQueryArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[str]]
        """
        Expression to evaluate for the replacement value.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Predefined replacement value.
        """
elif False:
    RulesetRuleActionParametersUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriQueryArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Expression to evaluate for the replacement value.
        :param pulumi.Input[str] value: Predefined replacement value.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Expression to evaluate for the replacement value.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Predefined replacement value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleExposedCredentialCheckArgsDict(TypedDict):
        password_expression: pulumi.Input[str]
        """
        Expression that selects the password used in the credentials check.
        """
        username_expression: pulumi.Input[str]
        """
        Expression that selects the user ID used in the credentials check.
        """
elif False:
    RulesetRuleExposedCredentialCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleExposedCredentialCheckArgs:
    def __init__(__self__, *,
                 password_expression: pulumi.Input[str],
                 username_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password_expression: Expression that selects the password used in the credentials check.
        :param pulumi.Input[str] username_expression: Expression that selects the user ID used in the credentials check.
        """
        pulumi.set(__self__, "password_expression", password_expression)
        pulumi.set(__self__, "username_expression", username_expression)

    @property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> pulumi.Input[str]:
        """
        Expression that selects the password used in the credentials check.
        """
        return pulumi.get(self, "password_expression")

    @password_expression.setter
    def password_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_expression", value)

    @property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> pulumi.Input[str]:
        """
        Expression that selects the user ID used in the credentials check.
        """
        return pulumi.get(self, "username_expression")

    @username_expression.setter
    def username_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "username_expression", value)


if not MYPY:
    class RulesetRuleLoggingArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether to generate a log when the rule matches.
        """
elif False:
    RulesetRuleLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleLoggingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether to generate a log when the rule matches.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to generate a log when the rule matches.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class RulesetRuleRatelimitArgsDict(TypedDict):
        characteristics: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Characteristics of the request on which the ratelimiter counter will be incremented.
        """
        period: pulumi.Input[int]
        """
        Period in seconds over which the counter is being incremented.
        """
        counting_expression: NotRequired[pulumi.Input[str]]
        """
        Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        """
        mitigation_timeout: NotRequired[pulumi.Input[int]]
        """
        Period of time in seconds after which the action will be disabled following its first execution.
        """
        requests_per_period: NotRequired[pulumi.Input[int]]
        """
        The threshold of requests per period after which the action will be executed for the first time.
        """
        requests_to_origin: NotRequired[pulumi.Input[bool]]
        """
        Defines if ratelimit counting is only done when an origin is reached.
        """
        score_per_period: NotRequired[pulumi.Input[int]]
        """
        The score threshold per period for which the action will be executed the first time.
        """
        score_response_header_name: NotRequired[pulumi.Input[str]]
        """
        The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
elif False:
    RulesetRuleRatelimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleRatelimitArgs:
    def __init__(__self__, *,
                 characteristics: pulumi.Input[Sequence[pulumi.Input[str]]],
                 period: pulumi.Input[int],
                 counting_expression: Optional[pulumi.Input[str]] = None,
                 mitigation_timeout: Optional[pulumi.Input[int]] = None,
                 requests_per_period: Optional[pulumi.Input[int]] = None,
                 requests_to_origin: Optional[pulumi.Input[bool]] = None,
                 score_per_period: Optional[pulumi.Input[int]] = None,
                 score_response_header_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] characteristics: Characteristics of the request on which the ratelimiter counter will be incremented.
        :param pulumi.Input[int] period: Period in seconds over which the counter is being incremented.
        :param pulumi.Input[str] counting_expression: Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        :param pulumi.Input[int] mitigation_timeout: Period of time in seconds after which the action will be disabled following its first execution.
        :param pulumi.Input[int] requests_per_period: The threshold of requests per period after which the action will be executed for the first time.
        :param pulumi.Input[bool] requests_to_origin: Defines if ratelimit counting is only done when an origin is reached.
        :param pulumi.Input[int] score_per_period: The score threshold per period for which the action will be executed the first time.
        :param pulumi.Input[str] score_response_header_name: The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
        pulumi.set(__self__, "characteristics", characteristics)
        pulumi.set(__self__, "period", period)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @property
    @pulumi.getter
    def characteristics(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Characteristics of the request on which the ratelimiter counter will be incremented.
        """
        return pulumi.get(self, "characteristics")

    @characteristics.setter
    def characteristics(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "characteristics", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[int]:
        """
        Period in seconds over which the counter is being incremented.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
        """
        return pulumi.get(self, "counting_expression")

    @counting_expression.setter
    def counting_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "counting_expression", value)

    @property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Period of time in seconds after which the action will be disabled following its first execution.
        """
        return pulumi.get(self, "mitigation_timeout")

    @mitigation_timeout.setter
    def mitigation_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mitigation_timeout", value)

    @property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[pulumi.Input[int]]:
        """
        The threshold of requests per period after which the action will be executed for the first time.
        """
        return pulumi.get(self, "requests_per_period")

    @requests_per_period.setter
    def requests_per_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requests_per_period", value)

    @property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if ratelimit counting is only done when an origin is reached.
        """
        return pulumi.get(self, "requests_to_origin")

    @requests_to_origin.setter
    def requests_to_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "requests_to_origin", value)

    @property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[pulumi.Input[int]]:
        """
        The score threshold per period for which the action will be executed the first time.
        """
        return pulumi.get(self, "score_per_period")

    @score_per_period.setter
    def score_per_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "score_per_period", value)

    @property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The response header name provided by the origin which should contain the score to increment ratelimit counter on.
        """
        return pulumi.get(self, "score_response_header_name")

    @score_response_header_name.setter
    def score_response_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_response_header_name", value)


if not MYPY:
    class SnippetRulesRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        expression: NotRequired[pulumi.Input[str]]
        snippet_name: NotRequired[pulumi.Input[str]]
        """
        Snippet identifying name
        """
elif False:
    SnippetRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetRulesRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 snippet_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] snippet_name: Snippet identifying name
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if snippet_name is not None:
            pulumi.set(__self__, "snippet_name", snippet_name)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> Optional[pulumi.Input[str]]:
        """
        Snippet identifying name
        """
        return pulumi.get(self, "snippet_name")

    @snippet_name.setter
    def snippet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snippet_name", value)


if not MYPY:
    class SnippetsMetadataArgsDict(TypedDict):
        main_module: NotRequired[pulumi.Input[str]]
        """
        Main module name of uploaded snippet
        """
elif False:
    SnippetsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetsMetadataArgs:
    def __init__(__self__, *,
                 main_module: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] main_module: Main module name of uploaded snippet
        """
        if main_module is not None:
            pulumi.set(__self__, "main_module", main_module)

    @property
    @pulumi.getter(name="mainModule")
    def main_module(self) -> Optional[pulumi.Input[str]]:
        """
        Main module name of uploaded snippet
        """
        return pulumi.get(self, "main_module")

    @main_module.setter
    def main_module(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_module", value)


if not MYPY:
    class SpectrumApplicationDnsArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the DNS record associated with the application.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of DNS record associated with the application.
        """
elif False:
    SpectrumApplicationDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationDnsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the DNS record associated with the application.
        :param pulumi.Input[str] type: The type of DNS record associated with the application.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of DNS record associated with the application.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SpectrumApplicationEdgeIpsArgsDict(TypedDict):
        connectivity: NotRequired[pulumi.Input[str]]
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The array of customer owned IPs we broadcast via anycast for this hostname and application.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
elif False:
    SpectrumApplicationEdgeIpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationEdgeIpsArgs:
    def __init__(__self__, *,
                 connectivity: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: The array of customer owned IPs we broadcast via anycast for this hostname and application.
        :param pulumi.Input[str] type: The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def connectivity(self) -> Optional[pulumi.Input[str]]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs.
        """
        return pulumi.get(self, "connectivity")

    @connectivity.setter
    def connectivity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connectivity", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The array of customer owned IPs we broadcast via anycast for this hostname and application.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SpectrumApplicationOriginDnsArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the DNS record associated with the origin.
        """
        ttl: NotRequired[pulumi.Input[int]]
        """
        The TTL of our resolution of your DNS record in seconds.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
elif False:
    SpectrumApplicationOriginDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationOriginDnsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the DNS record associated with the origin.
        :param pulumi.Input[int] ttl: The TTL of our resolution of your DNS record in seconds.
        :param pulumi.Input[str] type: The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the DNS record associated with the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The TTL of our resolution of your DNS record in seconds.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StreamInputArgsDict(TypedDict):
        height: NotRequired[pulumi.Input[int]]
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        width: NotRequired[pulumi.Input[int]]
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
elif False:
    StreamInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamInputArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] height: The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        :param pulumi.Input[int] width: The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class StreamLiveInputRecordingArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        """
        hide_live_viewer_count: NotRequired[pulumi.Input[bool]]
        """
        Disables reporting the number of live viewers when this property is set to `true`.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        """
        require_signed_urls: NotRequired[pulumi.Input[bool]]
        """
        Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
elif False:
    StreamLiveInputRecordingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputRecordingArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hide_live_viewer_count: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 require_signed_urls: Optional[pulumi.Input[bool]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        :param pulumi.Input[bool] hide_live_viewer_count: Disables reporting the number of live viewers when this property is set to `true`.
        :param pulumi.Input[str] mode: Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        :param pulumi.Input[bool] require_signed_urls: Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        :param pulumi.Input[int] timeout_seconds: Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if hide_live_viewer_count is not None:
            pulumi.set(__self__, "hide_live_viewer_count", hide_live_viewer_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if require_signed_urls is not None:
            pulumi.set(__self__, "require_signed_urls", require_signed_urls)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="hideLiveViewerCount")
    def hide_live_viewer_count(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables reporting the number of live viewers when this property is set to `true`.
        """
        return pulumi.get(self, "hide_live_viewer_count")

    @hide_live_viewer_count.setter
    def hide_live_viewer_count(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_live_viewer_count", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="requireSignedUrls")
    def require_signed_urls(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        """
        return pulumi.get(self, "require_signed_urls")

    @require_signed_urls.setter
    def require_signed_urls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_signed_urls", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class StreamLiveInputRtmpsArgsDict(TypedDict):
        stream_key: NotRequired[pulumi.Input[str]]
        """
        The secret key to use when streaming via RTMPS to a live input.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
elif False:
    StreamLiveInputRtmpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputRtmpsArgs:
    def __init__(__self__, *,
                 stream_key: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stream_key: The secret key to use when streaming via RTMPS to a live input.
        :param pulumi.Input[str] url: The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        if stream_key is not None:
            pulumi.set(__self__, "stream_key", stream_key)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key to use when streaming via RTMPS to a live input.
        """
        return pulumi.get(self, "stream_key")

    @stream_key.setter
    def stream_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_key", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputRtmpsPlaybackArgsDict(TypedDict):
        stream_key: NotRequired[pulumi.Input[str]]
        """
        The secret key to use for playback via RTMPS.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL used to play live video over RTMPS.
        """
elif False:
    StreamLiveInputRtmpsPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputRtmpsPlaybackArgs:
    def __init__(__self__, *,
                 stream_key: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] stream_key: The secret key to use for playback via RTMPS.
        :param pulumi.Input[str] url: The URL used to play live video over RTMPS.
        """
        if stream_key is not None:
            pulumi.set(__self__, "stream_key", stream_key)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key to use for playback via RTMPS.
        """
        return pulumi.get(self, "stream_key")

    @stream_key.setter
    def stream_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_key", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to play live video over RTMPS.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputSrtArgsDict(TypedDict):
        passphrase: NotRequired[pulumi.Input[str]]
        """
        The secret key to use when streaming via SRT to a live input.
        """
        stream_id: NotRequired[pulumi.Input[str]]
        """
        The identifier of the live input to use when streaming via SRT.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The SRT URL you provide to the broadcaster, which they stream live video to.
        """
elif False:
    StreamLiveInputSrtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputSrtArgs:
    def __init__(__self__, *,
                 passphrase: Optional[pulumi.Input[str]] = None,
                 stream_id: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] passphrase: The secret key to use when streaming via SRT to a live input.
        :param pulumi.Input[str] stream_id: The identifier of the live input to use when streaming via SRT.
        :param pulumi.Input[str] url: The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key to use when streaming via SRT to a live input.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passphrase", value)

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the live input to use when streaming via SRT.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_id", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputSrtPlaybackArgsDict(TypedDict):
        passphrase: NotRequired[pulumi.Input[str]]
        """
        The secret key to use for playback via SRT.
        """
        stream_id: NotRequired[pulumi.Input[str]]
        """
        The identifier of the live input to use for playback via SRT.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL used to play live video over SRT.
        """
elif False:
    StreamLiveInputSrtPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputSrtPlaybackArgs:
    def __init__(__self__, *,
                 passphrase: Optional[pulumi.Input[str]] = None,
                 stream_id: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] passphrase: The secret key to use for playback via SRT.
        :param pulumi.Input[str] stream_id: The identifier of the live input to use for playback via SRT.
        :param pulumi.Input[str] url: The URL used to play live video over SRT.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[str]]:
        """
        The secret key to use for playback via SRT.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "passphrase", value)

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of the live input to use for playback via SRT.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_id", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to play live video over SRT.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputWebRtcArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
elif False:
    StreamLiveInputWebRtcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputWebRtcArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputWebRtcPlaybackArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        The URL used to play live video over WebRTC.
        """
elif False:
    StreamLiveInputWebRtcPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputWebRtcPlaybackArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL used to play live video over WebRTC.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to play live video over WebRTC.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamPlaybackArgsDict(TypedDict):
        dash: NotRequired[pulumi.Input[str]]
        """
        DASH Media Presentation Description for the video.
        """
        hls: NotRequired[pulumi.Input[str]]
        """
        The HLS manifest for the video.
        """
elif False:
    StreamPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamPlaybackArgs:
    def __init__(__self__, *,
                 dash: Optional[pulumi.Input[str]] = None,
                 hls: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dash: DASH Media Presentation Description for the video.
        :param pulumi.Input[str] hls: The HLS manifest for the video.
        """
        if dash is not None:
            pulumi.set(__self__, "dash", dash)
        if hls is not None:
            pulumi.set(__self__, "hls", hls)

    @property
    @pulumi.getter
    def dash(self) -> Optional[pulumi.Input[str]]:
        """
        DASH Media Presentation Description for the video.
        """
        return pulumi.get(self, "dash")

    @dash.setter
    def dash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dash", value)

    @property
    @pulumi.getter
    def hls(self) -> Optional[pulumi.Input[str]]:
        """
        The HLS manifest for the video.
        """
        return pulumi.get(self, "hls")

    @hls.setter
    def hls(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hls", value)


if not MYPY:
    class StreamStatusArgsDict(TypedDict):
        error_reason_code: NotRequired[pulumi.Input[str]]
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        error_reason_text: NotRequired[pulumi.Input[str]]
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        pct_complete: NotRequired[pulumi.Input[str]]
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        Specifies the processing status for all quality levels for a video.
        """
elif False:
    StreamStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamStatusArgs:
    def __init__(__self__, *,
                 error_reason_code: Optional[pulumi.Input[str]] = None,
                 error_reason_text: Optional[pulumi.Input[str]] = None,
                 pct_complete: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] error_reason_code: Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        :param pulumi.Input[str] error_reason_text: Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        :param pulumi.Input[str] pct_complete: Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        :param pulumi.Input[str] state: Specifies the processing status for all quality levels for a video.
        """
        if error_reason_code is not None:
            pulumi.set(__self__, "error_reason_code", error_reason_code)
        if error_reason_text is not None:
            pulumi.set(__self__, "error_reason_text", error_reason_text)
        if pct_complete is not None:
            pulumi.set(__self__, "pct_complete", pct_complete)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorReasonCode")
    def error_reason_code(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        return pulumi.get(self, "error_reason_code")

    @error_reason_code.setter
    def error_reason_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_reason_code", value)

    @property
    @pulumi.getter(name="errorReasonText")
    def error_reason_text(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        return pulumi.get(self, "error_reason_text")

    @error_reason_text.setter
    def error_reason_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_reason_text", value)

    @property
    @pulumi.getter(name="pctComplete")
    def pct_complete(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        return pulumi.get(self, "pct_complete")

    @pct_complete.setter
    def pct_complete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pct_complete", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the processing status for all quality levels for a video.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class StreamWatermarkArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[str]]
        """
        The date and a time a watermark profile was created.
        """
        downloaded_from: NotRequired[pulumi.Input[str]]
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        height: NotRequired[pulumi.Input[int]]
        """
        The height of the image in pixels.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A short description of the watermark profile.
        """
        opacity: NotRequired[pulumi.Input[float]]
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        padding: NotRequired[pulumi.Input[float]]
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        position: NotRequired[pulumi.Input[str]]
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        scale: NotRequired[pulumi.Input[float]]
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        size: NotRequired[pulumi.Input[float]]
        """
        The size of the image in bytes.
        """
        uid: NotRequired[pulumi.Input[str]]
        """
        The unique identifier for a watermark profile.
        """
        width: NotRequired[pulumi.Input[int]]
        """
        The width of the image in pixels.
        """
elif False:
    StreamWatermarkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamWatermarkArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[str]] = None,
                 downloaded_from: Optional[pulumi.Input[str]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 opacity: Optional[pulumi.Input[float]] = None,
                 padding: Optional[pulumi.Input[float]] = None,
                 position: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] created: The date and a time a watermark profile was created.
        :param pulumi.Input[str] downloaded_from: The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        :param pulumi.Input[int] height: The height of the image in pixels.
        :param pulumi.Input[str] name: A short description of the watermark profile.
        :param pulumi.Input[float] opacity: The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        :param pulumi.Input[float] padding: The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        :param pulumi.Input[str] position: The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        :param pulumi.Input[float] scale: The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        :param pulumi.Input[float] size: The size of the image in bytes.
        :param pulumi.Input[str] uid: The unique identifier for a watermark profile.
        :param pulumi.Input[int] width: The width of the image in pixels.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if downloaded_from is not None:
            pulumi.set(__self__, "downloaded_from", downloaded_from)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and a time a watermark profile was created.
        """
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created", value)

    @property
    @pulumi.getter(name="downloadedFrom")
    def downloaded_from(self) -> Optional[pulumi.Input[str]]:
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        return pulumi.get(self, "downloaded_from")

    @downloaded_from.setter
    def downloaded_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "downloaded_from", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the watermark profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def opacity(self) -> Optional[pulumi.Input[float]]:
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        return pulumi.get(self, "opacity")

    @opacity.setter
    def opacity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "opacity", value)

    @property
    @pulumi.getter
    def padding(self) -> Optional[pulumi.Input[float]]:
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "padding", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        The size of the image in bytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for a watermark profile.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The width of the image in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class UserAgentBlockingRuleConfigurationArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[str]]
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
elif False:
    UserAgentBlockingRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAgentBlockingRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        :param pulumi.Input[str] value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WaitingRoomAdditionalRouteArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
elif False:
    WaitingRoomAdditionalRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomAdditionalRouteArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        :param pulumi.Input[str] path: Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WaitingRoomCookieAttributesArgsDict(TypedDict):
        samesite: NotRequired[pulumi.Input[str]]
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        """
        secure: NotRequired[pulumi.Input[str]]
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
elif False:
    WaitingRoomCookieAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomCookieAttributesArgs:
    def __init__(__self__, *,
                 samesite: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] samesite: Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        :param pulumi.Input[str] secure: Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "samesite", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure", value)


if not MYPY:
    class WaitingRoomRulesRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action to take when the expression matches.
        """
        expression: pulumi.Input[str]
        """
        Criteria defining when there is a match for the current rule.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the rule.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        When set to true, the rule is enabled.
        """
elif False:
    WaitingRoomRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomRulesRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 expression: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] action: The action to take when the expression matches.
        :param pulumi.Input[str] expression: Criteria defining when there is a match for the current rule.
        :param pulumi.Input[str] description: The description of the rule.
        :param pulumi.Input[bool] enabled: When set to true, the rule is enabled.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take when the expression matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Criteria defining when there is a match for the current rule.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WebAnalyticsSiteRuleArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[str]]
        host: NotRequired[pulumi.Input[str]]
        """
        The hostname the rule will be applied to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The Web Analytics rule identifier.
        """
        inclusive: NotRequired[pulumi.Input[bool]]
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        is_paused: NotRequired[pulumi.Input[bool]]
        """
        Whether the rule is paused or not.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The paths the rule will be applied to.
        """
        priority: NotRequired[pulumi.Input[float]]
elif False:
    WebAnalyticsSiteRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAnalyticsSiteRuleArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 inclusive: Optional[pulumi.Input[bool]] = None,
                 is_paused: Optional[pulumi.Input[bool]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 priority: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] host: The hostname the rule will be applied to.
        :param pulumi.Input[str] id: The Web Analytics rule identifier.
        :param pulumi.Input[bool] inclusive: Whether the rule includes or excludes traffic from being measured.
        :param pulumi.Input[bool] is_paused: Whether the rule is paused or not.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: The paths the rule will be applied to.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inclusive is not None:
            pulumi.set(__self__, "inclusive", inclusive)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname the rule will be applied to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Web Analytics rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def inclusive(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        return pulumi.get(self, "inclusive")

    @inclusive.setter
    def inclusive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "inclusive", value)

    @property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule is paused or not.
        """
        return pulumi.get(self, "is_paused")

    @is_paused.setter
    def is_paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_paused", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths the rule will be applied to.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class WebAnalyticsSiteRulesetArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the ruleset is enabled.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The Web Analytics ruleset identifier.
        """
        zone_name: NotRequired[pulumi.Input[str]]
        zone_tag: NotRequired[pulumi.Input[str]]
        """
        The zone identifier.
        """
elif False:
    WebAnalyticsSiteRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAnalyticsSiteRulesetArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 zone_name: Optional[pulumi.Input[str]] = None,
                 zone_tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether the ruleset is enabled.
        :param pulumi.Input[str] id: The Web Analytics ruleset identifier.
        :param pulumi.Input[str] zone_tag: The zone identifier.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)
        if zone_tag is not None:
            pulumi.set(__self__, "zone_tag", zone_tag)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the ruleset is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Web Analytics ruleset identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_name", value)

    @property
    @pulumi.getter(name="zoneTag")
    def zone_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The zone identifier.
        """
        return pulumi.get(self, "zone_tag")

    @zone_tag.setter
    def zone_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_tag", value)


if not MYPY:
    class WorkersCronTriggerScheduleArgsDict(TypedDict):
        cron: pulumi.Input[str]
elif False:
    WorkersCronTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersCronTriggerScheduleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[str]):
        pulumi.set(__self__, "cron", cron)

    @property
    @pulumi.getter
    def cron(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron", value)


if not MYPY:
    class WorkersDeploymentAnnotationsArgsDict(TypedDict):
        workers_message: NotRequired[pulumi.Input[str]]
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
elif False:
    WorkersDeploymentAnnotationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentAnnotationsArgs:
    def __init__(__self__, *,
                 workers_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] workers_message: Human-readable message about the deployment. Truncated to 100 bytes.
        """
        if workers_message is not None:
            pulumi.set(__self__, "workers_message", workers_message)

    @property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        return pulumi.get(self, "workers_message")

    @workers_message.setter
    def workers_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workers_message", value)


if not MYPY:
    class WorkersDeploymentDeploymentArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input['WorkersDeploymentDeploymentAnnotationsArgsDict']]
        author_email: NotRequired[pulumi.Input[str]]
        created_on: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        source: NotRequired[pulumi.Input[str]]
        strategy: NotRequired[pulumi.Input[str]]
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkersDeploymentDeploymentVersionArgsDict']]]]
elif False:
    WorkersDeploymentDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentDeploymentArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input['WorkersDeploymentDeploymentAnnotationsArgs']] = None,
                 author_email: Optional[pulumi.Input[str]] = None,
                 created_on: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 strategy: Optional[pulumi.Input[str]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersDeploymentDeploymentVersionArgs']]]] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if author_email is not None:
            pulumi.set(__self__, "author_email", author_email)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input['WorkersDeploymentDeploymentAnnotationsArgs']]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input['WorkersDeploymentDeploymentAnnotationsArgs']]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="authorEmail")
    def author_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "author_email")

    @author_email.setter
    def author_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "author_email", value)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkersDeploymentDeploymentVersionArgs']]]]:
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersDeploymentDeploymentVersionArgs']]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class WorkersDeploymentDeploymentAnnotationsArgsDict(TypedDict):
        workers_message: NotRequired[pulumi.Input[str]]
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
elif False:
    WorkersDeploymentDeploymentAnnotationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentDeploymentAnnotationsArgs:
    def __init__(__self__, *,
                 workers_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] workers_message: Human-readable message about the deployment. Truncated to 100 bytes.
        """
        if workers_message is not None:
            pulumi.set(__self__, "workers_message", workers_message)

    @property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        return pulumi.get(self, "workers_message")

    @workers_message.setter
    def workers_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workers_message", value)


if not MYPY:
    class WorkersDeploymentDeploymentVersionArgsDict(TypedDict):
        percentage: NotRequired[pulumi.Input[float]]
        version_id: NotRequired[pulumi.Input[str]]
elif False:
    WorkersDeploymentDeploymentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentDeploymentVersionArgs:
    def __init__(__self__, *,
                 percentage: Optional[pulumi.Input[float]] = None,
                 version_id: Optional[pulumi.Input[str]] = None):
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class WorkersDeploymentVersionArgsDict(TypedDict):
        percentage: pulumi.Input[float]
        version_id: pulumi.Input[str]
elif False:
    WorkersDeploymentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentVersionArgs:
    def __init__(__self__, *,
                 percentage: pulumi.Input[float],
                 version_id: pulumi.Input[str]):
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[float]:
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[float]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class WorkersRouteErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        message: NotRequired[pulumi.Input[str]]
elif False:
    WorkersRouteErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersRouteErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class WorkersRouteMessageArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        message: NotRequired[pulumi.Input[str]]
elif False:
    WorkersRouteMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersRouteMessageArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class WorkersScriptAssetsArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['WorkersScriptAssetsConfigArgsDict']]
        """
        Configuration for assets within a Worker.
        """
        jwt: NotRequired[pulumi.Input[str]]
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
elif False:
    WorkersScriptAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptAssetsArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['WorkersScriptAssetsConfigArgs']] = None,
                 jwt: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['WorkersScriptAssetsConfigArgs'] config: Configuration for assets within a Worker.
        :param pulumi.Input[str] jwt: Token provided upon successful upload of all files from a registered manifest.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['WorkersScriptAssetsConfigArgs']]:
        """
        Configuration for assets within a Worker.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['WorkersScriptAssetsConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def jwt(self) -> Optional[pulumi.Input[str]]:
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
        return pulumi.get(self, "jwt")

    @jwt.setter
    def jwt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwt", value)


if not MYPY:
    class WorkersScriptAssetsConfigArgsDict(TypedDict):
        html_handling: NotRequired[pulumi.Input[str]]
        """
        Determines the redirects and rewrites of requests for HTML content.
        """
        not_found_handling: NotRequired[pulumi.Input[str]]
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        """
        run_worker_first: NotRequired[pulumi.Input[bool]]
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        serve_directly: NotRequired[pulumi.Input[bool]]
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
elif False:
    WorkersScriptAssetsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptAssetsConfigArgs:
    def __init__(__self__, *,
                 html_handling: Optional[pulumi.Input[str]] = None,
                 not_found_handling: Optional[pulumi.Input[str]] = None,
                 run_worker_first: Optional[pulumi.Input[bool]] = None,
                 serve_directly: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] html_handling: Determines the redirects and rewrites of requests for HTML content.
        :param pulumi.Input[str] not_found_handling: Determines the response when a request does not match a static asset, and there is no Worker script.
        :param pulumi.Input[bool] run_worker_first: When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        :param pulumi.Input[bool] serve_directly: When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        if html_handling is not None:
            pulumi.set(__self__, "html_handling", html_handling)
        if not_found_handling is not None:
            pulumi.set(__self__, "not_found_handling", not_found_handling)
        if run_worker_first is not None:
            pulumi.set(__self__, "run_worker_first", run_worker_first)
        if serve_directly is not None:
            pulumi.set(__self__, "serve_directly", serve_directly)

    @property
    @pulumi.getter(name="htmlHandling")
    def html_handling(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the redirects and rewrites of requests for HTML content.
        """
        return pulumi.get(self, "html_handling")

    @html_handling.setter
    def html_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "html_handling", value)

    @property
    @pulumi.getter(name="notFoundHandling")
    def not_found_handling(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        """
        return pulumi.get(self, "not_found_handling")

    @not_found_handling.setter
    def not_found_handling(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "not_found_handling", value)

    @property
    @pulumi.getter(name="runWorkerFirst")
    def run_worker_first(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        return pulumi.get(self, "run_worker_first")

    @run_worker_first.setter
    def run_worker_first(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_worker_first", value)

    @property
    @pulumi.getter(name="serveDirectly")
    def serve_directly(self) -> Optional[pulumi.Input[bool]]:
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        return pulumi.get(self, "serve_directly")

    @serve_directly.setter
    def serve_directly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serve_directly", value)


if not MYPY:
    class WorkersScriptBindingArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A JavaScript variable name for the binding.
        """
        type: pulumi.Input[str]
        """
        The kind of resource that the binding provides.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        R2 bucket to bind to.
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the certificate to bind to.
        """
        class_name: NotRequired[pulumi.Input[str]]
        """
        The exported class name of the Durable Object.
        """
        dataset: NotRequired[pulumi.Input[str]]
        """
        The dataset name to bind to.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        The environment of the script_name to bind to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the D1 database to bind to.
        """
        index_name: NotRequired[pulumi.Input[str]]
        """
        Name of the Vectorize index to bind to.
        """
        json: NotRequired[pulumi.Input[str]]
        """
        JSON data to use.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace to bind to.
        """
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        Namespace identifier tag.
        """
        outbound: NotRequired[pulumi.Input['WorkersScriptBindingOutboundArgsDict']]
        """
        Outbound worker.
        """
        queue_name: NotRequired[pulumi.Input[str]]
        """
        Name of the Queue to bind to.
        """
        script_name: NotRequired[pulumi.Input[str]]
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Name of Worker to bind to.
        """
        text: NotRequired[pulumi.Input[str]]
        """
        The text value to use.
        """
elif False:
    WorkersScriptBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 class_name: Optional[pulumi.Input[str]] = None,
                 dataset: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 index_name: Optional[pulumi.Input[str]] = None,
                 json: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 namespace_id: Optional[pulumi.Input[str]] = None,
                 outbound: Optional[pulumi.Input['WorkersScriptBindingOutboundArgs']] = None,
                 queue_name: Optional[pulumi.Input[str]] = None,
                 script_name: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: A JavaScript variable name for the binding.
        :param pulumi.Input[str] type: The kind of resource that the binding provides.
        :param pulumi.Input[str] bucket_name: R2 bucket to bind to.
        :param pulumi.Input[str] certificate_id: Identifier of the certificate to bind to.
        :param pulumi.Input[str] class_name: The exported class name of the Durable Object.
        :param pulumi.Input[str] dataset: The dataset name to bind to.
        :param pulumi.Input[str] environment: The environment of the script_name to bind to.
        :param pulumi.Input[str] id: Identifier of the D1 database to bind to.
        :param pulumi.Input[str] index_name: Name of the Vectorize index to bind to.
        :param pulumi.Input[str] json: JSON data to use.
        :param pulumi.Input[str] namespace: Namespace to bind to.
        :param pulumi.Input[str] namespace_id: Namespace identifier tag.
        :param pulumi.Input['WorkersScriptBindingOutboundArgs'] outbound: Outbound worker.
        :param pulumi.Input[str] queue_name: Name of the Queue to bind to.
        :param pulumi.Input[str] script_name: The script where the Durable Object is defined, if it is external to this Worker.
        :param pulumi.Input[str] service: Name of Worker to bind to.
        :param pulumi.Input[str] text: The text value to use.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A JavaScript variable name for the binding.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The kind of resource that the binding provides.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        R2 bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the certificate to bind to.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The exported class name of the Durable Object.
        """
        return pulumi.get(self, "class_name")

    @class_name.setter
    def class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_name", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[str]]:
        """
        The dataset name to bind to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The environment of the script_name to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the D1 database to bind to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Vectorize index to bind to.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[str]]:
        """
        JSON data to use.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace to bind to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace identifier tag.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input['WorkersScriptBindingOutboundArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input['WorkersScriptBindingOutboundArgs']]):
        pulumi.set(self, "outbound", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Queue to bind to.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[pulumi.Input[str]]:
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        return pulumi.get(self, "script_name")

    @script_name.setter
    def script_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_name", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        The text value to use.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class WorkersScriptBindingOutboundArgsDict(TypedDict):
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        worker: NotRequired[pulumi.Input['WorkersScriptBindingOutboundWorkerArgsDict']]
        """
        Outbound worker.
        """
elif False:
    WorkersScriptBindingOutboundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptBindingOutboundArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 worker: Optional[pulumi.Input['WorkersScriptBindingOutboundWorkerArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] params: Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        :param pulumi.Input['WorkersScriptBindingOutboundWorkerArgs'] worker: Outbound worker.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['WorkersScriptBindingOutboundWorkerArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['WorkersScriptBindingOutboundWorkerArgs']]):
        pulumi.set(self, "worker", value)


if not MYPY:
    class WorkersScriptBindingOutboundWorkerArgsDict(TypedDict):
        environment: NotRequired[pulumi.Input[str]]
        """
        Environment of the outbound worker.
        """
        service: NotRequired[pulumi.Input[str]]
        """
        Name of the outbound worker.
        """
elif False:
    WorkersScriptBindingOutboundWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptBindingOutboundWorkerArgs:
    def __init__(__self__, *,
                 environment: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] environment: Environment of the outbound worker.
        :param pulumi.Input[str] service: Name of the outbound worker.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Environment of the outbound worker.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the outbound worker.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class WorkersScriptMigrationsArgsDict(TypedDict):
        deleted_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of classes to delete Durable Object namespaces from.
        """
        new_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of classes to create Durable Object namespaces from.
        """
        new_sqlite_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        new_tag: NotRequired[pulumi.Input[str]]
        """
        Tag to set as the latest migration tag.
        """
        old_tag: NotRequired[pulumi.Input[str]]
        """
        Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        """
        renamed_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsRenamedClassArgsDict']]]]
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepArgsDict']]]]
        """
        Migrations to apply in order.
        """
        transferred_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsTransferredClassArgsDict']]]]
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
elif False:
    WorkersScriptMigrationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptMigrationsArgs:
    def __init__(__self__, *,
                 deleted_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_sqlite_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_tag: Optional[pulumi.Input[str]] = None,
                 old_tag: Optional[pulumi.Input[str]] = None,
                 renamed_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsRenamedClassArgs']]]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepArgs']]]] = None,
                 transferred_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsTransferredClassArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] deleted_classes: A list of classes to delete Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_classes: A list of classes to create Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_sqlite_classes: A list of classes to create Durable Object namespaces with SQLite from.
        :param pulumi.Input[str] new_tag: Tag to set as the latest migration tag.
        :param pulumi.Input[str] old_tag: Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        :param pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsRenamedClassArgs']]] renamed_classes: A list of classes with Durable Object namespaces that were renamed.
        :param pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepArgs']]] steps: Migrations to apply in order.
        :param pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsTransferredClassArgs']]] transferred_classes: A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        if deleted_classes is not None:
            pulumi.set(__self__, "deleted_classes", deleted_classes)
        if new_classes is not None:
            pulumi.set(__self__, "new_classes", new_classes)
        if new_sqlite_classes is not None:
            pulumi.set(__self__, "new_sqlite_classes", new_sqlite_classes)
        if new_tag is not None:
            pulumi.set(__self__, "new_tag", new_tag)
        if old_tag is not None:
            pulumi.set(__self__, "old_tag", old_tag)
        if renamed_classes is not None:
            pulumi.set(__self__, "renamed_classes", renamed_classes)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if transferred_classes is not None:
            pulumi.set(__self__, "transferred_classes", transferred_classes)

    @property
    @pulumi.getter(name="deletedClasses")
    def deleted_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of classes to delete Durable Object namespaces from.
        """
        return pulumi.get(self, "deleted_classes")

    @deleted_classes.setter
    def deleted_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "deleted_classes", value)

    @property
    @pulumi.getter(name="newClasses")
    def new_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of classes to create Durable Object namespaces from.
        """
        return pulumi.get(self, "new_classes")

    @new_classes.setter
    def new_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_classes", value)

    @property
    @pulumi.getter(name="newSqliteClasses")
    def new_sqlite_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        return pulumi.get(self, "new_sqlite_classes")

    @new_sqlite_classes.setter
    def new_sqlite_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_sqlite_classes", value)

    @property
    @pulumi.getter(name="newTag")
    def new_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Tag to set as the latest migration tag.
        """
        return pulumi.get(self, "new_tag")

    @new_tag.setter
    def new_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_tag", value)

    @property
    @pulumi.getter(name="oldTag")
    def old_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        """
        return pulumi.get(self, "old_tag")

    @old_tag.setter
    def old_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "old_tag", value)

    @property
    @pulumi.getter(name="renamedClasses")
    def renamed_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsRenamedClassArgs']]]]:
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        return pulumi.get(self, "renamed_classes")

    @renamed_classes.setter
    def renamed_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsRenamedClassArgs']]]]):
        pulumi.set(self, "renamed_classes", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepArgs']]]]:
        """
        Migrations to apply in order.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepArgs']]]]):
        pulumi.set(self, "steps", value)

    @property
    @pulumi.getter(name="transferredClasses")
    def transferred_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsTransferredClassArgs']]]]:
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        return pulumi.get(self, "transferred_classes")

    @transferred_classes.setter
    def transferred_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsTransferredClassArgs']]]]):
        pulumi.set(self, "transferred_classes", value)


if not MYPY:
    class WorkersScriptMigrationsRenamedClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[str]]
        to: NotRequired[pulumi.Input[str]]
elif False:
    WorkersScriptMigrationsRenamedClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptMigrationsRenamedClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkersScriptMigrationsStepArgsDict(TypedDict):
        deleted_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of classes to delete Durable Object namespaces from.
        """
        new_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of classes to create Durable Object namespaces from.
        """
        new_sqlite_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        renamed_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepRenamedClassArgsDict']]]]
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        transferred_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepTransferredClassArgsDict']]]]
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
elif False:
    WorkersScriptMigrationsStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptMigrationsStepArgs:
    def __init__(__self__, *,
                 deleted_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new_sqlite_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 renamed_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepRenamedClassArgs']]]] = None,
                 transferred_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepTransferredClassArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] deleted_classes: A list of classes to delete Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_classes: A list of classes to create Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new_sqlite_classes: A list of classes to create Durable Object namespaces with SQLite from.
        :param pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepRenamedClassArgs']]] renamed_classes: A list of classes with Durable Object namespaces that were renamed.
        :param pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepTransferredClassArgs']]] transferred_classes: A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        if deleted_classes is not None:
            pulumi.set(__self__, "deleted_classes", deleted_classes)
        if new_classes is not None:
            pulumi.set(__self__, "new_classes", new_classes)
        if new_sqlite_classes is not None:
            pulumi.set(__self__, "new_sqlite_classes", new_sqlite_classes)
        if renamed_classes is not None:
            pulumi.set(__self__, "renamed_classes", renamed_classes)
        if transferred_classes is not None:
            pulumi.set(__self__, "transferred_classes", transferred_classes)

    @property
    @pulumi.getter(name="deletedClasses")
    def deleted_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of classes to delete Durable Object namespaces from.
        """
        return pulumi.get(self, "deleted_classes")

    @deleted_classes.setter
    def deleted_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "deleted_classes", value)

    @property
    @pulumi.getter(name="newClasses")
    def new_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of classes to create Durable Object namespaces from.
        """
        return pulumi.get(self, "new_classes")

    @new_classes.setter
    def new_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_classes", value)

    @property
    @pulumi.getter(name="newSqliteClasses")
    def new_sqlite_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        return pulumi.get(self, "new_sqlite_classes")

    @new_sqlite_classes.setter
    def new_sqlite_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new_sqlite_classes", value)

    @property
    @pulumi.getter(name="renamedClasses")
    def renamed_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepRenamedClassArgs']]]]:
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        return pulumi.get(self, "renamed_classes")

    @renamed_classes.setter
    def renamed_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepRenamedClassArgs']]]]):
        pulumi.set(self, "renamed_classes", value)

    @property
    @pulumi.getter(name="transferredClasses")
    def transferred_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepTransferredClassArgs']]]]:
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        return pulumi.get(self, "transferred_classes")

    @transferred_classes.setter
    def transferred_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkersScriptMigrationsStepTransferredClassArgs']]]]):
        pulumi.set(self, "transferred_classes", value)


if not MYPY:
    class WorkersScriptMigrationsStepRenamedClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[str]]
        to: NotRequired[pulumi.Input[str]]
elif False:
    WorkersScriptMigrationsStepRenamedClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptMigrationsStepRenamedClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkersScriptMigrationsStepTransferredClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[str]]
        from_script: NotRequired[pulumi.Input[str]]
        to: NotRequired[pulumi.Input[str]]
elif False:
    WorkersScriptMigrationsStepTransferredClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptMigrationsStepTransferredClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 from_script: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if from_script is not None:
            pulumi.set(__self__, "from_script", from_script)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="fromScript")
    def from_script(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_script")

    @from_script.setter
    def from_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_script", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkersScriptMigrationsTransferredClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[str]]
        from_script: NotRequired[pulumi.Input[str]]
        to: NotRequired[pulumi.Input[str]]
elif False:
    WorkersScriptMigrationsTransferredClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptMigrationsTransferredClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[str]] = None,
                 from_script: Optional[pulumi.Input[str]] = None,
                 to: Optional[pulumi.Input[str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if from_script is not None:
            pulumi.set(__self__, "from_script", from_script)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="fromScript")
    def from_script(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "from_script")

    @from_script.setter
    def from_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_script", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkersScriptObservabilityArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether observability is enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[float]]
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
elif False:
    WorkersScriptObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptObservabilityArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 head_sampling_rate: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether observability is enabled for the Worker.
        :param pulumi.Input[float] head_sampling_rate: The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        pulumi.set(__self__, "enabled", enabled)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether observability is enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[float]]:
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "head_sampling_rate", value)


if not MYPY:
    class WorkersScriptPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
elif False:
    WorkersScriptPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param pulumi.Input[str] status: Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class WorkersScriptTailConsumerArgsDict(TypedDict):
        service: pulumi.Input[str]
        """
        Name of Worker that is to be the consumer.
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        Optional environment if the Worker utilizes one.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Optional dispatch namespace the script belongs to.
        """
elif False:
    WorkersScriptTailConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptTailConsumerArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Name of Worker that is to be the consumer.
        :param pulumi.Input[str] environment: Optional environment if the Worker utilizes one.
        :param pulumi.Input[str] namespace: Optional dispatch namespace the script belongs to.
        """
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Name of Worker that is to be the consumer.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Optional environment if the Worker utilizes one.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Optional dispatch namespace the script belongs to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ZeroTrustAccessApplicationCorsHeadersArgsDict(TypedDict):
        allow_all_headers: NotRequired[pulumi.Input[bool]]
        """
        Allows all HTTP request headers.
        """
        allow_all_methods: NotRequired[pulumi.Input[bool]]
        """
        Allows all HTTP request methods.
        """
        allow_all_origins: NotRequired[pulumi.Input[bool]]
        """
        Allows all origins.
        """
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed HTTP request headers.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed HTTP request methods.
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed origins.
        """
        max_age: NotRequired[pulumi.Input[float]]
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
elif False:
    ZeroTrustAccessApplicationCorsHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationCorsHeadersArgs:
    def __init__(__self__, *,
                 allow_all_headers: Optional[pulumi.Input[bool]] = None,
                 allow_all_methods: Optional[pulumi.Input[bool]] = None,
                 allow_all_origins: Optional[pulumi.Input[bool]] = None,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] allow_all_headers: Allows all HTTP request headers.
        :param pulumi.Input[bool] allow_all_methods: Allows all HTTP request methods.
        :param pulumi.Input[bool] allow_all_origins: Allows all origins.
        :param pulumi.Input[bool] allow_credentials: When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Allowed HTTP request headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: Allowed HTTP request methods.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Allowed origins.
        :param pulumi.Input[float] max_age: The maximum number of seconds the results of a preflight request can be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows all HTTP request headers.
        """
        return pulumi.get(self, "allow_all_headers")

    @allow_all_headers.setter
    def allow_all_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_headers", value)

    @property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows all HTTP request methods.
        """
        return pulumi.get(self, "allow_all_methods")

    @allow_all_methods.setter
    def allow_all_methods(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_methods", value)

    @property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows all origins.
        """
        return pulumi.get(self, "allow_all_origins")

    @allow_all_origins.setter
    def allow_all_origins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_all_origins", value)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed HTTP request headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed HTTP request methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed origins.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class ZeroTrustAccessApplicationDestinationArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        l4_protocol: NotRequired[pulumi.Input[str]]
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        """
        port_range: NotRequired[pulumi.Input[str]]
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        type: NotRequired[pulumi.Input[str]]
        uri: NotRequired[pulumi.Input[str]]
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
elif False:
    ZeroTrustAccessApplicationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationDestinationArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 l4_protocol: Optional[pulumi.Input[str]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr: The CIDR range of the destination. Single IPs will be computed as /32.
        :param pulumi.Input[str] hostname: The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        :param pulumi.Input[str] l4_protocol: The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        :param pulumi.Input[str] port_range: The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        :param pulumi.Input[str] uri: The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        :param pulumi.Input[str] vnet_id: The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if l4_protocol is not None:
            pulumi.set(__self__, "l4_protocol", l4_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        """
        return pulumi.get(self, "l4_protocol")

    @l4_protocol.setter
    def l4_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l4_protocol", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationFooterLinkArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The hypertext in the footer link.
        """
        url: pulumi.Input[str]
        """
        the hyperlink in the footer link.
        """
elif False:
    ZeroTrustAccessApplicationFooterLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationFooterLinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The hypertext in the footer link.
        :param pulumi.Input[str] url: the hyperlink in the footer link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The hypertext in the footer link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        the hyperlink in the footer link.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ZeroTrustAccessApplicationLandingPageDesignArgsDict(TypedDict):
        button_color: NotRequired[pulumi.Input[str]]
        """
        The background color of the log in button on the landing page.
        """
        button_text_color: NotRequired[pulumi.Input[str]]
        """
        The color of the text in the log in button on the landing page.
        """
        image_url: NotRequired[pulumi.Input[str]]
        """
        The URL of the image shown on the landing page.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The message shown on the landing page.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title shown on the landing page.
        """
elif False:
    ZeroTrustAccessApplicationLandingPageDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationLandingPageDesignArgs:
    def __init__(__self__, *,
                 button_color: Optional[pulumi.Input[str]] = None,
                 button_text_color: Optional[pulumi.Input[str]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] button_color: The background color of the log in button on the landing page.
        :param pulumi.Input[str] button_text_color: The color of the text in the log in button on the landing page.
        :param pulumi.Input[str] image_url: The URL of the image shown on the landing page.
        :param pulumi.Input[str] message: The message shown on the landing page.
        :param pulumi.Input[str] title: The title shown on the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color of the log in button on the landing page.
        """
        return pulumi.get(self, "button_color")

    @button_color.setter
    def button_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_color", value)

    @property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the log in button on the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @button_text_color.setter
    def button_text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "button_text_color", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the image shown on the landing page.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The message shown on the landing page.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title shown on the landing page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyArgsDict(TypedDict):
        connection_rules: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict']]
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        decision: NotRequired[pulumi.Input[str]]
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgsDict']]]]
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The UUID of the policy
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgsDict']]]]
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Access policy.
        """
        precedence: NotRequired[pulumi.Input[int]]
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        requires: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgsDict']]]]
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
elif False:
    ZeroTrustAccessApplicationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyArgs:
    def __init__(__self__, *,
                 connection_rules: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs']] = None,
                 decision: Optional[pulumi.Input[str]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 precedence: Optional[pulumi.Input[int]] = None,
                 requires: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]]] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs'] connection_rules: The rules that define how users may connect to the targets secured by your application.
        :param pulumi.Input[str] decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param pulumi.Input[str] id: The UUID of the policy
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param pulumi.Input[str] name: The name of the Access policy.
        :param pulumi.Input[int] precedence: The order of execution for this policy. Must be unique for each policy within an app.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        if connection_rules is not None:
            pulumi.set(__self__, "connection_rules", connection_rules)
        if decision is not None:
            pulumi.set(__self__, "decision", decision)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if requires is not None:
            pulumi.set(__self__, "requires", requires)

    @property
    @pulumi.getter(name="connectionRules")
    def connection_rules(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs']]:
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "connection_rules")

    @connection_rules.setter
    def connection_rules(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs']]):
        pulumi.set(self, "connection_rules", value)

    @property
    @pulumi.getter
    def decision(self) -> Optional[pulumi.Input[str]]:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        """
        return pulumi.get(self, "decision")

    @decision.setter
    def decision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]]]:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]]]:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]]]):
        pulumi.set(self, "includes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def precedence(self) -> Optional[pulumi.Input[int]]:
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precedence", value)

    @property
    @pulumi.getter
    def requires(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]]]:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @requires.setter
    def requires(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]]]):
        pulumi.set(self, "requires", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict(TypedDict):
        ssh: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict']]
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
elif False:
    ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyConnectionRulesArgs:
    def __init__(__self__, *,
                 ssh: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs'] ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs']]:
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict(TypedDict):
        usernames: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        allow_email_alias: NotRequired[pulumi.Input[bool]]
        """
        Enables using Identity Provider email alias as SSH username.
        """
elif False:
    ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs:
    def __init__(__self__, *,
                 usernames: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allow_email_alias: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param pulumi.Input[bool] allow_email_alias: Enables using Identity Provider email alias as SSH username.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @property
    @pulumi.getter
    def usernames(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "usernames", value)

    @property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables using Identity Provider email alias as SSH username.
        """
        return pulumi.get(self, "allow_email_alias")

    @allow_email_alias.setter
    def allow_email_alias(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_email_alias", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessApplicationPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessApplicationPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessApplicationPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppArgsDict(TypedDict):
        access_token_lifetime: NotRequired[pulumi.Input[str]]
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        allow_pkce_without_client_secret: NotRequired[pulumi.Input[bool]]
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        app_launcher_url: NotRequired[pulumi.Input[str]]
        """
        The URL where this applications tile redirects users
        """
        auth_type: NotRequired[pulumi.Input[str]]
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The application client id
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The application client secret, only returned on POST request.
        """
        consumer_service_url: NotRequired[pulumi.Input[str]]
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        created_at: NotRequired[pulumi.Input[str]]
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict']]]]
        custom_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict']]]]
        default_relay_state: NotRequired[pulumi.Input[str]]
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The OIDC flows supported by this application
        """
        group_filter_regex: NotRequired[pulumi.Input[str]]
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        hybrid_and_implicit_options: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict']]
        idp_entity_id: NotRequired[pulumi.Input[str]]
        """
        The unique identifier for your SaaS application.
        """
        name_id_format: NotRequired[pulumi.Input[str]]
        """
        The format of the name identifier sent to the SaaS application.
        """
        name_id_transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        public_key: NotRequired[pulumi.Input[str]]
        """
        The Access public certificate that will be used to verify your identity.
        """
        redirect_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        refresh_token_options: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict']]
        saml_attribute_transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        sp_entity_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique name for an identity or service provider.
        """
        sso_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint where your SaaS application will send login requests.
        """
        updated_at: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustAccessApplicationSaasAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppArgs:
    def __init__(__self__, *,
                 access_token_lifetime: Optional[pulumi.Input[str]] = None,
                 allow_pkce_without_client_secret: Optional[pulumi.Input[bool]] = None,
                 app_launcher_url: Optional[pulumi.Input[str]] = None,
                 auth_type: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 consumer_service_url: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]] = None,
                 custom_claims: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[str]] = None,
                 grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_filter_regex: Optional[pulumi.Input[str]] = None,
                 hybrid_and_implicit_options: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']] = None,
                 idp_entity_id: Optional[pulumi.Input[str]] = None,
                 name_id_format: Optional[pulumi.Input[str]] = None,
                 name_id_transform_jsonata: Optional[pulumi.Input[str]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 refresh_token_options: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs']] = None,
                 saml_attribute_transform_jsonata: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sp_entity_id: Optional[pulumi.Input[str]] = None,
                 sso_endpoint: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token_lifetime: The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        :param pulumi.Input[bool] allow_pkce_without_client_secret: If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        :param pulumi.Input[str] app_launcher_url: The URL where this applications tile redirects users
        :param pulumi.Input[str] auth_type: Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        :param pulumi.Input[str] client_id: The application client id
        :param pulumi.Input[str] client_secret: The application client secret, only returned on POST request.
        :param pulumi.Input[str] consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param pulumi.Input[str] default_relay_state: The URL that the user will be redirected to after a successful login for IDP initiated logins.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] grant_types: The OIDC flows supported by this application
        :param pulumi.Input[str] group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        :param pulumi.Input[str] idp_entity_id: The unique identifier for your SaaS application.
        :param pulumi.Input[str] name_id_format: The format of the name identifier sent to the SaaS application.
        :param pulumi.Input[str] name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param pulumi.Input[str] public_key: The Access public certificate that will be used to verify your identity.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        :param pulumi.Input[str] saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        :param pulumi.Input[str] sp_entity_id: A globally unique name for an identity or service provider.
        :param pulumi.Input[str] sso_endpoint: The endpoint where your SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @access_token_lifetime.setter
    def access_token_lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_lifetime", value)

    @property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @allow_pkce_without_client_secret.setter
    def allow_pkce_without_client_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_pkce_without_client_secret", value)

    @property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL where this applications tile redirects users
        """
        return pulumi.get(self, "app_launcher_url")

    @app_launcher_url.setter
    def app_launcher_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_launcher_url", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[str]]:
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The application client id
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The application client secret, only returned on POST request.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[pulumi.Input[str]]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @consumer_service_url.setter
    def consumer_service_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_service_url", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]]:
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]]:
        return pulumi.get(self, "custom_claims")

    @custom_claims.setter
    def custom_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]]):
        pulumi.set(self, "custom_claims", value)

    @property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[str]]:
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_relay_state", value)

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OIDC flows supported by this application
        """
        return pulumi.get(self, "grant_types")

    @grant_types.setter
    def grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grant_types", value)

    @property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[pulumi.Input[str]]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        return pulumi.get(self, "group_filter_regex")

    @group_filter_regex.setter
    def group_filter_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_filter_regex", value)

    @property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']]:
        return pulumi.get(self, "hybrid_and_implicit_options")

    @hybrid_and_implicit_options.setter
    def hybrid_and_implicit_options(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']]):
        pulumi.set(self, "hybrid_and_implicit_options", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for your SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the name identifier sent to the SaaS application.
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_format", value)

    @property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @name_id_transform_jsonata.setter
    def name_id_transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_transform_jsonata", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Access public certificate that will be used to verify your identity.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "redirect_uris", value)

    @property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs']]:
        return pulumi.get(self, "refresh_token_options")

    @refresh_token_options.setter
    def refresh_token_options(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs']]):
        pulumi.set(self, "refresh_token_options", value)

    @property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @saml_attribute_transform_jsonata.setter
    def saml_attribute_transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_attribute_transform_jsonata", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint where your SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @sso_endpoint.setter
    def sso_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_endpoint", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict(TypedDict):
        friendly_name: NotRequired[pulumi.Input[str]]
        """
        The SAML FriendlyName of the attribute.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the attribute.
        """
        name_format: NotRequired[pulumi.Input[str]]
        """
        A globally unique name for an identity or service provider.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        If the attribute is required when building a SAML assertion.
        """
        source: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict']]
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeArgs:
    def __init__(__self__, *,
                 friendly_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_format: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']] = None):
        """
        :param pulumi.Input[str] friendly_name: The SAML FriendlyName of the attribute.
        :param pulumi.Input[str] name: The name of the attribute.
        :param pulumi.Input[str] name_format: A globally unique name for an identity or service provider.
        :param pulumi.Input[bool] required: If the attribute is required when building a SAML assertion.
        """
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[str]]:
        """
        The SAML FriendlyName of the attribute.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "name_format")

    @name_format.setter
    def name_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_format", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        If the attribute is required when building a SAML assertion.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the IdP attribute.
        """
        name_by_idps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict']]]]
        """
        A mapping from IdP ID to attribute name.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 name_by_idps: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the IdP attribute.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]] name_by_idps: A mapping from IdP ID to attribute name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idps is not None:
            pulumi.set(__self__, "name_by_idps", name_by_idps)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the IdP attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameByIdps")
    def name_by_idps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]]:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idps")

    @name_by_idps.setter
    def name_by_idps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]]):
        pulumi.set(self, "name_by_idps", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict(TypedDict):
        idp_id: NotRequired[pulumi.Input[str]]
        """
        The UID of the IdP.
        """
        source_name: NotRequired[pulumi.Input[str]]
        """
        The name of the IdP provided attribute.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs:
    def __init__(__self__, *,
                 idp_id: Optional[pulumi.Input[str]] = None,
                 source_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] idp_id: The UID of the IdP.
        :param pulumi.Input[str] source_name: The name of the IdP provided attribute.
        """
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UID of the IdP.
        """
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_id", value)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the IdP provided attribute.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the claim.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        If the claim is required when building an OIDC token.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The scope of the claim.
        """
        source: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict']]
elif False:
    ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomClaimArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name of the claim.
        :param pulumi.Input[bool] required: If the claim is required when building an OIDC token.
        :param pulumi.Input[str] scope: The scope of the claim.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        If the claim is required when building an OIDC token.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope of the claim.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the IdP claim.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the IdP claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the IdP claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict(TypedDict):
        return_access_token_from_authorization_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return_id_token_from_authorization_endpoint: NotRequired[pulumi.Input[bool]]
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
elif False:
    ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs:
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[pulumi.Input[bool]] = None,
                 return_id_token_from_authorization_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] return_access_token_from_authorization_endpoint: If an Access Token should be returned from the OIDC Authorization endpoint
        :param pulumi.Input[bool] return_id_token_from_authorization_endpoint: If an ID Token should be returned from the OIDC Authorization endpoint
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @return_access_token_from_authorization_endpoint.setter
    def return_access_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_access_token_from_authorization_endpoint", value)

    @property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")

    @return_id_token_from_authorization_endpoint.setter
    def return_id_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "return_id_token_from_authorization_endpoint", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict(TypedDict):
        lifetime: NotRequired[pulumi.Input[str]]
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs:
    def __init__(__self__, *,
                 lifetime: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lifetime: How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[str]]:
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifetime", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigArgsDict(TypedDict):
        idp_uid: pulumi.Input[str]
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        remote_uri: pulumi.Input[str]
        """
        The base URI for the application's SCIM-compatible API.
        """
        authentication: NotRequired[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict']]
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        deactivate_on_delete: NotRequired[pulumi.Input[bool]]
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether SCIM provisioning is turned on for this application.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgsDict']]]]
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigArgs:
    def __init__(__self__, *,
                 idp_uid: pulumi.Input[str],
                 remote_uri: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']] = None,
                 deactivate_on_delete: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] idp_uid: The UID of the IdP to use as the source for SCIM resources to provision to this application.
        :param pulumi.Input[str] remote_uri: The base URI for the application's SCIM-compatible API.
        :param pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs'] authentication: Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        :param pulumi.Input[bool] deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param pulumi.Input[bool] enabled: Whether SCIM provisioning is turned on for this application.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> pulumi.Input[str]:
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @idp_uid.setter
    def idp_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_uid", value)

    @property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> pulumi.Input[str]:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @remote_uri.setter
    def remote_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_uri", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']]:
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @deactivate_on_delete.setter
    def deactivate_on_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deactivate_on_delete", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict(TypedDict):
        scheme: pulumi.Input[str]
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        authorization_url: NotRequired[pulumi.Input[str]]
        """
        URL used to generate the auth code used during token generation.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password used to authenticate with the remote SCIM service.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Token used to authenticate with the remote SCIM service.
        """
        token_url: NotRequired[pulumi.Input[str]]
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        User name used to authenticate with the remote SCIM service.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigAuthenticationArgs:
    def __init__(__self__, *,
                 scheme: pulumi.Input[str],
                 authorization_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 token_url: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scheme: The authentication scheme to use when making SCIM requests to this application.
        :param pulumi.Input[str] authorization_url: URL used to generate the auth code used during token generation.
        :param pulumi.Input[str] client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param pulumi.Input[str] client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param pulumi.Input[str] password: Password used to authenticate with the remote SCIM service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param pulumi.Input[str] token: Token used to authenticate with the remote SCIM service.
        :param pulumi.Input[str] token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param pulumi.Input[str] user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        The authentication scheme to use when making SCIM requests to this application.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @authorization_url.setter
    def authorization_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigMappingArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Which SCIM resource type this mapping applies to.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping is enabled.
        """
        filter: NotRequired[pulumi.Input[str]]
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        operations: NotRequired[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict']]
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        strictness: NotRequired[pulumi.Input[str]]
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        """
        transform_jsonata: NotRequired[pulumi.Input[str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigMappingArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 operations: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']] = None,
                 strictness: Optional[pulumi.Input[str]] = None,
                 transform_jsonata: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] schema: Which SCIM resource type this mapping applies to.
        :param pulumi.Input[bool] enabled: Whether or not this mapping is enabled.
        :param pulumi.Input[str] filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs'] operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param pulumi.Input[str] strictness: The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        :param pulumi.Input[str] transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']]:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def strictness(self) -> Optional[pulumi.Input[str]]:
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        """
        return pulumi.get(self, "strictness")

    @strictness.setter
    def strictness(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strictness", value)

    @property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[pulumi.Input[str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")

    @transform_jsonata.setter
    def transform_jsonata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transform_jsonata", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        delete: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to DELETE operations.
        """
        update: NotRequired[pulumi.Input[bool]]
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigMappingOperationsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 update: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] create: Whether or not this mapping applies to create (POST) operations.
        :param pulumi.Input[bool] delete: Whether or not this mapping applies to DELETE operations.
        :param pulumi.Input[bool] update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ZeroTrustAccessApplicationTargetCriteriaArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        protocol: pulumi.Input[str]
        """
        The communication protocol your application secures.
        """
        target_attributes: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]
        """
        Contains a map of target attribute keys to target attribute values.
        """
elif False:
    ZeroTrustAccessApplicationTargetCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationTargetCriteriaArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 target_attributes: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]):
        """
        :param pulumi.Input[int] port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param pulumi.Input[str] protocol: The communication protocol your application secures.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The communication protocol your application secures.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]):
        pulumi.set(self, "target_attributes", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessGroupExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessGroupExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessGroupExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessGroupExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessGroupExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessGroupExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessGroupExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessGroupExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessGroupExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessGroupExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessGroupExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessGroupExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessGroupExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessGroupIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessGroupIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessGroupIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessGroupIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessGroupIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessGroupIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessGroupIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessGroupIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessGroupIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessGroupIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessGroupIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessGroupIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessGroupIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessGroupRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessGroupRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessGroupRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessGroupRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessGroupRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessGroupRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessGroupRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessGroupRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessGroupRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessGroupRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessGroupRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessGroupRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessGroupRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessGroupRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderConfigArgsDict(TypedDict):
        apps_domain: NotRequired[pulumi.Input[str]]
        """
        Your companies TLD
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        auth_url: NotRequired[pulumi.Input[str]]
        """
        The authorization_endpoint URL of your IdP
        """
        authorization_server_id: NotRequired[pulumi.Input[str]]
        """
        Your okta authorization server id
        """
        centrify_account: NotRequired[pulumi.Input[str]]
        """
        Your centrify account url
        """
        centrify_app_id: NotRequired[pulumi.Input[str]]
        """
        Your centrify app id
        """
        certs_url: NotRequired[pulumi.Input[str]]
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Custom claims
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Your OAuth Client ID
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Your OAuth Client Secret
        """
        conditional_access_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        directory_id: NotRequired[pulumi.Input[str]]
        """
        Your Azure directory uuid
        """
        email_attribute_name: NotRequired[pulumi.Input[str]]
        """
        The attribute name for email in the SAML response.
        """
        email_claim_name: NotRequired[pulumi.Input[str]]
        """
        The claim name for email in the id_token response.
        """
        header_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict']]]]
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        idp_public_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        issuer_url: NotRequired[pulumi.Input[str]]
        """
        IdP Entity ID or Issuer URL
        """
        okta_account: NotRequired[pulumi.Input[str]]
        """
        Your okta account url
        """
        onelogin_account: NotRequired[pulumi.Input[str]]
        """
        Your OneLogin account url
        """
        ping_env_id: NotRequired[pulumi.Input[str]]
        """
        Your PingOne environment identifier
        """
        pkce_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        prompt: NotRequired[pulumi.Input[str]]
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        """
        redirect_url: NotRequired[pulumi.Input[str]]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        OAuth scopes
        """
        sign_request: NotRequired[pulumi.Input[bool]]
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        sso_target_url: NotRequired[pulumi.Input[str]]
        """
        URL to send the SAML authentication requests to
        """
        support_groups: NotRequired[pulumi.Input[bool]]
        """
        Should Cloudflare try to load groups from your account
        """
        token_url: NotRequired[pulumi.Input[str]]
        """
        The token_endpoint URL of your IdP
        """
elif False:
    ZeroTrustAccessIdentityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderConfigArgs:
    def __init__(__self__, *,
                 apps_domain: Optional[pulumi.Input[str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 authorization_server_id: Optional[pulumi.Input[str]] = None,
                 centrify_account: Optional[pulumi.Input[str]] = None,
                 centrify_app_id: Optional[pulumi.Input[str]] = None,
                 certs_url: Optional[pulumi.Input[str]] = None,
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 conditional_access_enabled: Optional[pulumi.Input[bool]] = None,
                 directory_id: Optional[pulumi.Input[str]] = None,
                 email_attribute_name: Optional[pulumi.Input[str]] = None,
                 email_claim_name: Optional[pulumi.Input[str]] = None,
                 header_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]]] = None,
                 idp_public_certs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 issuer_url: Optional[pulumi.Input[str]] = None,
                 okta_account: Optional[pulumi.Input[str]] = None,
                 onelogin_account: Optional[pulumi.Input[str]] = None,
                 ping_env_id: Optional[pulumi.Input[str]] = None,
                 pkce_enabled: Optional[pulumi.Input[bool]] = None,
                 prompt: Optional[pulumi.Input[str]] = None,
                 redirect_url: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sign_request: Optional[pulumi.Input[bool]] = None,
                 sso_target_url: Optional[pulumi.Input[str]] = None,
                 support_groups: Optional[pulumi.Input[bool]] = None,
                 token_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apps_domain: Your companies TLD
        :param pulumi.Input[Sequence[pulumi.Input[str]]] attributes: A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        :param pulumi.Input[str] auth_url: The authorization_endpoint URL of your IdP
        :param pulumi.Input[str] authorization_server_id: Your okta authorization server id
        :param pulumi.Input[str] centrify_account: Your centrify account url
        :param pulumi.Input[str] centrify_app_id: Your centrify app id
        :param pulumi.Input[str] certs_url: The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        :param pulumi.Input[Sequence[pulumi.Input[str]]] claims: Custom claims
        :param pulumi.Input[str] client_id: Your OAuth Client ID
        :param pulumi.Input[str] client_secret: Your OAuth Client Secret
        :param pulumi.Input[bool] conditional_access_enabled: Should Cloudflare try to load authentication contexts from your account
        :param pulumi.Input[str] directory_id: Your Azure directory uuid
        :param pulumi.Input[str] email_attribute_name: The attribute name for email in the SAML response.
        :param pulumi.Input[str] email_claim_name: The claim name for email in the id_token response.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]] header_attributes: Add a list of attribute names that will be returned in the response header from the Access callback.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] idp_public_certs: X509 certificate to verify the signature in the SAML authentication response
        :param pulumi.Input[str] issuer_url: IdP Entity ID or Issuer URL
        :param pulumi.Input[str] okta_account: Your okta account url
        :param pulumi.Input[str] onelogin_account: Your OneLogin account url
        :param pulumi.Input[str] ping_env_id: Your PingOne environment identifier
        :param pulumi.Input[bool] pkce_enabled: Enable Proof Key for Code Exchange (PKCE)
        :param pulumi.Input[str] prompt: Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: OAuth scopes
        :param pulumi.Input[bool] sign_request: Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        :param pulumi.Input[str] sso_target_url: URL to send the SAML authentication requests to
        :param pulumi.Input[bool] support_groups: Should Cloudflare try to load groups from your account
        :param pulumi.Input[str] token_url: The token_endpoint URL of your IdP
        """
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if header_attributes is not None:
            pulumi.set(__self__, "header_attributes", header_attributes)
        if idp_public_certs is not None:
            pulumi.set(__self__, "idp_public_certs", idp_public_certs)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Your companies TLD
        """
        return pulumi.get(self, "apps_domain")

    @apps_domain.setter
    def apps_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apps_domain", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The authorization_endpoint URL of your IdP
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[str]]:
        """
        Your okta authorization server id
        """
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_server_id", value)

    @property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[pulumi.Input[str]]:
        """
        Your centrify account url
        """
        return pulumi.get(self, "centrify_account")

    @centrify_account.setter
    def centrify_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_account", value)

    @property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[pulumi.Input[str]]:
        """
        Your centrify app id
        """
        return pulumi.get(self, "centrify_app_id")

    @centrify_app_id.setter
    def centrify_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "centrify_app_id", value)

    @property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[pulumi.Input[str]]:
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        return pulumi.get(self, "certs_url")

    @certs_url.setter
    def certs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certs_url", value)

    @property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Custom claims
        """
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "claims", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Your OAuth Client ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Your OAuth Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        return pulumi.get(self, "conditional_access_enabled")

    @conditional_access_enabled.setter
    def conditional_access_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditional_access_enabled", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[str]]:
        """
        Your Azure directory uuid
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_id", value)

    @property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The attribute name for email in the SAML response.
        """
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_attribute_name", value)

    @property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[pulumi.Input[str]]:
        """
        The claim name for email in the id_token response.
        """
        return pulumi.get(self, "email_claim_name")

    @email_claim_name.setter
    def email_claim_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_claim_name", value)

    @property
    @pulumi.getter(name="headerAttributes")
    def header_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]]]:
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        return pulumi.get(self, "header_attributes")

    @header_attributes.setter
    def header_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]]]):
        pulumi.set(self, "header_attributes", value)

    @property
    @pulumi.getter(name="idpPublicCerts")
    def idp_public_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        return pulumi.get(self, "idp_public_certs")

    @idp_public_certs.setter
    def idp_public_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "idp_public_certs", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[pulumi.Input[str]]:
        """
        IdP Entity ID or Issuer URL
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[pulumi.Input[str]]:
        """
        Your okta account url
        """
        return pulumi.get(self, "okta_account")

    @okta_account.setter
    def okta_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "okta_account", value)

    @property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[pulumi.Input[str]]:
        """
        Your OneLogin account url
        """
        return pulumi.get(self, "onelogin_account")

    @onelogin_account.setter
    def onelogin_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "onelogin_account", value)

    @property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[pulumi.Input[str]]:
        """
        Your PingOne environment identifier
        """
        return pulumi.get(self, "ping_env_id")

    @ping_env_id.setter
    def ping_env_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ping_env_id", value)

    @property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prompt", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)

    @property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to send the SAML authentication requests to
        """
        return pulumi.get(self, "sso_target_url")

    @sso_target_url.setter
    def sso_target_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_target_url", value)

    @property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Should Cloudflare try to load groups from your account
        """
        return pulumi.get(self, "support_groups")

    @support_groups.setter
    def support_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_groups", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[str]]:
        """
        The token_endpoint URL of your IdP
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[str]]
        """
        attribute name from the IDP
        """
        header_name: NotRequired[pulumi.Input[str]]
        """
        header that will be added on the request to the origin
        """
elif False:
    ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[str]] = None,
                 header_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: attribute name from the IDP
        :param pulumi.Input[str] header_name: header that will be added on the request to the origin
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        attribute name from the IDP
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[str]]:
        """
        header that will be added on the request to the origin
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderScimConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        identity_update_behavior: NotRequired[pulumi.Input[str]]
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        scim_base_url: NotRequired[pulumi.Input[str]]
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        seat_deprovision: NotRequired[pulumi.Input[bool]]
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        user_deprovision: NotRequired[pulumi.Input[bool]]
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
elif False:
    ZeroTrustAccessIdentityProviderScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderScimConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 identity_update_behavior: Optional[pulumi.Input[str]] = None,
                 scim_base_url: Optional[pulumi.Input[str]] = None,
                 seat_deprovision: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 user_deprovision: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: A flag to enable or disable SCIM for the identity provider.
        :param pulumi.Input[str] identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        :param pulumi.Input[str] scim_base_url: The base URL of Cloudflare's SCIM V2.0 API endpoint.
        :param pulumi.Input[bool] seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param pulumi.Input[str] secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        :param pulumi.Input[bool] user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if scim_base_url is not None:
            pulumi.set(__self__, "scim_base_url", scim_base_url)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        """
        return pulumi.get(self, "identity_update_behavior")

    @identity_update_behavior.setter
    def identity_update_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_update_behavior", value)

    @property
    @pulumi.getter(name="scimBaseUrl")
    def scim_base_url(self) -> Optional[pulumi.Input[str]]:
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        return pulumi.get(self, "scim_base_url")

    @scim_base_url.setter
    def scim_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scim_base_url", value)

    @property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @seat_deprovision.setter
    def seat_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "seat_deprovision", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")

    @user_deprovision.setter
    def user_deprovision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_deprovision", value)


if not MYPY:
    class ZeroTrustAccessInfrastructureTargetIpArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict']]
        """
        The target's IPv4 address
        """
        ipv6: NotRequired[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict']]
        """
        The target's IPv6 address
        """
elif False:
    ZeroTrustAccessInfrastructureTargetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessInfrastructureTargetIpArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args'] ipv4: The target's IPv4 address
        :param pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args'] ipv6: The target's IPv6 address
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args']]:
        """
        The target's IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args']]:
        """
        The target's IPv6 address
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict(TypedDict):
        ip_addr: NotRequired[pulumi.Input[str]]
        """
        IP address of the target
        """
        virtual_network_id: NotRequired[pulumi.Input[str]]
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
elif False:
    ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessInfrastructureTargetIpIpv4Args:
    def __init__(__self__, *,
                 ip_addr: Optional[pulumi.Input[str]] = None,
                 virtual_network_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_addr: IP address of the target
        :param pulumi.Input[str] virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        if ip_addr is not None:
            pulumi.set(__self__, "ip_addr", ip_addr)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_addr", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict(TypedDict):
        ip_addr: NotRequired[pulumi.Input[str]]
        """
        IP address of the target
        """
        virtual_network_id: NotRequired[pulumi.Input[str]]
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
elif False:
    ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessInfrastructureTargetIpIpv6Args:
    def __init__(__self__, *,
                 ip_addr: Optional[pulumi.Input[str]] = None,
                 virtual_network_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_addr: IP address of the target
        :param pulumi.Input[str] virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        if ip_addr is not None:
            pulumi.set(__self__, "ip_addr", ip_addr)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_addr", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict(TypedDict):
        china_network: pulumi.Input[bool]
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        client_certificate_forwarding: pulumi.Input[bool]
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        hostname: pulumi.Input[str]
        """
        The hostname that these settings apply to.
        """
elif False:
    ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessMtlsHostnameSettingsSettingArgs:
    def __init__(__self__, *,
                 china_network: pulumi.Input[bool],
                 client_certificate_forwarding: pulumi.Input[bool],
                 hostname: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param pulumi.Input[bool] client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        :param pulumi.Input[str] hostname: The hostname that these settings apply to.
        """
        pulumi.set(__self__, "china_network", china_network)
        pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)
        pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> pulumi.Input[bool]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @china_network.setter
    def china_network(self, value: pulumi.Input[bool]):
        pulumi.set(self, "china_network", value)

    @property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> pulumi.Input[bool]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")

    @client_certificate_forwarding.setter
    def client_certificate_forwarding(self, value: pulumi.Input[bool]):
        pulumi.set(self, "client_certificate_forwarding", value)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class ZeroTrustAccessPolicyApprovalGroupArgsDict(TypedDict):
        approvals_needed: pulumi.Input[float]
        """
        The number of approvals needed to obtain access.
        """
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of emails that can approve the access request.
        """
        email_list_uuid: NotRequired[pulumi.Input[str]]
        """
        The UUID of an re-usable email list.
        """
elif False:
    ZeroTrustAccessPolicyApprovalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyApprovalGroupArgs:
    def __init__(__self__, *,
                 approvals_needed: pulumi.Input[float],
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_list_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] approvals_needed: The number of approvals needed to obtain access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_addresses: A list of emails that can approve the access request.
        :param pulumi.Input[str] email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> pulumi.Input[float]:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @approvals_needed.setter
    def approvals_needed(self, value: pulumi.Input[float]):
        pulumi.set(self, "approvals_needed", value)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)

    @property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")

    @email_list_uuid.setter
    def email_list_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_list_uuid", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessPolicyExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessPolicyExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessPolicyExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessPolicyExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessPolicyExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessPolicyExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessPolicyExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessPolicyExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessPolicyIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessPolicyIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessPolicyIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessPolicyIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessPolicyIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessPolicyIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessPolicyIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessPolicyIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[str] id: The ID of an Authentication context.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ac_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessPolicyRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an Azure group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessPolicyRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessPolicyRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[str]):
        """
        :param pulumi.Input[str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessPolicyRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessPolicyRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessPolicyRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[str],
                 keys_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "evaluate_url", value)

    @property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str],
                 team: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[str] name: The name of the organization.
        :param pulumi.Input[str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessPolicyRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the Google Workspace group.
        :param pulumi.Input[str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessPolicyRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessPolicyRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 identity_provider_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessPolicyRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileExcludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
elif False:
    ZeroTrustDeviceCustomProfileExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileExcludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param pulumi.Input[str] description: A description of the Split Tunnel item, displayed in the client UI.
        :param pulumi.Input[str] host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileFallbackDomainArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        The domain suffix to match when resolving locally.
        """
elif False:
    ZeroTrustDeviceCustomProfileFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileFallbackDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileIncludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
elif False:
    ZeroTrustDeviceCustomProfileIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileIncludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param pulumi.Input[str] description: A description of the split tunnel item, displayed in the client UI.
        :param pulumi.Input[str] host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgsDict(TypedDict):
        suffix: pulumi.Input[str]
        """
        The domain suffix to match when resolving locally.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
elif False:
    ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[str]):
        pulumi.set(self, "suffix", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileServiceModeV2ArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        The mode to run the WARP client under.
        """
        port: NotRequired[pulumi.Input[float]]
        """
        The port number when used with proxy mode.
        """
elif False:
    ZeroTrustDeviceCustomProfileServiceModeV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileServiceModeV2Args:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] mode: The mode to run the WARP client under.
        :param pulumi.Input[float] port: The port number when used with proxy mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileTargetTestArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The id of the DEX test targeting this policy
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the DEX test targeting this policy
        """
elif False:
    ZeroTrustDeviceCustomProfileTargetTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileTargetTestArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the DEX test targeting this policy
        :param pulumi.Input[str] name: The name of the DEX test targeting this policy
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the DEX test targeting this policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the DEX test targeting this policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileExcludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
elif False:
    ZeroTrustDeviceDefaultProfileExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileExcludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param pulumi.Input[str] description: A description of the Split Tunnel item, displayed in the client UI.
        :param pulumi.Input[str] host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileFallbackDomainArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        The domain suffix to match when resolving locally.
        """
elif False:
    ZeroTrustDeviceDefaultProfileFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileFallbackDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileIncludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
elif False:
    ZeroTrustDeviceDefaultProfileIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileIncludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        :param pulumi.Input[str] description: A description of the split tunnel item, displayed in the client UI.
        :param pulumi.Input[str] host: The domain name to include in the tunnel. If host is present, address must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address in CIDR format to include in the tunnel. If address is present, host must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the split tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The domain name to include in the tunnel. If host is present, address must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgsDict(TypedDict):
        suffix: pulumi.Input[str]
        """
        The domain suffix to match when resolving locally.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
elif False:
    ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] suffix: The domain suffix to match when resolving locally.
        :param pulumi.Input[str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[str]):
        pulumi.set(self, "suffix", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileServiceModeV2ArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        The mode to run the WARP client under.
        """
        port: NotRequired[pulumi.Input[float]]
        """
        The port number when used with proxy mode.
        """
elif False:
    ZeroTrustDeviceDefaultProfileServiceModeV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileServiceModeV2Args:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] mode: The mode to run the WARP client under.
        :param pulumi.Input[float] port: The port number when used with proxy mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[float]]:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustDeviceManagedNetworksConfigArgsDict(TypedDict):
        tls_sockaddr: pulumi.Input[str]
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        sha256: NotRequired[pulumi.Input[str]]
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
elif False:
    ZeroTrustDeviceManagedNetworksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceManagedNetworksConfigArgs:
    def __init__(__self__, *,
                 tls_sockaddr: pulumi.Input[str],
                 sha256: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        :param pulumi.Input[str] sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> pulumi.Input[str]:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @tls_sockaddr.setter
    def tls_sockaddr(self, value: pulumi.Input[str]):
        pulumi.set(self, "tls_sockaddr", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class ZeroTrustDevicePostureIntegrationConfigArgsDict(TypedDict):
        access_client_id: NotRequired[pulumi.Input[str]]
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`
        """
        access_client_secret: NotRequired[pulumi.Input[str]]
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`
        """
        api_url: NotRequired[pulumi.Input[str]]
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        auth_url: NotRequired[pulumi.Input[str]]
        """
        The Workspace One Authorization URL depending on your region.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        The Uptycs client secret.
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        customer_id: NotRequired[pulumi.Input[str]]
        """
        The Crowdstrike customer ID.
        """
elif False:
    ZeroTrustDevicePostureIntegrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureIntegrationConfigArgs:
    def __init__(__self__, *,
                 access_client_id: Optional[pulumi.Input[str]] = None,
                 access_client_secret: Optional[pulumi.Input[str]] = None,
                 api_url: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 customer_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_client_id: If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`
        :param pulumi.Input[str] access_client_secret: If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`
        :param pulumi.Input[str] api_url: The Workspace One API URL provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[str] auth_url: The Workspace One Authorization URL depending on your region.
        :param pulumi.Input[str] client_id: The Workspace One client ID provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[str] client_key: The Uptycs client secret.
        :param pulumi.Input[str] client_secret: The Workspace One client secret provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[str] customer_id: The Crowdstrike customer ID.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_id", value)

    @property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_client_secret", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Workspace One Authorization URL depending on your region.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Uptycs client secret.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Crowdstrike customer ID.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_id", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleInputArgsDict(TypedDict):
        active_threats: NotRequired[pulumi.Input[float]]
        """
        The Number of active threats.
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        UUID of Cloudflare managed certificate.
        """
        check_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of volume names to be checked for encryption.
        """
        check_private_key: NotRequired[pulumi.Input[bool]]
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        cn: NotRequired[pulumi.Input[str]]
        """
        Common Name that is protected by the certificate
        """
        compliance_status: NotRequired[pulumi.Input[str]]
        """
        Compliance Status
        """
        connection_id: NotRequired[pulumi.Input[str]]
        """
        Posture Integration ID.
        """
        count_operator: NotRequired[pulumi.Input[str]]
        """
        Count Operator
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Domain
        """
        eid_last_seen: NotRequired[pulumi.Input[str]]
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enabled
        """
        exists: NotRequired[pulumi.Input[bool]]
        """
        Whether or not file exists
        """
        extended_key_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of values indicating purposes for which the certificate public key can be used
        """
        id: NotRequired[pulumi.Input[str]]
        """
        List ID.
        """
        infected: NotRequired[pulumi.Input[bool]]
        """
        Whether device is infected.
        """
        is_active: NotRequired[pulumi.Input[bool]]
        """
        Whether device is active.
        """
        issue_count: NotRequired[pulumi.Input[str]]
        """
        The Number of Issues.
        """
        last_seen: NotRequired[pulumi.Input[str]]
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        locations: NotRequired[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgsDict']]
        network_status: NotRequired[pulumi.Input[str]]
        """
        Network status of device.
        """
        operating_system: NotRequired[pulumi.Input[str]]
        """
        Operating system
        """
        operational_state: NotRequired[pulumi.Input[str]]
        """
        Agent operational state.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        operator
        """
        os: NotRequired[pulumi.Input[str]]
        """
        Os Version
        """
        os_distro_name: NotRequired[pulumi.Input[str]]
        """
        Operating System Distribution Name (linux only)
        """
        os_distro_revision: NotRequired[pulumi.Input[str]]
        """
        Version of OS Distribution (linux only)
        """
        os_version_extra: NotRequired[pulumi.Input[str]]
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        """
        overall: NotRequired[pulumi.Input[str]]
        """
        overall
        """
        path: NotRequired[pulumi.Input[str]]
        """
        File path.
        """
        require_all: NotRequired[pulumi.Input[bool]]
        """
        Whether to check all disks for encryption.
        """
        risk_level: NotRequired[pulumi.Input[str]]
        """
        For more details on risk level, refer to the Tanium documentation.
        """
        score: NotRequired[pulumi.Input[float]]
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        score_operator: NotRequired[pulumi.Input[str]]
        """
        Score Operator
        """
        sensor_config: NotRequired[pulumi.Input[str]]
        """
        SensorConfig
        """
        sha256: NotRequired[pulumi.Input[str]]
        """
        SHA-256.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        For more details on state, please refer to the Crowdstrike documentation.
        """
        thumbprint: NotRequired[pulumi.Input[str]]
        """
        Signing certificate thumbprint.
        """
        total_score: NotRequired[pulumi.Input[float]]
        """
        For more details on total score, refer to the Tanium documentation.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of OS
        """
        version_operator: NotRequired[pulumi.Input[str]]
        """
        Version Operator
        """
elif False:
    ZeroTrustDevicePostureRuleInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleInputArgs:
    def __init__(__self__, *,
                 active_threats: Optional[pulumi.Input[float]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 check_private_key: Optional[pulumi.Input[bool]] = None,
                 cn: Optional[pulumi.Input[str]] = None,
                 compliance_status: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 count_operator: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 eid_last_seen: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exists: Optional[pulumi.Input[bool]] = None,
                 extended_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infected: Optional[pulumi.Input[bool]] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 issue_count: Optional[pulumi.Input[str]] = None,
                 last_seen: Optional[pulumi.Input[str]] = None,
                 locations: Optional[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgs']] = None,
                 network_status: Optional[pulumi.Input[str]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 operational_state: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_distro_name: Optional[pulumi.Input[str]] = None,
                 os_distro_revision: Optional[pulumi.Input[str]] = None,
                 os_version_extra: Optional[pulumi.Input[str]] = None,
                 overall: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 require_all: Optional[pulumi.Input[bool]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None,
                 score: Optional[pulumi.Input[float]] = None,
                 score_operator: Optional[pulumi.Input[str]] = None,
                 sensor_config: Optional[pulumi.Input[str]] = None,
                 sha256: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None,
                 total_score: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 version_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] active_threats: The Number of active threats.
        :param pulumi.Input[str] certificate_id: UUID of Cloudflare managed certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] check_disks: List of volume names to be checked for encryption.
        :param pulumi.Input[bool] check_private_key: Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        :param pulumi.Input[str] cn: Common Name that is protected by the certificate
        :param pulumi.Input[str] compliance_status: Compliance Status
        :param pulumi.Input[str] connection_id: Posture Integration ID.
        :param pulumi.Input[str] count_operator: Count Operator
        :param pulumi.Input[str] domain: Domain
        :param pulumi.Input[str] eid_last_seen: For more details on eid last seen, refer to the Tanium documentation.
        :param pulumi.Input[bool] enabled: Enabled
        :param pulumi.Input[bool] exists: Whether or not file exists
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extended_key_usages: List of values indicating purposes for which the certificate public key can be used
        :param pulumi.Input[str] id: List ID.
        :param pulumi.Input[bool] infected: Whether device is infected.
        :param pulumi.Input[bool] is_active: Whether device is active.
        :param pulumi.Input[str] issue_count: The Number of Issues.
        :param pulumi.Input[str] last_seen: For more details on last seen, please refer to the Crowdstrike documentation.
        :param pulumi.Input[str] network_status: Network status of device.
        :param pulumi.Input[str] operating_system: Operating system
        :param pulumi.Input[str] operational_state: Agent operational state.
        :param pulumi.Input[str] operator: operator
        :param pulumi.Input[str] os: Os Version
        :param pulumi.Input[str] os_distro_name: Operating System Distribution Name (linux only)
        :param pulumi.Input[str] os_distro_revision: Version of OS Distribution (linux only)
        :param pulumi.Input[str] os_version_extra: Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        :param pulumi.Input[str] overall: overall
        :param pulumi.Input[str] path: File path.
        :param pulumi.Input[bool] require_all: Whether to check all disks for encryption.
        :param pulumi.Input[str] risk_level: For more details on risk level, refer to the Tanium documentation.
        :param pulumi.Input[float] score: A value between 0-100 assigned to devices set by the 3rd party posture provider.
        :param pulumi.Input[str] score_operator: Score Operator
        :param pulumi.Input[str] sensor_config: SensorConfig
        :param pulumi.Input[str] sha256: SHA-256.
        :param pulumi.Input[str] state: For more details on state, please refer to the Crowdstrike documentation.
        :param pulumi.Input[str] thumbprint: Signing certificate thumbprint.
        :param pulumi.Input[float] total_score: For more details on total score, refer to the Tanium documentation.
        :param pulumi.Input[str] version: Version of OS
        :param pulumi.Input[str] version_operator: Version Operator
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if score_operator is not None:
            pulumi.set(__self__, "score_operator", score_operator)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[pulumi.Input[float]]:
        """
        The Number of active threats.
        """
        return pulumi.get(self, "active_threats")

    @active_threats.setter
    def active_threats(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "active_threats", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of volume names to be checked for encryption.
        """
        return pulumi.get(self, "check_disks")

    @check_disks.setter
    def check_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "check_disks", value)

    @property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        return pulumi.get(self, "check_private_key")

    @check_private_key.setter
    def check_private_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_private_key", value)

    @property
    @pulumi.getter
    def cn(self) -> Optional[pulumi.Input[str]]:
        """
        Common Name that is protected by the certificate
        """
        return pulumi.get(self, "cn")

    @cn.setter
    def cn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cn", value)

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[str]]:
        """
        Compliance Status
        """
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_status", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Posture Integration ID.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[pulumi.Input[str]]:
        """
        Count Operator
        """
        return pulumi.get(self, "count_operator")

    @count_operator.setter
    def count_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count_operator", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        return pulumi.get(self, "eid_last_seen")

    @eid_last_seen.setter
    def eid_last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "eid_last_seen", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def exists(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not file exists
        """
        return pulumi.get(self, "exists")

    @exists.setter
    def exists(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exists", value)

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of values indicating purposes for which the certificate public key can be used
        """
        return pulumi.get(self, "extended_key_usages")

    @extended_key_usages.setter
    def extended_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extended_key_usages", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        List ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infected(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether device is infected.
        """
        return pulumi.get(self, "infected")

    @infected.setter
    def infected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infected", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether device is active.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[pulumi.Input[str]]:
        """
        The Number of Issues.
        """
        return pulumi.get(self, "issue_count")

    @issue_count.setter
    def issue_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issue_count", value)

    @property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[pulumi.Input[str]]:
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "last_seen")

    @last_seen.setter
    def last_seen(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_seen", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgs']]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[pulumi.Input[str]]:
        """
        Network status of device.
        """
        return pulumi.get(self, "network_status")

    @network_status.setter
    def network_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_status", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        Operating system
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[str]]:
        """
        Agent operational state.
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operational_state", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        operator
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[str]]:
        """
        Os Version
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[pulumi.Input[str]]:
        """
        Operating System Distribution Name (linux only)
        """
        return pulumi.get(self, "os_distro_name")

    @os_distro_name.setter
    def os_distro_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_name", value)

    @property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[pulumi.Input[str]]:
        """
        Version of OS Distribution (linux only)
        """
        return pulumi.get(self, "os_distro_revision")

    @os_distro_revision.setter
    def os_distro_revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_distro_revision", value)

    @property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[pulumi.Input[str]]:
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only)
        """
        return pulumi.get(self, "os_version_extra")

    @os_version_extra.setter
    def os_version_extra(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_version_extra", value)

    @property
    @pulumi.getter
    def overall(self) -> Optional[pulumi.Input[str]]:
        """
        overall
        """
        return pulumi.get(self, "overall")

    @overall.setter
    def overall(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overall", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        File path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to check all disks for encryption.
        """
        return pulumi.get(self, "require_all")

    @require_all.setter
    def require_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_all", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        For more details on risk level, refer to the Tanium documentation.
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)

    @property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[float]]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "score", value)

    @property
    @pulumi.getter(name="scoreOperator")
    def score_operator(self) -> Optional[pulumi.Input[str]]:
        """
        Score Operator
        """
        return pulumi.get(self, "score_operator")

    @score_operator.setter
    def score_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "score_operator", value)

    @property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[pulumi.Input[str]]:
        """
        SensorConfig
        """
        return pulumi.get(self, "sensor_config")

    @sensor_config.setter
    def sensor_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sensor_config", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        """
        SHA-256.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        For more details on state, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        Signing certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)

    @property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[pulumi.Input[float]]:
        """
        For more details on total score, refer to the Tanium documentation.
        """
        return pulumi.get(self, "total_score")

    @total_score.setter
    def total_score(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "total_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of OS
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[pulumi.Input[str]]:
        """
        Version Operator
        """
        return pulumi.get(self, "version_operator")

    @version_operator.setter
    def version_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_operator", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleInputLocationsArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of paths to check for client certificate on linux.
        """
        trust_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of trust stores to check for client certificate.
        """
elif False:
    ZeroTrustDevicePostureRuleInputLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleInputLocationsArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 trust_stores: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: List of paths to check for client certificate on linux.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] trust_stores: List of trust stores to check for client certificate.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of paths to check for client certificate on linux.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of trust stores to check for client certificate.
        """
        return pulumi.get(self, "trust_stores")

    @trust_stores.setter
    def trust_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "trust_stores", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleMatchArgsDict(TypedDict):
        platform: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustDevicePostureRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleMatchArgs:
    def __init__(__self__, *,
                 platform: Optional[pulumi.Input[str]] = None):
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)


if not MYPY:
    class ZeroTrustDexTestDataArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        The desired endpoint to test.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        The type of test.
        """
        method: NotRequired[pulumi.Input[str]]
        """
        The HTTP request method type.
        """
elif False:
    ZeroTrustDexTestDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDexTestDataArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The desired endpoint to test.
        :param pulumi.Input[str] kind: The type of test.
        :param pulumi.Input[str] method: The HTTP request method type.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The desired endpoint to test.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        The type of test.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP request method type.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class ZeroTrustDexTestTargetPolicyArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[bool]]
        """
        Whether the profile is the account default
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The id of the device settings profile
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the device settings profile
        """
elif False:
    ZeroTrustDexTestTargetPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDexTestTargetPolicyArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] default: Whether the profile is the account default
        :param pulumi.Input[str] id: The id of the device settings profile
        :param pulumi.Input[str] name: The name of the device settings profile
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the profile is the account default
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the device settings profile
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the device settings profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpCustomProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 skip: pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def skip(self) -> pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        name: pulumi.Input[str]
        pattern: NotRequired[pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgsDict']]
        words: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ZeroTrustDlpCustomProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 pattern: Optional[pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgs']] = None,
                 words: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if words is not None:
            pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgs']]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgs']]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def words(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[str]
        validation: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustDlpCustomProfileEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str],
                 validation: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileProfileArgsDict(TypedDict):
        entries: pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryArgsDict']]]
        name: pulumi.Input[str]
        ai_context_enabled: NotRequired[pulumi.Input[bool]]
        allowed_match_count: NotRequired[pulumi.Input[int]]
        """
        Related DLP policies will trigger when the match count exceeds the number set.
        """
        confidence_threshold: NotRequired[pulumi.Input[str]]
        context_awareness: NotRequired[pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessArgsDict']]
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the profile
        """
        ocr_enabled: NotRequired[pulumi.Input[bool]]
        shared_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileSharedEntryArgsDict']]]]
        """
        Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
        """
elif False:
    ZeroTrustDlpCustomProfileProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileProfileArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryArgs']]],
                 name: pulumi.Input[str],
                 ai_context_enabled: Optional[pulumi.Input[bool]] = None,
                 allowed_match_count: Optional[pulumi.Input[int]] = None,
                 confidence_threshold: Optional[pulumi.Input[str]] = None,
                 context_awareness: Optional[pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ocr_enabled: Optional[pulumi.Input[bool]] = None,
                 shared_entries: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileSharedEntryArgs']]]] = None):
        """
        :param pulumi.Input[int] allowed_match_count: Related DLP policies will trigger when the match count exceeds the number set.
        :param pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessArgs'] context_awareness: Scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input[str] description: The description of the profile
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileSharedEntryArgs']]] shared_entries: Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
        """
        pulumi.set(__self__, "entries", entries)
        pulumi.set(__self__, "name", name)
        if ai_context_enabled is not None:
            pulumi.set(__self__, "ai_context_enabled", ai_context_enabled)
        if allowed_match_count is not None:
            pulumi.set(__self__, "allowed_match_count", allowed_match_count)
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)
        if context_awareness is not None:
            pulumi.set(__self__, "context_awareness", context_awareness)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ocr_enabled is not None:
            pulumi.set(__self__, "ocr_enabled", ocr_enabled)
        if shared_entries is not None:
            pulumi.set(__self__, "shared_entries", shared_entries)

    @property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryArgs']]]):
        pulumi.set(self, "entries", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="aiContextEnabled")
    def ai_context_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ai_context_enabled")

    @ai_context_enabled.setter
    def ai_context_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ai_context_enabled", value)

    @property
    @pulumi.getter(name="allowedMatchCount")
    def allowed_match_count(self) -> Optional[pulumi.Input[int]]:
        """
        Related DLP policies will trigger when the match count exceeds the number set.
        """
        return pulumi.get(self, "allowed_match_count")

    @allowed_match_count.setter
    def allowed_match_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allowed_match_count", value)

    @property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "confidence_threshold")

    @confidence_threshold.setter
    def confidence_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "confidence_threshold", value)

    @property
    @pulumi.getter(name="contextAwareness")
    def context_awareness(self) -> Optional[pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessArgs']]:
        """
        Scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "context_awareness")

    @context_awareness.setter
    def context_awareness(self, value: Optional[pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessArgs']]):
        pulumi.set(self, "context_awareness", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the profile
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ocrEnabled")
    def ocr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ocr_enabled")

    @ocr_enabled.setter
    def ocr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ocr_enabled", value)

    @property
    @pulumi.getter(name="sharedEntries")
    def shared_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileSharedEntryArgs']]]]:
        """
        Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
        """
        return pulumi.get(self, "shared_entries")

    @shared_entries.setter
    def shared_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpCustomProfileProfileSharedEntryArgs']]]]):
        pulumi.set(self, "shared_entries", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpCustomProfileProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 skip: pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def skip(self) -> pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        name: pulumi.Input[str]
        pattern: NotRequired[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryPatternArgsDict']]
        words: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ZeroTrustDlpCustomProfileProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 pattern: Optional[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryPatternArgs']] = None,
                 words: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if words is not None:
            pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryPatternArgs']]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input['ZeroTrustDlpCustomProfileProfileEntryPatternArgs']]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def words(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileProfileEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[str]
        validation: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustDlpCustomProfileProfileEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str],
                 validation: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileProfileSharedEntryArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        entry_id: pulumi.Input[str]
        entry_type: pulumi.Input[str]
elif False:
    ZeroTrustDlpCustomProfileProfileSharedEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileProfileSharedEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 entry_id: pulumi.Input[str],
                 entry_type: pulumi.Input[str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "entry_type", entry_type)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_id", value)

    @property
    @pulumi.getter(name="entryType")
    def entry_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entry_type")

    @entry_type.setter
    def entry_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_type", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileSharedEntryArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        entry_id: pulumi.Input[str]
        entry_type: pulumi.Input[str]
elif False:
    ZeroTrustDlpCustomProfileSharedEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileSharedEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 entry_id: pulumi.Input[str],
                 entry_type: pulumi.Input[str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "entry_type", entry_type)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_id", value)

    @property
    @pulumi.getter(name="entryType")
    def entry_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entry_type")

    @entry_type.setter
    def entry_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_type", value)


if not MYPY:
    class ZeroTrustDlpDatasetColumnArgsDict(TypedDict):
        entry_id: NotRequired[pulumi.Input[str]]
        header_name: NotRequired[pulumi.Input[str]]
        num_cells: NotRequired[pulumi.Input[int]]
        upload_status: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustDlpDatasetColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetColumnArgs:
    def __init__(__self__, *,
                 entry_id: Optional[pulumi.Input[str]] = None,
                 header_name: Optional[pulumi.Input[str]] = None,
                 num_cells: Optional[pulumi.Input[int]] = None,
                 upload_status: Optional[pulumi.Input[str]] = None):
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if upload_status is not None:
            pulumi.set(__self__, "upload_status", upload_status)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_id", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cells", value)

    @property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "upload_status")

    @upload_status.setter
    def upload_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upload_status", value)


if not MYPY:
    class ZeroTrustDlpDatasetDatasetArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgsDict']]]]
        created_at: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the dataset
        """
        encoding_version: NotRequired[pulumi.Input[int]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        num_cells: NotRequired[pulumi.Input[int]]
        secret: NotRequired[pulumi.Input[bool]]
        status: NotRequired[pulumi.Input[str]]
        updated_at: NotRequired[pulumi.Input[str]]
        """
        When the dataset was last updated.
        """
        uploads: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgsDict']]]]
elif False:
    ZeroTrustDlpDatasetDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetDatasetArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgs']]]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 encoding_version: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_cells: Optional[pulumi.Input[int]] = None,
                 secret: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 uploads: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgs']]]] = None):
        """
        :param pulumi.Input[str] description: The description of the dataset
        :param pulumi.Input[str] updated_at: When the dataset was last updated.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_version is not None:
            pulumi.set(__self__, "encoding_version", encoding_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uploads is not None:
            pulumi.set(__self__, "uploads", uploads)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgs']]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the dataset
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="encodingVersion")
    def encoding_version(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "encoding_version")

    @encoding_version.setter
    def encoding_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "encoding_version", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cells", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        When the dataset was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter
    def uploads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgs']]]]:
        return pulumi.get(self, "uploads")

    @uploads.setter
    def uploads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgs']]]]):
        pulumi.set(self, "uploads", value)


if not MYPY:
    class ZeroTrustDlpDatasetDatasetColumnArgsDict(TypedDict):
        entry_id: NotRequired[pulumi.Input[str]]
        header_name: NotRequired[pulumi.Input[str]]
        num_cells: NotRequired[pulumi.Input[int]]
        upload_status: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustDlpDatasetDatasetColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetDatasetColumnArgs:
    def __init__(__self__, *,
                 entry_id: Optional[pulumi.Input[str]] = None,
                 header_name: Optional[pulumi.Input[str]] = None,
                 num_cells: Optional[pulumi.Input[int]] = None,
                 upload_status: Optional[pulumi.Input[str]] = None):
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if upload_status is not None:
            pulumi.set(__self__, "upload_status", upload_status)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_id", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cells", value)

    @property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "upload_status")

    @upload_status.setter
    def upload_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upload_status", value)


if not MYPY:
    class ZeroTrustDlpDatasetDatasetUploadArgsDict(TypedDict):
        num_cells: NotRequired[pulumi.Input[int]]
        status: NotRequired[pulumi.Input[str]]
        version: NotRequired[pulumi.Input[int]]
elif False:
    ZeroTrustDlpDatasetDatasetUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetDatasetUploadArgs:
    def __init__(__self__, *,
                 num_cells: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[int]] = None):
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cells", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustDlpDatasetUploadArgsDict(TypedDict):
        num_cells: NotRequired[pulumi.Input[int]]
        status: NotRequired[pulumi.Input[str]]
        version: NotRequired[pulumi.Input[int]]
elif False:
    ZeroTrustDlpDatasetUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetUploadArgs:
    def __init__(__self__, *,
                 num_cells: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[int]] = None):
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cells", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustDlpEntryConfidenceArgsDict(TypedDict):
        ai_context_available: NotRequired[pulumi.Input[bool]]
        available: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
elif False:
    ZeroTrustDlpEntryConfidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpEntryConfidenceArgs:
    def __init__(__self__, *,
                 ai_context_available: Optional[pulumi.Input[bool]] = None,
                 available: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] available: Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
               Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        if ai_context_available is not None:
            pulumi.set(__self__, "ai_context_available", ai_context_available)
        if available is not None:
            pulumi.set(__self__, "available", available)

    @property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ai_context_available")

    @ai_context_available.setter
    def ai_context_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ai_context_available", value)

    @property
    @pulumi.getter
    def available(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether this entry can be made more or less sensitive by setting a confidence threshold.
        Profiles that use an entry with `available` set to true can use confidence thresholds
        """
        return pulumi.get(self, "available")

    @available.setter
    def available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "available", value)


if not MYPY:
    class ZeroTrustDlpEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[str]
        validation: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustDlpEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[str],
                 validation: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpPredefinedProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpPredefinedProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 skip: pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def skip(self) -> pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ZeroTrustDlpPredefinedProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        id: pulumi.Input[str]
elif False:
    ZeroTrustDlpPredefinedProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsArgsDict(TypedDict):
        doh: NotRequired[pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgsDict']]
        dot: NotRequired[pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgsDict']]
        ipv4: NotRequired[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4ArgsDict']]
        ipv6: NotRequired[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6ArgsDict']]
elif False:
    ZeroTrustDnsLocationEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsArgs:
    def __init__(__self__, *,
                 doh: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgs']] = None,
                 dot: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgs']] = None,
                 ipv4: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6Args']] = None):
        if doh is not None:
            pulumi.set(__self__, "doh", doh)
        if dot is not None:
            pulumi.set(__self__, "dot", dot)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def doh(self) -> Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgs']]:
        return pulumi.get(self, "doh")

    @doh.setter
    def doh(self, value: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgs']]):
        pulumi.set(self, "doh", value)

    @property
    @pulumi.getter
    def dot(self) -> Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgs']]:
        return pulumi.get(self, "dot")

    @dot.setter
    def dot(self, value: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgs']]):
        pulumi.set(self, "dot", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4Args']]:
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6Args']]:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDohArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgsDict']]]]
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        require_token: NotRequired[pulumi.Input[bool]]
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDohArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDohArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]]] = None,
                 require_token: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        :param pulumi.Input[bool] require_token: True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]]]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        return pulumi.get(self, "require_token")

    @require_token.setter
    def require_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_token", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDohNetworkArgsDict(TypedDict):
        network: pulumi.Input[str]
        """
        The IP address or IP CIDR.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDohNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDohNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str]):
        """
        :param pulumi.Input[str] network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDotArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgsDict']]]]
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDotArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]]]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDotNetworkArgsDict(TypedDict):
        network: pulumi.Input[str]
        """
        The IP address or IP CIDR.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDotNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDotNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str]):
        """
        :param pulumi.Input[str] network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsIpv4ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the endpoint is enabled for this location.
        """
elif False:
    ZeroTrustDnsLocationEndpointsIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsIpv4Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: True if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsIpv6ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict']]]]
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
elif False:
    ZeroTrustDnsLocationEndpointsIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsIpv6Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]] networks: A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]]]:
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict(TypedDict):
        network: pulumi.Input[str]
        """
        The IPv6 address or IPv6 CIDR.
        """
elif False:
    ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsIpv6NetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str]):
        """
        :param pulumi.Input[str] network: The IPv6 address or IPv6 CIDR.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        The IPv6 address or IPv6 CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustDnsLocationNetworkArgsDict(TypedDict):
        network: pulumi.Input[str]
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
elif False:
    ZeroTrustDnsLocationNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str]):
        """
        :param pulumi.Input[str] network: The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustGatewayLoggingSettingsByRuleTypeArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[str]]
        """
        Logging settings for DNS firewall.
        """
        http: NotRequired[pulumi.Input[str]]
        """
        Logging settings for HTTP/HTTPS firewall.
        """
        l4: NotRequired[pulumi.Input[str]]
        """
        Logging settings for Network firewall.
        """
elif False:
    ZeroTrustGatewayLoggingSettingsByRuleTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayLoggingSettingsByRuleTypeArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[str]] = None,
                 http: Optional[pulumi.Input[str]] = None,
                 l4: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dns: Logging settings for DNS firewall.
        :param pulumi.Input[str] http: Logging settings for HTTP/HTTPS firewall.
        :param pulumi.Input[str] l4: Logging settings for Network firewall.
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if l4 is not None:
            pulumi.set(__self__, "l4", l4)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[str]]:
        """
        Logging settings for DNS firewall.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[str]]:
        """
        Logging settings for HTTP/HTTPS firewall.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def l4(self) -> Optional[pulumi.Input[str]]:
        """
        Logging settings for Network firewall.
        """
        return pulumi.get(self, "l4")

    @l4.setter
    def l4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l4", value)


if not MYPY:
    class ZeroTrustGatewayPolicyExpirationArgsDict(TypedDict):
        expires_at: pulumi.Input[str]
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        duration: NotRequired[pulumi.Input[int]]
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        expired: NotRequired[pulumi.Input[bool]]
        """
        Whether the policy has expired.
        """
elif False:
    ZeroTrustGatewayPolicyExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyExpirationArgs:
    def __init__(__self__, *,
                 expires_at: pulumi.Input[str],
                 duration: Optional[pulumi.Input[int]] = None,
                 expired: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] expires_at: The time stamp at which the policy will expire and cease to be
               applied.
        :param pulumi.Input[int] duration: The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        :param pulumi.Input[bool] expired: Whether the policy has expired.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> pulumi.Input[str]:
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the policy has expired.
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsArgsDict(TypedDict):
        add_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        allow_child_bypass: NotRequired[pulumi.Input[bool]]
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        audit_ssh: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict']]
        """
        Settings for the Audit SSH action.
        """
        biso_admin_controls: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict']]
        """
        Configure how browser isolation behaves.
        """
        block_page_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the custom block page.
        """
        block_reason: NotRequired[pulumi.Input[str]]
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        bypass_parent_rule: NotRequired[pulumi.Input[bool]]
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        check_session: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict']]
        """
        Configure how session check behaves.
        """
        dns_resolvers: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict']]
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        egress: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict']]
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        ignore_cname_category_matches: NotRequired[pulumi.Input[bool]]
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        insecure_disable_dnssec_validation: NotRequired[pulumi.Input[bool]]
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        ip_categories: NotRequired[pulumi.Input[bool]]
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        ip_indicator_feeds: NotRequired[pulumi.Input[bool]]
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        l4override: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict']]
        """
        Send matching traffic to the supplied destination IP address and port.
        """
        notification_settings: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict']]
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        override_host: NotRequired[pulumi.Input[str]]
        """
        Override matching DNS queries with a hostname.
        """
        override_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        payload_log: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict']]
        """
        Configure DLP payload logging.
        """
        quarantine: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict']]
        """
        Settings that apply to quarantine rules
        """
        resolve_dns_internally: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict']]
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        resolve_dns_through_cloudflare: NotRequired[pulumi.Input[bool]]
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        untrusted_cert: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict']]
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 allow_child_bypass: Optional[pulumi.Input[bool]] = None,
                 audit_ssh: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']] = None,
                 biso_admin_controls: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']] = None,
                 block_page_enabled: Optional[pulumi.Input[bool]] = None,
                 block_reason: Optional[pulumi.Input[str]] = None,
                 bypass_parent_rule: Optional[pulumi.Input[bool]] = None,
                 check_session: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']] = None,
                 dns_resolvers: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']] = None,
                 egress: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']] = None,
                 ignore_cname_category_matches: Optional[pulumi.Input[bool]] = None,
                 insecure_disable_dnssec_validation: Optional[pulumi.Input[bool]] = None,
                 ip_categories: Optional[pulumi.Input[bool]] = None,
                 ip_indicator_feeds: Optional[pulumi.Input[bool]] = None,
                 l4override: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']] = None,
                 notification_settings: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']] = None,
                 override_host: Optional[pulumi.Input[str]] = None,
                 override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 payload_log: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']] = None,
                 quarantine: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs']] = None,
                 resolve_dns_internally: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs']] = None,
                 resolve_dns_through_cloudflare: Optional[pulumi.Input[bool]] = None,
                 untrusted_cert: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] add_headers: Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        :param pulumi.Input[bool] allow_child_bypass: Set by parent MSP accounts to enable their children to bypass this rule.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs'] audit_ssh: Settings for the Audit SSH action.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs'] biso_admin_controls: Configure how browser isolation behaves.
        :param pulumi.Input[bool] block_page_enabled: Enable the custom block page.
        :param pulumi.Input[str] block_reason: The text describing why this block occurred, displayed on the custom block page (if enabled).
        :param pulumi.Input[bool] bypass_parent_rule: Set by children MSP accounts to bypass their parent's rules.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs'] check_session: Configure how session check behaves.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs'] dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs'] egress: Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        :param pulumi.Input[bool] ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        :param pulumi.Input[bool] insecure_disable_dnssec_validation: INSECURE - disable DNSSEC validation (for Allow actions).
        :param pulumi.Input[bool] ip_categories: Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        :param pulumi.Input[bool] ip_indicator_feeds: Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs'] l4override: Send matching traffic to the supplied destination IP address and port.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs'] notification_settings: Configure a notification to display on the user's device when this rule is matched.
        :param pulumi.Input[str] override_host: Override matching DNS queries with a hostname.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] override_ips: Override matching DNS queries with an IP or set of IPs.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs'] payload_log: Configure DLP payload logging.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs'] quarantine: Settings that apply to quarantine rules
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs'] resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input[bool] resolve_dns_through_cloudflare: Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs'] untrusted_cert: Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_reason is not None:
            pulumi.set(__self__, "block_reason", block_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if ip_indicator_feeds is not None:
            pulumi.set(__self__, "ip_indicator_feeds", ip_indicator_feeds)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if resolve_dns_internally is not None:
            pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add_headers", value)

    @property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[pulumi.Input[bool]]:
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        return pulumi.get(self, "allow_child_bypass")

    @allow_child_bypass.setter
    def allow_child_bypass(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_child_bypass", value)

    @property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']]:
        """
        Settings for the Audit SSH action.
        """
        return pulumi.get(self, "audit_ssh")

    @audit_ssh.setter
    def audit_ssh(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']]):
        pulumi.set(self, "audit_ssh", value)

    @property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']]:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @biso_admin_controls.setter
    def biso_admin_controls(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']]):
        pulumi.set(self, "biso_admin_controls", value)

    @property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the custom block page.
        """
        return pulumi.get(self, "block_page_enabled")

    @block_page_enabled.setter
    def block_page_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_page_enabled", value)

    @property
    @pulumi.getter(name="blockReason")
    def block_reason(self) -> Optional[pulumi.Input[str]]:
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        return pulumi.get(self, "block_reason")

    @block_reason.setter
    def block_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_reason", value)

    @property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[pulumi.Input[bool]]:
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @bypass_parent_rule.setter
    def bypass_parent_rule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_parent_rule", value)

    @property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']]:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @check_session.setter
    def check_session(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']]):
        pulumi.set(self, "check_session", value)

    @property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']]:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "dns_resolvers")

    @dns_resolvers.setter
    def dns_resolvers(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']]):
        pulumi.set(self, "dns_resolvers", value)

    @property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']]:
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @ignore_cname_category_matches.setter
    def ignore_cname_category_matches(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_cname_category_matches", value)

    @property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[pulumi.Input[bool]]:
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @insecure_disable_dnssec_validation.setter
    def insecure_disable_dnssec_validation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_disable_dnssec_validation", value)

    @property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        return pulumi.get(self, "ip_categories")

    @ip_categories.setter
    def ip_categories(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_categories", value)

    @property
    @pulumi.getter(name="ipIndicatorFeeds")
    def ip_indicator_feeds(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        return pulumi.get(self, "ip_indicator_feeds")

    @ip_indicator_feeds.setter
    def ip_indicator_feeds(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_indicator_feeds", value)

    @property
    @pulumi.getter
    def l4override(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']]:
        """
        Send matching traffic to the supplied destination IP address and port.
        """
        return pulumi.get(self, "l4override")

    @l4override.setter
    def l4override(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']]):
        pulumi.set(self, "l4override", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']]:
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[str]]:
        """
        Override matching DNS queries with a hostname.
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_host", value)

    @property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        return pulumi.get(self, "override_ips")

    @override_ips.setter
    def override_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "override_ips", value)

    @property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']]:
        """
        Configure DLP payload logging.
        """
        return pulumi.get(self, "payload_log")

    @payload_log.setter
    def payload_log(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']]):
        pulumi.set(self, "payload_log", value)

    @property
    @pulumi.getter
    def quarantine(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs']]:
        """
        Settings that apply to quarantine rules
        """
        return pulumi.get(self, "quarantine")

    @quarantine.setter
    def quarantine(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs']]):
        pulumi.set(self, "quarantine", value)

    @property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs']]:
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @resolve_dns_internally.setter
    def resolve_dns_internally(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs']]):
        pulumi.set(self, "resolve_dns_internally", value)

    @property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @resolve_dns_through_cloudflare.setter
    def resolve_dns_through_cloudflare(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "resolve_dns_through_cloudflare", value)

    @property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']]:
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        return pulumi.get(self, "untrusted_cert")

    @untrusted_cert.setter
    def untrusted_cert(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']]):
        pulumi.set(self, "untrusted_cert", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict(TypedDict):
        command_logging: NotRequired[pulumi.Input[bool]]
        """
        Enable to turn on SSH command logging.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs:
    def __init__(__self__, *,
                 command_logging: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] command_logging: Enable to turn on SSH command logging.
        """
        if command_logging is not None:
            pulumi.set(__self__, "command_logging", command_logging)

    @property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable to turn on SSH command logging.
        """
        return pulumi.get(self, "command_logging")

    @command_logging.setter
    def command_logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "command_logging", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict(TypedDict):
        copy: NotRequired[pulumi.Input[str]]
        """
        Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        """
        dcp: NotRequired[pulumi.Input[bool]]
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        dd: NotRequired[pulumi.Input[bool]]
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        dk: NotRequired[pulumi.Input[bool]]
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        download: NotRequired[pulumi.Input[str]]
        """
        Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        """
        dp: NotRequired[pulumi.Input[bool]]
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        du: NotRequired[pulumi.Input[bool]]
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        keyboard: NotRequired[pulumi.Input[str]]
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        """
        paste: NotRequired[pulumi.Input[str]]
        """
        Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        """
        printing: NotRequired[pulumi.Input[str]]
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        """
        upload: NotRequired[pulumi.Input[str]]
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Indicates which version of the browser isolation controls should apply.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs:
    def __init__(__self__, *,
                 copy: Optional[pulumi.Input[str]] = None,
                 dcp: Optional[pulumi.Input[bool]] = None,
                 dd: Optional[pulumi.Input[bool]] = None,
                 dk: Optional[pulumi.Input[bool]] = None,
                 download: Optional[pulumi.Input[str]] = None,
                 dp: Optional[pulumi.Input[bool]] = None,
                 du: Optional[pulumi.Input[bool]] = None,
                 keyboard: Optional[pulumi.Input[str]] = None,
                 paste: Optional[pulumi.Input[str]] = None,
                 printing: Optional[pulumi.Input[str]] = None,
                 upload: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] copy: Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        :param pulumi.Input[bool] dcp: Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        :param pulumi.Input[bool] dd: Set to false to enable downloading. Only applies when `version == "v1"`.
        :param pulumi.Input[bool] dk: Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        :param pulumi.Input[str] download: Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        :param pulumi.Input[bool] dp: Set to false to enable printing. Only applies when `version == "v1"`.
        :param pulumi.Input[bool] du: Set to false to enable uploading. Only applies when `version == "v1"`.
        :param pulumi.Input[str] keyboard: Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        :param pulumi.Input[str] paste: Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        :param pulumi.Input[str] printing: Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        :param pulumi.Input[str] upload: Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        :param pulumi.Input[str] version: Indicates which version of the browser isolation controls should apply.
        """
        if copy is not None:
            pulumi.set(__self__, "copy", copy)
        if dcp is not None:
            pulumi.set(__self__, "dcp", dcp)
        if dd is not None:
            pulumi.set(__self__, "dd", dd)
        if dk is not None:
            pulumi.set(__self__, "dk", dk)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if dp is not None:
            pulumi.set(__self__, "dp", dp)
        if du is not None:
            pulumi.set(__self__, "du", du)
        if keyboard is not None:
            pulumi.set(__self__, "keyboard", keyboard)
        if paste is not None:
            pulumi.set(__self__, "paste", paste)
        if printing is not None:
            pulumi.set(__self__, "printing", printing)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def copy(self) -> Optional[pulumi.Input[str]]:
        """
        Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "copy")

    @copy.setter
    def copy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "copy", value)

    @property
    @pulumi.getter
    def dcp(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dcp")

    @dcp.setter
    def dcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dcp", value)

    @property
    @pulumi.getter
    def dd(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dd")

    @dd.setter
    def dd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dd", value)

    @property
    @pulumi.getter
    def dk(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dk")

    @dk.setter
    def dk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dk", value)

    @property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[str]]:
        """
        Configure whether downloading enabled or not. When absent, downloading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "download", value)

    @property
    @pulumi.getter
    def dp(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dp")

    @dp.setter
    def dp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dp", value)

    @property
    @pulumi.getter
    def du(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "du")

    @du.setter
    def du(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "du", value)

    @property
    @pulumi.getter
    def keyboard(self) -> Optional[pulumi.Input[str]]:
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "keyboard")

    @keyboard.setter
    def keyboard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keyboard", value)

    @property
    @pulumi.getter
    def paste(self) -> Optional[pulumi.Input[str]]:
        """
        Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "paste")

    @paste.setter
    def paste(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "paste", value)

    @property
    @pulumi.getter
    def printing(self) -> Optional[pulumi.Input[str]]:
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "printing")

    @printing.setter
    def printing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "printing", value)

    @property
    @pulumi.getter
    def upload(self) -> Optional[pulumi.Input[str]]:
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        """
        return pulumi.get(self, "upload")

    @upload.setter
    def upload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upload", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates which version of the browser isolation controls should apply.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[str]]
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        enforce: NotRequired[pulumi.Input[bool]]
        """
        Set to true to enable session enforcement.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 enforce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] duration: Configure how fresh the session needs to be to be considered valid.
        :param pulumi.Input[bool] enforce: Set to true to enable session enforcement.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Configure how fresh the session needs to be to be considered valid.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to enable session enforcement.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict']]]]
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        IPv4 address of upstream resolver.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        route_through_private_network: NotRequired[pulumi.Input[bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 route_through_private_network: Optional[pulumi.Input[bool]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: IPv4 address of upstream resolver.
        :param pulumi.Input[int] port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param pulumi.Input[bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param pulumi.Input[str] vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IPv4 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        IPv6 address of upstream resolver.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        route_through_private_network: NotRequired[pulumi.Input[bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        vnet_id: NotRequired[pulumi.Input[str]]
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 route_through_private_network: Optional[pulumi.Input[bool]] = None,
                 vnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: IPv6 address of upstream resolver.
        :param pulumi.Input[int] port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param pulumi.Input[bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param pulumi.Input[str] vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IPv6 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[str]]
        """
        The IPv4 address to be used for egress.
        """
        ipv4_fallback: NotRequired[pulumi.Input[str]]
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        ipv6: NotRequired[pulumi.Input[str]]
        """
        The IPv6 range to be used for egress.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsEgressArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[str]] = None,
                 ipv4_fallback: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipv4: The IPv4 address to be used for egress.
        :param pulumi.Input[str] ipv4_fallback: The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        :param pulumi.Input[str] ipv6: The IPv6 range to be used for egress.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[pulumi.Input[str]]:
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @ipv4_fallback.setter
    def ipv4_fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_fallback", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        """
        IPv4 or IPv6 address.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        A port number to use for TCP/UDP overrides.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ip: IPv4 or IPv6 address.
        :param pulumi.Input[int] port: A port number to use for TCP/UDP overrides.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        A port number to use for TCP/UDP overrides.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Set notification on
        """
        msg: NotRequired[pulumi.Input[str]]
        """
        Customize the message shown in the notification.
        """
        support_url: NotRequired[pulumi.Input[str]]
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 msg: Optional[pulumi.Input[str]] = None,
                 support_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Set notification on
        :param pulumi.Input[str] msg: Customize the message shown in the notification.
        :param pulumi.Input[str] support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[str]]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msg", value)

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[str]]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Set to true to enable DLP payload logging for this rule.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Set to true to enable DLP payload logging for this rule.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to enable DLP payload logging for this rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict(TypedDict):
        file_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Types of files to sandbox.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs:
    def __init__(__self__, *,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_types: Types of files to sandbox.
        """
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types of files to sandbox.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_types", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict(TypedDict):
        fallback: NotRequired[pulumi.Input[str]]
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        view_id: NotRequired[pulumi.Input[str]]
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs:
    def __init__(__self__, *,
                 fallback: Optional[pulumi.Input[str]] = None,
                 view_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        :param pulumi.Input[str] view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if view_id is not None:
            pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter
    def fallback(self) -> Optional[pulumi.Input[str]]:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        """
        return pulumi.get(self, "fallback")

    @fallback.setter
    def fallback(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback", value)

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> Optional[pulumi.Input[str]]:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")

    @view_id.setter
    def view_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class ZeroTrustGatewayPolicyScheduleArgsDict(TypedDict):
        fri: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        mon: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        sat: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        sun: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        thu: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        tue: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        wed: NotRequired[pulumi.Input[str]]
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
elif False:
    ZeroTrustGatewayPolicyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyScheduleArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[str]] = None,
                 mon: Optional[pulumi.Input[str]] = None,
                 sat: Optional[pulumi.Input[str]] = None,
                 sun: Optional[pulumi.Input[str]] = None,
                 thu: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 tue: Optional[pulumi.Input[str]] = None,
                 wed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] fri: The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        :param pulumi.Input[str] mon: The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        :param pulumi.Input[str] sat: The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        :param pulumi.Input[str] sun: The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        :param pulumi.Input[str] thu: The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        :param pulumi.Input[str] time_zone: The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        :param pulumi.Input[str] tue: The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        :param pulumi.Input[str] wed: The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fri", value)

    @property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mon", value)

    @property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sat", value)

    @property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sun", value)

    @property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thu", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tue", value)

    @property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[str]]:
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wed", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsArgsDict(TypedDict):
        activity_log: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgsDict']]
        """
        Activity log settings.
        """
        antivirus: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgsDict']]
        """
        Anti-virus settings.
        """
        block_page: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgsDict']]
        """
        Block page layout settings.
        """
        body_scanning: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict']]
        """
        DLP body scanning settings.
        """
        browser_isolation: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict']]
        """
        Browser isolation settings.
        """
        certificate: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgsDict']]
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        custom_certificate: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict']]
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        """
        extended_email_matching: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict']]
        """
        Extended e-mail matching settings.
        """
        fips: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgsDict']]
        """
        FIPS settings.
        """
        protocol_detection: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict']]
        """
        Protocol Detection settings.
        """
        sandbox: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgsDict']]
        """
        Sandbox settings.
        """
        tls_decrypt: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict']]
        """
        TLS interception settings.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsArgs:
    def __init__(__self__, *,
                 activity_log: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs']] = None,
                 antivirus: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs']] = None,
                 block_page: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs']] = None,
                 body_scanning: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs']] = None,
                 browser_isolation: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs']] = None,
                 custom_certificate: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs']] = None,
                 extended_email_matching: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs']] = None,
                 fips: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs']] = None,
                 protocol_detection: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs']] = None,
                 sandbox: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs']] = None,
                 tls_decrypt: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs'] activity_log: Activity log settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs'] antivirus: Anti-virus settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs'] block_page: Block page layout settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs'] body_scanning: DLP body scanning settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs'] browser_isolation: Browser isolation settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs'] certificate: Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs'] custom_certificate: Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs'] extended_email_matching: Extended e-mail matching settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs'] fips: FIPS settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs'] protocol_detection: Protocol Detection settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs'] sandbox: Sandbox settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs'] tls_decrypt: TLS interception settings.
        """
        if activity_log is not None:
            pulumi.set(__self__, "activity_log", activity_log)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if block_page is not None:
            pulumi.set(__self__, "block_page", block_page)
        if body_scanning is not None:
            pulumi.set(__self__, "body_scanning", body_scanning)
        if browser_isolation is not None:
            pulumi.set(__self__, "browser_isolation", browser_isolation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if extended_email_matching is not None:
            pulumi.set(__self__, "extended_email_matching", extended_email_matching)
        if fips is not None:
            pulumi.set(__self__, "fips", fips)
        if protocol_detection is not None:
            pulumi.set(__self__, "protocol_detection", protocol_detection)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if tls_decrypt is not None:
            pulumi.set(__self__, "tls_decrypt", tls_decrypt)

    @property
    @pulumi.getter(name="activityLog")
    def activity_log(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs']]:
        """
        Activity log settings.
        """
        return pulumi.get(self, "activity_log")

    @activity_log.setter
    def activity_log(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs']]):
        pulumi.set(self, "activity_log", value)

    @property
    @pulumi.getter
    def antivirus(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs']]:
        """
        Anti-virus settings.
        """
        return pulumi.get(self, "antivirus")

    @antivirus.setter
    def antivirus(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs']]):
        pulumi.set(self, "antivirus", value)

    @property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs']]:
        """
        Block page layout settings.
        """
        return pulumi.get(self, "block_page")

    @block_page.setter
    def block_page(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs']]):
        pulumi.set(self, "block_page", value)

    @property
    @pulumi.getter(name="bodyScanning")
    def body_scanning(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs']]:
        """
        DLP body scanning settings.
        """
        return pulumi.get(self, "body_scanning")

    @body_scanning.setter
    def body_scanning(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs']]):
        pulumi.set(self, "body_scanning", value)

    @property
    @pulumi.getter(name="browserIsolation")
    def browser_isolation(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs']]:
        """
        Browser isolation settings.
        """
        return pulumi.get(self, "browser_isolation")

    @browser_isolation.setter
    def browser_isolation(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs']]):
        pulumi.set(self, "browser_isolation", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs']]:
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs']]:
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs']]):
        pulumi.set(self, "custom_certificate", value)

    @property
    @pulumi.getter(name="extendedEmailMatching")
    def extended_email_matching(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs']]:
        """
        Extended e-mail matching settings.
        """
        return pulumi.get(self, "extended_email_matching")

    @extended_email_matching.setter
    def extended_email_matching(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs']]):
        pulumi.set(self, "extended_email_matching", value)

    @property
    @pulumi.getter
    def fips(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs']]:
        """
        FIPS settings.
        """
        return pulumi.get(self, "fips")

    @fips.setter
    def fips(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs']]):
        pulumi.set(self, "fips", value)

    @property
    @pulumi.getter(name="protocolDetection")
    def protocol_detection(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs']]:
        """
        Protocol Detection settings.
        """
        return pulumi.get(self, "protocol_detection")

    @protocol_detection.setter
    def protocol_detection(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs']]):
        pulumi.set(self, "protocol_detection", value)

    @property
    @pulumi.getter
    def sandbox(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs']]:
        """
        Sandbox settings.
        """
        return pulumi.get(self, "sandbox")

    @sandbox.setter
    def sandbox(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs']]):
        pulumi.set(self, "sandbox", value)

    @property
    @pulumi.getter(name="tlsDecrypt")
    def tls_decrypt(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs']]:
        """
        TLS interception settings.
        """
        return pulumi.get(self, "tls_decrypt")

    @tls_decrypt.setter
    def tls_decrypt(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs']]):
        pulumi.set(self, "tls_decrypt", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsActivityLogArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable activity logging.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsActivityLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsActivityLogArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable activity logging.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable activity logging.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsAntivirusArgsDict(TypedDict):
        enabled_download_phase: NotRequired[pulumi.Input[bool]]
        """
        Enable anti-virus scanning on downloads.
        """
        enabled_upload_phase: NotRequired[pulumi.Input[bool]]
        """
        Enable anti-virus scanning on uploads.
        """
        fail_closed: NotRequired[pulumi.Input[bool]]
        """
        Block requests for files that cannot be scanned.
        """
        notification_settings: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict']]
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsAntivirusArgs:
    def __init__(__self__, *,
                 enabled_download_phase: Optional[pulumi.Input[bool]] = None,
                 enabled_upload_phase: Optional[pulumi.Input[bool]] = None,
                 fail_closed: Optional[pulumi.Input[bool]] = None,
                 notification_settings: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs']] = None):
        """
        :param pulumi.Input[bool] enabled_download_phase: Enable anti-virus scanning on downloads.
        :param pulumi.Input[bool] enabled_upload_phase: Enable anti-virus scanning on uploads.
        :param pulumi.Input[bool] fail_closed: Block requests for files that cannot be scanned.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs'] notification_settings: Configure a message to display on the user's device when an antivirus search is performed.
        """
        if enabled_download_phase is not None:
            pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        if enabled_upload_phase is not None:
            pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        if fail_closed is not None:
            pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable anti-virus scanning on downloads.
        """
        return pulumi.get(self, "enabled_download_phase")

    @enabled_download_phase.setter
    def enabled_download_phase(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled_download_phase", value)

    @property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable anti-virus scanning on uploads.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @enabled_upload_phase.setter
    def enabled_upload_phase(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled_upload_phase", value)

    @property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> Optional[pulumi.Input[bool]]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @fail_closed.setter
    def fail_closed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_closed", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs']]:
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Set notification on
        """
        msg: NotRequired[pulumi.Input[str]]
        """
        Customize the message shown in the notification.
        """
        support_url: NotRequired[pulumi.Input[str]]
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 msg: Optional[pulumi.Input[str]] = None,
                 support_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Set notification on
        :param pulumi.Input[str] msg: Customize the message shown in the notification.
        :param pulumi.Input[str] support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Set notification on
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[str]]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msg", value)

    @property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[str]]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsBlockPageArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        Block page background color in #rrggbb format.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        footer_text: NotRequired[pulumi.Input[str]]
        """
        Block page footer text.
        """
        header_text: NotRequired[pulumi.Input[str]]
        """
        Block page header text.
        """
        logo_path: NotRequired[pulumi.Input[str]]
        """
        Full URL to the logo file.
        """
        mailto_address: NotRequired[pulumi.Input[str]]
        """
        Admin email for users to contact.
        """
        mailto_subject: NotRequired[pulumi.Input[str]]
        """
        Subject line for emails created from block page.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Block page title.
        """
        suppress_footer: NotRequired[pulumi.Input[bool]]
        """
        Suppress detailed info at the bottom of the block page.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsBlockPageArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 mailto_address: Optional[pulumi.Input[str]] = None,
                 mailto_subject: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 suppress_footer: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] background_color: Block page background color in #rrggbb format.
        :param pulumi.Input[bool] enabled: Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        :param pulumi.Input[str] footer_text: Block page footer text.
        :param pulumi.Input[str] header_text: Block page header text.
        :param pulumi.Input[str] logo_path: Full URL to the logo file.
        :param pulumi.Input[str] mailto_address: Admin email for users to contact.
        :param pulumi.Input[str] mailto_subject: Subject line for emails created from block page.
        :param pulumi.Input[str] name: Block page title.
        :param pulumi.Input[bool] suppress_footer: Suppress detailed info at the bottom of the block page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if suppress_footer is not None:
            pulumi.set(__self__, "suppress_footer", suppress_footer)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        Block page background color in #rrggbb format.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        Block page header text.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        Full URL to the logo file.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[pulumi.Input[str]]:
        """
        Admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @mailto_address.setter
    def mailto_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_address", value)

    @property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @mailto_subject.setter
    def mailto_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mailto_subject", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Block page title.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="suppressFooter")
    def suppress_footer(self) -> Optional[pulumi.Input[bool]]:
        """
        Suppress detailed info at the bottom of the block page.
        """
        return pulumi.get(self, "suppress_footer")

    @suppress_footer.setter
    def suppress_footer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress_footer", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict(TypedDict):
        inspection_mode: NotRequired[pulumi.Input[str]]
        """
        Set the inspection mode to either `deep` or `shallow`.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsBodyScanningArgs:
    def __init__(__self__, *,
                 inspection_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] inspection_mode: Set the inspection mode to either `deep` or `shallow`.
        """
        if inspection_mode is not None:
            pulumi.set(__self__, "inspection_mode", inspection_mode)

    @property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Set the inspection mode to either `deep` or `shallow`.
        """
        return pulumi.get(self, "inspection_mode")

    @inspection_mode.setter
    def inspection_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inspection_mode", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict(TypedDict):
        non_identity_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        url_browser_isolation_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable Clientless Browser Isolation.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs:
    def __init__(__self__, *,
                 non_identity_enabled: Optional[pulumi.Input[bool]] = None,
                 url_browser_isolation_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] non_identity_enabled: Enable non-identity onramp support for Browser Isolation.
        :param pulumi.Input[bool] url_browser_isolation_enabled: Enable Clientless Browser Isolation.
        """
        if non_identity_enabled is not None:
            pulumi.set(__self__, "non_identity_enabled", non_identity_enabled)
        if url_browser_isolation_enabled is not None:
            pulumi.set(__self__, "url_browser_isolation_enabled", url_browser_isolation_enabled)

    @property
    @pulumi.getter(name="nonIdentityEnabled")
    def non_identity_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        return pulumi.get(self, "non_identity_enabled")

    @non_identity_enabled.setter
    def non_identity_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "non_identity_enabled", value)

    @property
    @pulumi.getter(name="urlBrowserIsolationEnabled")
    def url_browser_isolation_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Clientless Browser Isolation.
        """
        return pulumi.get(self, "url_browser_isolation_enabled")

    @url_browser_isolation_enabled.setter
    def url_browser_isolation_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "url_browser_isolation_enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsCertificateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsCertificateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Enable use of custom certificate authority for signing Gateway traffic.
        """
        binding_status: NotRequired[pulumi.Input[str]]
        """
        Certificate status (internal).
        """
        id: NotRequired[pulumi.Input[str]]
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        updated_at: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsCustomCertificateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 binding_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable use of custom certificate authority for signing Gateway traffic.
        :param pulumi.Input[str] binding_status: Certificate status (internal).
        :param pulumi.Input[str] id: UUID of certificate (ID from MTLS certificate store).
        """
        pulumi.set(__self__, "enabled", enabled)
        if binding_status is not None:
            pulumi.set(__self__, "binding_status", binding_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable use of custom certificate authority for signing Gateway traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="bindingStatus")
    def binding_status(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate status (internal).
        """
        return pulumi.get(self, "binding_status")

    @binding_status.setter
    def binding_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "binding_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsFipsArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input[bool]]
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsFipsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsFipsArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] tls: Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS 140-2.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable detecting protocol on initial bytes of client traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsSandboxArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable sandbox.
        """
        fallback_action: NotRequired[pulumi.Input[str]]
        """
        Action to take when the file cannot be scanned.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsSandboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsSandboxArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fallback_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable sandbox.
        :param pulumi.Input[str] fallback_action: Action to take when the file cannot be scanned.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable sandbox.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take when the file cannot be scanned.
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_action", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable inspecting encrypted HTTP traffic.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsTlsDecryptArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable inspecting encrypted HTTP traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable inspecting encrypted HTTP traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustListItemArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the list item, if present
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the item in a list.
        """
elif False:
    ZeroTrustListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustListItemArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: The description of the list item, if present
        :param pulumi.Input[str] value: The value of the item in a list.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the list item, if present
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the item in a list.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ZeroTrustOrganizationCustomPagesArgsDict(TypedDict):
        forbidden: NotRequired[pulumi.Input[str]]
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        identity_denied: NotRequired[pulumi.Input[str]]
        """
        The uid of the custom page to use when a user is denied access.
        """
elif False:
    ZeroTrustOrganizationCustomPagesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustOrganizationCustomPagesArgs:
    def __init__(__self__, *,
                 forbidden: Optional[pulumi.Input[str]] = None,
                 identity_denied: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] forbidden: The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        :param pulumi.Input[str] identity_denied: The uid of the custom page to use when a user is denied access.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @property
    @pulumi.getter
    def forbidden(self) -> Optional[pulumi.Input[str]]:
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        return pulumi.get(self, "forbidden")

    @forbidden.setter
    def forbidden(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forbidden", value)

    @property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[pulumi.Input[str]]:
        """
        The uid of the custom page to use when a user is denied access.
        """
        return pulumi.get(self, "identity_denied")

    @identity_denied.setter
    def identity_denied(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_denied", value)


if not MYPY:
    class ZeroTrustOrganizationLoginDesignArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[str]]
        """
        The background color on your login page.
        """
        footer_text: NotRequired[pulumi.Input[str]]
        """
        The text at the bottom of your login page.
        """
        header_text: NotRequired[pulumi.Input[str]]
        """
        The text at the top of your login page.
        """
        logo_path: NotRequired[pulumi.Input[str]]
        """
        The URL of the logo on your login page.
        """
        text_color: NotRequired[pulumi.Input[str]]
        """
        The text color on your login page.
        """
elif False:
    ZeroTrustOrganizationLoginDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustOrganizationLoginDesignArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[str]] = None,
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None,
                 logo_path: Optional[pulumi.Input[str]] = None,
                 text_color: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] background_color: The background color on your login page.
        :param pulumi.Input[str] footer_text: The text at the bottom of your login page.
        :param pulumi.Input[str] header_text: The text at the top of your login page.
        :param pulumi.Input[str] logo_path: The URL of the logo on your login page.
        :param pulumi.Input[str] text_color: The text color on your login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color on your login page.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the bottom of your login page.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        The text at the top of your login page.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)

    @property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the logo on your login page.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo_path", value)

    @property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[str]]:
        """
        The text color on your login page.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_color", value)


if not MYPY:
    class ZeroTrustRiskBehaviorBehaviorsArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        risk_level: pulumi.Input[str]
elif False:
    ZeroTrustRiskBehaviorBehaviorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustRiskBehaviorBehaviorsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 risk_level: pulumi.Input[str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[str]:
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigArgsDict(TypedDict):
        ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict']]]]
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        origin_request: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict']]
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        warp_routing: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict']]
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigArgs:
    def __init__(__self__, *,
                 ingresses: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]]] = None,
                 origin_request: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']] = None,
                 warp_routing: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]] ingresses: List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs'] origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs'] warp_routing: Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        if ingresses is not None:
            pulumi.set(__self__, "ingresses", ingresses)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @property
    @pulumi.getter
    def ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]]]:
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        return pulumi.get(self, "ingresses")

    @ingresses.setter
    def ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]]]):
        pulumi.set(self, "ingresses", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']]:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']]:
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        return pulumi.get(self, "warp_routing")

    @warp_routing.setter
    def warp_routing(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']]):
        pulumi.set(self, "warp_routing", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict(TypedDict):
        service: pulumi.Input[str]
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Public hostname for this service.
        """
        origin_request: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict']]
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Requests with this path route to this public hostname.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 hostname: Optional[pulumi.Input[str]] = None,
                 origin_request: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        :param pulumi.Input[str] hostname: Public hostname for this service.
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs'] origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param pulumi.Input[str] path: Requests with this path route to this public hostname.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Public hostname for this service.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs']]:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Requests with this path route to this public hostname.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict']]
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        ca_pool: NotRequired[pulumi.Input[str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        connect_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        http2_origin: NotRequired[pulumi.Input[bool]]
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        http_host_header: NotRequired[pulumi.Input[str]]
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        origin_server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        proxy_type: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[int]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        tls_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs']] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[int]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[int]] = None,
                 tls_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs'] access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param pulumi.Input[int] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param pulumi.Input[bool] http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param pulumi.Input[int] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param pulumi.Input[int] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param pulumi.Input[int] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs']]:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict(TypedDict):
        aud_tags: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        team_name: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: pulumi.Input[Sequence[pulumi.Input[str]]],
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param pulumi.Input[bool] required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict']]
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        ca_pool: NotRequired[pulumi.Input[str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        connect_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        http2_origin: NotRequired[pulumi.Input[bool]]
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        http_host_header: NotRequired[pulumi.Input[str]]
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        origin_server_name: NotRequired[pulumi.Input[str]]
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        proxy_type: NotRequired[pulumi.Input[str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[int]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        tls_timeout: NotRequired[pulumi.Input[int]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']] = None,
                 ca_pool: Optional[pulumi.Input[str]] = None,
                 connect_timeout: Optional[pulumi.Input[int]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[bool]] = None,
                 http2_origin: Optional[pulumi.Input[bool]] = None,
                 http_host_header: Optional[pulumi.Input[str]] = None,
                 keep_alive_connections: Optional[pulumi.Input[int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[int]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None,
                 origin_server_name: Optional[pulumi.Input[str]] = None,
                 proxy_type: Optional[pulumi.Input[str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[int]] = None,
                 tls_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs'] access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param pulumi.Input[str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param pulumi.Input[int] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param pulumi.Input[bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param pulumi.Input[bool] http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param pulumi.Input[str] http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param pulumi.Input[int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param pulumi.Input[int] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param pulumi.Input[bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param pulumi.Input[bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param pulumi.Input[str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param pulumi.Input[str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param pulumi.Input[int] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param pulumi.Input[int] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']]:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_pool", value)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[bool]]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http2_origin", value)

    @property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_host_header", value)

    @property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_server_name", value)

    @property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_type", value)

    @property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict(TypedDict):
        aud_tags: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        team_name: NotRequired[pulumi.Input[str]]
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: pulumi.Input[Sequence[pulumi.Input[str]]],
                 required: Optional[pulumi.Input[bool]] = None,
                 team_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param pulumi.Input[bool] required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)

    @property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "aud_tags", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConnectionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[str]]
        """
        UUID of the Cloudflare Tunnel connector.
        """
        client_version: NotRequired[pulumi.Input[str]]
        """
        The cloudflared version used to establish this connection.
        """
        colo_name: NotRequired[pulumi.Input[str]]
        """
        The Cloudflare data center used for this connection.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
        is_pending_reconnect: NotRequired[pulumi.Input[bool]]
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        opened_at: NotRequired[pulumi.Input[str]]
        """
        Timestamp of when the connection was established.
        """
        origin_ip: NotRequired[pulumi.Input[str]]
        """
        The public IP address of the host running cloudflared.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
elif False:
    ZeroTrustTunnelCloudflaredConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConnectionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_version: Optional[pulumi.Input[str]] = None,
                 colo_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_pending_reconnect: Optional[pulumi.Input[bool]] = None,
                 opened_at: Optional[pulumi.Input[str]] = None,
                 origin_ip: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: UUID of the Cloudflare Tunnel connector.
        :param pulumi.Input[str] client_version: The cloudflared version used to establish this connection.
        :param pulumi.Input[str] colo_name: The Cloudflare data center used for this connection.
        :param pulumi.Input[str] id: UUID of the Cloudflare Tunnel connection.
        :param pulumi.Input[bool] is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param pulumi.Input[str] opened_at: Timestamp of when the connection was established.
        :param pulumi.Input[str] origin_ip: The public IP address of the host running cloudflared.
        :param pulumi.Input[str] uuid: UUID of the Cloudflare Tunnel connection.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_version is not None:
            pulumi.set(__self__, "client_version", client_version)
        if colo_name is not None:
            pulumi.set(__self__, "colo_name", colo_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_pending_reconnect is not None:
            pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        if opened_at is not None:
            pulumi.set(__self__, "opened_at", opened_at)
        if origin_ip is not None:
            pulumi.set(__self__, "origin_ip", origin_ip)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> Optional[pulumi.Input[str]]:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @client_version.setter
    def client_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_version", value)

    @property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @colo_name.setter
    def colo_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "colo_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> Optional[pulumi.Input[bool]]:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @is_pending_reconnect.setter
    def is_pending_reconnect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pending_reconnect", value)

    @property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @opened_at.setter
    def opened_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opened_at", value)

    @property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @origin_ip.setter
    def origin_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_ip", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ZoneAccountArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier
        """
elif False:
    ZoneAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneAccountArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Identifier
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZoneCacheVariantsValueArgsDict(TypedDict):
        avifs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for avif.
        """
        bmps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for bmp.
        """
        gifs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for gif.
        """
        jp2s: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jp2.
        """
        jpegs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jpeg.
        """
        jpg2s: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jpg2.
        """
        jpgs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jpg.
        """
        pngs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for png.
        """
        tiffs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for tiff.
        """
        tifs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for tif.
        """
        webps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for webp.
        """
elif False:
    ZoneCacheVariantsValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneCacheVariantsValueArgs:
    def __init__(__self__, *,
                 avifs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 bmps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gifs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jp2s: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jpegs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jpg2s: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jpgs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pngs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tiffs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tifs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 webps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] avifs: List of strings with the MIME types of all the variants that should be served for avif.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] bmps: List of strings with the MIME types of all the variants that should be served for bmp.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gifs: List of strings with the MIME types of all the variants that should be served for gif.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jp2s: List of strings with the MIME types of all the variants that should be served for jp2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jpegs: List of strings with the MIME types of all the variants that should be served for jpeg.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jpg2s: List of strings with the MIME types of all the variants that should be served for jpg2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jpgs: List of strings with the MIME types of all the variants that should be served for jpg.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pngs: List of strings with the MIME types of all the variants that should be served for png.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tiffs: List of strings with the MIME types of all the variants that should be served for tiff.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tifs: List of strings with the MIME types of all the variants that should be served for tif.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] webps: List of strings with the MIME types of all the variants that should be served for webp.
        """
        if avifs is not None:
            pulumi.set(__self__, "avifs", avifs)
        if bmps is not None:
            pulumi.set(__self__, "bmps", bmps)
        if gifs is not None:
            pulumi.set(__self__, "gifs", gifs)
        if jp2s is not None:
            pulumi.set(__self__, "jp2s", jp2s)
        if jpegs is not None:
            pulumi.set(__self__, "jpegs", jpegs)
        if jpg2s is not None:
            pulumi.set(__self__, "jpg2s", jpg2s)
        if jpgs is not None:
            pulumi.set(__self__, "jpgs", jpgs)
        if pngs is not None:
            pulumi.set(__self__, "pngs", pngs)
        if tiffs is not None:
            pulumi.set(__self__, "tiffs", tiffs)
        if tifs is not None:
            pulumi.set(__self__, "tifs", tifs)
        if webps is not None:
            pulumi.set(__self__, "webps", webps)

    @property
    @pulumi.getter
    def avifs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for avif.
        """
        return pulumi.get(self, "avifs")

    @avifs.setter
    def avifs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "avifs", value)

    @property
    @pulumi.getter
    def bmps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for bmp.
        """
        return pulumi.get(self, "bmps")

    @bmps.setter
    def bmps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "bmps", value)

    @property
    @pulumi.getter
    def gifs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for gif.
        """
        return pulumi.get(self, "gifs")

    @gifs.setter
    def gifs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gifs", value)

    @property
    @pulumi.getter
    def jp2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jp2.
        """
        return pulumi.get(self, "jp2s")

    @jp2s.setter
    def jp2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jp2s", value)

    @property
    @pulumi.getter
    def jpegs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpeg.
        """
        return pulumi.get(self, "jpegs")

    @jpegs.setter
    def jpegs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jpegs", value)

    @property
    @pulumi.getter
    def jpg2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpg2.
        """
        return pulumi.get(self, "jpg2s")

    @jpg2s.setter
    def jpg2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jpg2s", value)

    @property
    @pulumi.getter
    def jpgs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpg.
        """
        return pulumi.get(self, "jpgs")

    @jpgs.setter
    def jpgs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jpgs", value)

    @property
    @pulumi.getter
    def pngs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for png.
        """
        return pulumi.get(self, "pngs")

    @pngs.setter
    def pngs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pngs", value)

    @property
    @pulumi.getter
    def tiffs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for tiff.
        """
        return pulumi.get(self, "tiffs")

    @tiffs.setter
    def tiffs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tiffs", value)

    @property
    @pulumi.getter
    def tifs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for tif.
        """
        return pulumi.get(self, "tifs")

    @tifs.setter
    def tifs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tifs", value)

    @property
    @pulumi.getter
    def webps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for webp.
        """
        return pulumi.get(self, "webps")

    @webps.setter
    def webps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "webps", value)


if not MYPY:
    class ZoneLockdownConfigurationArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[str]]
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
elif False:
    ZoneLockdownConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneLockdownConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        :param pulumi.Input[str] value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ZoneMetaArgsDict(TypedDict):
        cdn_only: NotRequired[pulumi.Input[bool]]
        """
        The zone is only configured for CDN
        """
        custom_certificate_quota: NotRequired[pulumi.Input[int]]
        """
        Number of Custom Certificates the zone can have
        """
        dns_only: NotRequired[pulumi.Input[bool]]
        """
        The zone is only configured for DNS
        """
        foundation_dns: NotRequired[pulumi.Input[bool]]
        """
        The zone is setup with Foundation DNS
        """
        page_rule_quota: NotRequired[pulumi.Input[int]]
        """
        Number of Page Rules a zone can have
        """
        phishing_detected: NotRequired[pulumi.Input[bool]]
        """
        The zone has been flagged for phishing
        """
        step: NotRequired[pulumi.Input[int]]
elif False:
    ZoneMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneMetaArgs:
    def __init__(__self__, *,
                 cdn_only: Optional[pulumi.Input[bool]] = None,
                 custom_certificate_quota: Optional[pulumi.Input[int]] = None,
                 dns_only: Optional[pulumi.Input[bool]] = None,
                 foundation_dns: Optional[pulumi.Input[bool]] = None,
                 page_rule_quota: Optional[pulumi.Input[int]] = None,
                 phishing_detected: Optional[pulumi.Input[bool]] = None,
                 step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] cdn_only: The zone is only configured for CDN
        :param pulumi.Input[int] custom_certificate_quota: Number of Custom Certificates the zone can have
        :param pulumi.Input[bool] dns_only: The zone is only configured for DNS
        :param pulumi.Input[bool] foundation_dns: The zone is setup with Foundation DNS
        :param pulumi.Input[int] page_rule_quota: Number of Page Rules a zone can have
        :param pulumi.Input[bool] phishing_detected: The zone has been flagged for phishing
        """
        if cdn_only is not None:
            pulumi.set(__self__, "cdn_only", cdn_only)
        if custom_certificate_quota is not None:
            pulumi.set(__self__, "custom_certificate_quota", custom_certificate_quota)
        if dns_only is not None:
            pulumi.set(__self__, "dns_only", dns_only)
        if foundation_dns is not None:
            pulumi.set(__self__, "foundation_dns", foundation_dns)
        if page_rule_quota is not None:
            pulumi.set(__self__, "page_rule_quota", page_rule_quota)
        if phishing_detected is not None:
            pulumi.set(__self__, "phishing_detected", phishing_detected)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @property
    @pulumi.getter(name="cdnOnly")
    def cdn_only(self) -> Optional[pulumi.Input[bool]]:
        """
        The zone is only configured for CDN
        """
        return pulumi.get(self, "cdn_only")

    @cdn_only.setter
    def cdn_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cdn_only", value)

    @property
    @pulumi.getter(name="customCertificateQuota")
    def custom_certificate_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Number of Custom Certificates the zone can have
        """
        return pulumi.get(self, "custom_certificate_quota")

    @custom_certificate_quota.setter
    def custom_certificate_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_certificate_quota", value)

    @property
    @pulumi.getter(name="dnsOnly")
    def dns_only(self) -> Optional[pulumi.Input[bool]]:
        """
        The zone is only configured for DNS
        """
        return pulumi.get(self, "dns_only")

    @dns_only.setter
    def dns_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dns_only", value)

    @property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> Optional[pulumi.Input[bool]]:
        """
        The zone is setup with Foundation DNS
        """
        return pulumi.get(self, "foundation_dns")

    @foundation_dns.setter
    def foundation_dns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "foundation_dns", value)

    @property
    @pulumi.getter(name="pageRuleQuota")
    def page_rule_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Number of Page Rules a zone can have
        """
        return pulumi.get(self, "page_rule_quota")

    @page_rule_quota.setter
    def page_rule_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_rule_quota", value)

    @property
    @pulumi.getter(name="phishingDetected")
    def phishing_detected(self) -> Optional[pulumi.Input[bool]]:
        """
        The zone has been flagged for phishing
        """
        return pulumi.get(self, "phishing_detected")

    @phishing_detected.setter
    def phishing_detected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "phishing_detected", value)

    @property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "step", value)


if not MYPY:
    class ZoneOwnerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Identifier
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the owner
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of owner
        """
elif False:
    ZoneOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneOwnerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Identifier
        :param pulumi.Input[str] name: Name of the owner
        :param pulumi.Input[str] type: The type of owner
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the owner
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of owner
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZoneSubscriptionRatePlanArgsDict(TypedDict):
        currency: NotRequired[pulumi.Input[str]]
        """
        The currency applied to the rate plan subscription.
        """
        externally_managed: NotRequired[pulumi.Input[bool]]
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the rate plan.
        """
        is_contract: NotRequired[pulumi.Input[bool]]
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        public_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the rate plan.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The scope that this rate plan applies to.
        """
        sets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of sets this rate plan applies to.
        """
elif False:
    ZoneSubscriptionRatePlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSubscriptionRatePlanArgs:
    def __init__(__self__, *,
                 currency: Optional[pulumi.Input[str]] = None,
                 externally_managed: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_contract: Optional[pulumi.Input[bool]] = None,
                 public_name: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] currency: The currency applied to the rate plan subscription.
        :param pulumi.Input[bool] externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param pulumi.Input[str] id: The ID of the rate plan.
        :param pulumi.Input[bool] is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param pulumi.Input[str] public_name: The full name of the rate plan.
        :param pulumi.Input[str] scope: The scope that this rate plan applies to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sets: The list of sets this rate plan applies to.
        """
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_contract is not None:
            pulumi.set(__self__, "is_contract", is_contract)
        if public_name is not None:
            pulumi.set(__self__, "public_name", public_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[str]]:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @externally_managed.setter
    def externally_managed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "externally_managed", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the rate plan.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @is_contract.setter
    def is_contract(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contract", value)

    @property
    @pulumi.getter(name="publicName")
    def public_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @public_name.setter
    def public_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_name", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")

    @sets.setter
    def sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sets", value)


if not MYPY:
    class GetAccessRuleFilterArgsDict(TypedDict):
        match: str
        """
        When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        """
        configuration: NotRequired['GetAccessRuleFilterConfigurationArgsDict']
        direction: NotRequired[str]
        """
        The direction used to sort returned rules.
        """
        mode: NotRequired[str]
        """
        The action to apply to a matched request.
        """
        notes: NotRequired[str]
        """
        The string to search for in the notes of existing IP Access rules.
        Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        """
        order: NotRequired[str]
        """
        The field used to sort returned rules.
        """
elif False:
    GetAccessRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessRuleFilterArgs:
    def __init__(__self__, *,
                 match: str,
                 configuration: Optional['GetAccessRuleFilterConfigurationArgs'] = None,
                 direction: Optional[str] = None,
                 mode: Optional[str] = None,
                 notes: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str match: When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        :param str direction: The direction used to sort returned rules.
        :param str mode: The action to apply to a matched request.
        :param str notes: The string to search for in the notes of existing IP Access rules.
               Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        :param str order: The field used to sort returned rules.
        """
        pulumi.set(__self__, "match", match)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: str):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['GetAccessRuleFilterConfigurationArgs']:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional['GetAccessRuleFilterConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction used to sort returned rules.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The action to apply to a matched request.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        """
        The string to search for in the notes of existing IP Access rules.
        Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[str]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field used to sort returned rules.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetAccessRuleFilterConfigurationArgsDict(TypedDict):
        target: NotRequired[str]
        """
        The target to search in existing rules.
        """
        value: NotRequired[str]
        """
        The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
elif False:
    GetAccessRuleFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessRuleFilterConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The target to search in existing rules.
        :param str value: The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
               Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target to search in existing rules.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAccessRulesConfigurationArgsDict(TypedDict):
        target: NotRequired[str]
        """
        The target to search in existing rules.
        """
        value: NotRequired[str]
        """
        The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
elif False:
    GetAccessRulesConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessRulesConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str target: The target to search in existing rules.
        :param str value: The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
               Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target to search in existing rules.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAccountFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order results.
        """
        name: NotRequired[str]
        """
        Name of the account.
        """
elif False:
    GetAccountFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        :param str name: Name of the account.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetAccountMemberFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order results.
        """
        order: NotRequired[str]
        """
        Field to order results by.
        """
        status: NotRequired[str]
        """
        A member's status in the account.
        """
elif False:
    GetAccountMemberFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountMemberFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        :param str order: Field to order results by.
        :param str status: A member's status in the account.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order results by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        A member's status in the account.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetAccountTokenFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order results.
        """
elif False:
    GetAccountTokenFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountTokenFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetApiShieldOperationFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order results.
        """
        endpoint: NotRequired[str]
        """
        Filter results to only include endpoints containing this pattern.
        """
        features: NotRequired[Sequence[str]]
        """
        Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        """
        hosts: NotRequired[Sequence[str]]
        """
        Filter results to only include the specified hosts.
        """
        methods: NotRequired[Sequence[str]]
        """
        Filter results to only include the specified HTTP methods.
        """
        order: NotRequired[str]
        """
        Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        """
elif False:
    GetApiShieldOperationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiShieldOperationFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 features: Optional[Sequence[str]] = None,
                 hosts: Optional[Sequence[str]] = None,
                 methods: Optional[Sequence[str]] = None,
                 order: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        :param str endpoint: Filter results to only include endpoints containing this pattern.
        :param Sequence[str] features: Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        :param Sequence[str] hosts: Filter results to only include the specified hosts.
        :param Sequence[str] methods: Filter results to only include the specified HTTP methods.
        :param str order: Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Filter results to only include endpoints containing this pattern.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def features(self) -> Optional[Sequence[str]]:
        """
        Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        """
        return pulumi.get(self, "features")

    @features.setter
    def features(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "features", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        Filter results to only include the specified hosts.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[str]]:
        """
        Filter results to only include the specified HTTP methods.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetApiTokenFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order results.
        """
elif False:
    GetApiTokenFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiTokenFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None):
        """
        :param str direction: Direction to order results.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order results.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetCustomHostnameFilterArgsDict(TypedDict):
        order: str
        """
        Field to order hostnames by.
        """
        direction: NotRequired[str]
        """
        Direction to order hostnames.
        """
        hostname: NotRequired[str]
        """
        Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        """
        id: NotRequired[str]
        """
        Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        """
        ssl: NotRequired[float]
        """
        Whether to filter hostnames based on if they have SSL enabled.
        """
elif False:
    GetCustomHostnameFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCustomHostnameFilterArgs:
    def __init__(__self__, *,
                 order: str,
                 direction: Optional[str] = None,
                 hostname: Optional[str] = None,
                 id: Optional[str] = None,
                 ssl: Optional[float] = None):
        """
        :param str order: Field to order hostnames by.
        :param str direction: Direction to order hostnames.
        :param str hostname: Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        :param str id: Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        :param float ssl: Whether to filter hostnames based on if they have SSL enabled.
        """
        pulumi.set(__self__, "order", order)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Field to order hostnames by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: str):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order hostnames.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[float]:
        """
        Whether to filter hostnames based on if they have SSL enabled.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[float]):
        pulumi.set(self, "ssl", value)


if not MYPY:
    class GetCustomSslFilterArgsDict(TypedDict):
        match: str
        """
        Whether to match all search requirements or at least one (any).
        """
        status: NotRequired[str]
        """
        Status of the zone's custom SSL.
        """
elif False:
    GetCustomSslFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCustomSslFilterArgs:
    def __init__(__self__, *,
                 match: str,
                 status: Optional[str] = None):
        """
        :param str match: Whether to match all search requirements or at least one (any).
        :param str status: Status of the zone's custom SSL.
        """
        pulumi.set(__self__, "match", match)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any).
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: str):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the zone's custom SSL.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetD1DatabaseFilterArgsDict(TypedDict):
        name: NotRequired[str]
        """
        a database name to search for.
        """
elif False:
    GetD1DatabaseFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetD1DatabaseFilterArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: a database name to search for.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        a database name to search for.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetDnsRecordFilterArgsDict(TypedDict):
        direction: str
        """
        Direction to order DNS records in.
        """
        match: str
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        """
        order: str
        """
        Field to order DNS records by.
        """
        proxied: bool
        """
        Whether the record is receiving the performance and security benefits of Cloudflare.
        """
        tag_match: str
        """
        Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        """
        comment: NotRequired['GetDnsRecordFilterCommentArgsDict']
        content: NotRequired['GetDnsRecordFilterContentArgsDict']
        name: NotRequired['GetDnsRecordFilterNameArgsDict']
        search: NotRequired[str]
        """
        Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        """
        tag: NotRequired['GetDnsRecordFilterTagArgsDict']
        type: NotRequired[str]
        """
        Record type.
        """
elif False:
    GetDnsRecordFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterArgs:
    def __init__(__self__, *,
                 direction: str,
                 match: str,
                 order: str,
                 proxied: bool,
                 tag_match: str,
                 comment: Optional['GetDnsRecordFilterCommentArgs'] = None,
                 content: Optional['GetDnsRecordFilterContentArgs'] = None,
                 name: Optional['GetDnsRecordFilterNameArgs'] = None,
                 search: Optional[str] = None,
                 tag: Optional['GetDnsRecordFilterTagArgs'] = None,
                 type: Optional[str] = None):
        """
        :param str direction: Direction to order DNS records in.
        :param str match: Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        :param str order: Field to order DNS records by.
        :param bool proxied: Whether the record is receiving the performance and security benefits of Cloudflare.
        :param str tag_match: Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        :param str search: Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        :param str type: Record type.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "proxied", proxied)
        pulumi.set(__self__, "tag_match", tag_match)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction to order DNS records in.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: str):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: str):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Field to order DNS records by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: str):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def proxied(self) -> bool:
        """
        Whether the record is receiving the performance and security benefits of Cloudflare.
        """
        return pulumi.get(self, "proxied")

    @proxied.setter
    def proxied(self, value: bool):
        pulumi.set(self, "proxied", value)

    @property
    @pulumi.getter(name="tagMatch")
    def tag_match(self) -> str:
        """
        Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        """
        return pulumi.get(self, "tag_match")

    @tag_match.setter
    def tag_match(self, value: str):
        pulumi.set(self, "tag_match", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional['GetDnsRecordFilterCommentArgs']:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional['GetDnsRecordFilterCommentArgs']):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def content(self) -> Optional['GetDnsRecordFilterContentArgs']:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional['GetDnsRecordFilterContentArgs']):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def name(self) -> Optional['GetDnsRecordFilterNameArgs']:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional['GetDnsRecordFilterNameArgs']):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional['GetDnsRecordFilterTagArgs']:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional['GetDnsRecordFilterTagArgs']):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Record type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetDnsRecordFilterCommentArgsDict(TypedDict):
        absent: NotRequired[str]
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        contains: NotRequired[str]
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        present: NotRequired[str]
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterCommentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterCommentArgs:
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: If this parameter is present, only records *without* a comment are returned.
        :param str contains: Substring of the DNS record comment. Comment filters are case-insensitive.
        :param str endswith: Suffix of the DNS record comment. Comment filters are case-insensitive.
        :param str exact: Exact value of the DNS record comment. Comment filters are case-insensitive.
        :param str present: If this parameter is present, only records *with* a comment are returned.
        :param str startswith: Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[str]):
        pulumi.set(self, "absent", value)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[str]):
        pulumi.set(self, "present", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordFilterContentArgsDict(TypedDict):
        contains: NotRequired[str]
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterContentArgs:
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record content. Content filters are case-insensitive.
        :param str endswith: Suffix of the DNS record content. Content filters are case-insensitive.
        :param str exact: Exact value of the DNS record content. Content filters are case-insensitive.
        :param str startswith: Prefix of the DNS record content. Content filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordFilterNameArgsDict(TypedDict):
        contains: NotRequired[str]
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterNameArgs:
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record name. Name filters are case-insensitive.
        :param str endswith: Suffix of the DNS record name. Name filters are case-insensitive.
        :param str exact: Exact value of the DNS record name. Name filters are case-insensitive.
        :param str startswith: Prefix of the DNS record name. Name filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordFilterTagArgsDict(TypedDict):
        absent: NotRequired[str]
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        contains: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        present: NotRequired[str]
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        startswith: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterTagArgs:
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        :param str contains: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        :param str endswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        :param str exact: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        :param str present: Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        :param str startswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[str]):
        pulumi.set(self, "absent", value)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[str]):
        pulumi.set(self, "present", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsCommentArgsDict(TypedDict):
        absent: NotRequired[str]
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        contains: NotRequired[str]
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        present: NotRequired[str]
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
elif False:
    GetDnsRecordsCommentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsCommentArgs:
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: If this parameter is present, only records *without* a comment are returned.
        :param str contains: Substring of the DNS record comment. Comment filters are case-insensitive.
        :param str endswith: Suffix of the DNS record comment. Comment filters are case-insensitive.
        :param str exact: Exact value of the DNS record comment. Comment filters are case-insensitive.
        :param str present: If this parameter is present, only records *with* a comment are returned.
        :param str startswith: Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[str]):
        pulumi.set(self, "absent", value)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[str]):
        pulumi.set(self, "present", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsContentArgsDict(TypedDict):
        contains: NotRequired[str]
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
elif False:
    GetDnsRecordsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsContentArgs:
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record content. Content filters are case-insensitive.
        :param str endswith: Suffix of the DNS record content. Content filters are case-insensitive.
        :param str exact: Exact value of the DNS record content. Content filters are case-insensitive.
        :param str startswith: Prefix of the DNS record content. Content filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsNameArgsDict(TypedDict):
        contains: NotRequired[str]
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
elif False:
    GetDnsRecordsNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsNameArgs:
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS record name. Name filters are case-insensitive.
        :param str endswith: Suffix of the DNS record name. Name filters are case-insensitive.
        :param str exact: Exact value of the DNS record name. Name filters are case-insensitive.
        :param str startswith: Prefix of the DNS record name. Name filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsTagArgsDict(TypedDict):
        absent: NotRequired[str]
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        contains: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        endswith: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        exact: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        present: NotRequired[str]
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        startswith: NotRequired[str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
elif False:
    GetDnsRecordsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsTagArgs:
    def __init__(__self__, *,
                 absent: Optional[str] = None,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 present: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str absent: Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        :param str contains: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        :param str endswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        :param str exact: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        :param str present: Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        :param str startswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def absent(self) -> Optional[str]:
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[str]):
        pulumi.set(self, "absent", value)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def present(self) -> Optional[str]:
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[str]):
        pulumi.set(self, "present", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsSettingsInternalViewFilterArgsDict(TypedDict):
        direction: str
        """
        Direction to order DNS views in.
        """
        match: str
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        """
        name: NotRequired['GetDnsSettingsInternalViewFilterNameArgsDict']
        order: NotRequired[str]
        """
        Field to order DNS views by.
        """
        zone_id: NotRequired[str]
        """
        A zone ID that exists in the zones list for the view.
        """
        zone_name: NotRequired[str]
        """
        A zone name that exists in the zones list for the view.
        """
elif False:
    GetDnsSettingsInternalViewFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsSettingsInternalViewFilterArgs:
    def __init__(__self__, *,
                 direction: str,
                 match: str,
                 name: Optional['GetDnsSettingsInternalViewFilterNameArgs'] = None,
                 order: Optional[str] = None,
                 zone_id: Optional[str] = None,
                 zone_name: Optional[str] = None):
        """
        :param str direction: Direction to order DNS views in.
        :param str match: Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        :param str order: Field to order DNS views by.
        :param str zone_id: A zone ID that exists in the zones list for the view.
        :param str zone_name: A zone name that exists in the zones list for the view.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction to order DNS views in.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: str):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: str):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def name(self) -> Optional['GetDnsSettingsInternalViewFilterNameArgs']:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional['GetDnsSettingsInternalViewFilterNameArgs']):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order DNS views by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        A zone ID that exists in the zones list for the view.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        A zone name that exists in the zones list for the view.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[str]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class GetDnsSettingsInternalViewFilterNameArgsDict(TypedDict):
        contains: NotRequired[str]
        """
        Substring of the DNS view name.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS view name.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS view name.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS view name.
        """
elif False:
    GetDnsSettingsInternalViewFilterNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsSettingsInternalViewFilterNameArgs:
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS view name.
        :param str endswith: Suffix of the DNS view name.
        :param str exact: Exact value of the DNS view name.
        :param str startswith: Prefix of the DNS view name.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS view name.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS view name.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS view name.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS view name.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsSettingsInternalViewsNameArgsDict(TypedDict):
        contains: NotRequired[str]
        """
        Substring of the DNS view name.
        """
        endswith: NotRequired[str]
        """
        Suffix of the DNS view name.
        """
        exact: NotRequired[str]
        """
        Exact value of the DNS view name.
        """
        startswith: NotRequired[str]
        """
        Prefix of the DNS view name.
        """
elif False:
    GetDnsSettingsInternalViewsNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsSettingsInternalViewsNameArgs:
    def __init__(__self__, *,
                 contains: Optional[str] = None,
                 endswith: Optional[str] = None,
                 exact: Optional[str] = None,
                 startswith: Optional[str] = None):
        """
        :param str contains: Substring of the DNS view name.
        :param str endswith: Suffix of the DNS view name.
        :param str exact: Exact value of the DNS view name.
        :param str startswith: Prefix of the DNS view name.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @property
    @pulumi.getter
    def contains(self) -> Optional[str]:
        """
        Substring of the DNS view name.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[str]):
        pulumi.set(self, "contains", value)

    @property
    @pulumi.getter
    def endswith(self) -> Optional[str]:
        """
        Suffix of the DNS view name.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[str]):
        pulumi.set(self, "endswith", value)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Exact value of the DNS view name.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[str]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    def startswith(self) -> Optional[str]:
        """
        Prefix of the DNS view name.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetEmailRoutingAddressFilterArgsDict(TypedDict):
        direction: str
        """
        Sorts results in an ascending or descending order.
        """
        verified: bool
        """
        Filter by verified destination addresses.
        """
elif False:
    GetEmailRoutingAddressFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailRoutingAddressFilterArgs:
    def __init__(__self__, *,
                 direction: str,
                 verified: bool):
        """
        :param str direction: Sorts results in an ascending or descending order.
        :param bool verified: Filter by verified destination addresses.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "verified", verified)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Sorts results in an ascending or descending order.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: str):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def verified(self) -> bool:
        """
        Filter by verified destination addresses.
        """
        return pulumi.get(self, "verified")

    @verified.setter
    def verified(self, value: bool):
        pulumi.set(self, "verified", value)


if not MYPY:
    class GetEmailRoutingRuleFilterArgsDict(TypedDict):
        enabled: NotRequired[bool]
        """
        Filter by enabled routing rules.
        """
elif False:
    GetEmailRoutingRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailRoutingRuleFilterArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Filter by enabled routing rules.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Filter by enabled routing rules.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetEmailSecurityBlockSenderFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        The sorting direction.
        """
        order: NotRequired[str]
        """
        The field to sort by.
        """
        pattern_type: NotRequired[str]
        search: NotRequired[str]
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
elif False:
    GetEmailSecurityBlockSenderFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailSecurityBlockSenderFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None,
                 pattern_type: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str direction: The sorting direction.
        :param str order: The field to sort by.
        :param str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if pattern_type is not None:
            pulumi.set(__self__, "pattern_type", pattern_type)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> Optional[str]:
        return pulumi.get(self, "pattern_type")

    @pattern_type.setter
    def pattern_type(self, value: Optional[str]):
        pulumi.set(self, "pattern_type", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetEmailSecurityImpersonationRegistryFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        The sorting direction.
        """
        order: NotRequired[str]
        """
        The field to sort by.
        """
        provenance: NotRequired[str]
        search: NotRequired[str]
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
elif False:
    GetEmailSecurityImpersonationRegistryFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailSecurityImpersonationRegistryFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None,
                 provenance: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str direction: The sorting direction.
        :param str order: The field to sort by.
        :param str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def provenance(self) -> Optional[str]:
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[str]):
        pulumi.set(self, "provenance", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetEmailSecurityTrustedDomainsFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        The sorting direction.
        """
        is_recent: NotRequired[bool]
        is_similarity: NotRequired[bool]
        order: NotRequired[str]
        """
        The field to sort by.
        """
        search: NotRequired[str]
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
elif False:
    GetEmailSecurityTrustedDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailSecurityTrustedDomainsFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 is_recent: Optional[bool] = None,
                 is_similarity: Optional[bool] = None,
                 order: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str direction: The sorting direction.
        :param str order: The field to sort by.
        :param str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if is_recent is not None:
            pulumi.set(__self__, "is_recent", is_recent)
        if is_similarity is not None:
            pulumi.set(__self__, "is_similarity", is_similarity)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> Optional[bool]:
        return pulumi.get(self, "is_recent")

    @is_recent.setter
    def is_recent(self, value: Optional[bool]):
        pulumi.set(self, "is_recent", value)

    @property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> Optional[bool]:
        return pulumi.get(self, "is_similarity")

    @is_similarity.setter
    def is_similarity(self, value: Optional[bool]):
        pulumi.set(self, "is_similarity", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetFilterFilterArgsDict(TypedDict):
        description: NotRequired[str]
        """
        A case-insensitive string to find in the description.
        """
        expression: NotRequired[str]
        """
        A case-insensitive string to find in the expression.
        """
        id: NotRequired[str]
        """
        The unique identifier of the filter.
        """
        paused: NotRequired[bool]
        """
        When true, indicates that the filter is currently paused.
        """
        ref: NotRequired[str]
        """
        The filter ref (a short reference tag) to search for. Must be an exact match.
        """
elif False:
    GetFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFilterFilterArgs:
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 expression: Optional[str] = None,
                 id: Optional[str] = None,
                 paused: Optional[bool] = None,
                 ref: Optional[str] = None):
        """
        :param str description: A case-insensitive string to find in the description.
        :param str expression: A case-insensitive string to find in the expression.
        :param str id: The unique identifier of the filter.
        :param bool paused: When true, indicates that the filter is currently paused.
        :param str ref: The filter ref (a short reference tag) to search for. Must be an exact match.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A case-insensitive string to find in the description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A case-insensitive string to find in the expression.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[bool]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[bool]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        The filter ref (a short reference tag) to search for. Must be an exact match.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[str]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class GetLoadBalancerPoolFilterArgsDict(TypedDict):
        monitor: NotRequired[str]
        """
        The ID of the Monitor to use for checking the health of origins within this pool.
        """
elif False:
    GetLoadBalancerPoolFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolFilterArgs:
    def __init__(__self__, *,
                 monitor: Optional[str] = None):
        """
        :param str monitor: The ID of the Monitor to use for checking the health of origins within this pool.
        """
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)

    @property
    @pulumi.getter
    def monitor(self) -> Optional[str]:
        """
        The ID of the Monitor to use for checking the health of origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: Optional[str]):
        pulumi.set(self, "monitor", value)


if not MYPY:
    class GetMagicTransitSiteFilterArgsDict(TypedDict):
        connectorid: NotRequired[str]
        """
        Identifier
        """
elif False:
    GetMagicTransitSiteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMagicTransitSiteFilterArgs:
    def __init__(__self__, *,
                 connectorid: Optional[str] = None):
        """
        :param str connectorid: Identifier
        """
        if connectorid is not None:
            pulumi.set(__self__, "connectorid", connectorid)

    @property
    @pulumi.getter
    def connectorid(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "connectorid")

    @connectorid.setter
    def connectorid(self, value: Optional[str]):
        pulumi.set(self, "connectorid", value)


if not MYPY:
    class GetOriginCaCertificateFilterArgsDict(TypedDict):
        zone_id: NotRequired[str]
        """
        Identifier
        """
elif False:
    GetOriginCaCertificateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOriginCaCertificateFilterArgs:
    def __init__(__self__, *,
                 zone_id: Optional[str] = None):
        """
        :param str zone_id: Identifier
        """
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Identifier
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetTurnstileWidgetFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order widgets.
        """
        order: NotRequired[str]
        """
        Field to order widgets by.
        """
elif False:
    GetTurnstileWidgetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTurnstileWidgetFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str direction: Direction to order widgets.
        :param str order: Field to order widgets by.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order widgets.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order widgets by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetWebAnalyticsSiteFilterArgsDict(TypedDict):
        order_by: NotRequired[str]
        """
        The property used to sort the list of results.
        """
elif False:
    GetWebAnalyticsSiteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWebAnalyticsSiteFilterArgs:
    def __init__(__self__, *,
                 order_by: Optional[str] = None):
        """
        :param str order_by: The property used to sort the list of results.
        """
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        The property used to sort the list of results.
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[str]):
        pulumi.set(self, "order_by", value)


if not MYPY:
    class GetWorkersCustomDomainFilterArgsDict(TypedDict):
        environment: NotRequired[str]
        """
        Worker environment associated with the zone and hostname.
        """
        hostname: NotRequired[str]
        """
        Hostname of the Worker Domain.
        """
        service: NotRequired[str]
        """
        Worker service associated with the zone and hostname.
        """
        zone_id: NotRequired[str]
        """
        Identifier of the zone.
        """
        zone_name: NotRequired[str]
        """
        Name of the zone.
        """
elif False:
    GetWorkersCustomDomainFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkersCustomDomainFilterArgs:
    def __init__(__self__, *,
                 environment: Optional[str] = None,
                 hostname: Optional[str] = None,
                 service: Optional[str] = None,
                 zone_id: Optional[str] = None,
                 zone_name: Optional[str] = None):
        """
        :param str environment: Worker environment associated with the zone and hostname.
        :param str hostname: Hostname of the Worker Domain.
        :param str service: Worker service associated with the zone and hostname.
        :param str zone_id: Identifier of the zone.
        :param str zone_name: Name of the zone.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Worker environment associated with the zone and hostname.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[str]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the Worker Domain.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Worker service associated with the zone and hostname.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Identifier of the zone.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name of the zone.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[str]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class GetWorkersKvNamespaceFilterArgsDict(TypedDict):
        direction: NotRequired[str]
        """
        Direction to order namespaces.
        """
        order: NotRequired[str]
        """
        Field to order results by.
        """
elif False:
    GetWorkersKvNamespaceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkersKvNamespaceFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str direction: Direction to order namespaces.
        :param str order: Field to order results by.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order namespaces.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order results by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetZeroTrustAccessApplicationFilterArgsDict(TypedDict):
        aud: NotRequired[str]
        """
        The aud of the app.
        """
        domain: NotRequired[str]
        """
        The domain of the app.
        """
        name: NotRequired[str]
        """
        The name of the app.
        """
        search: NotRequired[str]
        """
        Search for apps by other listed query parameters.
        """
elif False:
    GetZeroTrustAccessApplicationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessApplicationFilterArgs:
    def __init__(__self__, *,
                 aud: Optional[str] = None,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str aud: The aud of the app.
        :param str domain: The domain of the app.
        :param str name: The name of the app.
        :param str search: Search for apps by other listed query parameters.
        """
        if aud is not None:
            pulumi.set(__self__, "aud", aud)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def aud(self) -> Optional[str]:
        """
        The aud of the app.
        """
        return pulumi.get(self, "aud")

    @aud.setter
    def aud(self, value: Optional[str]):
        pulumi.set(self, "aud", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain of the app.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Search for apps by other listed query parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetZeroTrustAccessGroupFilterArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the group.
        """
        search: NotRequired[str]
        """
        Search for groups by other listed query parameters.
        """
elif False:
    GetZeroTrustAccessGroupFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessGroupFilterArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str name: The name of the group.
        :param str search: Search for groups by other listed query parameters.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Search for groups by other listed query parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetZeroTrustAccessIdentityProviderFilterArgsDict(TypedDict):
        scim_enabled: NotRequired[str]
        """
        Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
elif False:
    GetZeroTrustAccessIdentityProviderFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessIdentityProviderFilterArgs:
    def __init__(__self__, *,
                 scim_enabled: Optional[str] = None):
        """
        :param str scim_enabled: Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
        if scim_enabled is not None:
            pulumi.set(__self__, "scim_enabled", scim_enabled)

    @property
    @pulumi.getter(name="scimEnabled")
    def scim_enabled(self) -> Optional[str]:
        """
        Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
        return pulumi.get(self, "scim_enabled")

    @scim_enabled.setter
    def scim_enabled(self, value: Optional[str]):
        pulumi.set(self, "scim_enabled", value)


if not MYPY:
    class GetZeroTrustAccessInfrastructureTargetFilterArgsDict(TypedDict):
        created_after: NotRequired[str]
        """
        Date and time at which the target was created after (inclusive)
        """
        created_before: NotRequired[str]
        """
        Date and time at which the target was created before (inclusive)
        """
        direction: NotRequired[str]
        """
        The sorting direction.
        """
        hostname: NotRequired[str]
        """
        Hostname of a target
        """
        hostname_contains: NotRequired[str]
        """
        Partial match to the hostname of a target
        """
        ip_like: NotRequired[str]
        """
        Filters for targets whose IP addresses look like the specified string.
        Supports `*` as a wildcard character
        """
        ip_v4: NotRequired[str]
        """
        IPv4 address of the target
        """
        ip_v6: NotRequired[str]
        """
        IPv6 address of the target
        """
        ips: NotRequired[Sequence[str]]
        """
        Filters for targets that have any of the following IP addresses. Specify
        `ips` multiple times in query parameter to build list of candidates.
        """
        ipv4_end: NotRequired[str]
        """
        Defines an IPv4 filter range's ending value (inclusive). Requires
        `ipv4_start` to be specified as well.
        """
        ipv4_start: NotRequired[str]
        """
        Defines an IPv4 filter range's starting value (inclusive). Requires
        `ipv4_end` to be specified as well.
        """
        ipv6_end: NotRequired[str]
        """
        Defines an IPv6 filter range's ending value (inclusive). Requires
        `ipv6_start` to be specified as well.
        """
        ipv6_start: NotRequired[str]
        """
        Defines an IPv6 filter range's starting value (inclusive). Requires
        `ipv6_end` to be specified as well.
        """
        modified_after: NotRequired[str]
        """
        Date and time at which the target was modified after (inclusive)
        """
        modified_before: NotRequired[str]
        """
        Date and time at which the target was modified before (inclusive)
        """
        order: NotRequired[str]
        """
        The field to sort by.
        """
        target_ids: NotRequired[Sequence[str]]
        """
        Filters for targets that have any of the following UUIDs. Specify
        `target_ids` multiple times in query parameter to build list of
        candidates.
        """
        virtual_network_id: NotRequired[str]
        """
        Private virtual network identifier of the target
        """
elif False:
    GetZeroTrustAccessInfrastructureTargetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessInfrastructureTargetFilterArgs:
    def __init__(__self__, *,
                 created_after: Optional[str] = None,
                 created_before: Optional[str] = None,
                 direction: Optional[str] = None,
                 hostname: Optional[str] = None,
                 hostname_contains: Optional[str] = None,
                 ip_like: Optional[str] = None,
                 ip_v4: Optional[str] = None,
                 ip_v6: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 ipv4_end: Optional[str] = None,
                 ipv4_start: Optional[str] = None,
                 ipv6_end: Optional[str] = None,
                 ipv6_start: Optional[str] = None,
                 modified_after: Optional[str] = None,
                 modified_before: Optional[str] = None,
                 order: Optional[str] = None,
                 target_ids: Optional[Sequence[str]] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str created_after: Date and time at which the target was created after (inclusive)
        :param str created_before: Date and time at which the target was created before (inclusive)
        :param str direction: The sorting direction.
        :param str hostname: Hostname of a target
        :param str hostname_contains: Partial match to the hostname of a target
        :param str ip_like: Filters for targets whose IP addresses look like the specified string.
               Supports `*` as a wildcard character
        :param str ip_v4: IPv4 address of the target
        :param str ip_v6: IPv6 address of the target
        :param Sequence[str] ips: Filters for targets that have any of the following IP addresses. Specify
               `ips` multiple times in query parameter to build list of candidates.
        :param str ipv4_end: Defines an IPv4 filter range's ending value (inclusive). Requires
               `ipv4_start` to be specified as well.
        :param str ipv4_start: Defines an IPv4 filter range's starting value (inclusive). Requires
               `ipv4_end` to be specified as well.
        :param str ipv6_end: Defines an IPv6 filter range's ending value (inclusive). Requires
               `ipv6_start` to be specified as well.
        :param str ipv6_start: Defines an IPv6 filter range's starting value (inclusive). Requires
               `ipv6_end` to be specified as well.
        :param str modified_after: Date and time at which the target was modified after (inclusive)
        :param str modified_before: Date and time at which the target was modified before (inclusive)
        :param str order: The field to sort by.
        :param Sequence[str] target_ids: Filters for targets that have any of the following UUIDs. Specify
               `target_ids` multiple times in query parameter to build list of
               candidates.
        :param str virtual_network_id: Private virtual network identifier of the target
        """
        if created_after is not None:
            pulumi.set(__self__, "created_after", created_after)
        if created_before is not None:
            pulumi.set(__self__, "created_before", created_before)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hostname_contains is not None:
            pulumi.set(__self__, "hostname_contains", hostname_contains)
        if ip_like is not None:
            pulumi.set(__self__, "ip_like", ip_like)
        if ip_v4 is not None:
            pulumi.set(__self__, "ip_v4", ip_v4)
        if ip_v6 is not None:
            pulumi.set(__self__, "ip_v6", ip_v6)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv4_end is not None:
            pulumi.set(__self__, "ipv4_end", ipv4_end)
        if ipv4_start is not None:
            pulumi.set(__self__, "ipv4_start", ipv4_start)
        if ipv6_end is not None:
            pulumi.set(__self__, "ipv6_end", ipv6_end)
        if ipv6_start is not None:
            pulumi.set(__self__, "ipv6_start", ipv6_start)
        if modified_after is not None:
            pulumi.set(__self__, "modified_after", modified_after)
        if modified_before is not None:
            pulumi.set(__self__, "modified_before", modified_before)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if target_ids is not None:
            pulumi.set(__self__, "target_ids", target_ids)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="createdAfter")
    def created_after(self) -> Optional[str]:
        """
        Date and time at which the target was created after (inclusive)
        """
        return pulumi.get(self, "created_after")

    @created_after.setter
    def created_after(self, value: Optional[str]):
        pulumi.set(self, "created_after", value)

    @property
    @pulumi.getter(name="createdBefore")
    def created_before(self) -> Optional[str]:
        """
        Date and time at which the target was created before (inclusive)
        """
        return pulumi.get(self, "created_before")

    @created_before.setter
    def created_before(self, value: Optional[str]):
        pulumi.set(self, "created_before", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sorting direction.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of a target
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="hostnameContains")
    def hostname_contains(self) -> Optional[str]:
        """
        Partial match to the hostname of a target
        """
        return pulumi.get(self, "hostname_contains")

    @hostname_contains.setter
    def hostname_contains(self, value: Optional[str]):
        pulumi.set(self, "hostname_contains", value)

    @property
    @pulumi.getter(name="ipLike")
    def ip_like(self) -> Optional[str]:
        """
        Filters for targets whose IP addresses look like the specified string.
        Supports `*` as a wildcard character
        """
        return pulumi.get(self, "ip_like")

    @ip_like.setter
    def ip_like(self, value: Optional[str]):
        pulumi.set(self, "ip_like", value)

    @property
    @pulumi.getter(name="ipV4")
    def ip_v4(self) -> Optional[str]:
        """
        IPv4 address of the target
        """
        return pulumi.get(self, "ip_v4")

    @ip_v4.setter
    def ip_v4(self, value: Optional[str]):
        pulumi.set(self, "ip_v4", value)

    @property
    @pulumi.getter(name="ipV6")
    def ip_v6(self) -> Optional[str]:
        """
        IPv6 address of the target
        """
        return pulumi.get(self, "ip_v6")

    @ip_v6.setter
    def ip_v6(self, value: Optional[str]):
        pulumi.set(self, "ip_v6", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Filters for targets that have any of the following IP addresses. Specify
        `ips` multiple times in query parameter to build list of candidates.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="ipv4End")
    def ipv4_end(self) -> Optional[str]:
        """
        Defines an IPv4 filter range's ending value (inclusive). Requires
        `ipv4_start` to be specified as well.
        """
        return pulumi.get(self, "ipv4_end")

    @ipv4_end.setter
    def ipv4_end(self, value: Optional[str]):
        pulumi.set(self, "ipv4_end", value)

    @property
    @pulumi.getter(name="ipv4Start")
    def ipv4_start(self) -> Optional[str]:
        """
        Defines an IPv4 filter range's starting value (inclusive). Requires
        `ipv4_end` to be specified as well.
        """
        return pulumi.get(self, "ipv4_start")

    @ipv4_start.setter
    def ipv4_start(self, value: Optional[str]):
        pulumi.set(self, "ipv4_start", value)

    @property
    @pulumi.getter(name="ipv6End")
    def ipv6_end(self) -> Optional[str]:
        """
        Defines an IPv6 filter range's ending value (inclusive). Requires
        `ipv6_start` to be specified as well.
        """
        return pulumi.get(self, "ipv6_end")

    @ipv6_end.setter
    def ipv6_end(self, value: Optional[str]):
        pulumi.set(self, "ipv6_end", value)

    @property
    @pulumi.getter(name="ipv6Start")
    def ipv6_start(self) -> Optional[str]:
        """
        Defines an IPv6 filter range's starting value (inclusive). Requires
        `ipv6_end` to be specified as well.
        """
        return pulumi.get(self, "ipv6_start")

    @ipv6_start.setter
    def ipv6_start(self, value: Optional[str]):
        pulumi.set(self, "ipv6_start", value)

    @property
    @pulumi.getter(name="modifiedAfter")
    def modified_after(self) -> Optional[str]:
        """
        Date and time at which the target was modified after (inclusive)
        """
        return pulumi.get(self, "modified_after")

    @modified_after.setter
    def modified_after(self, value: Optional[str]):
        pulumi.set(self, "modified_after", value)

    @property
    @pulumi.getter(name="modifiedBefore")
    def modified_before(self) -> Optional[str]:
        """
        Date and time at which the target was modified before (inclusive)
        """
        return pulumi.get(self, "modified_before")

    @modified_before.setter
    def modified_before(self, value: Optional[str]):
        pulumi.set(self, "modified_before", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The field to sort by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Optional[Sequence[str]]:
        """
        Filters for targets that have any of the following UUIDs. Specify
        `target_ids` multiple times in query parameter to build list of
        candidates.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "target_ids", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        Private virtual network identifier of the target
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class GetZeroTrustAccessServiceTokenFilterArgsDict(TypedDict):
        name: NotRequired[str]
        """
        The name of the service token.
        """
        search: NotRequired[str]
        """
        Search for service tokens by other listed query parameters.
        """
elif False:
    GetZeroTrustAccessServiceTokenFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessServiceTokenFilterArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 search: Optional[str] = None):
        """
        :param str name: The name of the service token.
        :param str search: Search for service tokens by other listed query parameters.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the service token.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Search for service tokens by other listed query parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetZeroTrustListFilterArgsDict(TypedDict):
        type: NotRequired[str]
        """
        The type of list.
        """
elif False:
    GetZeroTrustListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustListFilterArgs:
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: The type of list.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetZeroTrustTunnelCloudflaredFilterArgsDict(TypedDict):
        exclude_prefix: NotRequired[str]
        existed_at: NotRequired[str]
        """
        If provided, include only tunnels that were created (and not deleted) before this time.
        """
        include_prefix: NotRequired[str]
        is_deleted: NotRequired[bool]
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        name: NotRequired[str]
        """
        A user-friendly name for a tunnel.
        """
        status: NotRequired[str]
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        """
        uuid: NotRequired[str]
        """
        UUID of the tunnel.
        """
        was_active_at: NotRequired[str]
        was_inactive_at: NotRequired[str]
elif False:
    GetZeroTrustTunnelCloudflaredFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelCloudflaredFilterArgs:
    def __init__(__self__, *,
                 exclude_prefix: Optional[str] = None,
                 existed_at: Optional[str] = None,
                 include_prefix: Optional[str] = None,
                 is_deleted: Optional[bool] = None,
                 name: Optional[str] = None,
                 status: Optional[str] = None,
                 uuid: Optional[str] = None,
                 was_active_at: Optional[str] = None,
                 was_inactive_at: Optional[str] = None):
        """
        :param str existed_at: If provided, include only tunnels that were created (and not deleted) before this time.
        :param bool is_deleted: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        :param str name: A user-friendly name for a tunnel.
        :param str status: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        :param str uuid: UUID of the tunnel.
        """
        if exclude_prefix is not None:
            pulumi.set(__self__, "exclude_prefix", exclude_prefix)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if include_prefix is not None:
            pulumi.set(__self__, "include_prefix", include_prefix)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if was_active_at is not None:
            pulumi.set(__self__, "was_active_at", was_active_at)
        if was_inactive_at is not None:
            pulumi.set(__self__, "was_inactive_at", was_inactive_at)

    @property
    @pulumi.getter(name="excludePrefix")
    def exclude_prefix(self) -> Optional[str]:
        return pulumi.get(self, "exclude_prefix")

    @exclude_prefix.setter
    def exclude_prefix(self, value: Optional[str]):
        pulumi.set(self, "exclude_prefix", value)

    @property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[str]:
        """
        If provided, include only tunnels that were created (and not deleted) before this time.
        """
        return pulumi.get(self, "existed_at")

    @existed_at.setter
    def existed_at(self, value: Optional[str]):
        pulumi.set(self, "existed_at", value)

    @property
    @pulumi.getter(name="includePrefix")
    def include_prefix(self) -> Optional[str]:
        return pulumi.get(self, "include_prefix")

    @include_prefix.setter
    def include_prefix(self, value: Optional[str]):
        pulumi.set(self, "include_prefix", value)

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[bool]:
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[bool]):
        pulumi.set(self, "is_deleted", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A user-friendly name for a tunnel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter(name="wasActiveAt")
    def was_active_at(self) -> Optional[str]:
        return pulumi.get(self, "was_active_at")

    @was_active_at.setter
    def was_active_at(self, value: Optional[str]):
        pulumi.set(self, "was_active_at", value)

    @property
    @pulumi.getter(name="wasInactiveAt")
    def was_inactive_at(self) -> Optional[str]:
        return pulumi.get(self, "was_inactive_at")

    @was_inactive_at.setter
    def was_inactive_at(self, value: Optional[str]):
        pulumi.set(self, "was_inactive_at", value)


if not MYPY:
    class GetZeroTrustTunnelCloudflaredRouteFilterArgsDict(TypedDict):
        comment: NotRequired[str]
        """
        Optional remark describing the route.
        """
        existed_at: NotRequired[str]
        """
        If provided, include only tunnels that were created (and not deleted) before this time.
        """
        is_deleted: NotRequired[bool]
        """
        If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        """
        network_subset: NotRequired[str]
        """
        If set, only list routes that are contained within this IP range.
        """
        network_superset: NotRequired[str]
        """
        If set, only list routes that contain this IP range.
        """
        route_id: NotRequired[str]
        """
        UUID of the route.
        """
        tun_types: NotRequired[str]
        """
        The types of tunnels to filter separated by a comma.
        """
        tunnel_id: NotRequired[str]
        """
        UUID of the tunnel.
        """
        virtual_network_id: NotRequired[str]
        """
        UUID of the virtual network.
        """
elif False:
    GetZeroTrustTunnelCloudflaredRouteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelCloudflaredRouteFilterArgs:
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 existed_at: Optional[str] = None,
                 is_deleted: Optional[bool] = None,
                 network_subset: Optional[str] = None,
                 network_superset: Optional[str] = None,
                 route_id: Optional[str] = None,
                 tun_types: Optional[str] = None,
                 tunnel_id: Optional[str] = None,
                 virtual_network_id: Optional[str] = None):
        """
        :param str comment: Optional remark describing the route.
        :param str existed_at: If provided, include only tunnels that were created (and not deleted) before this time.
        :param bool is_deleted: If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        :param str network_subset: If set, only list routes that are contained within this IP range.
        :param str network_superset: If set, only list routes that contain this IP range.
        :param str route_id: UUID of the route.
        :param str tun_types: The types of tunnels to filter separated by a comma.
        :param str tunnel_id: UUID of the tunnel.
        :param str virtual_network_id: UUID of the virtual network.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if network_subset is not None:
            pulumi.set(__self__, "network_subset", network_subset)
        if network_superset is not None:
            pulumi.set(__self__, "network_superset", network_superset)
        if route_id is not None:
            pulumi.set(__self__, "route_id", route_id)
        if tun_types is not None:
            pulumi.set(__self__, "tun_types", tun_types)
        if tunnel_id is not None:
            pulumi.set(__self__, "tunnel_id", tunnel_id)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Optional remark describing the route.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[str]:
        """
        If provided, include only tunnels that were created (and not deleted) before this time.
        """
        return pulumi.get(self, "existed_at")

    @existed_at.setter
    def existed_at(self, value: Optional[str]):
        pulumi.set(self, "existed_at", value)

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[bool]:
        """
        If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[bool]):
        pulumi.set(self, "is_deleted", value)

    @property
    @pulumi.getter(name="networkSubset")
    def network_subset(self) -> Optional[str]:
        """
        If set, only list routes that are contained within this IP range.
        """
        return pulumi.get(self, "network_subset")

    @network_subset.setter
    def network_subset(self, value: Optional[str]):
        pulumi.set(self, "network_subset", value)

    @property
    @pulumi.getter(name="networkSuperset")
    def network_superset(self) -> Optional[str]:
        """
        If set, only list routes that contain this IP range.
        """
        return pulumi.get(self, "network_superset")

    @network_superset.setter
    def network_superset(self, value: Optional[str]):
        pulumi.set(self, "network_superset", value)

    @property
    @pulumi.getter(name="routeId")
    def route_id(self) -> Optional[str]:
        """
        UUID of the route.
        """
        return pulumi.get(self, "route_id")

    @route_id.setter
    def route_id(self, value: Optional[str]):
        pulumi.set(self, "route_id", value)

    @property
    @pulumi.getter(name="tunTypes")
    def tun_types(self) -> Optional[str]:
        """
        The types of tunnels to filter separated by a comma.
        """
        return pulumi.get(self, "tun_types")

    @tun_types.setter
    def tun_types(self, value: Optional[str]):
        pulumi.set(self, "tun_types", value)

    @property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> Optional[str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "tunnel_id")

    @tunnel_id.setter
    def tunnel_id(self, value: Optional[str]):
        pulumi.set(self, "tunnel_id", value)

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[str]:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgsDict(TypedDict):
        id: NotRequired[str]
        """
        UUID of the virtual network.
        """
        is_default: NotRequired[bool]
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        is_deleted: NotRequired[bool]
        """
        If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        """
        name: NotRequired[str]
        """
        A user-friendly name for the virtual network.
        """
elif False:
    GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 is_default: Optional[bool] = None,
                 is_deleted: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str id: UUID of the virtual network.
        :param bool is_default: If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        :param bool is_deleted: If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        :param str name: A user-friendly name for the virtual network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[bool]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[bool]:
        """
        If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[bool]):
        pulumi.set(self, "is_deleted", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A user-friendly name for the virtual network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetZoneFilterArgsDict(TypedDict):
        match: str
        """
        Whether to match all search requirements or at least one (any).
        """
        account: NotRequired['GetZoneFilterAccountArgsDict']
        direction: NotRequired[str]
        """
        Direction to order zones.
        """
        name: NotRequired[str]
        """
        A domain name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        order: NotRequired[str]
        """
        Field to order zones by.
        """
        status: NotRequired[str]
        """
        A zone status
        """
elif False:
    GetZoneFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZoneFilterArgs:
    def __init__(__self__, *,
                 match: str,
                 account: Optional['GetZoneFilterAccountArgs'] = None,
                 direction: Optional[str] = None,
                 name: Optional[str] = None,
                 order: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str match: Whether to match all search requirements or at least one (any).
        :param str direction: Direction to order zones.
        :param str name: A domain name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        :param str order: Field to order zones by.
        :param str status: A zone status
        """
        pulumi.set(__self__, "match", match)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        Whether to match all search requirements or at least one (any).
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: str):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def account(self) -> Optional['GetZoneFilterAccountArgs']:
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional['GetZoneFilterAccountArgs']):
        pulumi.set(self, "account", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction to order zones.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A domain name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Field to order zones by.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        A zone status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetZoneFilterAccountArgsDict(TypedDict):
        id: NotRequired[str]
        """
        An account ID
        """
        name: NotRequired[str]
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
elif False:
    GetZoneFilterAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZoneFilterAccountArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: An account ID
        :param str name: An account Name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        An account ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetZoneLockdownFilterArgsDict(TypedDict):
        created_on: NotRequired[str]
        """
        The timestamp of when the rule was created.
        """
        description: NotRequired[str]
        """
        A string to search for in the description of existing rules.
        """
        description_search: NotRequired[str]
        """
        A string to search for in the description of existing rules.
        """
        ip: NotRequired[str]
        """
        A single IP address to search for in existing rules.
        """
        ip_range_search: NotRequired[str]
        """
        A single IP address range to search for in existing rules.
        """
        ip_search: NotRequired[str]
        """
        A single IP address to search for in existing rules.
        """
        modified_on: NotRequired[str]
        """
        The timestamp of when the rule was last modified.
        """
        priority: NotRequired[float]
        """
        The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        """
        uri_search: NotRequired[str]
        """
        A single URI to search for in the list of URLs of existing rules.
        """
elif False:
    GetZoneLockdownFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZoneLockdownFilterArgs:
    def __init__(__self__, *,
                 created_on: Optional[str] = None,
                 description: Optional[str] = None,
                 description_search: Optional[str] = None,
                 ip: Optional[str] = None,
                 ip_range_search: Optional[str] = None,
                 ip_search: Optional[str] = None,
                 modified_on: Optional[str] = None,
                 priority: Optional[float] = None,
                 uri_search: Optional[str] = None):
        """
        :param str created_on: The timestamp of when the rule was created.
        :param str description: A string to search for in the description of existing rules.
        :param str description_search: A string to search for in the description of existing rules.
        :param str ip: A single IP address to search for in existing rules.
        :param str ip_range_search: A single IP address range to search for in existing rules.
        :param str ip_search: A single IP address to search for in existing rules.
        :param str modified_on: The timestamp of when the rule was last modified.
        :param float priority: The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        :param str uri_search: A single URI to search for in the list of URLs of existing rules.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if description_search is not None:
            pulumi.set(__self__, "description_search", description_search)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range_search is not None:
            pulumi.set(__self__, "ip_range_search", ip_range_search)
        if ip_search is not None:
            pulumi.set(__self__, "ip_search", ip_search)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if uri_search is not None:
            pulumi.set(__self__, "uri_search", uri_search)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        The timestamp of when the rule was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[str]):
        pulumi.set(self, "created_on", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="descriptionSearch")
    def description_search(self) -> Optional[str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description_search")

    @description_search.setter
    def description_search(self, value: Optional[str]):
        pulumi.set(self, "description_search", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        A single IP address to search for in existing rules.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipRangeSearch")
    def ip_range_search(self) -> Optional[str]:
        """
        A single IP address range to search for in existing rules.
        """
        return pulumi.get(self, "ip_range_search")

    @ip_range_search.setter
    def ip_range_search(self, value: Optional[str]):
        pulumi.set(self, "ip_range_search", value)

    @property
    @pulumi.getter(name="ipSearch")
    def ip_search(self) -> Optional[str]:
        """
        A single IP address to search for in existing rules.
        """
        return pulumi.get(self, "ip_search")

    @ip_search.setter
    def ip_search(self, value: Optional[str]):
        pulumi.set(self, "ip_search", value)

    @property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[str]:
        """
        The timestamp of when the rule was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[str]):
        pulumi.set(self, "modified_on", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[float]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="uriSearch")
    def uri_search(self) -> Optional[str]:
        """
        A single URI to search for in the list of URLs of existing rules.
        """
        return pulumi.get(self, "uri_search")

    @uri_search.setter
    def uri_search(self, value: Optional[str]):
        pulumi.set(self, "uri_search", value)


if not MYPY:
    class GetZonesAccountArgsDict(TypedDict):
        id: NotRequired[str]
        """
        An account ID
        """
        name: NotRequired[str]
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
elif False:
    GetZonesAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZonesAccountArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: An account ID
        :param str name: An account Name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        An account ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


