# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessApplicationCorsHeadersArgs',
    'AccessApplicationCorsHeadersArgsDict',
    'AccessApplicationDestinationArgs',
    'AccessApplicationDestinationArgsDict',
    'AccessApplicationFooterLinkArgs',
    'AccessApplicationFooterLinkArgsDict',
    'AccessApplicationLandingPageDesignArgs',
    'AccessApplicationLandingPageDesignArgsDict',
    'AccessApplicationPolicyArgs',
    'AccessApplicationPolicyArgsDict',
    'AccessApplicationPolicyConnectionRulesArgs',
    'AccessApplicationPolicyConnectionRulesArgsDict',
    'AccessApplicationPolicyConnectionRulesSshArgs',
    'AccessApplicationPolicyConnectionRulesSshArgsDict',
    'AccessApplicationPolicyExcludeArgs',
    'AccessApplicationPolicyExcludeArgsDict',
    'AccessApplicationPolicyExcludeAnyValidServiceTokenArgs',
    'AccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict',
    'AccessApplicationPolicyExcludeAuthContextArgs',
    'AccessApplicationPolicyExcludeAuthContextArgsDict',
    'AccessApplicationPolicyExcludeAuthMethodArgs',
    'AccessApplicationPolicyExcludeAuthMethodArgsDict',
    'AccessApplicationPolicyExcludeAzureAdArgs',
    'AccessApplicationPolicyExcludeAzureAdArgsDict',
    'AccessApplicationPolicyExcludeCertificateArgs',
    'AccessApplicationPolicyExcludeCertificateArgsDict',
    'AccessApplicationPolicyExcludeCommonNameArgs',
    'AccessApplicationPolicyExcludeCommonNameArgsDict',
    'AccessApplicationPolicyExcludeDevicePostureArgs',
    'AccessApplicationPolicyExcludeDevicePostureArgsDict',
    'AccessApplicationPolicyExcludeEmailArgs',
    'AccessApplicationPolicyExcludeEmailArgsDict',
    'AccessApplicationPolicyExcludeEmailDomainArgs',
    'AccessApplicationPolicyExcludeEmailDomainArgsDict',
    'AccessApplicationPolicyExcludeEmailListArgs',
    'AccessApplicationPolicyExcludeEmailListArgsDict',
    'AccessApplicationPolicyExcludeEveryoneArgs',
    'AccessApplicationPolicyExcludeEveryoneArgsDict',
    'AccessApplicationPolicyExcludeExternalEvaluationArgs',
    'AccessApplicationPolicyExcludeExternalEvaluationArgsDict',
    'AccessApplicationPolicyExcludeGeoArgs',
    'AccessApplicationPolicyExcludeGeoArgsDict',
    'AccessApplicationPolicyExcludeGithubOrganizationArgs',
    'AccessApplicationPolicyExcludeGithubOrganizationArgsDict',
    'AccessApplicationPolicyExcludeGroupArgs',
    'AccessApplicationPolicyExcludeGroupArgsDict',
    'AccessApplicationPolicyExcludeGsuiteArgs',
    'AccessApplicationPolicyExcludeGsuiteArgsDict',
    'AccessApplicationPolicyExcludeIpArgs',
    'AccessApplicationPolicyExcludeIpArgsDict',
    'AccessApplicationPolicyExcludeIpListArgs',
    'AccessApplicationPolicyExcludeIpListArgsDict',
    'AccessApplicationPolicyExcludeLinkedAppTokenArgs',
    'AccessApplicationPolicyExcludeLinkedAppTokenArgsDict',
    'AccessApplicationPolicyExcludeLoginMethodArgs',
    'AccessApplicationPolicyExcludeLoginMethodArgsDict',
    'AccessApplicationPolicyExcludeOidcArgs',
    'AccessApplicationPolicyExcludeOidcArgsDict',
    'AccessApplicationPolicyExcludeOktaArgs',
    'AccessApplicationPolicyExcludeOktaArgsDict',
    'AccessApplicationPolicyExcludeSamlArgs',
    'AccessApplicationPolicyExcludeSamlArgsDict',
    'AccessApplicationPolicyExcludeServiceTokenArgs',
    'AccessApplicationPolicyExcludeServiceTokenArgsDict',
    'AccessApplicationPolicyIncludeArgs',
    'AccessApplicationPolicyIncludeArgsDict',
    'AccessApplicationPolicyIncludeAnyValidServiceTokenArgs',
    'AccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict',
    'AccessApplicationPolicyIncludeAuthContextArgs',
    'AccessApplicationPolicyIncludeAuthContextArgsDict',
    'AccessApplicationPolicyIncludeAuthMethodArgs',
    'AccessApplicationPolicyIncludeAuthMethodArgsDict',
    'AccessApplicationPolicyIncludeAzureAdArgs',
    'AccessApplicationPolicyIncludeAzureAdArgsDict',
    'AccessApplicationPolicyIncludeCertificateArgs',
    'AccessApplicationPolicyIncludeCertificateArgsDict',
    'AccessApplicationPolicyIncludeCommonNameArgs',
    'AccessApplicationPolicyIncludeCommonNameArgsDict',
    'AccessApplicationPolicyIncludeDevicePostureArgs',
    'AccessApplicationPolicyIncludeDevicePostureArgsDict',
    'AccessApplicationPolicyIncludeEmailArgs',
    'AccessApplicationPolicyIncludeEmailArgsDict',
    'AccessApplicationPolicyIncludeEmailDomainArgs',
    'AccessApplicationPolicyIncludeEmailDomainArgsDict',
    'AccessApplicationPolicyIncludeEmailListArgs',
    'AccessApplicationPolicyIncludeEmailListArgsDict',
    'AccessApplicationPolicyIncludeEveryoneArgs',
    'AccessApplicationPolicyIncludeEveryoneArgsDict',
    'AccessApplicationPolicyIncludeExternalEvaluationArgs',
    'AccessApplicationPolicyIncludeExternalEvaluationArgsDict',
    'AccessApplicationPolicyIncludeGeoArgs',
    'AccessApplicationPolicyIncludeGeoArgsDict',
    'AccessApplicationPolicyIncludeGithubOrganizationArgs',
    'AccessApplicationPolicyIncludeGithubOrganizationArgsDict',
    'AccessApplicationPolicyIncludeGroupArgs',
    'AccessApplicationPolicyIncludeGroupArgsDict',
    'AccessApplicationPolicyIncludeGsuiteArgs',
    'AccessApplicationPolicyIncludeGsuiteArgsDict',
    'AccessApplicationPolicyIncludeIpArgs',
    'AccessApplicationPolicyIncludeIpArgsDict',
    'AccessApplicationPolicyIncludeIpListArgs',
    'AccessApplicationPolicyIncludeIpListArgsDict',
    'AccessApplicationPolicyIncludeLinkedAppTokenArgs',
    'AccessApplicationPolicyIncludeLinkedAppTokenArgsDict',
    'AccessApplicationPolicyIncludeLoginMethodArgs',
    'AccessApplicationPolicyIncludeLoginMethodArgsDict',
    'AccessApplicationPolicyIncludeOidcArgs',
    'AccessApplicationPolicyIncludeOidcArgsDict',
    'AccessApplicationPolicyIncludeOktaArgs',
    'AccessApplicationPolicyIncludeOktaArgsDict',
    'AccessApplicationPolicyIncludeSamlArgs',
    'AccessApplicationPolicyIncludeSamlArgsDict',
    'AccessApplicationPolicyIncludeServiceTokenArgs',
    'AccessApplicationPolicyIncludeServiceTokenArgsDict',
    'AccessApplicationPolicyRequireArgs',
    'AccessApplicationPolicyRequireArgsDict',
    'AccessApplicationPolicyRequireAnyValidServiceTokenArgs',
    'AccessApplicationPolicyRequireAnyValidServiceTokenArgsDict',
    'AccessApplicationPolicyRequireAuthContextArgs',
    'AccessApplicationPolicyRequireAuthContextArgsDict',
    'AccessApplicationPolicyRequireAuthMethodArgs',
    'AccessApplicationPolicyRequireAuthMethodArgsDict',
    'AccessApplicationPolicyRequireAzureAdArgs',
    'AccessApplicationPolicyRequireAzureAdArgsDict',
    'AccessApplicationPolicyRequireCertificateArgs',
    'AccessApplicationPolicyRequireCertificateArgsDict',
    'AccessApplicationPolicyRequireCommonNameArgs',
    'AccessApplicationPolicyRequireCommonNameArgsDict',
    'AccessApplicationPolicyRequireDevicePostureArgs',
    'AccessApplicationPolicyRequireDevicePostureArgsDict',
    'AccessApplicationPolicyRequireEmailArgs',
    'AccessApplicationPolicyRequireEmailArgsDict',
    'AccessApplicationPolicyRequireEmailDomainArgs',
    'AccessApplicationPolicyRequireEmailDomainArgsDict',
    'AccessApplicationPolicyRequireEmailListArgs',
    'AccessApplicationPolicyRequireEmailListArgsDict',
    'AccessApplicationPolicyRequireEveryoneArgs',
    'AccessApplicationPolicyRequireEveryoneArgsDict',
    'AccessApplicationPolicyRequireExternalEvaluationArgs',
    'AccessApplicationPolicyRequireExternalEvaluationArgsDict',
    'AccessApplicationPolicyRequireGeoArgs',
    'AccessApplicationPolicyRequireGeoArgsDict',
    'AccessApplicationPolicyRequireGithubOrganizationArgs',
    'AccessApplicationPolicyRequireGithubOrganizationArgsDict',
    'AccessApplicationPolicyRequireGroupArgs',
    'AccessApplicationPolicyRequireGroupArgsDict',
    'AccessApplicationPolicyRequireGsuiteArgs',
    'AccessApplicationPolicyRequireGsuiteArgsDict',
    'AccessApplicationPolicyRequireIpArgs',
    'AccessApplicationPolicyRequireIpArgsDict',
    'AccessApplicationPolicyRequireIpListArgs',
    'AccessApplicationPolicyRequireIpListArgsDict',
    'AccessApplicationPolicyRequireLinkedAppTokenArgs',
    'AccessApplicationPolicyRequireLinkedAppTokenArgsDict',
    'AccessApplicationPolicyRequireLoginMethodArgs',
    'AccessApplicationPolicyRequireLoginMethodArgsDict',
    'AccessApplicationPolicyRequireOidcArgs',
    'AccessApplicationPolicyRequireOidcArgsDict',
    'AccessApplicationPolicyRequireOktaArgs',
    'AccessApplicationPolicyRequireOktaArgsDict',
    'AccessApplicationPolicyRequireSamlArgs',
    'AccessApplicationPolicyRequireSamlArgsDict',
    'AccessApplicationPolicyRequireServiceTokenArgs',
    'AccessApplicationPolicyRequireServiceTokenArgsDict',
    'AccessApplicationSaasAppArgs',
    'AccessApplicationSaasAppArgsDict',
    'AccessApplicationSaasAppCustomAttributeArgs',
    'AccessApplicationSaasAppCustomAttributeArgsDict',
    'AccessApplicationSaasAppCustomAttributeSourceArgs',
    'AccessApplicationSaasAppCustomAttributeSourceArgsDict',
    'AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs',
    'AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict',
    'AccessApplicationSaasAppCustomClaimArgs',
    'AccessApplicationSaasAppCustomClaimArgsDict',
    'AccessApplicationSaasAppCustomClaimSourceArgs',
    'AccessApplicationSaasAppCustomClaimSourceArgsDict',
    'AccessApplicationSaasAppHybridAndImplicitOptionsArgs',
    'AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict',
    'AccessApplicationSaasAppRefreshTokenOptionsArgs',
    'AccessApplicationSaasAppRefreshTokenOptionsArgsDict',
    'AccessApplicationScimConfigArgs',
    'AccessApplicationScimConfigArgsDict',
    'AccessApplicationScimConfigAuthenticationArgs',
    'AccessApplicationScimConfigAuthenticationArgsDict',
    'AccessApplicationScimConfigMappingArgs',
    'AccessApplicationScimConfigMappingArgsDict',
    'AccessApplicationScimConfigMappingOperationsArgs',
    'AccessApplicationScimConfigMappingOperationsArgsDict',
    'AccessApplicationTargetCriteriaArgs',
    'AccessApplicationTargetCriteriaArgsDict',
    'AccessGroupExcludeArgs',
    'AccessGroupExcludeArgsDict',
    'AccessGroupExcludeAnyValidServiceTokenArgs',
    'AccessGroupExcludeAnyValidServiceTokenArgsDict',
    'AccessGroupExcludeAuthContextArgs',
    'AccessGroupExcludeAuthContextArgsDict',
    'AccessGroupExcludeAuthMethodArgs',
    'AccessGroupExcludeAuthMethodArgsDict',
    'AccessGroupExcludeAzureAdArgs',
    'AccessGroupExcludeAzureAdArgsDict',
    'AccessGroupExcludeCertificateArgs',
    'AccessGroupExcludeCertificateArgsDict',
    'AccessGroupExcludeCommonNameArgs',
    'AccessGroupExcludeCommonNameArgsDict',
    'AccessGroupExcludeDevicePostureArgs',
    'AccessGroupExcludeDevicePostureArgsDict',
    'AccessGroupExcludeEmailArgs',
    'AccessGroupExcludeEmailArgsDict',
    'AccessGroupExcludeEmailDomainArgs',
    'AccessGroupExcludeEmailDomainArgsDict',
    'AccessGroupExcludeEmailListArgs',
    'AccessGroupExcludeEmailListArgsDict',
    'AccessGroupExcludeEveryoneArgs',
    'AccessGroupExcludeEveryoneArgsDict',
    'AccessGroupExcludeExternalEvaluationArgs',
    'AccessGroupExcludeExternalEvaluationArgsDict',
    'AccessGroupExcludeGeoArgs',
    'AccessGroupExcludeGeoArgsDict',
    'AccessGroupExcludeGithubOrganizationArgs',
    'AccessGroupExcludeGithubOrganizationArgsDict',
    'AccessGroupExcludeGroupArgs',
    'AccessGroupExcludeGroupArgsDict',
    'AccessGroupExcludeGsuiteArgs',
    'AccessGroupExcludeGsuiteArgsDict',
    'AccessGroupExcludeIpArgs',
    'AccessGroupExcludeIpArgsDict',
    'AccessGroupExcludeIpListArgs',
    'AccessGroupExcludeIpListArgsDict',
    'AccessGroupExcludeLinkedAppTokenArgs',
    'AccessGroupExcludeLinkedAppTokenArgsDict',
    'AccessGroupExcludeLoginMethodArgs',
    'AccessGroupExcludeLoginMethodArgsDict',
    'AccessGroupExcludeOidcArgs',
    'AccessGroupExcludeOidcArgsDict',
    'AccessGroupExcludeOktaArgs',
    'AccessGroupExcludeOktaArgsDict',
    'AccessGroupExcludeSamlArgs',
    'AccessGroupExcludeSamlArgsDict',
    'AccessGroupExcludeServiceTokenArgs',
    'AccessGroupExcludeServiceTokenArgsDict',
    'AccessGroupIncludeArgs',
    'AccessGroupIncludeArgsDict',
    'AccessGroupIncludeAnyValidServiceTokenArgs',
    'AccessGroupIncludeAnyValidServiceTokenArgsDict',
    'AccessGroupIncludeAuthContextArgs',
    'AccessGroupIncludeAuthContextArgsDict',
    'AccessGroupIncludeAuthMethodArgs',
    'AccessGroupIncludeAuthMethodArgsDict',
    'AccessGroupIncludeAzureAdArgs',
    'AccessGroupIncludeAzureAdArgsDict',
    'AccessGroupIncludeCertificateArgs',
    'AccessGroupIncludeCertificateArgsDict',
    'AccessGroupIncludeCommonNameArgs',
    'AccessGroupIncludeCommonNameArgsDict',
    'AccessGroupIncludeDevicePostureArgs',
    'AccessGroupIncludeDevicePostureArgsDict',
    'AccessGroupIncludeEmailArgs',
    'AccessGroupIncludeEmailArgsDict',
    'AccessGroupIncludeEmailDomainArgs',
    'AccessGroupIncludeEmailDomainArgsDict',
    'AccessGroupIncludeEmailListArgs',
    'AccessGroupIncludeEmailListArgsDict',
    'AccessGroupIncludeEveryoneArgs',
    'AccessGroupIncludeEveryoneArgsDict',
    'AccessGroupIncludeExternalEvaluationArgs',
    'AccessGroupIncludeExternalEvaluationArgsDict',
    'AccessGroupIncludeGeoArgs',
    'AccessGroupIncludeGeoArgsDict',
    'AccessGroupIncludeGithubOrganizationArgs',
    'AccessGroupIncludeGithubOrganizationArgsDict',
    'AccessGroupIncludeGroupArgs',
    'AccessGroupIncludeGroupArgsDict',
    'AccessGroupIncludeGsuiteArgs',
    'AccessGroupIncludeGsuiteArgsDict',
    'AccessGroupIncludeIpArgs',
    'AccessGroupIncludeIpArgsDict',
    'AccessGroupIncludeIpListArgs',
    'AccessGroupIncludeIpListArgsDict',
    'AccessGroupIncludeLinkedAppTokenArgs',
    'AccessGroupIncludeLinkedAppTokenArgsDict',
    'AccessGroupIncludeLoginMethodArgs',
    'AccessGroupIncludeLoginMethodArgsDict',
    'AccessGroupIncludeOidcArgs',
    'AccessGroupIncludeOidcArgsDict',
    'AccessGroupIncludeOktaArgs',
    'AccessGroupIncludeOktaArgsDict',
    'AccessGroupIncludeSamlArgs',
    'AccessGroupIncludeSamlArgsDict',
    'AccessGroupIncludeServiceTokenArgs',
    'AccessGroupIncludeServiceTokenArgsDict',
    'AccessGroupRequireArgs',
    'AccessGroupRequireArgsDict',
    'AccessGroupRequireAnyValidServiceTokenArgs',
    'AccessGroupRequireAnyValidServiceTokenArgsDict',
    'AccessGroupRequireAuthContextArgs',
    'AccessGroupRequireAuthContextArgsDict',
    'AccessGroupRequireAuthMethodArgs',
    'AccessGroupRequireAuthMethodArgsDict',
    'AccessGroupRequireAzureAdArgs',
    'AccessGroupRequireAzureAdArgsDict',
    'AccessGroupRequireCertificateArgs',
    'AccessGroupRequireCertificateArgsDict',
    'AccessGroupRequireCommonNameArgs',
    'AccessGroupRequireCommonNameArgsDict',
    'AccessGroupRequireDevicePostureArgs',
    'AccessGroupRequireDevicePostureArgsDict',
    'AccessGroupRequireEmailArgs',
    'AccessGroupRequireEmailArgsDict',
    'AccessGroupRequireEmailDomainArgs',
    'AccessGroupRequireEmailDomainArgsDict',
    'AccessGroupRequireEmailListArgs',
    'AccessGroupRequireEmailListArgsDict',
    'AccessGroupRequireEveryoneArgs',
    'AccessGroupRequireEveryoneArgsDict',
    'AccessGroupRequireExternalEvaluationArgs',
    'AccessGroupRequireExternalEvaluationArgsDict',
    'AccessGroupRequireGeoArgs',
    'AccessGroupRequireGeoArgsDict',
    'AccessGroupRequireGithubOrganizationArgs',
    'AccessGroupRequireGithubOrganizationArgsDict',
    'AccessGroupRequireGroupArgs',
    'AccessGroupRequireGroupArgsDict',
    'AccessGroupRequireGsuiteArgs',
    'AccessGroupRequireGsuiteArgsDict',
    'AccessGroupRequireIpArgs',
    'AccessGroupRequireIpArgsDict',
    'AccessGroupRequireIpListArgs',
    'AccessGroupRequireIpListArgsDict',
    'AccessGroupRequireLinkedAppTokenArgs',
    'AccessGroupRequireLinkedAppTokenArgsDict',
    'AccessGroupRequireLoginMethodArgs',
    'AccessGroupRequireLoginMethodArgsDict',
    'AccessGroupRequireOidcArgs',
    'AccessGroupRequireOidcArgsDict',
    'AccessGroupRequireOktaArgs',
    'AccessGroupRequireOktaArgsDict',
    'AccessGroupRequireSamlArgs',
    'AccessGroupRequireSamlArgsDict',
    'AccessGroupRequireServiceTokenArgs',
    'AccessGroupRequireServiceTokenArgsDict',
    'AccessIdentityProviderConfigArgs',
    'AccessIdentityProviderConfigArgsDict',
    'AccessIdentityProviderConfigHeaderAttributeArgs',
    'AccessIdentityProviderConfigHeaderAttributeArgsDict',
    'AccessIdentityProviderScimConfigArgs',
    'AccessIdentityProviderScimConfigArgsDict',
    'AccessMutualTlsHostnameSettingsSettingArgs',
    'AccessMutualTlsHostnameSettingsSettingArgsDict',
    'AccessOrganizationCustomPagesArgs',
    'AccessOrganizationCustomPagesArgsDict',
    'AccessOrganizationLoginDesignArgs',
    'AccessOrganizationLoginDesignArgsDict',
    'AccessPolicyApprovalGroupArgs',
    'AccessPolicyApprovalGroupArgsDict',
    'AccessPolicyExcludeArgs',
    'AccessPolicyExcludeArgsDict',
    'AccessPolicyExcludeAnyValidServiceTokenArgs',
    'AccessPolicyExcludeAnyValidServiceTokenArgsDict',
    'AccessPolicyExcludeAuthContextArgs',
    'AccessPolicyExcludeAuthContextArgsDict',
    'AccessPolicyExcludeAuthMethodArgs',
    'AccessPolicyExcludeAuthMethodArgsDict',
    'AccessPolicyExcludeAzureAdArgs',
    'AccessPolicyExcludeAzureAdArgsDict',
    'AccessPolicyExcludeCertificateArgs',
    'AccessPolicyExcludeCertificateArgsDict',
    'AccessPolicyExcludeCommonNameArgs',
    'AccessPolicyExcludeCommonNameArgsDict',
    'AccessPolicyExcludeDevicePostureArgs',
    'AccessPolicyExcludeDevicePostureArgsDict',
    'AccessPolicyExcludeEmailArgs',
    'AccessPolicyExcludeEmailArgsDict',
    'AccessPolicyExcludeEmailDomainArgs',
    'AccessPolicyExcludeEmailDomainArgsDict',
    'AccessPolicyExcludeEmailListArgs',
    'AccessPolicyExcludeEmailListArgsDict',
    'AccessPolicyExcludeEveryoneArgs',
    'AccessPolicyExcludeEveryoneArgsDict',
    'AccessPolicyExcludeExternalEvaluationArgs',
    'AccessPolicyExcludeExternalEvaluationArgsDict',
    'AccessPolicyExcludeGeoArgs',
    'AccessPolicyExcludeGeoArgsDict',
    'AccessPolicyExcludeGithubOrganizationArgs',
    'AccessPolicyExcludeGithubOrganizationArgsDict',
    'AccessPolicyExcludeGroupArgs',
    'AccessPolicyExcludeGroupArgsDict',
    'AccessPolicyExcludeGsuiteArgs',
    'AccessPolicyExcludeGsuiteArgsDict',
    'AccessPolicyExcludeIpArgs',
    'AccessPolicyExcludeIpArgsDict',
    'AccessPolicyExcludeIpListArgs',
    'AccessPolicyExcludeIpListArgsDict',
    'AccessPolicyExcludeLinkedAppTokenArgs',
    'AccessPolicyExcludeLinkedAppTokenArgsDict',
    'AccessPolicyExcludeLoginMethodArgs',
    'AccessPolicyExcludeLoginMethodArgsDict',
    'AccessPolicyExcludeOidcArgs',
    'AccessPolicyExcludeOidcArgsDict',
    'AccessPolicyExcludeOktaArgs',
    'AccessPolicyExcludeOktaArgsDict',
    'AccessPolicyExcludeSamlArgs',
    'AccessPolicyExcludeSamlArgsDict',
    'AccessPolicyExcludeServiceTokenArgs',
    'AccessPolicyExcludeServiceTokenArgsDict',
    'AccessPolicyIncludeArgs',
    'AccessPolicyIncludeArgsDict',
    'AccessPolicyIncludeAnyValidServiceTokenArgs',
    'AccessPolicyIncludeAnyValidServiceTokenArgsDict',
    'AccessPolicyIncludeAuthContextArgs',
    'AccessPolicyIncludeAuthContextArgsDict',
    'AccessPolicyIncludeAuthMethodArgs',
    'AccessPolicyIncludeAuthMethodArgsDict',
    'AccessPolicyIncludeAzureAdArgs',
    'AccessPolicyIncludeAzureAdArgsDict',
    'AccessPolicyIncludeCertificateArgs',
    'AccessPolicyIncludeCertificateArgsDict',
    'AccessPolicyIncludeCommonNameArgs',
    'AccessPolicyIncludeCommonNameArgsDict',
    'AccessPolicyIncludeDevicePostureArgs',
    'AccessPolicyIncludeDevicePostureArgsDict',
    'AccessPolicyIncludeEmailArgs',
    'AccessPolicyIncludeEmailArgsDict',
    'AccessPolicyIncludeEmailDomainArgs',
    'AccessPolicyIncludeEmailDomainArgsDict',
    'AccessPolicyIncludeEmailListArgs',
    'AccessPolicyIncludeEmailListArgsDict',
    'AccessPolicyIncludeEveryoneArgs',
    'AccessPolicyIncludeEveryoneArgsDict',
    'AccessPolicyIncludeExternalEvaluationArgs',
    'AccessPolicyIncludeExternalEvaluationArgsDict',
    'AccessPolicyIncludeGeoArgs',
    'AccessPolicyIncludeGeoArgsDict',
    'AccessPolicyIncludeGithubOrganizationArgs',
    'AccessPolicyIncludeGithubOrganizationArgsDict',
    'AccessPolicyIncludeGroupArgs',
    'AccessPolicyIncludeGroupArgsDict',
    'AccessPolicyIncludeGsuiteArgs',
    'AccessPolicyIncludeGsuiteArgsDict',
    'AccessPolicyIncludeIpArgs',
    'AccessPolicyIncludeIpArgsDict',
    'AccessPolicyIncludeIpListArgs',
    'AccessPolicyIncludeIpListArgsDict',
    'AccessPolicyIncludeLinkedAppTokenArgs',
    'AccessPolicyIncludeLinkedAppTokenArgsDict',
    'AccessPolicyIncludeLoginMethodArgs',
    'AccessPolicyIncludeLoginMethodArgsDict',
    'AccessPolicyIncludeOidcArgs',
    'AccessPolicyIncludeOidcArgsDict',
    'AccessPolicyIncludeOktaArgs',
    'AccessPolicyIncludeOktaArgsDict',
    'AccessPolicyIncludeSamlArgs',
    'AccessPolicyIncludeSamlArgsDict',
    'AccessPolicyIncludeServiceTokenArgs',
    'AccessPolicyIncludeServiceTokenArgsDict',
    'AccessPolicyRequireArgs',
    'AccessPolicyRequireArgsDict',
    'AccessPolicyRequireAnyValidServiceTokenArgs',
    'AccessPolicyRequireAnyValidServiceTokenArgsDict',
    'AccessPolicyRequireAuthContextArgs',
    'AccessPolicyRequireAuthContextArgsDict',
    'AccessPolicyRequireAuthMethodArgs',
    'AccessPolicyRequireAuthMethodArgsDict',
    'AccessPolicyRequireAzureAdArgs',
    'AccessPolicyRequireAzureAdArgsDict',
    'AccessPolicyRequireCertificateArgs',
    'AccessPolicyRequireCertificateArgsDict',
    'AccessPolicyRequireCommonNameArgs',
    'AccessPolicyRequireCommonNameArgsDict',
    'AccessPolicyRequireDevicePostureArgs',
    'AccessPolicyRequireDevicePostureArgsDict',
    'AccessPolicyRequireEmailArgs',
    'AccessPolicyRequireEmailArgsDict',
    'AccessPolicyRequireEmailDomainArgs',
    'AccessPolicyRequireEmailDomainArgsDict',
    'AccessPolicyRequireEmailListArgs',
    'AccessPolicyRequireEmailListArgsDict',
    'AccessPolicyRequireEveryoneArgs',
    'AccessPolicyRequireEveryoneArgsDict',
    'AccessPolicyRequireExternalEvaluationArgs',
    'AccessPolicyRequireExternalEvaluationArgsDict',
    'AccessPolicyRequireGeoArgs',
    'AccessPolicyRequireGeoArgsDict',
    'AccessPolicyRequireGithubOrganizationArgs',
    'AccessPolicyRequireGithubOrganizationArgsDict',
    'AccessPolicyRequireGroupArgs',
    'AccessPolicyRequireGroupArgsDict',
    'AccessPolicyRequireGsuiteArgs',
    'AccessPolicyRequireGsuiteArgsDict',
    'AccessPolicyRequireIpArgs',
    'AccessPolicyRequireIpArgsDict',
    'AccessPolicyRequireIpListArgs',
    'AccessPolicyRequireIpListArgsDict',
    'AccessPolicyRequireLinkedAppTokenArgs',
    'AccessPolicyRequireLinkedAppTokenArgsDict',
    'AccessPolicyRequireLoginMethodArgs',
    'AccessPolicyRequireLoginMethodArgsDict',
    'AccessPolicyRequireOidcArgs',
    'AccessPolicyRequireOidcArgsDict',
    'AccessPolicyRequireOktaArgs',
    'AccessPolicyRequireOktaArgsDict',
    'AccessPolicyRequireSamlArgs',
    'AccessPolicyRequireSamlArgsDict',
    'AccessPolicyRequireServiceTokenArgs',
    'AccessPolicyRequireServiceTokenArgsDict',
    'AccessRuleConfigurationArgs',
    'AccessRuleConfigurationArgsDict',
    'AccessRuleScopeArgs',
    'AccessRuleScopeArgsDict',
    'AccountDnsSettingsZoneDefaultsArgs',
    'AccountDnsSettingsZoneDefaultsArgsDict',
    'AccountDnsSettingsZoneDefaultsInternalDnsArgs',
    'AccountDnsSettingsZoneDefaultsInternalDnsArgsDict',
    'AccountDnsSettingsZoneDefaultsNameserversArgs',
    'AccountDnsSettingsZoneDefaultsNameserversArgsDict',
    'AccountDnsSettingsZoneDefaultsSoaArgs',
    'AccountDnsSettingsZoneDefaultsSoaArgsDict',
    'AccountMemberPolicyArgs',
    'AccountMemberPolicyArgsDict',
    'AccountMemberPolicyPermissionGroupArgs',
    'AccountMemberPolicyPermissionGroupArgsDict',
    'AccountMemberPolicyResourceGroupArgs',
    'AccountMemberPolicyResourceGroupArgsDict',
    'AccountMemberUserArgs',
    'AccountMemberUserArgsDict',
    'AccountSettingsArgs',
    'AccountSettingsArgsDict',
    'AccountSubscriptionRatePlanArgs',
    'AccountSubscriptionRatePlanArgsDict',
    'AccountTokenConditionArgs',
    'AccountTokenConditionArgsDict',
    'AccountTokenConditionRequestIpArgs',
    'AccountTokenConditionRequestIpArgsDict',
    'AccountTokenPolicyArgs',
    'AccountTokenPolicyArgsDict',
    'AccountTokenPolicyPermissionGroupArgs',
    'AccountTokenPolicyPermissionGroupArgsDict',
    'AccountTokenPolicyPermissionGroupMetaArgs',
    'AccountTokenPolicyPermissionGroupMetaArgsDict',
    'AccountUnitArgs',
    'AccountUnitArgsDict',
    'AddressMapMembershipArgs',
    'AddressMapMembershipArgsDict',
    'ApiShieldAuthIdCharacteristicArgs',
    'ApiShieldAuthIdCharacteristicArgsDict',
    'ApiShieldErrorArgs',
    'ApiShieldErrorArgsDict',
    'ApiShieldErrorSourceArgs',
    'ApiShieldErrorSourceArgsDict',
    'ApiShieldMessageArgs',
    'ApiShieldMessageArgsDict',
    'ApiShieldMessageSourceArgs',
    'ApiShieldMessageSourceArgsDict',
    'ApiShieldOperationFeaturesArgs',
    'ApiShieldOperationFeaturesArgsDict',
    'ApiShieldOperationFeaturesApiRoutingArgs',
    'ApiShieldOperationFeaturesApiRoutingArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsArgs',
    'ApiShieldOperationFeaturesConfidenceIntervalsArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args',
    'ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict',
    'ApiShieldOperationFeaturesParameterSchemasArgs',
    'ApiShieldOperationFeaturesParameterSchemasArgsDict',
    'ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs',
    'ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict',
    'ApiShieldOperationFeaturesSchemaInfoArgs',
    'ApiShieldOperationFeaturesSchemaInfoArgsDict',
    'ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs',
    'ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict',
    'ApiShieldOperationFeaturesThresholdsArgs',
    'ApiShieldOperationFeaturesThresholdsArgsDict',
    'ApiShieldSchemaSchemaArgs',
    'ApiShieldSchemaSchemaArgsDict',
    'ApiShieldSchemaUploadDetailsArgs',
    'ApiShieldSchemaUploadDetailsArgsDict',
    'ApiShieldSchemaUploadDetailsWarningArgs',
    'ApiShieldSchemaUploadDetailsWarningArgsDict',
    'ApiTokenConditionArgs',
    'ApiTokenConditionArgsDict',
    'ApiTokenConditionRequestIpArgs',
    'ApiTokenConditionRequestIpArgsDict',
    'ApiTokenPolicyArgs',
    'ApiTokenPolicyArgsDict',
    'ApiTokenPolicyPermissionGroupArgs',
    'ApiTokenPolicyPermissionGroupArgsDict',
    'ApiTokenPolicyPermissionGroupMetaArgs',
    'ApiTokenPolicyPermissionGroupMetaArgsDict',
    'AuthenticatedOriginPullsConfigArgs',
    'AuthenticatedOriginPullsConfigArgsDict',
    'BotManagementStaleZoneConfigurationArgs',
    'BotManagementStaleZoneConfigurationArgsDict',
    'CertificatePackValidationErrorArgs',
    'CertificatePackValidationErrorArgsDict',
    'CertificatePackValidationRecordArgs',
    'CertificatePackValidationRecordArgsDict',
    'CloudConnectorRulesRuleArgs',
    'CloudConnectorRulesRuleArgsDict',
    'CloudConnectorRulesRuleParametersArgs',
    'CloudConnectorRulesRuleParametersArgsDict',
    'ContentScanningExpressionBodyArgs',
    'ContentScanningExpressionBodyArgsDict',
    'CustomHostnameOwnershipVerificationArgs',
    'CustomHostnameOwnershipVerificationArgsDict',
    'CustomHostnameOwnershipVerificationHttpArgs',
    'CustomHostnameOwnershipVerificationHttpArgsDict',
    'CustomHostnameSslArgs',
    'CustomHostnameSslArgsDict',
    'CustomHostnameSslCustomCertBundleArgs',
    'CustomHostnameSslCustomCertBundleArgsDict',
    'CustomHostnameSslSettingsArgs',
    'CustomHostnameSslSettingsArgsDict',
    'CustomSslGeoRestrictionsArgs',
    'CustomSslGeoRestrictionsArgsDict',
    'CustomSslKeylessServerArgs',
    'CustomSslKeylessServerArgsDict',
    'CustomSslKeylessServerTunnelArgs',
    'CustomSslKeylessServerTunnelArgsDict',
    'D1DatabaseReadReplicationArgs',
    'D1DatabaseReadReplicationArgsDict',
    'DeviceManagedNetworksConfigArgs',
    'DeviceManagedNetworksConfigArgsDict',
    'DevicePostureIntegrationConfigArgs',
    'DevicePostureIntegrationConfigArgsDict',
    'DevicePostureRuleInputArgs',
    'DevicePostureRuleInputArgsDict',
    'DevicePostureRuleInputLocationsArgs',
    'DevicePostureRuleInputLocationsArgsDict',
    'DevicePostureRuleMatchArgs',
    'DevicePostureRuleMatchArgsDict',
    'DlpCustomProfileContextAwarenessArgs',
    'DlpCustomProfileContextAwarenessArgsDict',
    'DlpCustomProfileContextAwarenessSkipArgs',
    'DlpCustomProfileContextAwarenessSkipArgsDict',
    'DlpCustomProfileEntryArgs',
    'DlpCustomProfileEntryArgsDict',
    'DlpCustomProfileEntryPatternArgs',
    'DlpCustomProfileEntryPatternArgsDict',
    'DlpCustomProfileSharedEntryArgs',
    'DlpCustomProfileSharedEntryArgsDict',
    'DlpPredefinedProfileContextAwarenessArgs',
    'DlpPredefinedProfileContextAwarenessArgsDict',
    'DlpPredefinedProfileContextAwarenessSkipArgs',
    'DlpPredefinedProfileContextAwarenessSkipArgsDict',
    'DlpPredefinedProfileEntryArgs',
    'DlpPredefinedProfileEntryArgsDict',
    'DnsFirewallAttackMitigationArgs',
    'DnsFirewallAttackMitigationArgsDict',
    'DnsRecordDataArgs',
    'DnsRecordDataArgsDict',
    'DnsRecordSettingsArgs',
    'DnsRecordSettingsArgsDict',
    'EmailRoutingCatchAllActionArgs',
    'EmailRoutingCatchAllActionArgsDict',
    'EmailRoutingCatchAllMatcherArgs',
    'EmailRoutingCatchAllMatcherArgsDict',
    'EmailRoutingDnsErrorArgs',
    'EmailRoutingDnsErrorArgsDict',
    'EmailRoutingDnsErrorSourceArgs',
    'EmailRoutingDnsErrorSourceArgsDict',
    'EmailRoutingDnsMessageArgs',
    'EmailRoutingDnsMessageArgsDict',
    'EmailRoutingDnsMessageSourceArgs',
    'EmailRoutingDnsMessageSourceArgsDict',
    'EmailRoutingDnsResultArgs',
    'EmailRoutingDnsResultArgsDict',
    'EmailRoutingDnsResultErrorArgs',
    'EmailRoutingDnsResultErrorArgsDict',
    'EmailRoutingDnsResultErrorMissingArgs',
    'EmailRoutingDnsResultErrorMissingArgsDict',
    'EmailRoutingDnsResultInfoArgs',
    'EmailRoutingDnsResultInfoArgsDict',
    'EmailRoutingDnsResultRecordArgs',
    'EmailRoutingDnsResultRecordArgsDict',
    'EmailRoutingRuleActionArgs',
    'EmailRoutingRuleActionArgsDict',
    'EmailRoutingRuleMatcherArgs',
    'EmailRoutingRuleMatcherArgsDict',
    'EmailSecurityTrustedDomainsBodyArgs',
    'EmailSecurityTrustedDomainsBodyArgsDict',
    'FilterBodyArgs',
    'FilterBodyArgsDict',
    'FirewallRuleActionArgs',
    'FirewallRuleActionArgsDict',
    'FirewallRuleActionResponseArgs',
    'FirewallRuleActionResponseArgsDict',
    'FirewallRuleFilterArgs',
    'FirewallRuleFilterArgsDict',
    'HealthcheckHttpConfigArgs',
    'HealthcheckHttpConfigArgsDict',
    'HealthcheckTcpConfigArgs',
    'HealthcheckTcpConfigArgsDict',
    'HyperdriveConfigCachingArgs',
    'HyperdriveConfigCachingArgsDict',
    'HyperdriveConfigMtlsArgs',
    'HyperdriveConfigMtlsArgsDict',
    'HyperdriveConfigOriginArgs',
    'HyperdriveConfigOriginArgsDict',
    'ImageVariantOptionsArgs',
    'ImageVariantOptionsArgsDict',
    'ImageVariantVariantArgs',
    'ImageVariantVariantArgsDict',
    'ImageVariantVariantOptionsArgs',
    'ImageVariantVariantOptionsArgsDict',
    'KeylessCertificateTunnelArgs',
    'KeylessCertificateTunnelArgsDict',
    'ListItemArgs',
    'ListItemArgsDict',
    'ListItemHostnameArgs',
    'ListItemHostnameArgsDict',
    'ListItemRedirectArgs',
    'ListItemRedirectArgsDict',
    'LoadBalancerAdaptiveRoutingArgs',
    'LoadBalancerAdaptiveRoutingArgsDict',
    'LoadBalancerLocationStrategyArgs',
    'LoadBalancerLocationStrategyArgsDict',
    'LoadBalancerPoolLoadSheddingArgs',
    'LoadBalancerPoolLoadSheddingArgsDict',
    'LoadBalancerPoolNotificationFilterArgs',
    'LoadBalancerPoolNotificationFilterArgsDict',
    'LoadBalancerPoolNotificationFilterOriginArgs',
    'LoadBalancerPoolNotificationFilterOriginArgsDict',
    'LoadBalancerPoolNotificationFilterPoolArgs',
    'LoadBalancerPoolNotificationFilterPoolArgsDict',
    'LoadBalancerPoolOriginArgs',
    'LoadBalancerPoolOriginArgsDict',
    'LoadBalancerPoolOriginHeaderArgs',
    'LoadBalancerPoolOriginHeaderArgsDict',
    'LoadBalancerPoolOriginSteeringArgs',
    'LoadBalancerPoolOriginSteeringArgsDict',
    'LoadBalancerRandomSteeringArgs',
    'LoadBalancerRandomSteeringArgsDict',
    'LoadBalancerRuleArgs',
    'LoadBalancerRuleArgsDict',
    'LoadBalancerRuleFixedResponseArgs',
    'LoadBalancerRuleFixedResponseArgsDict',
    'LoadBalancerRuleOverridesArgs',
    'LoadBalancerRuleOverridesArgsDict',
    'LoadBalancerRuleOverridesAdaptiveRoutingArgs',
    'LoadBalancerRuleOverridesAdaptiveRoutingArgsDict',
    'LoadBalancerRuleOverridesLocationStrategyArgs',
    'LoadBalancerRuleOverridesLocationStrategyArgsDict',
    'LoadBalancerRuleOverridesRandomSteeringArgs',
    'LoadBalancerRuleOverridesRandomSteeringArgsDict',
    'LoadBalancerRuleOverridesSessionAffinityAttributesArgs',
    'LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict',
    'LoadBalancerSessionAffinityAttributesArgs',
    'LoadBalancerSessionAffinityAttributesArgsDict',
    'LogpushJobOutputOptionsArgs',
    'LogpushJobOutputOptionsArgsDict',
    'MagicNetworkMonitoringConfigurationWarpDeviceArgs',
    'MagicNetworkMonitoringConfigurationWarpDeviceArgsDict',
    'MagicTransitConnectorDeviceArgs',
    'MagicTransitConnectorDeviceArgsDict',
    'MagicTransitSiteAclLan1Args',
    'MagicTransitSiteAclLan1ArgsDict',
    'MagicTransitSiteAclLan2Args',
    'MagicTransitSiteAclLan2ArgsDict',
    'MagicTransitSiteLanNatArgs',
    'MagicTransitSiteLanNatArgsDict',
    'MagicTransitSiteLanRoutedSubnetArgs',
    'MagicTransitSiteLanRoutedSubnetArgsDict',
    'MagicTransitSiteLanRoutedSubnetNatArgs',
    'MagicTransitSiteLanRoutedSubnetNatArgsDict',
    'MagicTransitSiteLanStaticAddressingArgs',
    'MagicTransitSiteLanStaticAddressingArgsDict',
    'MagicTransitSiteLanStaticAddressingDhcpRelayArgs',
    'MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict',
    'MagicTransitSiteLanStaticAddressingDhcpServerArgs',
    'MagicTransitSiteLanStaticAddressingDhcpServerArgsDict',
    'MagicTransitSiteLocationArgs',
    'MagicTransitSiteLocationArgsDict',
    'MagicTransitSiteWanStaticAddressingArgs',
    'MagicTransitSiteWanStaticAddressingArgsDict',
    'MagicWanGreTunnelHealthCheckArgs',
    'MagicWanGreTunnelHealthCheckArgsDict',
    'MagicWanGreTunnelHealthCheckTargetArgs',
    'MagicWanGreTunnelHealthCheckTargetArgsDict',
    'MagicWanIpsecTunnelHealthCheckArgs',
    'MagicWanIpsecTunnelHealthCheckArgsDict',
    'MagicWanIpsecTunnelHealthCheckTargetArgs',
    'MagicWanIpsecTunnelHealthCheckTargetArgsDict',
    'MagicWanIpsecTunnelPskMetadataArgs',
    'MagicWanIpsecTunnelPskMetadataArgsDict',
    'MagicWanStaticRouteScopeArgs',
    'MagicWanStaticRouteScopeArgsDict',
    'ManagedHeadersManagedRequestHeaderArgs',
    'ManagedHeadersManagedRequestHeaderArgsDict',
    'ManagedHeadersManagedResponseHeaderArgs',
    'ManagedHeadersManagedResponseHeaderArgsDict',
    'ManagedTransformsManagedRequestHeaderArgs',
    'ManagedTransformsManagedRequestHeaderArgsDict',
    'ManagedTransformsManagedResponseHeaderArgs',
    'ManagedTransformsManagedResponseHeaderArgsDict',
    'NotificationPolicyFiltersArgs',
    'NotificationPolicyFiltersArgsDict',
    'NotificationPolicyMechanismsArgs',
    'NotificationPolicyMechanismsArgsDict',
    'NotificationPolicyMechanismsEmailArgs',
    'NotificationPolicyMechanismsEmailArgsDict',
    'NotificationPolicyMechanismsPagerdutyArgs',
    'NotificationPolicyMechanismsPagerdutyArgsDict',
    'NotificationPolicyMechanismsWebhookArgs',
    'NotificationPolicyMechanismsWebhookArgsDict',
    'ObservatoryScheduledTestScheduleArgs',
    'ObservatoryScheduledTestScheduleArgsDict',
    'ObservatoryScheduledTestTestArgs',
    'ObservatoryScheduledTestTestArgsDict',
    'ObservatoryScheduledTestTestDesktopReportArgs',
    'ObservatoryScheduledTestTestDesktopReportArgsDict',
    'ObservatoryScheduledTestTestDesktopReportErrorArgs',
    'ObservatoryScheduledTestTestDesktopReportErrorArgsDict',
    'ObservatoryScheduledTestTestMobileReportArgs',
    'ObservatoryScheduledTestTestMobileReportArgsDict',
    'ObservatoryScheduledTestTestMobileReportErrorArgs',
    'ObservatoryScheduledTestTestMobileReportErrorArgsDict',
    'ObservatoryScheduledTestTestRegionArgs',
    'ObservatoryScheduledTestTestRegionArgsDict',
    'PageRuleActionsArgs',
    'PageRuleActionsArgsDict',
    'PageRuleActionsCacheKeyFieldsArgs',
    'PageRuleActionsCacheKeyFieldsArgsDict',
    'PageRuleActionsCacheKeyFieldsCookieArgs',
    'PageRuleActionsCacheKeyFieldsCookieArgsDict',
    'PageRuleActionsCacheKeyFieldsHeaderArgs',
    'PageRuleActionsCacheKeyFieldsHeaderArgsDict',
    'PageRuleActionsCacheKeyFieldsHostArgs',
    'PageRuleActionsCacheKeyFieldsHostArgsDict',
    'PageRuleActionsCacheKeyFieldsQueryStringArgs',
    'PageRuleActionsCacheKeyFieldsQueryStringArgsDict',
    'PageRuleActionsCacheKeyFieldsUserArgs',
    'PageRuleActionsCacheKeyFieldsUserArgsDict',
    'PageRuleActionsForwardingUrlArgs',
    'PageRuleActionsForwardingUrlArgsDict',
    'PagesDomainValidationDataArgs',
    'PagesDomainValidationDataArgsDict',
    'PagesDomainVerificationDataArgs',
    'PagesDomainVerificationDataArgsDict',
    'PagesProjectBuildConfigArgs',
    'PagesProjectBuildConfigArgsDict',
    'PagesProjectCanonicalDeploymentArgs',
    'PagesProjectCanonicalDeploymentArgsDict',
    'PagesProjectCanonicalDeploymentBuildConfigArgs',
    'PagesProjectCanonicalDeploymentBuildConfigArgsDict',
    'PagesProjectCanonicalDeploymentDeploymentTriggerArgs',
    'PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict',
    'PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs',
    'PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict',
    'PagesProjectCanonicalDeploymentEnvVarsArgs',
    'PagesProjectCanonicalDeploymentEnvVarsArgsDict',
    'PagesProjectCanonicalDeploymentLatestStageArgs',
    'PagesProjectCanonicalDeploymentLatestStageArgsDict',
    'PagesProjectCanonicalDeploymentSourceArgs',
    'PagesProjectCanonicalDeploymentSourceArgsDict',
    'PagesProjectCanonicalDeploymentSourceConfigArgs',
    'PagesProjectCanonicalDeploymentSourceConfigArgsDict',
    'PagesProjectCanonicalDeploymentStageArgs',
    'PagesProjectCanonicalDeploymentStageArgsDict',
    'PagesProjectDeploymentConfigsArgs',
    'PagesProjectDeploymentConfigsArgsDict',
    'PagesProjectDeploymentConfigsPreviewArgs',
    'PagesProjectDeploymentConfigsPreviewArgsDict',
    'PagesProjectDeploymentConfigsPreviewAiBindingsArgs',
    'PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict',
    'PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs',
    'PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict',
    'PagesProjectDeploymentConfigsPreviewBrowsersArgs',
    'PagesProjectDeploymentConfigsPreviewBrowsersArgsDict',
    'PagesProjectDeploymentConfigsPreviewD1DatabasesArgs',
    'PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict',
    'PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs',
    'PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict',
    'PagesProjectDeploymentConfigsPreviewEnvVarsArgs',
    'PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict',
    'PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs',
    'PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict',
    'PagesProjectDeploymentConfigsPreviewKvNamespacesArgs',
    'PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict',
    'PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs',
    'PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict',
    'PagesProjectDeploymentConfigsPreviewPlacementArgs',
    'PagesProjectDeploymentConfigsPreviewPlacementArgsDict',
    'PagesProjectDeploymentConfigsPreviewQueueProducersArgs',
    'PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict',
    'PagesProjectDeploymentConfigsPreviewR2BucketsArgs',
    'PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict',
    'PagesProjectDeploymentConfigsPreviewServicesArgs',
    'PagesProjectDeploymentConfigsPreviewServicesArgsDict',
    'PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs',
    'PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict',
    'PagesProjectDeploymentConfigsProductionArgs',
    'PagesProjectDeploymentConfigsProductionArgsDict',
    'PagesProjectDeploymentConfigsProductionAiBindingsArgs',
    'PagesProjectDeploymentConfigsProductionAiBindingsArgsDict',
    'PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs',
    'PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict',
    'PagesProjectDeploymentConfigsProductionBrowsersArgs',
    'PagesProjectDeploymentConfigsProductionBrowsersArgsDict',
    'PagesProjectDeploymentConfigsProductionD1DatabasesArgs',
    'PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict',
    'PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs',
    'PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict',
    'PagesProjectDeploymentConfigsProductionEnvVarsArgs',
    'PagesProjectDeploymentConfigsProductionEnvVarsArgsDict',
    'PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs',
    'PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict',
    'PagesProjectDeploymentConfigsProductionKvNamespacesArgs',
    'PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict',
    'PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs',
    'PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict',
    'PagesProjectDeploymentConfigsProductionPlacementArgs',
    'PagesProjectDeploymentConfigsProductionPlacementArgsDict',
    'PagesProjectDeploymentConfigsProductionQueueProducersArgs',
    'PagesProjectDeploymentConfigsProductionQueueProducersArgsDict',
    'PagesProjectDeploymentConfigsProductionR2BucketsArgs',
    'PagesProjectDeploymentConfigsProductionR2BucketsArgsDict',
    'PagesProjectDeploymentConfigsProductionServicesArgs',
    'PagesProjectDeploymentConfigsProductionServicesArgsDict',
    'PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs',
    'PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict',
    'PagesProjectLatestDeploymentArgs',
    'PagesProjectLatestDeploymentArgsDict',
    'PagesProjectLatestDeploymentBuildConfigArgs',
    'PagesProjectLatestDeploymentBuildConfigArgsDict',
    'PagesProjectLatestDeploymentDeploymentTriggerArgs',
    'PagesProjectLatestDeploymentDeploymentTriggerArgsDict',
    'PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs',
    'PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict',
    'PagesProjectLatestDeploymentEnvVarsArgs',
    'PagesProjectLatestDeploymentEnvVarsArgsDict',
    'PagesProjectLatestDeploymentLatestStageArgs',
    'PagesProjectLatestDeploymentLatestStageArgsDict',
    'PagesProjectLatestDeploymentSourceArgs',
    'PagesProjectLatestDeploymentSourceArgsDict',
    'PagesProjectLatestDeploymentSourceConfigArgs',
    'PagesProjectLatestDeploymentSourceConfigArgsDict',
    'PagesProjectLatestDeploymentStageArgs',
    'PagesProjectLatestDeploymentStageArgsDict',
    'PagesProjectSourceArgs',
    'PagesProjectSourceArgsDict',
    'PagesProjectSourceConfigArgs',
    'PagesProjectSourceConfigArgsDict',
    'QueueConsumerArgs',
    'QueueConsumerArgsDict',
    'QueueConsumerSettingsArgs',
    'QueueConsumerSettingsArgsDict',
    'QueueProducerArgs',
    'QueueProducerArgsDict',
    'QueueSettingsArgs',
    'QueueSettingsArgsDict',
    'R2BucketCorsRuleArgs',
    'R2BucketCorsRuleArgsDict',
    'R2BucketCorsRuleAllowedArgs',
    'R2BucketCorsRuleAllowedArgsDict',
    'R2BucketEventNotificationRuleArgs',
    'R2BucketEventNotificationRuleArgsDict',
    'R2BucketLifecycleRuleArgs',
    'R2BucketLifecycleRuleArgsDict',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs',
    'R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict',
    'R2BucketLifecycleRuleConditionsArgs',
    'R2BucketLifecycleRuleConditionsArgsDict',
    'R2BucketLifecycleRuleDeleteObjectsTransitionArgs',
    'R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict',
    'R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs',
    'R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict',
    'R2BucketLifecycleRuleStorageClassTransitionArgs',
    'R2BucketLifecycleRuleStorageClassTransitionArgsDict',
    'R2BucketLifecycleRuleStorageClassTransitionConditionArgs',
    'R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict',
    'R2BucketLockRuleArgs',
    'R2BucketLockRuleArgsDict',
    'R2BucketLockRuleConditionArgs',
    'R2BucketLockRuleConditionArgsDict',
    'R2BucketSippyDestinationArgs',
    'R2BucketSippyDestinationArgsDict',
    'R2BucketSippySourceArgs',
    'R2BucketSippySourceArgsDict',
    'R2CustomDomainStatusArgs',
    'R2CustomDomainStatusArgsDict',
    'RateLimitActionArgs',
    'RateLimitActionArgsDict',
    'RateLimitActionResponseArgs',
    'RateLimitActionResponseArgsDict',
    'RateLimitBypassArgs',
    'RateLimitBypassArgsDict',
    'RateLimitMatchArgs',
    'RateLimitMatchArgsDict',
    'RateLimitMatchHeaderArgs',
    'RateLimitMatchHeaderArgsDict',
    'RateLimitMatchRequestArgs',
    'RateLimitMatchRequestArgsDict',
    'RateLimitMatchResponseArgs',
    'RateLimitMatchResponseArgsDict',
    'RecordDataArgs',
    'RecordDataArgsDict',
    'RecordSettingsArgs',
    'RecordSettingsArgsDict',
    'RiskBehaviorBehaviorsArgs',
    'RiskBehaviorBehaviorsArgsDict',
    'RulesetRuleArgs',
    'RulesetRuleArgsDict',
    'RulesetRuleActionParametersArgs',
    'RulesetRuleActionParametersArgsDict',
    'RulesetRuleActionParametersAlgorithmArgs',
    'RulesetRuleActionParametersAlgorithmArgsDict',
    'RulesetRuleActionParametersAutominifyArgs',
    'RulesetRuleActionParametersAutominifyArgsDict',
    'RulesetRuleActionParametersBrowserTtlArgs',
    'RulesetRuleActionParametersBrowserTtlArgsDict',
    'RulesetRuleActionParametersCacheKeyArgs',
    'RulesetRuleActionParametersCacheKeyArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgs',
    'RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict',
    'RulesetRuleActionParametersCacheReserveArgs',
    'RulesetRuleActionParametersCacheReserveArgsDict',
    'RulesetRuleActionParametersCookieFieldArgs',
    'RulesetRuleActionParametersCookieFieldArgsDict',
    'RulesetRuleActionParametersEdgeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlArgsDict',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs',
    'RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict',
    'RulesetRuleActionParametersFromListArgs',
    'RulesetRuleActionParametersFromListArgsDict',
    'RulesetRuleActionParametersFromValueArgs',
    'RulesetRuleActionParametersFromValueArgsDict',
    'RulesetRuleActionParametersFromValueTargetUrlArgs',
    'RulesetRuleActionParametersFromValueTargetUrlArgsDict',
    'RulesetRuleActionParametersHeadersArgs',
    'RulesetRuleActionParametersHeadersArgsDict',
    'RulesetRuleActionParametersMatchedDataArgs',
    'RulesetRuleActionParametersMatchedDataArgsDict',
    'RulesetRuleActionParametersOriginArgs',
    'RulesetRuleActionParametersOriginArgsDict',
    'RulesetRuleActionParametersOverridesArgs',
    'RulesetRuleActionParametersOverridesArgsDict',
    'RulesetRuleActionParametersOverridesCategoryArgs',
    'RulesetRuleActionParametersOverridesCategoryArgsDict',
    'RulesetRuleActionParametersOverridesRuleArgs',
    'RulesetRuleActionParametersOverridesRuleArgsDict',
    'RulesetRuleActionParametersRawResponseFieldArgs',
    'RulesetRuleActionParametersRawResponseFieldArgsDict',
    'RulesetRuleActionParametersRequestFieldArgs',
    'RulesetRuleActionParametersRequestFieldArgsDict',
    'RulesetRuleActionParametersResponseArgs',
    'RulesetRuleActionParametersResponseArgsDict',
    'RulesetRuleActionParametersResponseFieldArgs',
    'RulesetRuleActionParametersResponseFieldArgsDict',
    'RulesetRuleActionParametersServeStaleArgs',
    'RulesetRuleActionParametersServeStaleArgsDict',
    'RulesetRuleActionParametersSniArgs',
    'RulesetRuleActionParametersSniArgsDict',
    'RulesetRuleActionParametersTransformedRequestFieldArgs',
    'RulesetRuleActionParametersTransformedRequestFieldArgsDict',
    'RulesetRuleActionParametersUriArgs',
    'RulesetRuleActionParametersUriArgsDict',
    'RulesetRuleActionParametersUriPathArgs',
    'RulesetRuleActionParametersUriPathArgsDict',
    'RulesetRuleActionParametersUriQueryArgs',
    'RulesetRuleActionParametersUriQueryArgsDict',
    'RulesetRuleExposedCredentialCheckArgs',
    'RulesetRuleExposedCredentialCheckArgsDict',
    'RulesetRuleLoggingArgs',
    'RulesetRuleLoggingArgsDict',
    'RulesetRuleRatelimitArgs',
    'RulesetRuleRatelimitArgsDict',
    'SnippetFileArgs',
    'SnippetFileArgsDict',
    'SnippetMetadataArgs',
    'SnippetMetadataArgsDict',
    'SnippetRulesRuleArgs',
    'SnippetRulesRuleArgsDict',
    'SnippetsMetadataArgs',
    'SnippetsMetadataArgsDict',
    'SpectrumApplicationDnsArgs',
    'SpectrumApplicationDnsArgsDict',
    'SpectrumApplicationEdgeIpsArgs',
    'SpectrumApplicationEdgeIpsArgsDict',
    'SpectrumApplicationOriginDnsArgs',
    'SpectrumApplicationOriginDnsArgsDict',
    'StaticRouteScopeArgs',
    'StaticRouteScopeArgsDict',
    'StreamInputArgs',
    'StreamInputArgsDict',
    'StreamLiveInputRecordingArgs',
    'StreamLiveInputRecordingArgsDict',
    'StreamLiveInputRtmpsArgs',
    'StreamLiveInputRtmpsArgsDict',
    'StreamLiveInputRtmpsPlaybackArgs',
    'StreamLiveInputRtmpsPlaybackArgsDict',
    'StreamLiveInputSrtArgs',
    'StreamLiveInputSrtArgsDict',
    'StreamLiveInputSrtPlaybackArgs',
    'StreamLiveInputSrtPlaybackArgsDict',
    'StreamLiveInputWebRtcArgs',
    'StreamLiveInputWebRtcArgsDict',
    'StreamLiveInputWebRtcPlaybackArgs',
    'StreamLiveInputWebRtcPlaybackArgsDict',
    'StreamPlaybackArgs',
    'StreamPlaybackArgsDict',
    'StreamStatusArgs',
    'StreamStatusArgsDict',
    'StreamWatermarkArgs',
    'StreamWatermarkArgsDict',
    'TeamsAccountSettingsArgs',
    'TeamsAccountSettingsArgsDict',
    'TeamsAccountSettingsActivityLogArgs',
    'TeamsAccountSettingsActivityLogArgsDict',
    'TeamsAccountSettingsAntivirusArgs',
    'TeamsAccountSettingsAntivirusArgsDict',
    'TeamsAccountSettingsAntivirusNotificationSettingsArgs',
    'TeamsAccountSettingsAntivirusNotificationSettingsArgsDict',
    'TeamsAccountSettingsBlockPageArgs',
    'TeamsAccountSettingsBlockPageArgsDict',
    'TeamsAccountSettingsBodyScanningArgs',
    'TeamsAccountSettingsBodyScanningArgsDict',
    'TeamsAccountSettingsBrowserIsolationArgs',
    'TeamsAccountSettingsBrowserIsolationArgsDict',
    'TeamsAccountSettingsCertificateArgs',
    'TeamsAccountSettingsCertificateArgsDict',
    'TeamsAccountSettingsCustomCertificateArgs',
    'TeamsAccountSettingsCustomCertificateArgsDict',
    'TeamsAccountSettingsExtendedEmailMatchingArgs',
    'TeamsAccountSettingsExtendedEmailMatchingArgsDict',
    'TeamsAccountSettingsFipsArgs',
    'TeamsAccountSettingsFipsArgsDict',
    'TeamsAccountSettingsHostSelectorArgs',
    'TeamsAccountSettingsHostSelectorArgsDict',
    'TeamsAccountSettingsInspectionArgs',
    'TeamsAccountSettingsInspectionArgsDict',
    'TeamsAccountSettingsProtocolDetectionArgs',
    'TeamsAccountSettingsProtocolDetectionArgsDict',
    'TeamsAccountSettingsSandboxArgs',
    'TeamsAccountSettingsSandboxArgsDict',
    'TeamsAccountSettingsTlsDecryptArgs',
    'TeamsAccountSettingsTlsDecryptArgsDict',
    'TeamsListItemArgs',
    'TeamsListItemArgsDict',
    'TeamsLocationEndpointsArgs',
    'TeamsLocationEndpointsArgsDict',
    'TeamsLocationEndpointsDohArgs',
    'TeamsLocationEndpointsDohArgsDict',
    'TeamsLocationEndpointsDohNetworkArgs',
    'TeamsLocationEndpointsDohNetworkArgsDict',
    'TeamsLocationEndpointsDotArgs',
    'TeamsLocationEndpointsDotArgsDict',
    'TeamsLocationEndpointsDotNetworkArgs',
    'TeamsLocationEndpointsDotNetworkArgsDict',
    'TeamsLocationEndpointsIpv4Args',
    'TeamsLocationEndpointsIpv4ArgsDict',
    'TeamsLocationEndpointsIpv6Args',
    'TeamsLocationEndpointsIpv6ArgsDict',
    'TeamsLocationEndpointsIpv6NetworkArgs',
    'TeamsLocationEndpointsIpv6NetworkArgsDict',
    'TeamsLocationNetworkArgs',
    'TeamsLocationNetworkArgsDict',
    'TeamsRuleExpirationArgs',
    'TeamsRuleExpirationArgsDict',
    'TeamsRuleRuleSettingsArgs',
    'TeamsRuleRuleSettingsArgsDict',
    'TeamsRuleRuleSettingsAuditSshArgs',
    'TeamsRuleRuleSettingsAuditSshArgsDict',
    'TeamsRuleRuleSettingsBisoAdminControlsArgs',
    'TeamsRuleRuleSettingsBisoAdminControlsArgsDict',
    'TeamsRuleRuleSettingsBlockPageArgs',
    'TeamsRuleRuleSettingsBlockPageArgsDict',
    'TeamsRuleRuleSettingsCheckSessionArgs',
    'TeamsRuleRuleSettingsCheckSessionArgsDict',
    'TeamsRuleRuleSettingsDnsResolversArgs',
    'TeamsRuleRuleSettingsDnsResolversArgsDict',
    'TeamsRuleRuleSettingsDnsResolversIpv4Args',
    'TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict',
    'TeamsRuleRuleSettingsDnsResolversIpv6Args',
    'TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict',
    'TeamsRuleRuleSettingsEgressArgs',
    'TeamsRuleRuleSettingsEgressArgsDict',
    'TeamsRuleRuleSettingsL4overrideArgs',
    'TeamsRuleRuleSettingsL4overrideArgsDict',
    'TeamsRuleRuleSettingsNotificationSettingsArgs',
    'TeamsRuleRuleSettingsNotificationSettingsArgsDict',
    'TeamsRuleRuleSettingsPayloadLogArgs',
    'TeamsRuleRuleSettingsPayloadLogArgsDict',
    'TeamsRuleRuleSettingsQuarantineArgs',
    'TeamsRuleRuleSettingsQuarantineArgsDict',
    'TeamsRuleRuleSettingsRedirectArgs',
    'TeamsRuleRuleSettingsRedirectArgsDict',
    'TeamsRuleRuleSettingsResolveDnsInternallyArgs',
    'TeamsRuleRuleSettingsResolveDnsInternallyArgsDict',
    'TeamsRuleRuleSettingsUntrustedCertArgs',
    'TeamsRuleRuleSettingsUntrustedCertArgsDict',
    'TeamsRuleScheduleArgs',
    'TeamsRuleScheduleArgsDict',
    'TunnelConfigConfigArgs',
    'TunnelConfigConfigArgsDict',
    'TunnelConfigConfigIngressArgs',
    'TunnelConfigConfigIngressArgsDict',
    'TunnelConfigConfigIngressOriginRequestArgs',
    'TunnelConfigConfigIngressOriginRequestArgsDict',
    'TunnelConfigConfigIngressOriginRequestAccessArgs',
    'TunnelConfigConfigIngressOriginRequestAccessArgsDict',
    'TunnelConfigConfigOriginRequestArgs',
    'TunnelConfigConfigOriginRequestArgsDict',
    'TunnelConfigConfigOriginRequestAccessArgs',
    'TunnelConfigConfigOriginRequestAccessArgsDict',
    'TunnelConfigConfigWarpRoutingArgs',
    'TunnelConfigConfigWarpRoutingArgsDict',
    'TunnelConnectionArgs',
    'TunnelConnectionArgsDict',
    'UserAgentBlockingRuleConfigurationArgs',
    'UserAgentBlockingRuleConfigurationArgsDict',
    'UserOrganizationArgs',
    'UserOrganizationArgsDict',
    'WaitingRoomAdditionalRouteArgs',
    'WaitingRoomAdditionalRouteArgsDict',
    'WaitingRoomCookieAttributesArgs',
    'WaitingRoomCookieAttributesArgsDict',
    'WaitingRoomRulesRuleArgs',
    'WaitingRoomRulesRuleArgsDict',
    'WebAnalyticsSiteRuleArgs',
    'WebAnalyticsSiteRuleArgsDict',
    'WebAnalyticsSiteRulesetArgs',
    'WebAnalyticsSiteRulesetArgsDict',
    'WorkerCronTriggerScheduleArgs',
    'WorkerCronTriggerScheduleArgsDict',
    'WorkerObservabilityArgs',
    'WorkerObservabilityArgsDict',
    'WorkerObservabilityLogsArgs',
    'WorkerObservabilityLogsArgsDict',
    'WorkerScriptAssetsArgs',
    'WorkerScriptAssetsArgsDict',
    'WorkerScriptAssetsConfigArgs',
    'WorkerScriptAssetsConfigArgsDict',
    'WorkerScriptBindingArgs',
    'WorkerScriptBindingArgsDict',
    'WorkerScriptBindingOutboundArgs',
    'WorkerScriptBindingOutboundArgsDict',
    'WorkerScriptBindingOutboundWorkerArgs',
    'WorkerScriptBindingOutboundWorkerArgsDict',
    'WorkerScriptLimitsArgs',
    'WorkerScriptLimitsArgsDict',
    'WorkerScriptNamedHandlerArgs',
    'WorkerScriptNamedHandlerArgsDict',
    'WorkerScriptObservabilityArgs',
    'WorkerScriptObservabilityArgsDict',
    'WorkerScriptObservabilityLogsArgs',
    'WorkerScriptObservabilityLogsArgsDict',
    'WorkerScriptPlacementArgs',
    'WorkerScriptPlacementArgsDict',
    'WorkerScriptTailConsumerArgs',
    'WorkerScriptTailConsumerArgsDict',
    'WorkerSubdomainArgs',
    'WorkerSubdomainArgsDict',
    'WorkerTailConsumerArgs',
    'WorkerTailConsumerArgsDict',
    'WorkerVersionAnnotationsArgs',
    'WorkerVersionAnnotationsArgsDict',
    'WorkerVersionAssetsArgs',
    'WorkerVersionAssetsArgsDict',
    'WorkerVersionAssetsConfigArgs',
    'WorkerVersionAssetsConfigArgsDict',
    'WorkerVersionBindingArgs',
    'WorkerVersionBindingArgsDict',
    'WorkerVersionBindingOutboundArgs',
    'WorkerVersionBindingOutboundArgsDict',
    'WorkerVersionBindingOutboundWorkerArgs',
    'WorkerVersionBindingOutboundWorkerArgsDict',
    'WorkerVersionLimitsArgs',
    'WorkerVersionLimitsArgsDict',
    'WorkerVersionMigrationsArgs',
    'WorkerVersionMigrationsArgsDict',
    'WorkerVersionMigrationsRenamedClassArgs',
    'WorkerVersionMigrationsRenamedClassArgsDict',
    'WorkerVersionMigrationsStepArgs',
    'WorkerVersionMigrationsStepArgsDict',
    'WorkerVersionMigrationsStepRenamedClassArgs',
    'WorkerVersionMigrationsStepRenamedClassArgsDict',
    'WorkerVersionMigrationsStepTransferredClassArgs',
    'WorkerVersionMigrationsStepTransferredClassArgsDict',
    'WorkerVersionMigrationsTransferredClassArgs',
    'WorkerVersionMigrationsTransferredClassArgsDict',
    'WorkerVersionModuleArgs',
    'WorkerVersionModuleArgsDict',
    'WorkerVersionPlacementArgs',
    'WorkerVersionPlacementArgsDict',
    'WorkersCronTriggerScheduleArgs',
    'WorkersCronTriggerScheduleArgsDict',
    'WorkersDeploymentAnnotationsArgs',
    'WorkersDeploymentAnnotationsArgsDict',
    'WorkersDeploymentVersionArgs',
    'WorkersDeploymentVersionArgsDict',
    'WorkersScriptAssetsArgs',
    'WorkersScriptAssetsArgsDict',
    'WorkersScriptAssetsConfigArgs',
    'WorkersScriptAssetsConfigArgsDict',
    'WorkersScriptBindingArgs',
    'WorkersScriptBindingArgsDict',
    'WorkersScriptBindingOutboundArgs',
    'WorkersScriptBindingOutboundArgsDict',
    'WorkersScriptBindingOutboundWorkerArgs',
    'WorkersScriptBindingOutboundWorkerArgsDict',
    'WorkersScriptLimitsArgs',
    'WorkersScriptLimitsArgsDict',
    'WorkersScriptNamedHandlerArgs',
    'WorkersScriptNamedHandlerArgsDict',
    'WorkersScriptObservabilityArgs',
    'WorkersScriptObservabilityArgsDict',
    'WorkersScriptObservabilityLogsArgs',
    'WorkersScriptObservabilityLogsArgsDict',
    'WorkersScriptPlacementArgs',
    'WorkersScriptPlacementArgsDict',
    'WorkersScriptTailConsumerArgs',
    'WorkersScriptTailConsumerArgsDict',
    'ZeroTrustAccessApplicationCorsHeadersArgs',
    'ZeroTrustAccessApplicationCorsHeadersArgsDict',
    'ZeroTrustAccessApplicationDestinationArgs',
    'ZeroTrustAccessApplicationDestinationArgsDict',
    'ZeroTrustAccessApplicationFooterLinkArgs',
    'ZeroTrustAccessApplicationFooterLinkArgsDict',
    'ZeroTrustAccessApplicationLandingPageDesignArgs',
    'ZeroTrustAccessApplicationLandingPageDesignArgsDict',
    'ZeroTrustAccessApplicationPolicyArgs',
    'ZeroTrustAccessApplicationPolicyArgsDict',
    'ZeroTrustAccessApplicationPolicyConnectionRulesArgs',
    'ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict',
    'ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs',
    'ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeArgs',
    'ZeroTrustAccessApplicationPolicyExcludeArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs',
    'ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeCertificateArgs',
    'ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs',
    'ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs',
    'ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEmailArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEmailListArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs',
    'ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs',
    'ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGeoArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGroupArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs',
    'ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeIpArgs',
    'ZeroTrustAccessApplicationPolicyExcludeIpArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeIpListArgs',
    'ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgs',
    'ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs',
    'ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeOidcArgs',
    'ZeroTrustAccessApplicationPolicyExcludeOidcArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeOktaArgs',
    'ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeSamlArgs',
    'ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict',
    'ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeArgs',
    'ZeroTrustAccessApplicationPolicyIncludeArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs',
    'ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeCertificateArgs',
    'ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs',
    'ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs',
    'ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEmailArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEmailListArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs',
    'ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs',
    'ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGeoArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGroupArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs',
    'ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeIpArgs',
    'ZeroTrustAccessApplicationPolicyIncludeIpArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeIpListArgs',
    'ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgs',
    'ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs',
    'ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeOidcArgs',
    'ZeroTrustAccessApplicationPolicyIncludeOidcArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeOktaArgs',
    'ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeSamlArgs',
    'ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict',
    'ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireArgs',
    'ZeroTrustAccessApplicationPolicyRequireArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAuthContextArgs',
    'ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs',
    'ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireAzureAdArgs',
    'ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireCertificateArgs',
    'ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireCommonNameArgs',
    'ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs',
    'ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEmailArgs',
    'ZeroTrustAccessApplicationPolicyRequireEmailArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs',
    'ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEmailListArgs',
    'ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireEveryoneArgs',
    'ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs',
    'ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGeoArgs',
    'ZeroTrustAccessApplicationPolicyRequireGeoArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs',
    'ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGroupArgs',
    'ZeroTrustAccessApplicationPolicyRequireGroupArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireGsuiteArgs',
    'ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireIpArgs',
    'ZeroTrustAccessApplicationPolicyRequireIpArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireIpListArgs',
    'ZeroTrustAccessApplicationPolicyRequireIpListArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgs',
    'ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs',
    'ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireOidcArgs',
    'ZeroTrustAccessApplicationPolicyRequireOidcArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireOktaArgs',
    'ZeroTrustAccessApplicationPolicyRequireOktaArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireSamlArgs',
    'ZeroTrustAccessApplicationPolicyRequireSamlArgsDict',
    'ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs',
    'ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict',
    'ZeroTrustAccessApplicationSaasAppArgs',
    'ZeroTrustAccessApplicationSaasAppArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs',
    'ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomClaimArgs',
    'ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs',
    'ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs',
    'ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs',
    'ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict',
    'ZeroTrustAccessApplicationScimConfigArgs',
    'ZeroTrustAccessApplicationScimConfigArgsDict',
    'ZeroTrustAccessApplicationScimConfigAuthenticationArgs',
    'ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict',
    'ZeroTrustAccessApplicationScimConfigMappingArgs',
    'ZeroTrustAccessApplicationScimConfigMappingArgsDict',
    'ZeroTrustAccessApplicationScimConfigMappingOperationsArgs',
    'ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict',
    'ZeroTrustAccessApplicationTargetCriteriaArgs',
    'ZeroTrustAccessApplicationTargetCriteriaArgsDict',
    'ZeroTrustAccessGroupExcludeArgs',
    'ZeroTrustAccessGroupExcludeArgsDict',
    'ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessGroupExcludeAuthContextArgs',
    'ZeroTrustAccessGroupExcludeAuthContextArgsDict',
    'ZeroTrustAccessGroupExcludeAuthMethodArgs',
    'ZeroTrustAccessGroupExcludeAuthMethodArgsDict',
    'ZeroTrustAccessGroupExcludeAzureAdArgs',
    'ZeroTrustAccessGroupExcludeAzureAdArgsDict',
    'ZeroTrustAccessGroupExcludeCertificateArgs',
    'ZeroTrustAccessGroupExcludeCertificateArgsDict',
    'ZeroTrustAccessGroupExcludeCommonNameArgs',
    'ZeroTrustAccessGroupExcludeCommonNameArgsDict',
    'ZeroTrustAccessGroupExcludeDevicePostureArgs',
    'ZeroTrustAccessGroupExcludeDevicePostureArgsDict',
    'ZeroTrustAccessGroupExcludeEmailArgs',
    'ZeroTrustAccessGroupExcludeEmailArgsDict',
    'ZeroTrustAccessGroupExcludeEmailDomainArgs',
    'ZeroTrustAccessGroupExcludeEmailDomainArgsDict',
    'ZeroTrustAccessGroupExcludeEmailListArgs',
    'ZeroTrustAccessGroupExcludeEmailListArgsDict',
    'ZeroTrustAccessGroupExcludeEveryoneArgs',
    'ZeroTrustAccessGroupExcludeEveryoneArgsDict',
    'ZeroTrustAccessGroupExcludeExternalEvaluationArgs',
    'ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupExcludeGeoArgs',
    'ZeroTrustAccessGroupExcludeGeoArgsDict',
    'ZeroTrustAccessGroupExcludeGithubOrganizationArgs',
    'ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict',
    'ZeroTrustAccessGroupExcludeGroupArgs',
    'ZeroTrustAccessGroupExcludeGroupArgsDict',
    'ZeroTrustAccessGroupExcludeGsuiteArgs',
    'ZeroTrustAccessGroupExcludeGsuiteArgsDict',
    'ZeroTrustAccessGroupExcludeIpArgs',
    'ZeroTrustAccessGroupExcludeIpArgsDict',
    'ZeroTrustAccessGroupExcludeIpListArgs',
    'ZeroTrustAccessGroupExcludeIpListArgsDict',
    'ZeroTrustAccessGroupExcludeLinkedAppTokenArgs',
    'ZeroTrustAccessGroupExcludeLinkedAppTokenArgsDict',
    'ZeroTrustAccessGroupExcludeLoginMethodArgs',
    'ZeroTrustAccessGroupExcludeLoginMethodArgsDict',
    'ZeroTrustAccessGroupExcludeOidcArgs',
    'ZeroTrustAccessGroupExcludeOidcArgsDict',
    'ZeroTrustAccessGroupExcludeOktaArgs',
    'ZeroTrustAccessGroupExcludeOktaArgsDict',
    'ZeroTrustAccessGroupExcludeSamlArgs',
    'ZeroTrustAccessGroupExcludeSamlArgsDict',
    'ZeroTrustAccessGroupExcludeServiceTokenArgs',
    'ZeroTrustAccessGroupExcludeServiceTokenArgsDict',
    'ZeroTrustAccessGroupIncludeArgs',
    'ZeroTrustAccessGroupIncludeArgsDict',
    'ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessGroupIncludeAuthContextArgs',
    'ZeroTrustAccessGroupIncludeAuthContextArgsDict',
    'ZeroTrustAccessGroupIncludeAuthMethodArgs',
    'ZeroTrustAccessGroupIncludeAuthMethodArgsDict',
    'ZeroTrustAccessGroupIncludeAzureAdArgs',
    'ZeroTrustAccessGroupIncludeAzureAdArgsDict',
    'ZeroTrustAccessGroupIncludeCertificateArgs',
    'ZeroTrustAccessGroupIncludeCertificateArgsDict',
    'ZeroTrustAccessGroupIncludeCommonNameArgs',
    'ZeroTrustAccessGroupIncludeCommonNameArgsDict',
    'ZeroTrustAccessGroupIncludeDevicePostureArgs',
    'ZeroTrustAccessGroupIncludeDevicePostureArgsDict',
    'ZeroTrustAccessGroupIncludeEmailArgs',
    'ZeroTrustAccessGroupIncludeEmailArgsDict',
    'ZeroTrustAccessGroupIncludeEmailDomainArgs',
    'ZeroTrustAccessGroupIncludeEmailDomainArgsDict',
    'ZeroTrustAccessGroupIncludeEmailListArgs',
    'ZeroTrustAccessGroupIncludeEmailListArgsDict',
    'ZeroTrustAccessGroupIncludeEveryoneArgs',
    'ZeroTrustAccessGroupIncludeEveryoneArgsDict',
    'ZeroTrustAccessGroupIncludeExternalEvaluationArgs',
    'ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupIncludeGeoArgs',
    'ZeroTrustAccessGroupIncludeGeoArgsDict',
    'ZeroTrustAccessGroupIncludeGithubOrganizationArgs',
    'ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict',
    'ZeroTrustAccessGroupIncludeGroupArgs',
    'ZeroTrustAccessGroupIncludeGroupArgsDict',
    'ZeroTrustAccessGroupIncludeGsuiteArgs',
    'ZeroTrustAccessGroupIncludeGsuiteArgsDict',
    'ZeroTrustAccessGroupIncludeIpArgs',
    'ZeroTrustAccessGroupIncludeIpArgsDict',
    'ZeroTrustAccessGroupIncludeIpListArgs',
    'ZeroTrustAccessGroupIncludeIpListArgsDict',
    'ZeroTrustAccessGroupIncludeLinkedAppTokenArgs',
    'ZeroTrustAccessGroupIncludeLinkedAppTokenArgsDict',
    'ZeroTrustAccessGroupIncludeLoginMethodArgs',
    'ZeroTrustAccessGroupIncludeLoginMethodArgsDict',
    'ZeroTrustAccessGroupIncludeOidcArgs',
    'ZeroTrustAccessGroupIncludeOidcArgsDict',
    'ZeroTrustAccessGroupIncludeOktaArgs',
    'ZeroTrustAccessGroupIncludeOktaArgsDict',
    'ZeroTrustAccessGroupIncludeSamlArgs',
    'ZeroTrustAccessGroupIncludeSamlArgsDict',
    'ZeroTrustAccessGroupIncludeServiceTokenArgs',
    'ZeroTrustAccessGroupIncludeServiceTokenArgsDict',
    'ZeroTrustAccessGroupRequireArgs',
    'ZeroTrustAccessGroupRequireArgsDict',
    'ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs',
    'ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessGroupRequireAuthContextArgs',
    'ZeroTrustAccessGroupRequireAuthContextArgsDict',
    'ZeroTrustAccessGroupRequireAuthMethodArgs',
    'ZeroTrustAccessGroupRequireAuthMethodArgsDict',
    'ZeroTrustAccessGroupRequireAzureAdArgs',
    'ZeroTrustAccessGroupRequireAzureAdArgsDict',
    'ZeroTrustAccessGroupRequireCertificateArgs',
    'ZeroTrustAccessGroupRequireCertificateArgsDict',
    'ZeroTrustAccessGroupRequireCommonNameArgs',
    'ZeroTrustAccessGroupRequireCommonNameArgsDict',
    'ZeroTrustAccessGroupRequireDevicePostureArgs',
    'ZeroTrustAccessGroupRequireDevicePostureArgsDict',
    'ZeroTrustAccessGroupRequireEmailArgs',
    'ZeroTrustAccessGroupRequireEmailArgsDict',
    'ZeroTrustAccessGroupRequireEmailDomainArgs',
    'ZeroTrustAccessGroupRequireEmailDomainArgsDict',
    'ZeroTrustAccessGroupRequireEmailListArgs',
    'ZeroTrustAccessGroupRequireEmailListArgsDict',
    'ZeroTrustAccessGroupRequireEveryoneArgs',
    'ZeroTrustAccessGroupRequireEveryoneArgsDict',
    'ZeroTrustAccessGroupRequireExternalEvaluationArgs',
    'ZeroTrustAccessGroupRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessGroupRequireGeoArgs',
    'ZeroTrustAccessGroupRequireGeoArgsDict',
    'ZeroTrustAccessGroupRequireGithubOrganizationArgs',
    'ZeroTrustAccessGroupRequireGithubOrganizationArgsDict',
    'ZeroTrustAccessGroupRequireGroupArgs',
    'ZeroTrustAccessGroupRequireGroupArgsDict',
    'ZeroTrustAccessGroupRequireGsuiteArgs',
    'ZeroTrustAccessGroupRequireGsuiteArgsDict',
    'ZeroTrustAccessGroupRequireIpArgs',
    'ZeroTrustAccessGroupRequireIpArgsDict',
    'ZeroTrustAccessGroupRequireIpListArgs',
    'ZeroTrustAccessGroupRequireIpListArgsDict',
    'ZeroTrustAccessGroupRequireLinkedAppTokenArgs',
    'ZeroTrustAccessGroupRequireLinkedAppTokenArgsDict',
    'ZeroTrustAccessGroupRequireLoginMethodArgs',
    'ZeroTrustAccessGroupRequireLoginMethodArgsDict',
    'ZeroTrustAccessGroupRequireOidcArgs',
    'ZeroTrustAccessGroupRequireOidcArgsDict',
    'ZeroTrustAccessGroupRequireOktaArgs',
    'ZeroTrustAccessGroupRequireOktaArgsDict',
    'ZeroTrustAccessGroupRequireSamlArgs',
    'ZeroTrustAccessGroupRequireSamlArgsDict',
    'ZeroTrustAccessGroupRequireServiceTokenArgs',
    'ZeroTrustAccessGroupRequireServiceTokenArgsDict',
    'ZeroTrustAccessIdentityProviderConfigArgs',
    'ZeroTrustAccessIdentityProviderConfigArgsDict',
    'ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs',
    'ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict',
    'ZeroTrustAccessIdentityProviderScimConfigArgs',
    'ZeroTrustAccessIdentityProviderScimConfigArgsDict',
    'ZeroTrustAccessInfrastructureTargetIpArgs',
    'ZeroTrustAccessInfrastructureTargetIpArgsDict',
    'ZeroTrustAccessInfrastructureTargetIpIpv4Args',
    'ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict',
    'ZeroTrustAccessInfrastructureTargetIpIpv6Args',
    'ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict',
    'ZeroTrustAccessMtlsHostnameSettingsSettingArgs',
    'ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict',
    'ZeroTrustAccessPolicyApprovalGroupArgs',
    'ZeroTrustAccessPolicyApprovalGroupArgsDict',
    'ZeroTrustAccessPolicyExcludeArgs',
    'ZeroTrustAccessPolicyExcludeArgsDict',
    'ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessPolicyExcludeAuthContextArgs',
    'ZeroTrustAccessPolicyExcludeAuthContextArgsDict',
    'ZeroTrustAccessPolicyExcludeAuthMethodArgs',
    'ZeroTrustAccessPolicyExcludeAuthMethodArgsDict',
    'ZeroTrustAccessPolicyExcludeAzureAdArgs',
    'ZeroTrustAccessPolicyExcludeAzureAdArgsDict',
    'ZeroTrustAccessPolicyExcludeCertificateArgs',
    'ZeroTrustAccessPolicyExcludeCertificateArgsDict',
    'ZeroTrustAccessPolicyExcludeCommonNameArgs',
    'ZeroTrustAccessPolicyExcludeCommonNameArgsDict',
    'ZeroTrustAccessPolicyExcludeDevicePostureArgs',
    'ZeroTrustAccessPolicyExcludeDevicePostureArgsDict',
    'ZeroTrustAccessPolicyExcludeEmailArgs',
    'ZeroTrustAccessPolicyExcludeEmailArgsDict',
    'ZeroTrustAccessPolicyExcludeEmailDomainArgs',
    'ZeroTrustAccessPolicyExcludeEmailDomainArgsDict',
    'ZeroTrustAccessPolicyExcludeEmailListArgs',
    'ZeroTrustAccessPolicyExcludeEmailListArgsDict',
    'ZeroTrustAccessPolicyExcludeEveryoneArgs',
    'ZeroTrustAccessPolicyExcludeEveryoneArgsDict',
    'ZeroTrustAccessPolicyExcludeExternalEvaluationArgs',
    'ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyExcludeGeoArgs',
    'ZeroTrustAccessPolicyExcludeGeoArgsDict',
    'ZeroTrustAccessPolicyExcludeGithubOrganizationArgs',
    'ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict',
    'ZeroTrustAccessPolicyExcludeGroupArgs',
    'ZeroTrustAccessPolicyExcludeGroupArgsDict',
    'ZeroTrustAccessPolicyExcludeGsuiteArgs',
    'ZeroTrustAccessPolicyExcludeGsuiteArgsDict',
    'ZeroTrustAccessPolicyExcludeIpArgs',
    'ZeroTrustAccessPolicyExcludeIpArgsDict',
    'ZeroTrustAccessPolicyExcludeIpListArgs',
    'ZeroTrustAccessPolicyExcludeIpListArgsDict',
    'ZeroTrustAccessPolicyExcludeLinkedAppTokenArgs',
    'ZeroTrustAccessPolicyExcludeLinkedAppTokenArgsDict',
    'ZeroTrustAccessPolicyExcludeLoginMethodArgs',
    'ZeroTrustAccessPolicyExcludeLoginMethodArgsDict',
    'ZeroTrustAccessPolicyExcludeOidcArgs',
    'ZeroTrustAccessPolicyExcludeOidcArgsDict',
    'ZeroTrustAccessPolicyExcludeOktaArgs',
    'ZeroTrustAccessPolicyExcludeOktaArgsDict',
    'ZeroTrustAccessPolicyExcludeSamlArgs',
    'ZeroTrustAccessPolicyExcludeSamlArgsDict',
    'ZeroTrustAccessPolicyExcludeServiceTokenArgs',
    'ZeroTrustAccessPolicyExcludeServiceTokenArgsDict',
    'ZeroTrustAccessPolicyIncludeArgs',
    'ZeroTrustAccessPolicyIncludeArgsDict',
    'ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs',
    'ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessPolicyIncludeAuthContextArgs',
    'ZeroTrustAccessPolicyIncludeAuthContextArgsDict',
    'ZeroTrustAccessPolicyIncludeAuthMethodArgs',
    'ZeroTrustAccessPolicyIncludeAuthMethodArgsDict',
    'ZeroTrustAccessPolicyIncludeAzureAdArgs',
    'ZeroTrustAccessPolicyIncludeAzureAdArgsDict',
    'ZeroTrustAccessPolicyIncludeCertificateArgs',
    'ZeroTrustAccessPolicyIncludeCertificateArgsDict',
    'ZeroTrustAccessPolicyIncludeCommonNameArgs',
    'ZeroTrustAccessPolicyIncludeCommonNameArgsDict',
    'ZeroTrustAccessPolicyIncludeDevicePostureArgs',
    'ZeroTrustAccessPolicyIncludeDevicePostureArgsDict',
    'ZeroTrustAccessPolicyIncludeEmailArgs',
    'ZeroTrustAccessPolicyIncludeEmailArgsDict',
    'ZeroTrustAccessPolicyIncludeEmailDomainArgs',
    'ZeroTrustAccessPolicyIncludeEmailDomainArgsDict',
    'ZeroTrustAccessPolicyIncludeEmailListArgs',
    'ZeroTrustAccessPolicyIncludeEmailListArgsDict',
    'ZeroTrustAccessPolicyIncludeEveryoneArgs',
    'ZeroTrustAccessPolicyIncludeEveryoneArgsDict',
    'ZeroTrustAccessPolicyIncludeExternalEvaluationArgs',
    'ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyIncludeGeoArgs',
    'ZeroTrustAccessPolicyIncludeGeoArgsDict',
    'ZeroTrustAccessPolicyIncludeGithubOrganizationArgs',
    'ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict',
    'ZeroTrustAccessPolicyIncludeGroupArgs',
    'ZeroTrustAccessPolicyIncludeGroupArgsDict',
    'ZeroTrustAccessPolicyIncludeGsuiteArgs',
    'ZeroTrustAccessPolicyIncludeGsuiteArgsDict',
    'ZeroTrustAccessPolicyIncludeIpArgs',
    'ZeroTrustAccessPolicyIncludeIpArgsDict',
    'ZeroTrustAccessPolicyIncludeIpListArgs',
    'ZeroTrustAccessPolicyIncludeIpListArgsDict',
    'ZeroTrustAccessPolicyIncludeLinkedAppTokenArgs',
    'ZeroTrustAccessPolicyIncludeLinkedAppTokenArgsDict',
    'ZeroTrustAccessPolicyIncludeLoginMethodArgs',
    'ZeroTrustAccessPolicyIncludeLoginMethodArgsDict',
    'ZeroTrustAccessPolicyIncludeOidcArgs',
    'ZeroTrustAccessPolicyIncludeOidcArgsDict',
    'ZeroTrustAccessPolicyIncludeOktaArgs',
    'ZeroTrustAccessPolicyIncludeOktaArgsDict',
    'ZeroTrustAccessPolicyIncludeSamlArgs',
    'ZeroTrustAccessPolicyIncludeSamlArgsDict',
    'ZeroTrustAccessPolicyIncludeServiceTokenArgs',
    'ZeroTrustAccessPolicyIncludeServiceTokenArgsDict',
    'ZeroTrustAccessPolicyRequireArgs',
    'ZeroTrustAccessPolicyRequireArgsDict',
    'ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs',
    'ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict',
    'ZeroTrustAccessPolicyRequireAuthContextArgs',
    'ZeroTrustAccessPolicyRequireAuthContextArgsDict',
    'ZeroTrustAccessPolicyRequireAuthMethodArgs',
    'ZeroTrustAccessPolicyRequireAuthMethodArgsDict',
    'ZeroTrustAccessPolicyRequireAzureAdArgs',
    'ZeroTrustAccessPolicyRequireAzureAdArgsDict',
    'ZeroTrustAccessPolicyRequireCertificateArgs',
    'ZeroTrustAccessPolicyRequireCertificateArgsDict',
    'ZeroTrustAccessPolicyRequireCommonNameArgs',
    'ZeroTrustAccessPolicyRequireCommonNameArgsDict',
    'ZeroTrustAccessPolicyRequireDevicePostureArgs',
    'ZeroTrustAccessPolicyRequireDevicePostureArgsDict',
    'ZeroTrustAccessPolicyRequireEmailArgs',
    'ZeroTrustAccessPolicyRequireEmailArgsDict',
    'ZeroTrustAccessPolicyRequireEmailDomainArgs',
    'ZeroTrustAccessPolicyRequireEmailDomainArgsDict',
    'ZeroTrustAccessPolicyRequireEmailListArgs',
    'ZeroTrustAccessPolicyRequireEmailListArgsDict',
    'ZeroTrustAccessPolicyRequireEveryoneArgs',
    'ZeroTrustAccessPolicyRequireEveryoneArgsDict',
    'ZeroTrustAccessPolicyRequireExternalEvaluationArgs',
    'ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict',
    'ZeroTrustAccessPolicyRequireGeoArgs',
    'ZeroTrustAccessPolicyRequireGeoArgsDict',
    'ZeroTrustAccessPolicyRequireGithubOrganizationArgs',
    'ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict',
    'ZeroTrustAccessPolicyRequireGroupArgs',
    'ZeroTrustAccessPolicyRequireGroupArgsDict',
    'ZeroTrustAccessPolicyRequireGsuiteArgs',
    'ZeroTrustAccessPolicyRequireGsuiteArgsDict',
    'ZeroTrustAccessPolicyRequireIpArgs',
    'ZeroTrustAccessPolicyRequireIpArgsDict',
    'ZeroTrustAccessPolicyRequireIpListArgs',
    'ZeroTrustAccessPolicyRequireIpListArgsDict',
    'ZeroTrustAccessPolicyRequireLinkedAppTokenArgs',
    'ZeroTrustAccessPolicyRequireLinkedAppTokenArgsDict',
    'ZeroTrustAccessPolicyRequireLoginMethodArgs',
    'ZeroTrustAccessPolicyRequireLoginMethodArgsDict',
    'ZeroTrustAccessPolicyRequireOidcArgs',
    'ZeroTrustAccessPolicyRequireOidcArgsDict',
    'ZeroTrustAccessPolicyRequireOktaArgs',
    'ZeroTrustAccessPolicyRequireOktaArgsDict',
    'ZeroTrustAccessPolicyRequireSamlArgs',
    'ZeroTrustAccessPolicyRequireSamlArgsDict',
    'ZeroTrustAccessPolicyRequireServiceTokenArgs',
    'ZeroTrustAccessPolicyRequireServiceTokenArgsDict',
    'ZeroTrustDeviceCustomProfileExcludeArgs',
    'ZeroTrustDeviceCustomProfileExcludeArgsDict',
    'ZeroTrustDeviceCustomProfileFallbackDomainArgs',
    'ZeroTrustDeviceCustomProfileFallbackDomainArgsDict',
    'ZeroTrustDeviceCustomProfileIncludeArgs',
    'ZeroTrustDeviceCustomProfileIncludeArgsDict',
    'ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgs',
    'ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgsDict',
    'ZeroTrustDeviceCustomProfileServiceModeV2Args',
    'ZeroTrustDeviceCustomProfileServiceModeV2ArgsDict',
    'ZeroTrustDeviceCustomProfileTargetTestArgs',
    'ZeroTrustDeviceCustomProfileTargetTestArgsDict',
    'ZeroTrustDeviceDefaultProfileExcludeArgs',
    'ZeroTrustDeviceDefaultProfileExcludeArgsDict',
    'ZeroTrustDeviceDefaultProfileFallbackDomainArgs',
    'ZeroTrustDeviceDefaultProfileFallbackDomainArgsDict',
    'ZeroTrustDeviceDefaultProfileIncludeArgs',
    'ZeroTrustDeviceDefaultProfileIncludeArgsDict',
    'ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgs',
    'ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgsDict',
    'ZeroTrustDeviceDefaultProfileServiceModeV2Args',
    'ZeroTrustDeviceDefaultProfileServiceModeV2ArgsDict',
    'ZeroTrustDeviceManagedNetworksConfigArgs',
    'ZeroTrustDeviceManagedNetworksConfigArgsDict',
    'ZeroTrustDevicePostureIntegrationConfigArgs',
    'ZeroTrustDevicePostureIntegrationConfigArgsDict',
    'ZeroTrustDevicePostureRuleInputArgs',
    'ZeroTrustDevicePostureRuleInputArgsDict',
    'ZeroTrustDevicePostureRuleInputLocationsArgs',
    'ZeroTrustDevicePostureRuleInputLocationsArgsDict',
    'ZeroTrustDevicePostureRuleMatchArgs',
    'ZeroTrustDevicePostureRuleMatchArgsDict',
    'ZeroTrustDexTestDataArgs',
    'ZeroTrustDexTestDataArgsDict',
    'ZeroTrustDexTestTargetPolicyArgs',
    'ZeroTrustDexTestTargetPolicyArgsDict',
    'ZeroTrustDlpCustomEntryConfidenceArgs',
    'ZeroTrustDlpCustomEntryConfidenceArgsDict',
    'ZeroTrustDlpCustomEntryPatternArgs',
    'ZeroTrustDlpCustomEntryPatternArgsDict',
    'ZeroTrustDlpCustomEntryVariantArgs',
    'ZeroTrustDlpCustomEntryVariantArgsDict',
    'ZeroTrustDlpCustomProfileContextAwarenessArgs',
    'ZeroTrustDlpCustomProfileContextAwarenessArgsDict',
    'ZeroTrustDlpCustomProfileContextAwarenessSkipArgs',
    'ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict',
    'ZeroTrustDlpCustomProfileEntryArgs',
    'ZeroTrustDlpCustomProfileEntryArgsDict',
    'ZeroTrustDlpCustomProfileEntryPatternArgs',
    'ZeroTrustDlpCustomProfileEntryPatternArgsDict',
    'ZeroTrustDlpCustomProfileSharedEntryArgs',
    'ZeroTrustDlpCustomProfileSharedEntryArgsDict',
    'ZeroTrustDlpDatasetColumnArgs',
    'ZeroTrustDlpDatasetColumnArgsDict',
    'ZeroTrustDlpDatasetDatasetArgs',
    'ZeroTrustDlpDatasetDatasetArgsDict',
    'ZeroTrustDlpDatasetDatasetColumnArgs',
    'ZeroTrustDlpDatasetDatasetColumnArgsDict',
    'ZeroTrustDlpDatasetDatasetUploadArgs',
    'ZeroTrustDlpDatasetDatasetUploadArgsDict',
    'ZeroTrustDlpDatasetUploadArgs',
    'ZeroTrustDlpDatasetUploadArgsDict',
    'ZeroTrustDlpEntryConfidenceArgs',
    'ZeroTrustDlpEntryConfidenceArgsDict',
    'ZeroTrustDlpEntryPatternArgs',
    'ZeroTrustDlpEntryPatternArgsDict',
    'ZeroTrustDlpEntryVariantArgs',
    'ZeroTrustDlpEntryVariantArgsDict',
    'ZeroTrustDlpIntegrationEntryConfidenceArgs',
    'ZeroTrustDlpIntegrationEntryConfidenceArgsDict',
    'ZeroTrustDlpIntegrationEntryPatternArgs',
    'ZeroTrustDlpIntegrationEntryPatternArgsDict',
    'ZeroTrustDlpIntegrationEntryVariantArgs',
    'ZeroTrustDlpIntegrationEntryVariantArgsDict',
    'ZeroTrustDlpPredefinedEntryConfidenceArgs',
    'ZeroTrustDlpPredefinedEntryConfidenceArgsDict',
    'ZeroTrustDlpPredefinedEntryPatternArgs',
    'ZeroTrustDlpPredefinedEntryPatternArgsDict',
    'ZeroTrustDlpPredefinedEntryVariantArgs',
    'ZeroTrustDlpPredefinedEntryVariantArgsDict',
    'ZeroTrustDlpPredefinedProfileContextAwarenessArgs',
    'ZeroTrustDlpPredefinedProfileContextAwarenessArgsDict',
    'ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs',
    'ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict',
    'ZeroTrustDlpPredefinedProfileEntryArgs',
    'ZeroTrustDlpPredefinedProfileEntryArgsDict',
    'ZeroTrustDnsLocationEndpointsArgs',
    'ZeroTrustDnsLocationEndpointsArgsDict',
    'ZeroTrustDnsLocationEndpointsDohArgs',
    'ZeroTrustDnsLocationEndpointsDohArgsDict',
    'ZeroTrustDnsLocationEndpointsDohNetworkArgs',
    'ZeroTrustDnsLocationEndpointsDohNetworkArgsDict',
    'ZeroTrustDnsLocationEndpointsDotArgs',
    'ZeroTrustDnsLocationEndpointsDotArgsDict',
    'ZeroTrustDnsLocationEndpointsDotNetworkArgs',
    'ZeroTrustDnsLocationEndpointsDotNetworkArgsDict',
    'ZeroTrustDnsLocationEndpointsIpv4Args',
    'ZeroTrustDnsLocationEndpointsIpv4ArgsDict',
    'ZeroTrustDnsLocationEndpointsIpv6Args',
    'ZeroTrustDnsLocationEndpointsIpv6ArgsDict',
    'ZeroTrustDnsLocationEndpointsIpv6NetworkArgs',
    'ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict',
    'ZeroTrustDnsLocationNetworkArgs',
    'ZeroTrustDnsLocationNetworkArgsDict',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeArgs',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeArgsDict',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgs',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgsDict',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgs',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgsDict',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeL4Args',
    'ZeroTrustGatewayLoggingSettingsByRuleTypeL4ArgsDict',
    'ZeroTrustGatewayPolicyExpirationArgs',
    'ZeroTrustGatewayPolicyExpirationArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs',
    'ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs',
    'ZeroTrustGatewayPolicyRuleSettingsBlockPageArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs',
    'ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args',
    'ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsEgressArgs',
    'ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs',
    'ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs',
    'ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs',
    'ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs',
    'ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsRedirectArgs',
    'ZeroTrustGatewayPolicyRuleSettingsRedirectArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs',
    'ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs',
    'ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict',
    'ZeroTrustGatewayPolicyScheduleArgs',
    'ZeroTrustGatewayPolicyScheduleArgsDict',
    'ZeroTrustGatewaySettingsSettingsArgs',
    'ZeroTrustGatewaySettingsSettingsArgsDict',
    'ZeroTrustGatewaySettingsSettingsActivityLogArgs',
    'ZeroTrustGatewaySettingsSettingsActivityLogArgsDict',
    'ZeroTrustGatewaySettingsSettingsAntivirusArgs',
    'ZeroTrustGatewaySettingsSettingsAntivirusArgsDict',
    'ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs',
    'ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict',
    'ZeroTrustGatewaySettingsSettingsBlockPageArgs',
    'ZeroTrustGatewaySettingsSettingsBlockPageArgsDict',
    'ZeroTrustGatewaySettingsSettingsBodyScanningArgs',
    'ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict',
    'ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs',
    'ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict',
    'ZeroTrustGatewaySettingsSettingsCertificateArgs',
    'ZeroTrustGatewaySettingsSettingsCertificateArgsDict',
    'ZeroTrustGatewaySettingsSettingsCustomCertificateArgs',
    'ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict',
    'ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs',
    'ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict',
    'ZeroTrustGatewaySettingsSettingsFipsArgs',
    'ZeroTrustGatewaySettingsSettingsFipsArgsDict',
    'ZeroTrustGatewaySettingsSettingsHostSelectorArgs',
    'ZeroTrustGatewaySettingsSettingsHostSelectorArgsDict',
    'ZeroTrustGatewaySettingsSettingsInspectionArgs',
    'ZeroTrustGatewaySettingsSettingsInspectionArgsDict',
    'ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs',
    'ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict',
    'ZeroTrustGatewaySettingsSettingsSandboxArgs',
    'ZeroTrustGatewaySettingsSettingsSandboxArgsDict',
    'ZeroTrustGatewaySettingsSettingsTlsDecryptArgs',
    'ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict',
    'ZeroTrustListItemArgs',
    'ZeroTrustListItemArgsDict',
    'ZeroTrustLocalFallbackDomainDomainArgs',
    'ZeroTrustLocalFallbackDomainDomainArgsDict',
    'ZeroTrustOrganizationCustomPagesArgs',
    'ZeroTrustOrganizationCustomPagesArgsDict',
    'ZeroTrustOrganizationLoginDesignArgs',
    'ZeroTrustOrganizationLoginDesignArgsDict',
    'ZeroTrustRiskBehaviorBehaviorsArgs',
    'ZeroTrustRiskBehaviorBehaviorsArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs',
    'ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict',
    'ZeroTrustTunnelCloudflaredConnectionArgs',
    'ZeroTrustTunnelCloudflaredConnectionArgsDict',
    'ZeroTrustTunnelWarpConnectorConnectionArgs',
    'ZeroTrustTunnelWarpConnectorConnectionArgsDict',
    'ZoneAccountArgs',
    'ZoneAccountArgsDict',
    'ZoneCacheVariantsValueArgs',
    'ZoneCacheVariantsValueArgsDict',
    'ZoneDnsSettingsInternalDnsArgs',
    'ZoneDnsSettingsInternalDnsArgsDict',
    'ZoneDnsSettingsNameserversArgs',
    'ZoneDnsSettingsNameserversArgsDict',
    'ZoneDnsSettingsSoaArgs',
    'ZoneDnsSettingsSoaArgsDict',
    'ZoneLockdownConfigurationArgs',
    'ZoneLockdownConfigurationArgsDict',
    'ZoneMetaArgs',
    'ZoneMetaArgsDict',
    'ZoneOwnerArgs',
    'ZoneOwnerArgsDict',
    'ZonePlanArgs',
    'ZonePlanArgsDict',
    'ZoneSubscriptionRatePlanArgs',
    'ZoneSubscriptionRatePlanArgsDict',
    'ZoneTenantArgs',
    'ZoneTenantArgsDict',
    'ZoneTenantUnitArgs',
    'ZoneTenantUnitArgsDict',
    'GetAccessRuleFilterArgs',
    'GetAccessRuleFilterArgsDict',
    'GetAccessRuleFilterConfigurationArgs',
    'GetAccessRuleFilterConfigurationArgsDict',
    'GetAccessRulesConfigurationArgs',
    'GetAccessRulesConfigurationArgsDict',
    'GetAccountDnsSettingsInternalViewFilterArgs',
    'GetAccountDnsSettingsInternalViewFilterArgsDict',
    'GetAccountDnsSettingsInternalViewFilterNameArgs',
    'GetAccountDnsSettingsInternalViewFilterNameArgsDict',
    'GetAccountDnsSettingsInternalViewsNameArgs',
    'GetAccountDnsSettingsInternalViewsNameArgsDict',
    'GetAccountFilterArgs',
    'GetAccountFilterArgsDict',
    'GetAccountMemberFilterArgs',
    'GetAccountMemberFilterArgsDict',
    'GetAccountTokenFilterArgs',
    'GetAccountTokenFilterArgsDict',
    'GetApiShieldOperationFilterArgs',
    'GetApiShieldOperationFilterArgsDict',
    'GetApiTokenFilterArgs',
    'GetApiTokenFilterArgsDict',
    'GetCloudforceOneRequestFilterArgs',
    'GetCloudforceOneRequestFilterArgsDict',
    'GetCustomHostnameFilterArgs',
    'GetCustomHostnameFilterArgsDict',
    'GetCustomSslFilterArgs',
    'GetCustomSslFilterArgsDict',
    'GetD1DatabaseFilterArgs',
    'GetD1DatabaseFilterArgsDict',
    'GetDnsRecordFilterArgs',
    'GetDnsRecordFilterArgsDict',
    'GetDnsRecordFilterCommentArgs',
    'GetDnsRecordFilterCommentArgsDict',
    'GetDnsRecordFilterContentArgs',
    'GetDnsRecordFilterContentArgsDict',
    'GetDnsRecordFilterNameArgs',
    'GetDnsRecordFilterNameArgsDict',
    'GetDnsRecordFilterTagArgs',
    'GetDnsRecordFilterTagArgsDict',
    'GetDnsRecordsCommentArgs',
    'GetDnsRecordsCommentArgsDict',
    'GetDnsRecordsContentArgs',
    'GetDnsRecordsContentArgsDict',
    'GetDnsRecordsNameArgs',
    'GetDnsRecordsNameArgsDict',
    'GetDnsRecordsTagArgs',
    'GetDnsRecordsTagArgsDict',
    'GetEmailRoutingAddressFilterArgs',
    'GetEmailRoutingAddressFilterArgsDict',
    'GetEmailRoutingRuleFilterArgs',
    'GetEmailRoutingRuleFilterArgsDict',
    'GetEmailSecurityBlockSenderFilterArgs',
    'GetEmailSecurityBlockSenderFilterArgsDict',
    'GetEmailSecurityImpersonationRegistryFilterArgs',
    'GetEmailSecurityImpersonationRegistryFilterArgsDict',
    'GetEmailSecurityTrustedDomainsFilterArgs',
    'GetEmailSecurityTrustedDomainsFilterArgsDict',
    'GetFilterFilterArgs',
    'GetFilterFilterArgsDict',
    'GetLoadBalancerPoolFilterArgs',
    'GetLoadBalancerPoolFilterArgsDict',
    'GetMagicTransitSiteFilterArgs',
    'GetMagicTransitSiteFilterArgsDict',
    'GetOriginCaCertificateFilterArgs',
    'GetOriginCaCertificateFilterArgsDict',
    'GetSchemaValidationSchemasFilterArgs',
    'GetSchemaValidationSchemasFilterArgsDict',
    'GetTurnstileWidgetFilterArgs',
    'GetTurnstileWidgetFilterArgsDict',
    'GetUserAgentBlockingRuleFilterArgs',
    'GetUserAgentBlockingRuleFilterArgsDict',
    'GetWebAnalyticsSiteFilterArgs',
    'GetWebAnalyticsSiteFilterArgsDict',
    'GetWorkersCustomDomainFilterArgs',
    'GetWorkersCustomDomainFilterArgsDict',
    'GetWorkersKvNamespaceFilterArgs',
    'GetWorkersKvNamespaceFilterArgsDict',
    'GetZeroTrustAccessApplicationFilterArgs',
    'GetZeroTrustAccessApplicationFilterArgsDict',
    'GetZeroTrustAccessGroupFilterArgs',
    'GetZeroTrustAccessGroupFilterArgsDict',
    'GetZeroTrustAccessIdentityProviderFilterArgs',
    'GetZeroTrustAccessIdentityProviderFilterArgsDict',
    'GetZeroTrustAccessInfrastructureTargetFilterArgs',
    'GetZeroTrustAccessInfrastructureTargetFilterArgsDict',
    'GetZeroTrustAccessServiceTokenFilterArgs',
    'GetZeroTrustAccessServiceTokenFilterArgsDict',
    'GetZeroTrustListFilterArgs',
    'GetZeroTrustListFilterArgsDict',
    'GetZeroTrustTunnelCloudflaredFilterArgs',
    'GetZeroTrustTunnelCloudflaredFilterArgsDict',
    'GetZeroTrustTunnelCloudflaredRouteFilterArgs',
    'GetZeroTrustTunnelCloudflaredRouteFilterArgsDict',
    'GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgs',
    'GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgsDict',
    'GetZeroTrustTunnelWarpConnectorFilterArgs',
    'GetZeroTrustTunnelWarpConnectorFilterArgsDict',
    'GetZoneFilterArgs',
    'GetZoneFilterArgsDict',
    'GetZoneFilterAccountArgs',
    'GetZoneFilterAccountArgsDict',
    'GetZoneLockdownFilterArgs',
    'GetZoneLockdownFilterArgsDict',
    'GetZonesAccountArgs',
    'GetZonesAccountArgsDict',
]

MYPY = False

if not MYPY:
    class AccessApplicationCorsHeadersArgsDict(TypedDict):
        allow_all_headers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows all HTTP request headers.
        """
        allow_all_methods: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows all HTTP request methods.
        """
        allow_all_origins: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows all origins.
        """
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed HTTP request headers.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed HTTP request methods.
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed origins.
        """
        max_age: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
elif False:
    AccessApplicationCorsHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationCorsHeadersArgs:
    def __init__(__self__, *,
                 allow_all_headers: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_all_methods: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_all_origins: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_all_headers: Allows all HTTP request headers.
        :param pulumi.Input[_builtins.bool] allow_all_methods: Allows all HTTP request methods.
        :param pulumi.Input[_builtins.bool] allow_all_origins: Allows all origins.
        :param pulumi.Input[_builtins.bool] allow_credentials: When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: Allowed HTTP request headers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: Allowed HTTP request methods.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Allowed origins.
        :param pulumi.Input[_builtins.float] max_age: The maximum number of seconds the results of a preflight request can be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows all HTTP request headers.
        """
        return pulumi.get(self, "allow_all_headers")

    @allow_all_headers.setter
    def allow_all_headers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows all HTTP request methods.
        """
        return pulumi.get(self, "allow_all_methods")

    @allow_all_methods.setter
    def allow_all_methods(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows all origins.
        """
        return pulumi.get(self, "allow_all_origins")

    @allow_all_origins.setter
    def allow_all_origins(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed HTTP request headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed HTTP request methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed origins.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AccessApplicationDestinationArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        l4_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        Available values: "tcp", "udp".
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "public", "private".
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
elif False:
    AccessApplicationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationDestinationArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 l4_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: The CIDR range of the destination. Single IPs will be computed as /32.
        :param pulumi.Input[_builtins.str] hostname: The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        :param pulumi.Input[_builtins.str] l4_protocol: The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
               Available values: "tcp", "udp".
        :param pulumi.Input[_builtins.str] port_range: The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        :param pulumi.Input[_builtins.str] type: Available values: "public", "private".
        :param pulumi.Input[_builtins.str] uri: The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        :param pulumi.Input[_builtins.str] vnet_id: The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if l4_protocol is not None:
            pulumi.set(__self__, "l4_protocol", l4_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        Available values: "tcp", "udp".
        """
        return pulumi.get(self, "l4_protocol")

    @l4_protocol.setter
    def l4_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "l4_protocol", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "public", "private".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class AccessApplicationFooterLinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The hypertext in the footer link.
        """
        url: pulumi.Input[_builtins.str]
        """
        the hyperlink in the footer link.
        """
elif False:
    AccessApplicationFooterLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationFooterLinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The hypertext in the footer link.
        :param pulumi.Input[_builtins.str] url: the hyperlink in the footer link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The hypertext in the footer link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        the hyperlink in the footer link.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AccessApplicationLandingPageDesignArgsDict(TypedDict):
        button_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color of the log in button on the landing page.
        """
        button_text_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The color of the text in the log in button on the landing page.
        """
        image_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the image shown on the landing page.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The message shown on the landing page.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title shown on the landing page.
        """
elif False:
    AccessApplicationLandingPageDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationLandingPageDesignArgs:
    def __init__(__self__, *,
                 button_color: Optional[pulumi.Input[_builtins.str]] = None,
                 button_text_color: Optional[pulumi.Input[_builtins.str]] = None,
                 image_url: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] button_color: The background color of the log in button on the landing page.
        :param pulumi.Input[_builtins.str] button_text_color: The color of the text in the log in button on the landing page.
        :param pulumi.Input[_builtins.str] image_url: The URL of the image shown on the landing page.
        :param pulumi.Input[_builtins.str] message: The message shown on the landing page.
        :param pulumi.Input[_builtins.str] title: The title shown on the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color of the log in button on the landing page.
        """
        return pulumi.get(self, "button_color")

    @button_color.setter
    def button_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_color", value)

    @_builtins.property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The color of the text in the log in button on the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @button_text_color.setter
    def button_text_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_text_color", value)

    @_builtins.property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the image shown on the landing page.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_url", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The message shown on the landing page.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title shown on the landing page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class AccessApplicationPolicyArgsDict(TypedDict):
        connection_rules: NotRequired[pulumi.Input['AccessApplicationPolicyConnectionRulesArgsDict']]
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        decision: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        Available values: "allow", "deny", "non_identity", "bypass".
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyExcludeArgsDict']]]]
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UUID of the policy
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyIncludeArgsDict']]]]
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Access policy.
        """
        precedence: NotRequired[pulumi.Input[_builtins.int]]
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        requires: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyRequireArgsDict']]]]
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
elif False:
    AccessApplicationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyArgs:
    def __init__(__self__, *,
                 connection_rules: Optional[pulumi.Input['AccessApplicationPolicyConnectionRulesArgs']] = None,
                 decision: Optional[pulumi.Input[_builtins.str]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyExcludeArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyIncludeArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 requires: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyRequireArgs']]]] = None):
        """
        :param pulumi.Input['AccessApplicationPolicyConnectionRulesArgs'] connection_rules: The rules that define how users may connect to the targets secured by your application.
        :param pulumi.Input[_builtins.str] decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
               Available values: "allow", "deny", "non_identity", "bypass".
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyExcludeArgs']]] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param pulumi.Input[_builtins.str] id: The UUID of the policy
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyIncludeArgs']]] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param pulumi.Input[_builtins.str] name: The name of the Access policy.
        :param pulumi.Input[_builtins.int] precedence: The order of execution for this policy. Must be unique for each policy within an app.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyRequireArgs']]] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        if connection_rules is not None:
            pulumi.set(__self__, "connection_rules", connection_rules)
        if decision is not None:
            pulumi.set(__self__, "decision", decision)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if requires is not None:
            pulumi.set(__self__, "requires", requires)

    @_builtins.property
    @pulumi.getter(name="connectionRules")
    def connection_rules(self) -> Optional[pulumi.Input['AccessApplicationPolicyConnectionRulesArgs']]:
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "connection_rules")

    @connection_rules.setter
    def connection_rules(self, value: Optional[pulumi.Input['AccessApplicationPolicyConnectionRulesArgs']]):
        pulumi.set(self, "connection_rules", value)

    @_builtins.property
    @pulumi.getter
    def decision(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        Available values: "allow", "deny", "non_identity", "bypass".
        """
        return pulumi.get(self, "decision")

    @decision.setter
    def decision(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "decision", value)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyExcludeArgs']]]]:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyExcludeArgs']]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyIncludeArgs']]]]:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyIncludeArgs']]]]):
        pulumi.set(self, "includes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "precedence", value)

    @_builtins.property
    @pulumi.getter
    def requires(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyRequireArgs']]]]:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @requires.setter
    def requires(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationPolicyRequireArgs']]]]):
        pulumi.set(self, "requires", value)


if not MYPY:
    class AccessApplicationPolicyConnectionRulesArgsDict(TypedDict):
        ssh: NotRequired[pulumi.Input['AccessApplicationPolicyConnectionRulesSshArgsDict']]
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
elif False:
    AccessApplicationPolicyConnectionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyConnectionRulesArgs:
    def __init__(__self__, *,
                 ssh: Optional[pulumi.Input['AccessApplicationPolicyConnectionRulesSshArgs']] = None):
        """
        :param pulumi.Input['AccessApplicationPolicyConnectionRulesSshArgs'] ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @_builtins.property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['AccessApplicationPolicyConnectionRulesSshArgs']]:
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['AccessApplicationPolicyConnectionRulesSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class AccessApplicationPolicyConnectionRulesSshArgsDict(TypedDict):
        usernames: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        allow_email_alias: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables using Identity Provider email alias as SSH username.
        """
elif False:
    AccessApplicationPolicyConnectionRulesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyConnectionRulesSshArgs:
    def __init__(__self__, *,
                 usernames: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allow_email_alias: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param pulumi.Input[_builtins.bool] allow_email_alias: Enables using Identity Provider email alias as SSH username.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "usernames", value)

    @_builtins.property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables using Identity Provider email alias as SSH username.
        """
        return pulumi.get(self, "allow_email_alias")

    @allow_email_alias.setter
    def allow_email_alias(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_email_alias", value)


if not MYPY:
    class AccessApplicationPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessApplicationPolicyExcludeServiceTokenArgsDict']]
elif False:
    AccessApplicationPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessApplicationPolicyExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessApplicationPolicyExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessApplicationPolicyExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessApplicationPolicyExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessApplicationPolicyExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessApplicationPolicyExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessApplicationPolicyExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessApplicationPolicyExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessApplicationPolicyExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessApplicationPolicyExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessApplicationPolicyExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessApplicationPolicyExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessApplicationPolicyExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessApplicationPolicyExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessApplicationPolicyExcludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessApplicationPolicyExcludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessApplicationPolicyExcludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessApplicationPolicyExcludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessApplicationPolicyExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessApplicationPolicyExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessApplicationPolicyExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessApplicationPolicyExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessApplicationPolicyExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessApplicationPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessApplicationPolicyExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessApplicationPolicyExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessApplicationPolicyExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessApplicationPolicyExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessApplicationPolicyExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessApplicationPolicyExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessApplicationPolicyExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessApplicationPolicyExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessApplicationPolicyExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessApplicationPolicyExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessApplicationPolicyExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessApplicationPolicyExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessApplicationPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessApplicationPolicyExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessApplicationPolicyExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessApplicationPolicyExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessApplicationPolicyExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessApplicationPolicyExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessApplicationPolicyExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessApplicationPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessApplicationPolicyExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessApplicationPolicyExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessApplicationPolicyExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessApplicationPolicyExcludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessApplicationPolicyExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessApplicationPolicyExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessApplicationPolicyExcludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessApplicationPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessApplicationPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessApplicationPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessApplicationPolicyExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessApplicationPolicyIncludeServiceTokenArgsDict']]
elif False:
    AccessApplicationPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessApplicationPolicyIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessApplicationPolicyIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessApplicationPolicyIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessApplicationPolicyIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessApplicationPolicyIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessApplicationPolicyIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessApplicationPolicyIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessApplicationPolicyIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessApplicationPolicyIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessApplicationPolicyIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessApplicationPolicyIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessApplicationPolicyIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessApplicationPolicyIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessApplicationPolicyIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessApplicationPolicyIncludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessApplicationPolicyIncludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessApplicationPolicyIncludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessApplicationPolicyIncludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessApplicationPolicyIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessApplicationPolicyIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessApplicationPolicyIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessApplicationPolicyIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessApplicationPolicyIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessApplicationPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessApplicationPolicyIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessApplicationPolicyIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessApplicationPolicyIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessApplicationPolicyIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessApplicationPolicyIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessApplicationPolicyIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessApplicationPolicyIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessApplicationPolicyIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessApplicationPolicyIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessApplicationPolicyIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessApplicationPolicyIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessApplicationPolicyIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessApplicationPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessApplicationPolicyIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessApplicationPolicyIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessApplicationPolicyIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessApplicationPolicyIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessApplicationPolicyIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessApplicationPolicyIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessApplicationPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessApplicationPolicyIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessApplicationPolicyIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessApplicationPolicyIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessApplicationPolicyIncludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessApplicationPolicyIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessApplicationPolicyIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessApplicationPolicyIncludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessApplicationPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessApplicationPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessApplicationPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessApplicationPolicyIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessApplicationPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessApplicationPolicyRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessApplicationPolicyRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessApplicationPolicyRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessApplicationPolicyRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessApplicationPolicyRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessApplicationPolicyRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessApplicationPolicyRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessApplicationPolicyRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessApplicationPolicyRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessApplicationPolicyRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessApplicationPolicyRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessApplicationPolicyRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessApplicationPolicyRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessApplicationPolicyRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessApplicationPolicyRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessApplicationPolicyRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessApplicationPolicyRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessApplicationPolicyRequireIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessApplicationPolicyRequireLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessApplicationPolicyRequireLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessApplicationPolicyRequireOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessApplicationPolicyRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessApplicationPolicyRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessApplicationPolicyRequireServiceTokenArgsDict']]
elif False:
    AccessApplicationPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessApplicationPolicyRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessApplicationPolicyRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessApplicationPolicyRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessApplicationPolicyRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessApplicationPolicyRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessApplicationPolicyRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessApplicationPolicyRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessApplicationPolicyRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessApplicationPolicyRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessApplicationPolicyRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessApplicationPolicyRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessApplicationPolicyRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessApplicationPolicyRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessApplicationPolicyRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessApplicationPolicyRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessApplicationPolicyRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessApplicationPolicyRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessApplicationPolicyRequireIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessApplicationPolicyRequireLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessApplicationPolicyRequireLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessApplicationPolicyRequireOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessApplicationPolicyRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessApplicationPolicyRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessApplicationPolicyRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessApplicationPolicyRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessApplicationPolicyRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessApplicationPolicyRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessApplicationPolicyRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessApplicationPolicyRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessApplicationPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessApplicationPolicyRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessApplicationPolicyRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessApplicationPolicyRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessApplicationPolicyRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessApplicationPolicyRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessApplicationPolicyRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessApplicationPolicyRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessApplicationPolicyRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessApplicationPolicyRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessApplicationPolicyRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessApplicationPolicyRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessApplicationPolicyRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessApplicationPolicyRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessApplicationPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessApplicationPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessApplicationPolicyRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessApplicationPolicyRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessApplicationPolicyRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessApplicationPolicyRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessApplicationPolicyRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessApplicationPolicyRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessApplicationPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessApplicationPolicyRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessApplicationPolicyRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessApplicationPolicyRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyRequireLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessApplicationPolicyRequireLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessApplicationPolicyRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessApplicationPolicyRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessApplicationPolicyRequireOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessApplicationPolicyRequireOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessApplicationPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessApplicationPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessApplicationPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessApplicationPolicyRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessApplicationPolicyRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationPolicyRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessApplicationSaasAppArgsDict(TypedDict):
        access_token_lifetime: NotRequired[pulumi.Input[_builtins.str]]
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        allow_pkce_without_client_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        app_launcher_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where this applications tile redirects users
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        Available values: "saml", "oidc".
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The application client id
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The application client secret, only returned on POST request.
        """
        consumer_service_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgsDict']]]]
        custom_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgsDict']]]]
        default_relay_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OIDC flows supported by this application
        """
        group_filter_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        hybrid_and_implicit_options: NotRequired[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict']]
        idp_entity_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier for your SaaS application.
        """
        name_id_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the name identifier sent to the SaaS application.
        Available values: "id", "email".
        """
        name_id_transform_jsonata: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access public certificate that will be used to verify your identity.
        """
        redirect_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        refresh_token_options: NotRequired[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionsArgsDict']]
        saml_attribute_transform_jsonata: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        sp_entity_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A globally unique name for an identity or service provider.
        """
        sso_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint where your SaaS application will send login requests.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AccessApplicationSaasAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppArgs:
    def __init__(__self__, *,
                 access_token_lifetime: Optional[pulumi.Input[_builtins.str]] = None,
                 allow_pkce_without_client_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 app_launcher_url: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_service_url: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]] = None,
                 custom_claims: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[_builtins.str]] = None,
                 grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_filter_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 hybrid_and_implicit_options: Optional[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs']] = None,
                 idp_entity_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name_id_format: Optional[pulumi.Input[_builtins.str]] = None,
                 name_id_transform_jsonata: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 refresh_token_options: Optional[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionsArgs']] = None,
                 saml_attribute_transform_jsonata: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sp_entity_id: Optional[pulumi.Input[_builtins.str]] = None,
                 sso_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_token_lifetime: The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        :param pulumi.Input[_builtins.bool] allow_pkce_without_client_secret: If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        :param pulumi.Input[_builtins.str] app_launcher_url: The URL where this applications tile redirects users
        :param pulumi.Input[_builtins.str] auth_type: Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
               Available values: "saml", "oidc".
        :param pulumi.Input[_builtins.str] client_id: The application client id
        :param pulumi.Input[_builtins.str] client_secret: The application client secret, only returned on POST request.
        :param pulumi.Input[_builtins.str] consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param pulumi.Input[_builtins.str] default_relay_state: The URL that the user will be redirected to after a successful login for IDP initiated logins.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] grant_types: The OIDC flows supported by this application
        :param pulumi.Input[_builtins.str] group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        :param pulumi.Input[_builtins.str] idp_entity_id: The unique identifier for your SaaS application.
        :param pulumi.Input[_builtins.str] name_id_format: The format of the name identifier sent to the SaaS application.
               Available values: "id", "email".
        :param pulumi.Input[_builtins.str] name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param pulumi.Input[_builtins.str] public_key: The Access public certificate that will be used to verify your identity.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        :param pulumi.Input[_builtins.str] saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        :param pulumi.Input[_builtins.str] sp_entity_id: A globally unique name for an identity or service provider.
        :param pulumi.Input[_builtins.str] sso_endpoint: The endpoint where your SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @access_token_lifetime.setter
    def access_token_lifetime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @allow_pkce_without_client_secret.setter
    def allow_pkce_without_client_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_pkce_without_client_secret", value)

    @_builtins.property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where this applications tile redirects users
        """
        return pulumi.get(self, "app_launcher_url")

    @app_launcher_url.setter
    def app_launcher_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_launcher_url", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        Available values: "saml", "oidc".
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The application client id
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The application client secret, only returned on POST request.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @consumer_service_url.setter
    def consumer_service_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_service_url", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]]:
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @_builtins.property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]]]:
        return pulumi.get(self, "custom_claims")

    @custom_claims.setter
    def custom_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomClaimArgs']]]]):
        pulumi.set(self, "custom_claims", value)

    @_builtins.property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_relay_state", value)

    @_builtins.property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OIDC flows supported by this application
        """
        return pulumi.get(self, "grant_types")

    @grant_types.setter
    def grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "grant_types", value)

    @_builtins.property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        return pulumi.get(self, "group_filter_regex")

    @group_filter_regex.setter
    def group_filter_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_filter_regex", value)

    @_builtins.property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs']]:
        return pulumi.get(self, "hybrid_and_implicit_options")

    @hybrid_and_implicit_options.setter
    def hybrid_and_implicit_options(self, value: Optional[pulumi.Input['AccessApplicationSaasAppHybridAndImplicitOptionsArgs']]):
        pulumi.set(self, "hybrid_and_implicit_options", value)

    @_builtins.property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier for your SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idp_entity_id", value)

    @_builtins.property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the name identifier sent to the SaaS application.
        Available values: "id", "email".
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_id_format", value)

    @_builtins.property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @name_id_transform_jsonata.setter
    def name_id_transform_jsonata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_id_transform_jsonata", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access public certificate that will be used to verify your identity.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "redirect_uris", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionsArgs']]:
        return pulumi.get(self, "refresh_token_options")

    @refresh_token_options.setter
    def refresh_token_options(self, value: Optional[pulumi.Input['AccessApplicationSaasAppRefreshTokenOptionsArgs']]):
        pulumi.set(self, "refresh_token_options", value)

    @_builtins.property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @saml_attribute_transform_jsonata.setter
    def saml_attribute_transform_jsonata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "saml_attribute_transform_jsonata", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sp_entity_id", value)

    @_builtins.property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint where your SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @sso_endpoint.setter
    def sso_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sso_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class AccessApplicationSaasAppCustomAttributeArgsDict(TypedDict):
        friendly_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SAML FriendlyName of the attribute.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the attribute.
        """
        name_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        A globally unique name for an identity or service provider.
        Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the attribute is required when building a SAML assertion.
        """
        source: NotRequired[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgsDict']]
elif False:
    AccessApplicationSaasAppCustomAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeArgs:
    def __init__(__self__, *,
                 friendly_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_format: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 source: Optional[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] friendly_name: The SAML FriendlyName of the attribute.
        :param pulumi.Input[_builtins.str] name: The name of the attribute.
        :param pulumi.Input[_builtins.str] name_format: A globally unique name for an identity or service provider.
               Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
        :param pulumi.Input[_builtins.bool] required: If the attribute is required when building a SAML assertion.
        """
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SAML FriendlyName of the attribute.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "friendly_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A globally unique name for an identity or service provider.
        Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
        """
        return pulumi.get(self, "name_format")

    @name_format.setter
    def name_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_format", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the attribute is required when building a SAML assertion.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class AccessApplicationSaasAppCustomAttributeSourceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the IdP attribute.
        """
        name_by_idps: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict']]]]
        """
        A mapping from IdP ID to attribute name.
        """
elif False:
    AccessApplicationSaasAppCustomAttributeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_by_idps: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the IdP attribute.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]] name_by_idps: A mapping from IdP ID to attribute name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idps is not None:
            pulumi.set(__self__, "name_by_idps", name_by_idps)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the IdP attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameByIdps")
    def name_by_idps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]]:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idps")

    @name_by_idps.setter
    def name_by_idps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]]):
        pulumi.set(self, "name_by_idps", value)


if not MYPY:
    class AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict(TypedDict):
        idp_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the IdP.
        """
        source_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the IdP provided attribute.
        """
elif False:
    AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs:
    def __init__(__self__, *,
                 idp_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] idp_id: The UID of the IdP.
        :param pulumi.Input[_builtins.str] source_name: The name of the IdP provided attribute.
        """
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @_builtins.property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the IdP.
        """
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idp_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the IdP provided attribute.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_name", value)


if not MYPY:
    class AccessApplicationSaasAppCustomClaimArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the claim.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the claim is required when building an OIDC token.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope of the claim.
        Available values: "groups", "profile", "email", "openid".
        """
        source: NotRequired[pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgsDict']]
elif False:
    AccessApplicationSaasAppCustomClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomClaimArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the claim.
        :param pulumi.Input[_builtins.bool] required: If the claim is required when building an OIDC token.
        :param pulumi.Input[_builtins.str] scope: The scope of the claim.
               Available values: "groups", "profile", "email", "openid".
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the claim is required when building an OIDC token.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope of the claim.
        Available values: "groups", "profile", "email", "openid".
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['AccessApplicationSaasAppCustomClaimSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class AccessApplicationSaasAppCustomClaimSourceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the IdP claim.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    AccessApplicationSaasAppCustomClaimSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppCustomClaimSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the IdP claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the IdP claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict(TypedDict):
        return_access_token_from_authorization_endpoint: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return_id_token_from_authorization_endpoint: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
elif False:
    AccessApplicationSaasAppHybridAndImplicitOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppHybridAndImplicitOptionsArgs:
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[pulumi.Input[_builtins.bool]] = None,
                 return_id_token_from_authorization_endpoint: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] return_access_token_from_authorization_endpoint: If an Access Token should be returned from the OIDC Authorization endpoint
        :param pulumi.Input[_builtins.bool] return_id_token_from_authorization_endpoint: If an ID Token should be returned from the OIDC Authorization endpoint
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @_builtins.property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @return_access_token_from_authorization_endpoint.setter
    def return_access_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_access_token_from_authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")

    @return_id_token_from_authorization_endpoint.setter
    def return_id_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_id_token_from_authorization_endpoint", value)


if not MYPY:
    class AccessApplicationSaasAppRefreshTokenOptionsArgsDict(TypedDict):
        lifetime: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
elif False:
    AccessApplicationSaasAppRefreshTokenOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationSaasAppRefreshTokenOptionsArgs:
    def __init__(__self__, *,
                 lifetime: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] lifetime: How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @_builtins.property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifetime", value)


if not MYPY:
    class AccessApplicationScimConfigArgsDict(TypedDict):
        idp_uid: pulumi.Input[_builtins.str]
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        remote_uri: pulumi.Input[_builtins.str]
        """
        The base URI for the application's SCIM-compatible API.
        """
        authentication: NotRequired[pulumi.Input['AccessApplicationScimConfigAuthenticationArgsDict']]
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        deactivate_on_delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether SCIM provisioning is turned on for this application.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgsDict']]]]
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
elif False:
    AccessApplicationScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigArgs:
    def __init__(__self__, *,
                 idp_uid: pulumi.Input[_builtins.str],
                 remote_uri: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['AccessApplicationScimConfigAuthenticationArgs']] = None,
                 deactivate_on_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] idp_uid: The UID of the IdP to use as the source for SCIM resources to provision to this application.
        :param pulumi.Input[_builtins.str] remote_uri: The base URI for the application's SCIM-compatible API.
        :param pulumi.Input['AccessApplicationScimConfigAuthenticationArgs'] authentication: Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        :param pulumi.Input[_builtins.bool] deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param pulumi.Input[_builtins.bool] enabled: Whether SCIM provisioning is turned on for this application.
        :param pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @_builtins.property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @idp_uid.setter
    def idp_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "idp_uid", value)

    @_builtins.property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @remote_uri.setter
    def remote_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_uri", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['AccessApplicationScimConfigAuthenticationArgs']]:
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['AccessApplicationScimConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @deactivate_on_delete.setter
    def deactivate_on_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deactivate_on_delete", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]]]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessApplicationScimConfigMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class AccessApplicationScimConfigAuthenticationArgsDict(TypedDict):
        scheme: pulumi.Input[_builtins.str]
        """
        The authentication scheme to use when making SCIM requests to this application.
        Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
        """
        authorization_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL used to generate the auth code used during token generation.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password used to authenticate with the remote SCIM service.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Token used to authenticate with the remote SCIM service.
        """
        token_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name used to authenticate with the remote SCIM service.
        """
elif False:
    AccessApplicationScimConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigAuthenticationArgs:
    def __init__(__self__, *,
                 scheme: pulumi.Input[_builtins.str],
                 authorization_url: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 token_url: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scheme: The authentication scheme to use when making SCIM requests to this application.
               Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
        :param pulumi.Input[_builtins.str] authorization_url: URL used to generate the auth code used during token generation.
        :param pulumi.Input[_builtins.str] client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param pulumi.Input[_builtins.str] client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param pulumi.Input[_builtins.str] password: Password used to authenticate with the remote SCIM service.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param pulumi.Input[_builtins.str] token: Token used to authenticate with the remote SCIM service.
        :param pulumi.Input[_builtins.str] token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param pulumi.Input[_builtins.str] user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication scheme to use when making SCIM requests to this application.
        Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @authorization_url.setter
    def authorization_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AccessApplicationScimConfigMappingArgsDict(TypedDict):
        schema: pulumi.Input[_builtins.str]
        """
        Which SCIM resource type this mapping applies to.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping is enabled.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        operations: NotRequired[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgsDict']]
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        strictness: NotRequired[pulumi.Input[_builtins.str]]
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        Available values: "strict", "passthrough".
        """
        transform_jsonata: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
elif False:
    AccessApplicationScimConfigMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigMappingArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 operations: Optional[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs']] = None,
                 strictness: Optional[pulumi.Input[_builtins.str]] = None,
                 transform_jsonata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] schema: Which SCIM resource type this mapping applies to.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not this mapping is enabled.
        :param pulumi.Input[_builtins.str] filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs'] operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param pulumi.Input[_builtins.str] strictness: The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
               Available values: "strict", "passthrough".
        :param pulumi.Input[_builtins.str] transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> pulumi.Input[_builtins.str]:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs']]:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input['AccessApplicationScimConfigMappingOperationsArgs']]):
        pulumi.set(self, "operations", value)

    @_builtins.property
    @pulumi.getter
    def strictness(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        Available values: "strict", "passthrough".
        """
        return pulumi.get(self, "strictness")

    @strictness.setter
    def strictness(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strictness", value)

    @_builtins.property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")

    @transform_jsonata.setter
    def transform_jsonata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transform_jsonata", value)


if not MYPY:
    class AccessApplicationScimConfigMappingOperationsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping applies to DELETE operations.
        """
        update: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
elif False:
    AccessApplicationScimConfigMappingOperationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationScimConfigMappingOperationsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 update: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] create: Whether or not this mapping applies to create (POST) operations.
        :param pulumi.Input[_builtins.bool] delete: Whether or not this mapping applies to DELETE operations.
        :param pulumi.Input[_builtins.bool] update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class AccessApplicationTargetCriteriaArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The communication protocol your application secures.
        Available values: "SSH", "RDP".
        """
        target_attributes: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]
        """
        Contains a map of target attribute keys to target attribute values.
        """
elif False:
    AccessApplicationTargetCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessApplicationTargetCriteriaArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 target_attributes: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]):
        """
        :param pulumi.Input[_builtins.int] port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param pulumi.Input[_builtins.str] protocol: The communication protocol your application secures.
               Available values: "SSH", "RDP".
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The communication protocol your application secures.
        Available values: "SSH", "RDP".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]):
        pulumi.set(self, "target_attributes", value)


if not MYPY:
    class AccessGroupExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessGroupExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessGroupExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessGroupExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessGroupExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessGroupExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessGroupExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessGroupExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessGroupExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessGroupExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessGroupExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessGroupExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessGroupExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessGroupExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessGroupExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessGroupExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessGroupExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessGroupExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessGroupExcludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessGroupExcludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessGroupExcludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessGroupExcludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessGroupExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessGroupExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessGroupExcludeServiceTokenArgsDict']]
elif False:
    AccessGroupExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessGroupExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessGroupExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessGroupExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessGroupExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessGroupExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessGroupExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessGroupExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessGroupExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessGroupExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessGroupExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessGroupExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessGroupExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessGroupExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessGroupExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessGroupExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessGroupExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessGroupExcludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessGroupExcludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessGroupExcludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessGroupExcludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessGroupExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessGroupExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessGroupExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessGroupExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessGroupExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessGroupExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessGroupExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessGroupExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessGroupExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessGroupExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessGroupExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessGroupExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessGroupExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessGroupExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessGroupExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessGroupExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessGroupExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessGroupExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessGroupExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessGroupExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessGroupExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessGroupExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessGroupExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessGroupExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessGroupExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessGroupExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessGroupExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessGroupExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessGroupExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessGroupExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessGroupExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessGroupExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessGroupExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessGroupExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessGroupExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessGroupExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessGroupExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessGroupExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessGroupExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessGroupExcludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessGroupExcludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessGroupExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessGroupExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessGroupExcludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessGroupExcludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessGroupExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessGroupExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessGroupExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessGroupExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessGroupExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessGroupExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessGroupExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessGroupExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessGroupExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessGroupExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessGroupExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessGroupExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessGroupExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessGroupExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessGroupExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessGroupExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessGroupExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessGroupExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessGroupExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessGroupExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessGroupExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessGroupExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessGroupExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessGroupExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessGroupExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessGroupExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessGroupExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessGroupExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessGroupExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessGroupExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessGroupExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessGroupExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessGroupExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessGroupExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupExcludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessGroupExcludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessGroupExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessGroupExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupExcludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessGroupExcludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessGroupExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessGroupExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessGroupExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessGroupExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessGroupIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessGroupIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessGroupIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessGroupIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessGroupIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessGroupIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessGroupIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessGroupIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessGroupIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessGroupIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessGroupIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessGroupIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessGroupIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessGroupIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessGroupIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessGroupIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessGroupIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessGroupIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessGroupIncludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessGroupIncludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessGroupIncludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessGroupIncludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessGroupIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessGroupIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessGroupIncludeServiceTokenArgsDict']]
elif False:
    AccessGroupIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessGroupIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessGroupIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessGroupIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessGroupIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessGroupIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessGroupIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessGroupIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessGroupIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessGroupIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessGroupIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessGroupIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessGroupIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessGroupIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessGroupIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessGroupIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessGroupIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessGroupIncludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessGroupIncludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessGroupIncludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessGroupIncludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessGroupIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessGroupIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessGroupIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessGroupIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessGroupIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessGroupIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessGroupIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessGroupIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessGroupIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessGroupIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessGroupIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessGroupIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessGroupIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessGroupIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessGroupIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessGroupIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessGroupIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessGroupIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessGroupIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessGroupIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessGroupIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessGroupIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessGroupIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessGroupIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessGroupIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessGroupIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessGroupIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessGroupIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessGroupIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessGroupIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessGroupIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessGroupIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessGroupIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessGroupIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessGroupIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessGroupIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessGroupIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessGroupIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessGroupIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessGroupIncludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessGroupIncludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessGroupIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessGroupIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessGroupIncludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessGroupIncludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessGroupIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessGroupIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessGroupIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessGroupIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessGroupIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessGroupIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessGroupIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessGroupIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessGroupIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessGroupIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessGroupIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessGroupIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessGroupIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessGroupIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessGroupIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessGroupIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessGroupIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessGroupIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessGroupIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessGroupIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessGroupIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessGroupIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessGroupIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessGroupIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessGroupIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessGroupIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessGroupIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessGroupIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessGroupIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessGroupIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessGroupIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessGroupIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessGroupIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessGroupIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupIncludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessGroupIncludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessGroupIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessGroupIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupIncludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessGroupIncludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessGroupIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessGroupIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessGroupIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessGroupIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessGroupRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessGroupRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessGroupRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessGroupRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessGroupRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessGroupRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessGroupRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessGroupRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessGroupRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessGroupRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessGroupRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessGroupRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessGroupRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessGroupRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessGroupRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessGroupRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessGroupRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessGroupRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessGroupRequireIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessGroupRequireLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessGroupRequireLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessGroupRequireOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessGroupRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessGroupRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessGroupRequireServiceTokenArgsDict']]
elif False:
    AccessGroupRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessGroupRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessGroupRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessGroupRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessGroupRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessGroupRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessGroupRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessGroupRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessGroupRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessGroupRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessGroupRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessGroupRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessGroupRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessGroupRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessGroupRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessGroupRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessGroupRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessGroupRequireIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessGroupRequireLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessGroupRequireLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessGroupRequireOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessGroupRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessGroupRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessGroupRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessGroupRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessGroupRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessGroupRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessGroupRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessGroupRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessGroupRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessGroupRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessGroupRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessGroupRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessGroupRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessGroupRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessGroupRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessGroupRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessGroupRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessGroupRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessGroupRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessGroupRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessGroupRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessGroupRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessGroupRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessGroupRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessGroupRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessGroupRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessGroupRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessGroupRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessGroupRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessGroupRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessGroupRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessGroupRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessGroupRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessGroupRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessGroupRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessGroupRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessGroupRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessGroupRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessGroupRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessGroupRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessGroupRequireLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessGroupRequireLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessGroupRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessGroupRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessGroupRequireOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessGroupRequireOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessGroupRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessGroupRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessGroupRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessGroupRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessGroupRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessGroupRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessGroupRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessGroupRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessGroupRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessGroupRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessGroupRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessGroupRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessGroupRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessGroupRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessGroupRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessGroupRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessGroupRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessGroupRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessGroupRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessGroupRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessGroupRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessGroupRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessGroupRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessGroupRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessGroupRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessGroupRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessGroupRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessGroupRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessGroupRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessGroupRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessGroupRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessGroupRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessGroupRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessGroupRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessGroupRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupRequireLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessGroupRequireLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessGroupRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessGroupRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessGroupRequireOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessGroupRequireOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessGroupRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessGroupRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessGroupRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessGroupRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessGroupRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessGroupRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessIdentityProviderConfigArgsDict(TypedDict):
        apps_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your companies TLD
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        auth_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authorization_endpoint URL of your IdP
        """
        authorization_server_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your okta authorization server id
        """
        centrify_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your centrify account url
        """
        centrify_app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your centrify app id
        """
        certs_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom claims
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your OAuth Client ID
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your OAuth Client Secret
        """
        conditional_access_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        directory_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your Azure directory uuid
        """
        email_attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attribute name for email in the SAML response.
        """
        email_claim_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The claim name for email in the id_token response.
        """
        header_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessIdentityProviderConfigHeaderAttributeArgsDict']]]]
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        idp_public_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        issuer_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        IdP Entity ID or Issuer URL
        """
        okta_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your okta account url
        """
        onelogin_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your OneLogin account url
        """
        ping_env_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your PingOne environment identifier
        """
        pkce_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        Available values: "login", "select_account", "none".
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        OAuth scopes
        """
        sign_request: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        sso_target_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL to send the SAML authentication requests to
        """
        support_groups: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Should Cloudflare try to load groups from your account
        """
        token_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The token_endpoint URL of your IdP
        """
elif False:
    AccessIdentityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessIdentityProviderConfigArgs:
    def __init__(__self__, *,
                 apps_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 auth_url: Optional[pulumi.Input[_builtins.str]] = None,
                 authorization_server_id: Optional[pulumi.Input[_builtins.str]] = None,
                 centrify_account: Optional[pulumi.Input[_builtins.str]] = None,
                 centrify_app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certs_url: Optional[pulumi.Input[_builtins.str]] = None,
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 conditional_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 directory_id: Optional[pulumi.Input[_builtins.str]] = None,
                 email_attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 email_claim_name: Optional[pulumi.Input[_builtins.str]] = None,
                 header_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['AccessIdentityProviderConfigHeaderAttributeArgs']]]] = None,
                 idp_public_certs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 issuer_url: Optional[pulumi.Input[_builtins.str]] = None,
                 okta_account: Optional[pulumi.Input[_builtins.str]] = None,
                 onelogin_account: Optional[pulumi.Input[_builtins.str]] = None,
                 ping_env_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pkce_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sign_request: Optional[pulumi.Input[_builtins.bool]] = None,
                 sso_target_url: Optional[pulumi.Input[_builtins.str]] = None,
                 support_groups: Optional[pulumi.Input[_builtins.bool]] = None,
                 token_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apps_domain: Your companies TLD
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attributes: A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        :param pulumi.Input[_builtins.str] auth_url: The authorization_endpoint URL of your IdP
        :param pulumi.Input[_builtins.str] authorization_server_id: Your okta authorization server id
        :param pulumi.Input[_builtins.str] centrify_account: Your centrify account url
        :param pulumi.Input[_builtins.str] centrify_app_id: Your centrify app id
        :param pulumi.Input[_builtins.str] certs_url: The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] claims: Custom claims
        :param pulumi.Input[_builtins.str] client_id: Your OAuth Client ID
        :param pulumi.Input[_builtins.str] client_secret: Your OAuth Client Secret
        :param pulumi.Input[_builtins.bool] conditional_access_enabled: Should Cloudflare try to load authentication contexts from your account
        :param pulumi.Input[_builtins.str] directory_id: Your Azure directory uuid
        :param pulumi.Input[_builtins.str] email_attribute_name: The attribute name for email in the SAML response.
        :param pulumi.Input[_builtins.str] email_claim_name: The claim name for email in the id_token response.
        :param pulumi.Input[Sequence[pulumi.Input['AccessIdentityProviderConfigHeaderAttributeArgs']]] header_attributes: Add a list of attribute names that will be returned in the response header from the Access callback.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] idp_public_certs: X509 certificate to verify the signature in the SAML authentication response
        :param pulumi.Input[_builtins.str] issuer_url: IdP Entity ID or Issuer URL
        :param pulumi.Input[_builtins.str] okta_account: Your okta account url
        :param pulumi.Input[_builtins.str] onelogin_account: Your OneLogin account url
        :param pulumi.Input[_builtins.str] ping_env_id: Your PingOne environment identifier
        :param pulumi.Input[_builtins.bool] pkce_enabled: Enable Proof Key for Code Exchange (PKCE)
        :param pulumi.Input[_builtins.str] prompt: Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
               Available values: "login", "select_account", "none".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: OAuth scopes
        :param pulumi.Input[_builtins.bool] sign_request: Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        :param pulumi.Input[_builtins.str] sso_target_url: URL to send the SAML authentication requests to
        :param pulumi.Input[_builtins.bool] support_groups: Should Cloudflare try to load groups from your account
        :param pulumi.Input[_builtins.str] token_url: The token_endpoint URL of your IdP
        """
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if header_attributes is not None:
            pulumi.set(__self__, "header_attributes", header_attributes)
        if idp_public_certs is not None:
            pulumi.set(__self__, "idp_public_certs", idp_public_certs)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @_builtins.property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your companies TLD
        """
        return pulumi.get(self, "apps_domain")

    @apps_domain.setter
    def apps_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apps_domain", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authorization_endpoint URL of your IdP
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_url", value)

    @_builtins.property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your okta authorization server id
        """
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_server_id", value)

    @_builtins.property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your centrify account url
        """
        return pulumi.get(self, "centrify_account")

    @centrify_account.setter
    def centrify_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "centrify_account", value)

    @_builtins.property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your centrify app id
        """
        return pulumi.get(self, "centrify_app_id")

    @centrify_app_id.setter
    def centrify_app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "centrify_app_id", value)

    @_builtins.property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        return pulumi.get(self, "certs_url")

    @certs_url.setter
    def certs_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certs_url", value)

    @_builtins.property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom claims
        """
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claims", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your OAuth Client ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your OAuth Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        return pulumi.get(self, "conditional_access_enabled")

    @conditional_access_enabled.setter
    def conditional_access_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "conditional_access_enabled", value)

    @_builtins.property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your Azure directory uuid
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "directory_id", value)

    @_builtins.property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attribute name for email in the SAML response.
        """
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The claim name for email in the id_token response.
        """
        return pulumi.get(self, "email_claim_name")

    @email_claim_name.setter
    def email_claim_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_claim_name", value)

    @_builtins.property
    @pulumi.getter(name="headerAttributes")
    def header_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessIdentityProviderConfigHeaderAttributeArgs']]]]:
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        return pulumi.get(self, "header_attributes")

    @header_attributes.setter
    def header_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessIdentityProviderConfigHeaderAttributeArgs']]]]):
        pulumi.set(self, "header_attributes", value)

    @_builtins.property
    @pulumi.getter(name="idpPublicCerts")
    def idp_public_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        return pulumi.get(self, "idp_public_certs")

    @idp_public_certs.setter
    def idp_public_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "idp_public_certs", value)

    @_builtins.property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IdP Entity ID or Issuer URL
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer_url", value)

    @_builtins.property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your okta account url
        """
        return pulumi.get(self, "okta_account")

    @okta_account.setter
    def okta_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "okta_account", value)

    @_builtins.property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your OneLogin account url
        """
        return pulumi.get(self, "onelogin_account")

    @onelogin_account.setter
    def onelogin_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "onelogin_account", value)

    @_builtins.property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your PingOne environment identifier
        """
        return pulumi.get(self, "ping_env_id")

    @ping_env_id.setter
    def ping_env_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ping_env_id", value)

    @_builtins.property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        Available values: "login", "select_account", "none".
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sign_request", value)

    @_builtins.property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL to send the SAML authentication requests to
        """
        return pulumi.get(self, "sso_target_url")

    @sso_target_url.setter
    def sso_target_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sso_target_url", value)

    @_builtins.property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Should Cloudflare try to load groups from your account
        """
        return pulumi.get(self, "support_groups")

    @support_groups.setter
    def support_groups(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "support_groups", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The token_endpoint URL of your IdP
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class AccessIdentityProviderConfigHeaderAttributeArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        attribute name from the IDP
        """
        header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        header that will be added on the request to the origin
        """
elif False:
    AccessIdentityProviderConfigHeaderAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessIdentityProviderConfigHeaderAttributeArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 header_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_name: attribute name from the IDP
        :param pulumi.Input[_builtins.str] header_name: header that will be added on the request to the origin
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        attribute name from the IDP
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        header that will be added on the request to the origin
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class AccessIdentityProviderScimConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        identity_update_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        Available values: "automatic", "reauth", "no*action".
        """
        scim_base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        seat_deprovision: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        user_deprovision: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
elif False:
    AccessIdentityProviderScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessIdentityProviderScimConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 identity_update_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 scim_base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 seat_deprovision: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 user_deprovision: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: A flag to enable or disable SCIM for the identity provider.
        :param pulumi.Input[_builtins.str] identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
               Available values: "automatic", "reauth", "no*action".
        :param pulumi.Input[_builtins.str] scim_base_url: The base URL of Cloudflare's SCIM V2.0 API endpoint.
        :param pulumi.Input[_builtins.bool] seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param pulumi.Input[_builtins.str] secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        :param pulumi.Input[_builtins.bool] user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if scim_base_url is not None:
            pulumi.set(__self__, "scim_base_url", scim_base_url)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        Available values: "automatic", "reauth", "no*action".
        """
        return pulumi.get(self, "identity_update_behavior")

    @identity_update_behavior.setter
    def identity_update_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_update_behavior", value)

    @_builtins.property
    @pulumi.getter(name="scimBaseUrl")
    def scim_base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        return pulumi.get(self, "scim_base_url")

    @scim_base_url.setter
    def scim_base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scim_base_url", value)

    @_builtins.property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @seat_deprovision.setter
    def seat_deprovision(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "seat_deprovision", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")

    @user_deprovision.setter
    def user_deprovision(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "user_deprovision", value)


if not MYPY:
    class AccessMutualTlsHostnameSettingsSettingArgsDict(TypedDict):
        china_network: pulumi.Input[_builtins.bool]
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        client_certificate_forwarding: pulumi.Input[_builtins.bool]
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The hostname that these settings apply to.
        """
elif False:
    AccessMutualTlsHostnameSettingsSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessMutualTlsHostnameSettingsSettingArgs:
    def __init__(__self__, *,
                 china_network: pulumi.Input[_builtins.bool],
                 client_certificate_forwarding: pulumi.Input[_builtins.bool],
                 hostname: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param pulumi.Input[_builtins.bool] client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        :param pulumi.Input[_builtins.str] hostname: The hostname that these settings apply to.
        """
        pulumi.set(__self__, "china_network", china_network)
        pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)
        pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> pulumi.Input[_builtins.bool]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @china_network.setter
    def china_network(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "china_network", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> pulumi.Input[_builtins.bool]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")

    @client_certificate_forwarding.setter
    def client_certificate_forwarding(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "client_certificate_forwarding", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class AccessOrganizationCustomPagesArgsDict(TypedDict):
        forbidden: NotRequired[pulumi.Input[_builtins.str]]
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        identity_denied: NotRequired[pulumi.Input[_builtins.str]]
        """
        The uid of the custom page to use when a user is denied access.
        """
elif False:
    AccessOrganizationCustomPagesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessOrganizationCustomPagesArgs:
    def __init__(__self__, *,
                 forbidden: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_denied: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] forbidden: The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        :param pulumi.Input[_builtins.str] identity_denied: The uid of the custom page to use when a user is denied access.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @_builtins.property
    @pulumi.getter
    def forbidden(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        return pulumi.get(self, "forbidden")

    @forbidden.setter
    def forbidden(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forbidden", value)

    @_builtins.property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The uid of the custom page to use when a user is denied access.
        """
        return pulumi.get(self, "identity_denied")

    @identity_denied.setter
    def identity_denied(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_denied", value)


if not MYPY:
    class AccessOrganizationLoginDesignArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color on your login page.
        """
        footer_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text at the bottom of your login page.
        """
        header_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text at the top of your login page.
        """
        logo_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo on your login page.
        """
        text_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color on your login page.
        """
elif False:
    AccessOrganizationLoginDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessOrganizationLoginDesignArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 footer_text: Optional[pulumi.Input[_builtins.str]] = None,
                 header_text: Optional[pulumi.Input[_builtins.str]] = None,
                 logo_path: Optional[pulumi.Input[_builtins.str]] = None,
                 text_color: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] background_color: The background color on your login page.
        :param pulumi.Input[_builtins.str] footer_text: The text at the bottom of your login page.
        :param pulumi.Input[_builtins.str] header_text: The text at the top of your login page.
        :param pulumi.Input[_builtins.str] logo_path: The URL of the logo on your login page.
        :param pulumi.Input[_builtins.str] text_color: The text color on your login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @_builtins.property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color on your login page.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "background_color", value)

    @_builtins.property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text at the bottom of your login page.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "footer_text", value)

    @_builtins.property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text at the top of your login page.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_text", value)

    @_builtins.property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo on your login page.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo_path", value)

    @_builtins.property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color on your login page.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_color", value)


if not MYPY:
    class AccessPolicyApprovalGroupArgsDict(TypedDict):
        approvals_needed: pulumi.Input[_builtins.float]
        """
        The number of approvals needed to obtain access.
        """
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that can approve the access request.
        """
        email_list_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UUID of an re-usable email list.
        """
elif False:
    AccessPolicyApprovalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyApprovalGroupArgs:
    def __init__(__self__, *,
                 approvals_needed: pulumi.Input[_builtins.float],
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 email_list_uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] approvals_needed: The number of approvals needed to obtain access.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] email_addresses: A list of emails that can approve the access request.
        :param pulumi.Input[_builtins.str] email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @_builtins.property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> pulumi.Input[_builtins.float]:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @approvals_needed.setter
    def approvals_needed(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "approvals_needed", value)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "email_addresses", value)

    @_builtins.property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")

    @email_list_uuid.setter
    def email_list_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_list_uuid", value)


if not MYPY:
    class AccessPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessPolicyExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessPolicyExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessPolicyExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessPolicyExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessPolicyExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessPolicyExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessPolicyExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessPolicyExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessPolicyExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessPolicyExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessPolicyExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessPolicyExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessPolicyExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessPolicyExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessPolicyExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessPolicyExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessPolicyExcludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessPolicyExcludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessPolicyExcludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessPolicyExcludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessPolicyExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessPolicyExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessPolicyExcludeServiceTokenArgsDict']]
elif False:
    AccessPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessPolicyExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessPolicyExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessPolicyExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessPolicyExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessPolicyExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessPolicyExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessPolicyExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessPolicyExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessPolicyExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessPolicyExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessPolicyExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessPolicyExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessPolicyExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessPolicyExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessPolicyExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessPolicyExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessPolicyExcludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessPolicyExcludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessPolicyExcludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessPolicyExcludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessPolicyExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessPolicyExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessPolicyExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessPolicyExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessPolicyExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessPolicyExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessPolicyExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessPolicyExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessPolicyExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessPolicyExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessPolicyExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessPolicyExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessPolicyExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessPolicyExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessPolicyExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessPolicyExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessPolicyExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessPolicyExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessPolicyExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessPolicyExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessPolicyExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessPolicyExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessPolicyExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessPolicyExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessPolicyExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessPolicyExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessPolicyExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessPolicyExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessPolicyExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessPolicyExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessPolicyExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessPolicyExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessPolicyExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessPolicyExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessPolicyExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessPolicyExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessPolicyExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessPolicyExcludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessPolicyExcludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessPolicyExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessPolicyExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessPolicyExcludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessPolicyExcludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessPolicyExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessPolicyExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessPolicyExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessPolicyExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessPolicyExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessPolicyExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessPolicyExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessPolicyExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessPolicyExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessPolicyExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessPolicyExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessPolicyExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessPolicyExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessPolicyExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessPolicyExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessPolicyExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessPolicyExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessPolicyExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessPolicyExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessPolicyExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessPolicyExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessPolicyExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessPolicyExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessPolicyExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessPolicyExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessPolicyExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessPolicyExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessPolicyExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyExcludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessPolicyExcludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessPolicyExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessPolicyExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyExcludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessPolicyExcludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessPolicyExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessPolicyIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessPolicyIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessPolicyIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessPolicyIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessPolicyIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessPolicyIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessPolicyIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessPolicyIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessPolicyIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessPolicyIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessPolicyIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessPolicyIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessPolicyIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessPolicyIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessPolicyIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessPolicyIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessPolicyIncludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessPolicyIncludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessPolicyIncludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessPolicyIncludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessPolicyIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessPolicyIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessPolicyIncludeServiceTokenArgsDict']]
elif False:
    AccessPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessPolicyIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessPolicyIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessPolicyIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessPolicyIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessPolicyIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessPolicyIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessPolicyIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessPolicyIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessPolicyIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessPolicyIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessPolicyIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessPolicyIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessPolicyIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessPolicyIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessPolicyIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessPolicyIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessPolicyIncludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessPolicyIncludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessPolicyIncludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessPolicyIncludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessPolicyIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessPolicyIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessPolicyIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessPolicyIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessPolicyIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessPolicyIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessPolicyIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessPolicyIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessPolicyIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessPolicyIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessPolicyIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessPolicyIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessPolicyIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessPolicyIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessPolicyIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessPolicyIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessPolicyIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessPolicyIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessPolicyIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessPolicyIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessPolicyIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessPolicyIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessPolicyIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessPolicyIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessPolicyIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessPolicyIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessPolicyIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessPolicyIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessPolicyIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessPolicyIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessPolicyIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessPolicyIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessPolicyIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessPolicyIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessPolicyIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessPolicyIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessPolicyIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessPolicyIncludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessPolicyIncludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessPolicyIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessPolicyIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessPolicyIncludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessPolicyIncludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessPolicyIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessPolicyIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessPolicyIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessPolicyIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessPolicyIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessPolicyIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessPolicyIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessPolicyIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessPolicyIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessPolicyIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessPolicyIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessPolicyIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessPolicyIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessPolicyIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessPolicyIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessPolicyIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessPolicyIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessPolicyIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessPolicyIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessPolicyIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessPolicyIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessPolicyIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessPolicyIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessPolicyIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessPolicyIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessPolicyIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessPolicyIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessPolicyIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyIncludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessPolicyIncludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessPolicyIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessPolicyIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyIncludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessPolicyIncludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessPolicyIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['AccessPolicyRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['AccessPolicyRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['AccessPolicyRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['AccessPolicyRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['AccessPolicyRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['AccessPolicyRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['AccessPolicyRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['AccessPolicyRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['AccessPolicyRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['AccessPolicyRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['AccessPolicyRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['AccessPolicyRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['AccessPolicyRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['AccessPolicyRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['AccessPolicyRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['AccessPolicyRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['AccessPolicyRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['AccessPolicyRequireIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['AccessPolicyRequireLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['AccessPolicyRequireLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['AccessPolicyRequireOidcArgsDict']]
        okta: NotRequired[pulumi.Input['AccessPolicyRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['AccessPolicyRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['AccessPolicyRequireServiceTokenArgsDict']]
elif False:
    AccessPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['AccessPolicyRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['AccessPolicyRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['AccessPolicyRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['AccessPolicyRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['AccessPolicyRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['AccessPolicyRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['AccessPolicyRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['AccessPolicyRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['AccessPolicyRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['AccessPolicyRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['AccessPolicyRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['AccessPolicyRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['AccessPolicyRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['AccessPolicyRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['AccessPolicyRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['AccessPolicyRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['AccessPolicyRequireIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['AccessPolicyRequireLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['AccessPolicyRequireLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['AccessPolicyRequireOidcArgs']] = None,
                 okta: Optional[pulumi.Input['AccessPolicyRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['AccessPolicyRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['AccessPolicyRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['AccessPolicyRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['AccessPolicyRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['AccessPolicyRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['AccessPolicyRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['AccessPolicyRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['AccessPolicyRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['AccessPolicyRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['AccessPolicyRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['AccessPolicyRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['AccessPolicyRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['AccessPolicyRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['AccessPolicyRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['AccessPolicyRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['AccessPolicyRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['AccessPolicyRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['AccessPolicyRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['AccessPolicyRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['AccessPolicyRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['AccessPolicyRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['AccessPolicyRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['AccessPolicyRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['AccessPolicyRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['AccessPolicyRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['AccessPolicyRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['AccessPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['AccessPolicyRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['AccessPolicyRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['AccessPolicyRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['AccessPolicyRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['AccessPolicyRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['AccessPolicyRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['AccessPolicyRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['AccessPolicyRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['AccessPolicyRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['AccessPolicyRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['AccessPolicyRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['AccessPolicyRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['AccessPolicyRequireLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['AccessPolicyRequireLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['AccessPolicyRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['AccessPolicyRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['AccessPolicyRequireOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['AccessPolicyRequireOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['AccessPolicyRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['AccessPolicyRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['AccessPolicyRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['AccessPolicyRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['AccessPolicyRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['AccessPolicyRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class AccessPolicyRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    AccessPolicyRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class AccessPolicyRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    AccessPolicyRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    AccessPolicyRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class AccessPolicyRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    AccessPolicyRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class AccessPolicyRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    AccessPolicyRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class AccessPolicyRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    AccessPolicyRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AccessPolicyRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    AccessPolicyRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    AccessPolicyRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AccessPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    AccessPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class AccessPolicyRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    AccessPolicyRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class AccessPolicyRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    AccessPolicyRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class AccessPolicyRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    AccessPolicyRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    AccessPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    AccessPolicyRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class AccessPolicyRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    AccessPolicyRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyRequireLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    AccessPolicyRequireLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class AccessPolicyRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    AccessPolicyRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccessPolicyRequireOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    AccessPolicyRequireOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    AccessPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    AccessPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class AccessPolicyRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    AccessPolicyRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class AccessRuleConfigurationArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        Available values: "ip", "ip6", "ip_range", "asn", "country".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
elif False:
    AccessRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target: The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
               Available values: "ip", "ip6", "ip_range", "asn", "country".
        :param pulumi.Input[_builtins.str] value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
        Available values: "ip", "ip6", "ip_range", "asn", "country".
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AccessRuleScopeArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contact email address of the user.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines an identifier.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the scope of the rule.
        Available values: "user", "organization".
        """
elif False:
    AccessRuleScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleScopeArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: The contact email address of the user.
        :param pulumi.Input[_builtins.str] id: Defines an identifier.
        :param pulumi.Input[_builtins.str] type: Defines the scope of the rule.
               Available values: "user", "organization".
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines an identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the scope of the rule.
        Available values: "user", "organization".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AccountDnsSettingsZoneDefaultsArgsDict(TypedDict):
        flatten_all_cnames: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        """
        foundation_dns: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Foundation DNS Advanced Nameservers on the zone.
        """
        internal_dns: NotRequired[pulumi.Input['AccountDnsSettingsZoneDefaultsInternalDnsArgsDict']]
        """
        Settings for this internal zone.
        """
        multi_provider: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        """
        nameservers: NotRequired[pulumi.Input['AccountDnsSettingsZoneDefaultsNameserversArgsDict']]
        """
        Settings determining the nameservers through which the zone should be available.
        """
        ns_ttl: NotRequired[pulumi.Input[_builtins.float]]
        """
        The time to live (TTL) of the zone's nameserver (NS) records.
        """
        secondary_overrides: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        """
        soa: NotRequired[pulumi.Input['AccountDnsSettingsZoneDefaultsSoaArgsDict']]
        """
        Components of the zone's SOA record.
        """
        zone_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the zone mode is a regular or CDN/DNS only zone.
        Available values: "standard", "cdn*only", "dns*only".
        """
elif False:
    AccountDnsSettingsZoneDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountDnsSettingsZoneDefaultsArgs:
    def __init__(__self__, *,
                 flatten_all_cnames: Optional[pulumi.Input[_builtins.bool]] = None,
                 foundation_dns: Optional[pulumi.Input[_builtins.bool]] = None,
                 internal_dns: Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsInternalDnsArgs']] = None,
                 multi_provider: Optional[pulumi.Input[_builtins.bool]] = None,
                 nameservers: Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsNameserversArgs']] = None,
                 ns_ttl: Optional[pulumi.Input[_builtins.float]] = None,
                 secondary_overrides: Optional[pulumi.Input[_builtins.bool]] = None,
                 soa: Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsSoaArgs']] = None,
                 zone_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] flatten_all_cnames: Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        :param pulumi.Input[_builtins.bool] foundation_dns: Whether to enable Foundation DNS Advanced Nameservers on the zone.
        :param pulumi.Input['AccountDnsSettingsZoneDefaultsInternalDnsArgs'] internal_dns: Settings for this internal zone.
        :param pulumi.Input[_builtins.bool] multi_provider: Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        :param pulumi.Input['AccountDnsSettingsZoneDefaultsNameserversArgs'] nameservers: Settings determining the nameservers through which the zone should be available.
        :param pulumi.Input[_builtins.float] ns_ttl: The time to live (TTL) of the zone's nameserver (NS) records.
        :param pulumi.Input[_builtins.bool] secondary_overrides: Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        :param pulumi.Input['AccountDnsSettingsZoneDefaultsSoaArgs'] soa: Components of the zone's SOA record.
        :param pulumi.Input[_builtins.str] zone_mode: Whether the zone mode is a regular or CDN/DNS only zone.
               Available values: "standard", "cdn*only", "dns*only".
        """
        if flatten_all_cnames is not None:
            pulumi.set(__self__, "flatten_all_cnames", flatten_all_cnames)
        if foundation_dns is not None:
            pulumi.set(__self__, "foundation_dns", foundation_dns)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if multi_provider is not None:
            pulumi.set(__self__, "multi_provider", multi_provider)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if ns_ttl is not None:
            pulumi.set(__self__, "ns_ttl", ns_ttl)
        if secondary_overrides is not None:
            pulumi.set(__self__, "secondary_overrides", secondary_overrides)
        if soa is not None:
            pulumi.set(__self__, "soa", soa)
        if zone_mode is not None:
            pulumi.set(__self__, "zone_mode", zone_mode)

    @_builtins.property
    @pulumi.getter(name="flattenAllCnames")
    def flatten_all_cnames(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
        """
        return pulumi.get(self, "flatten_all_cnames")

    @flatten_all_cnames.setter
    def flatten_all_cnames(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flatten_all_cnames", value)

    @_builtins.property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Foundation DNS Advanced Nameservers on the zone.
        """
        return pulumi.get(self, "foundation_dns")

    @foundation_dns.setter
    def foundation_dns(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "foundation_dns", value)

    @_builtins.property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsInternalDnsArgs']]:
        """
        Settings for this internal zone.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsInternalDnsArgs']]):
        pulumi.set(self, "internal_dns", value)

    @_builtins.property
    @pulumi.getter(name="multiProvider")
    def multi_provider(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
        """
        return pulumi.get(self, "multi_provider")

    @multi_provider.setter
    def multi_provider(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_provider", value)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsNameserversArgs']]:
        """
        Settings determining the nameservers through which the zone should be available.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsNameserversArgs']]):
        pulumi.set(self, "nameservers", value)

    @_builtins.property
    @pulumi.getter(name="nsTtl")
    def ns_ttl(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The time to live (TTL) of the zone's nameserver (NS) records.
        """
        return pulumi.get(self, "ns_ttl")

    @ns_ttl.setter
    def ns_ttl(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ns_ttl", value)

    @_builtins.property
    @pulumi.getter(name="secondaryOverrides")
    def secondary_overrides(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
        """
        return pulumi.get(self, "secondary_overrides")

    @secondary_overrides.setter
    def secondary_overrides(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "secondary_overrides", value)

    @_builtins.property
    @pulumi.getter
    def soa(self) -> Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsSoaArgs']]:
        """
        Components of the zone's SOA record.
        """
        return pulumi.get(self, "soa")

    @soa.setter
    def soa(self, value: Optional[pulumi.Input['AccountDnsSettingsZoneDefaultsSoaArgs']]):
        pulumi.set(self, "soa", value)

    @_builtins.property
    @pulumi.getter(name="zoneMode")
    def zone_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the zone mode is a regular or CDN/DNS only zone.
        Available values: "standard", "cdn*only", "dns*only".
        """
        return pulumi.get(self, "zone_mode")

    @zone_mode.setter
    def zone_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_mode", value)


if not MYPY:
    class AccountDnsSettingsZoneDefaultsInternalDnsArgsDict(TypedDict):
        reference_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the zone to fallback to.
        """
elif False:
    AccountDnsSettingsZoneDefaultsInternalDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountDnsSettingsZoneDefaultsInternalDnsArgs:
    def __init__(__self__, *,
                 reference_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] reference_zone_id: The ID of the zone to fallback to.
        """
        if reference_zone_id is not None:
            pulumi.set(__self__, "reference_zone_id", reference_zone_id)

    @_builtins.property
    @pulumi.getter(name="referenceZoneId")
    def reference_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the zone to fallback to.
        """
        return pulumi.get(self, "reference_zone_id")

    @reference_zone_id.setter
    def reference_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reference_zone_id", value)


if not MYPY:
    class AccountDnsSettingsZoneDefaultsNameserversArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Nameserver type
        Available values: "cloudflare.standard", "cloudflare.standard.random", "custom.account", "custom.tenant".
        """
elif False:
    AccountDnsSettingsZoneDefaultsNameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountDnsSettingsZoneDefaultsNameserversArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Nameserver type
               Available values: "cloudflare.standard", "cloudflare.standard.random", "custom.account", "custom.tenant".
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Nameserver type
        Available values: "cloudflare.standard", "cloudflare.standard.random", "custom.account", "custom.tenant".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AccountDnsSettingsZoneDefaultsSoaArgsDict(TypedDict):
        expire: pulumi.Input[_builtins.float]
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        min_ttl: pulumi.Input[_builtins.float]
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        mname: pulumi.Input[_builtins.str]
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        refresh: pulumi.Input[_builtins.float]
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        retry: pulumi.Input[_builtins.float]
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        rname: pulumi.Input[_builtins.str]
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        ttl: pulumi.Input[_builtins.float]
        """
        The time to live (TTL) of the SOA record itself.
        """
elif False:
    AccountDnsSettingsZoneDefaultsSoaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountDnsSettingsZoneDefaultsSoaArgs:
    def __init__(__self__, *,
                 expire: pulumi.Input[_builtins.float],
                 min_ttl: pulumi.Input[_builtins.float],
                 mname: pulumi.Input[_builtins.str],
                 refresh: pulumi.Input[_builtins.float],
                 retry: pulumi.Input[_builtins.float],
                 rname: pulumi.Input[_builtins.str],
                 ttl: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] expire: Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        :param pulumi.Input[_builtins.float] min_ttl: The time to live (TTL) for negative caching of records within the zone.
        :param pulumi.Input[_builtins.str] mname: The primary nameserver, which may be used for outbound zone transfers.
        :param pulumi.Input[_builtins.float] refresh: Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        :param pulumi.Input[_builtins.float] retry: Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        :param pulumi.Input[_builtins.str] rname: The email address of the zone administrator, with the first label representing the local part of the email address.
        :param pulumi.Input[_builtins.float] ttl: The time to live (TTL) of the SOA record itself.
        """
        pulumi.set(__self__, "expire", expire)
        pulumi.set(__self__, "min_ttl", min_ttl)
        pulumi.set(__self__, "mname", mname)
        pulumi.set(__self__, "refresh", refresh)
        pulumi.set(__self__, "retry", retry)
        pulumi.set(__self__, "rname", rname)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def expire(self) -> pulumi.Input[_builtins.float]:
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "expire", value)

    @_builtins.property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> pulumi.Input[_builtins.float]:
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        return pulumi.get(self, "min_ttl")

    @min_ttl.setter
    def min_ttl(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "min_ttl", value)

    @_builtins.property
    @pulumi.getter
    def mname(self) -> pulumi.Input[_builtins.str]:
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        return pulumi.get(self, "mname")

    @mname.setter
    def mname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mname", value)

    @_builtins.property
    @pulumi.getter
    def refresh(self) -> pulumi.Input[_builtins.float]:
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        return pulumi.get(self, "refresh")

    @refresh.setter
    def refresh(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "refresh", value)

    @_builtins.property
    @pulumi.getter
    def retry(self) -> pulumi.Input[_builtins.float]:
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "retry", value)

    @_builtins.property
    @pulumi.getter
    def rname(self) -> pulumi.Input[_builtins.str]:
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        return pulumi.get(self, "rname")

    @rname.setter
    def rname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rname", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.float]:
        """
        The time to live (TTL) of the SOA record itself.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class AccountMemberPolicyArgsDict(TypedDict):
        access: pulumi.Input[_builtins.str]
        """
        Allow or deny operations against the resources.
        Available values: "allow", "deny".
        """
        permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgsDict']]]
        """
        A set of permission groups that are specified to the policy.
        """
        resource_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgsDict']]]
        """
        A list of resource groups that the policy applies to.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Policy identifier.
        """
elif False:
    AccountMemberPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberPolicyArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[_builtins.str],
                 permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]],
                 resource_groups: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access: Allow or deny operations against the resources.
               Available values: "allow", "deny".
        :param pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]] permission_groups: A set of permission groups that are specified to the policy.
        :param pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]] resource_groups: A list of resource groups that the policy applies to.
        :param pulumi.Input[_builtins.str] id: Policy identifier.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resource_groups", resource_groups)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def access(self) -> pulumi.Input[_builtins.str]:
        """
        Allow or deny operations against the resources.
        Available values: "allow", "deny".
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]]:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyPermissionGroupArgs']]]):
        pulumi.set(self, "permission_groups", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]]:
        """
        A list of resource groups that the policy applies to.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: pulumi.Input[Sequence[pulumi.Input['AccountMemberPolicyResourceGroupArgs']]]):
        pulumi.set(self, "resource_groups", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountMemberPolicyPermissionGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Identifier of the group.
        """
elif False:
    AccountMemberPolicyPermissionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberPolicyPermissionGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Identifier of the group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountMemberPolicyResourceGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Identifier of the group.
        """
elif False:
    AccountMemberPolicyResourceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberPolicyResourceGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Identifier of the group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountMemberUserArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contact email address of the user.
        """
        first_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        User's first name
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
        last_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        User's last name
        """
        two_factor_authentication_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
elif False:
    AccountMemberUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountMemberUserArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 first_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 last_name: Optional[pulumi.Input[_builtins.str]] = None,
                 two_factor_authentication_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] email: The contact email address of the user.
        :param pulumi.Input[_builtins.str] first_name: User's first name
        :param pulumi.Input[_builtins.str] id: Identifier
        :param pulumi.Input[_builtins.str] last_name: User's last name
        :param pulumi.Input[_builtins.bool] two_factor_authentication_enabled: Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if two_factor_authentication_enabled is not None:
            pulumi.set(__self__, "two_factor_authentication_enabled", two_factor_authentication_enabled)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contact email address of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User's first name
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User's last name
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter(name="twoFactorAuthenticationEnabled")
    def two_factor_authentication_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
        """
        return pulumi.get(self, "two_factor_authentication_enabled")

    @two_factor_authentication_enabled.setter
    def two_factor_authentication_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "two_factor_authentication_enabled", value)


if not MYPY:
    class AccountSettingsArgsDict(TypedDict):
        abuse_contact_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        enforce_twofactor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
elif False:
    AccountSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountSettingsArgs:
    def __init__(__self__, *,
                 abuse_contact_email: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_twofactor: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] abuse_contact_email: Sets an abuse contact email to notify for abuse reports.
        :param pulumi.Input[_builtins.bool] enforce_twofactor: Indicates whether membership in this account requires that
               Two-Factor Authentication is enabled
        """
        if abuse_contact_email is not None:
            pulumi.set(__self__, "abuse_contact_email", abuse_contact_email)
        if enforce_twofactor is not None:
            pulumi.set(__self__, "enforce_twofactor", enforce_twofactor)

    @_builtins.property
    @pulumi.getter(name="abuseContactEmail")
    def abuse_contact_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets an abuse contact email to notify for abuse reports.
        """
        return pulumi.get(self, "abuse_contact_email")

    @abuse_contact_email.setter
    def abuse_contact_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "abuse_contact_email", value)

    @_builtins.property
    @pulumi.getter(name="enforceTwofactor")
    def enforce_twofactor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether membership in this account requires that
        Two-Factor Authentication is enabled
        """
        return pulumi.get(self, "enforce_twofactor")

    @enforce_twofactor.setter
    def enforce_twofactor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_twofactor", value)


if not MYPY:
    class AccountSubscriptionRatePlanArgsDict(TypedDict):
        currency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The currency applied to the rate plan subscription.
        """
        externally_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the rate plan.
        Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partners_enterprise".
        """
        is_contract: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        public_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the rate plan.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope that this rate plan applies to.
        """
        sets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of sets this rate plan applies to.
        """
elif False:
    AccountSubscriptionRatePlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountSubscriptionRatePlanArgs:
    def __init__(__self__, *,
                 currency: Optional[pulumi.Input[_builtins.str]] = None,
                 externally_managed: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_contract: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_name: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 sets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] currency: The currency applied to the rate plan subscription.
        :param pulumi.Input[_builtins.bool] externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param pulumi.Input[_builtins.str] id: The ID of the rate plan.
               Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partners_enterprise".
        :param pulumi.Input[_builtins.bool] is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param pulumi.Input[_builtins.str] public_name: The full name of the rate plan.
        :param pulumi.Input[_builtins.str] scope: The scope that this rate plan applies to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sets: The list of sets this rate plan applies to.
        """
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_contract is not None:
            pulumi.set(__self__, "is_contract", is_contract)
        if public_name is not None:
            pulumi.set(__self__, "public_name", public_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @externally_managed.setter
    def externally_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "externally_managed", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the rate plan.
        Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partners_enterprise".
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @is_contract.setter
    def is_contract(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_contract", value)

    @_builtins.property
    @pulumi.getter(name="publicName")
    def public_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @public_name.setter
    def public_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_name", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")

    @sets.setter
    def sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sets", value)


if not MYPY:
    class AccountTokenConditionArgsDict(TypedDict):
        request_ip: NotRequired[pulumi.Input['AccountTokenConditionRequestIpArgsDict']]
        """
        Client IP restrictions.
        """
elif False:
    AccountTokenConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenConditionArgs:
    def __init__(__self__, *,
                 request_ip: Optional[pulumi.Input['AccountTokenConditionRequestIpArgs']] = None):
        """
        :param pulumi.Input['AccountTokenConditionRequestIpArgs'] request_ip: Client IP restrictions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @_builtins.property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input['AccountTokenConditionRequestIpArgs']]:
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input['AccountTokenConditionRequestIpArgs']]):
        pulumi.set(self, "request_ip", value)


if not MYPY:
    class AccountTokenConditionRequestIpArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
elif False:
    AccountTokenConditionRequestIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenConditionRequestIpArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ins: List of IPv4/IPv6 CIDR addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @_builtins.property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ins", value)

    @_builtins.property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class AccountTokenPolicyArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Allow or deny operations against the resources.
        Available values: "allow", "deny".
        """
        permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgsDict']]]
        """
        A set of permission groups that are specified to the policy.
        """
        resources: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        A list of resource names that the policy applies to.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Policy identifier.
        """
elif False:
    AccountTokenPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenPolicyArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 permission_groups: pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]],
                 resources: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Allow or deny operations against the resources.
               Available values: "allow", "deny".
        :param pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]] permission_groups: A set of permission groups that are specified to the policy.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] resources: A list of resource names that the policy applies to.
        :param pulumi.Input[_builtins.str] id: Policy identifier.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Allow or deny operations against the resources.
        Available values: "allow", "deny".
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]]:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input['AccountTokenPolicyPermissionGroupArgs']]]):
        pulumi.set(self, "permission_groups", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AccountTokenPolicyPermissionGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Identifier of the permission group.
        """
        meta: NotRequired[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgsDict']]
        """
        Attributes associated to the permission group.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the permission group.
        """
elif False:
    AccountTokenPolicyPermissionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenPolicyPermissionGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 meta: Optional[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier of the permission group.
        :param pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs'] meta: Attributes associated to the permission group.
        :param pulumi.Input[_builtins.str] name: Name of the permission group.
        """
        pulumi.set(__self__, "id", id)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the permission group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Optional[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs']]:
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @meta.setter
    def meta(self, value: Optional[pulumi.Input['AccountTokenPolicyPermissionGroupMetaArgs']]):
        pulumi.set(self, "meta", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the permission group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccountTokenPolicyPermissionGroupMetaArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AccountTokenPolicyPermissionGroupMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountTokenPolicyPermissionGroupMetaArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AccountUnitArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tenant unit ID
        """
elif False:
    AccountUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountUnitArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Tenant unit ID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tenant unit ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AddressMapMembershipArgsDict(TypedDict):
        can_delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Controls whether the membership can be deleted via the API or not.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier for the membership (eg. a zone or account tag).
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the membership.
        Available values: "zone", "account".
        """
elif False:
    AddressMapMembershipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressMapMembershipArgs:
    def __init__(__self__, *,
                 can_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] can_delete: Controls whether the membership can be deleted via the API or not.
        :param pulumi.Input[_builtins.str] identifier: The identifier for the membership (eg. a zone or account tag).
        :param pulumi.Input[_builtins.str] kind: The type of the membership.
               Available values: "zone", "account".
        """
        if can_delete is not None:
            pulumi.set(__self__, "can_delete", can_delete)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Controls whether the membership can be deleted via the API or not.
        """
        return pulumi.get(self, "can_delete")

    @can_delete.setter
    def can_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_delete", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier for the membership (eg. a zone or account tag).
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identifier", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the membership.
        Available values: "zone", "account".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class ApiShieldAuthIdCharacteristicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the characteristic field, i.e., the header or cookie name.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of characteristic.
        Available values: "header", "cookie", "jwt".
        """
elif False:
    ApiShieldAuthIdCharacteristicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldAuthIdCharacteristicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the characteristic field, i.e., the header or cookie name.
        :param pulumi.Input[_builtins.str] type: The type of characteristic.
               Available values: "header", "cookie", "jwt".
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the characteristic field, i.e., the header or cookie name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of characteristic.
        Available values: "header", "cookie", "jwt".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiShieldErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        documentation_url: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input['ApiShieldErrorSourceArgsDict']]
elif False:
    ApiShieldErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 documentation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ApiShieldErrorSourceArgs']] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "documentation_url")

    @documentation_url.setter
    def documentation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "documentation_url", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ApiShieldErrorSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ApiShieldErrorSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ApiShieldErrorSourceArgsDict(TypedDict):
        pointer: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApiShieldErrorSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldErrorSourceArgs:
    def __init__(__self__, *,
                 pointer: Optional[pulumi.Input[_builtins.str]] = None):
        if pointer is not None:
            pulumi.set(__self__, "pointer", pointer)

    @_builtins.property
    @pulumi.getter
    def pointer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "pointer")

    @pointer.setter
    def pointer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pointer", value)


if not MYPY:
    class ApiShieldMessageArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        documentation_url: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input['ApiShieldMessageSourceArgsDict']]
elif False:
    ApiShieldMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldMessageArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 documentation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ApiShieldMessageSourceArgs']] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "documentation_url")

    @documentation_url.setter
    def documentation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "documentation_url", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ApiShieldMessageSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ApiShieldMessageSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ApiShieldMessageSourceArgsDict(TypedDict):
        pointer: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApiShieldMessageSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldMessageSourceArgs:
    def __init__(__self__, *,
                 pointer: Optional[pulumi.Input[_builtins.str]] = None):
        if pointer is not None:
            pulumi.set(__self__, "pointer", pointer)

    @_builtins.property
    @pulumi.getter
    def pointer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "pointer")

    @pointer.setter
    def pointer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pointer", value)


if not MYPY:
    class ApiShieldOperationFeaturesArgsDict(TypedDict):
        api_routing: NotRequired[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgsDict']]
        """
        API Routing settings on endpoint.
        """
        confidence_intervals: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgsDict']]
        parameter_schemas: NotRequired[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgsDict']]
        schema_info: NotRequired[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgsDict']]
        thresholds: NotRequired[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgsDict']]
elif False:
    ApiShieldOperationFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesArgs:
    def __init__(__self__, *,
                 api_routing: Optional[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs']] = None,
                 confidence_intervals: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgs']] = None,
                 parameter_schemas: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgs']] = None,
                 schema_info: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgs']] = None,
                 thresholds: Optional[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgs']] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs'] api_routing: API Routing settings on endpoint.
        """
        if api_routing is not None:
            pulumi.set(__self__, "api_routing", api_routing)
        if confidence_intervals is not None:
            pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        if parameter_schemas is not None:
            pulumi.set(__self__, "parameter_schemas", parameter_schemas)
        if schema_info is not None:
            pulumi.set(__self__, "schema_info", schema_info)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="apiRouting")
    def api_routing(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs']]:
        """
        API Routing settings on endpoint.
        """
        return pulumi.get(self, "api_routing")

    @api_routing.setter
    def api_routing(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesApiRoutingArgs']]):
        pulumi.set(self, "api_routing", value)

    @_builtins.property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgs']]:
        return pulumi.get(self, "confidence_intervals")

    @confidence_intervals.setter
    def confidence_intervals(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsArgs']]):
        pulumi.set(self, "confidence_intervals", value)

    @_builtins.property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgs']]:
        return pulumi.get(self, "parameter_schemas")

    @parameter_schemas.setter
    def parameter_schemas(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasArgs']]):
        pulumi.set(self, "parameter_schemas", value)

    @_builtins.property
    @pulumi.getter(name="schemaInfo")
    def schema_info(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgs']]:
        return pulumi.get(self, "schema_info")

    @schema_info.setter
    def schema_info(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoArgs']]):
        pulumi.set(self, "schema_info", value)

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgs']]:
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesThresholdsArgs']]):
        pulumi.set(self, "thresholds", value)


if not MYPY:
    class ApiShieldOperationFeaturesApiRoutingArgsDict(TypedDict):
        last_updated: NotRequired[pulumi.Input[_builtins.str]]
        route: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target route.
        """
elif False:
    ApiShieldOperationFeaturesApiRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesApiRoutingArgs:
    def __init__(__self__, *,
                 last_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 route: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] route: Target route.
        """
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated", value)

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target route.
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsArgsDict(TypedDict):
        last_updated: NotRequired[pulumi.Input[_builtins.str]]
        suggested_threshold: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict']]
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsArgs:
    def __init__(__self__, *,
                 last_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 suggested_threshold: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs']] = None):
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if suggested_threshold is not None:
            pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @_builtins.property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated", value)

    @_builtins.property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs']]:
        return pulumi.get(self, "suggested_threshold")

    @suggested_threshold.setter
    def suggested_threshold(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs']]):
        pulumi.set(self, "suggested_threshold", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict(TypedDict):
        confidence_intervals: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict']]
        mean: NotRequired[pulumi.Input[_builtins.float]]
        """
        Suggested threshold.
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdArgs:
    def __init__(__self__, *,
                 confidence_intervals: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs']] = None,
                 mean: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] mean: Suggested threshold.
        """
        if confidence_intervals is not None:
            pulumi.set(__self__, "confidence_intervals", confidence_intervals)
        if mean is not None:
            pulumi.set(__self__, "mean", mean)

    @_builtins.property
    @pulumi.getter(name="confidenceIntervals")
    def confidence_intervals(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs']]:
        return pulumi.get(self, "confidence_intervals")

    @confidence_intervals.setter
    def confidence_intervals(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs']]):
        pulumi.set(self, "confidence_intervals", value)

    @_builtins.property
    @pulumi.getter
    def mean(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Suggested threshold.
        """
        return pulumi.get(self, "mean")

    @mean.setter
    def mean(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "mean", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict(TypedDict):
        p90: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict']]
        """
        Upper and lower bound for percentile estimate
        """
        p95: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict']]
        """
        Upper and lower bound for percentile estimate
        """
        p99: NotRequired[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict']]
        """
        Upper and lower bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsArgs:
    def __init__(__self__, *,
                 p90: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args']] = None,
                 p95: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args']] = None,
                 p99: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args']] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args'] p90: Upper and lower bound for percentile estimate
        :param pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args'] p95: Upper and lower bound for percentile estimate
        :param pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args'] p99: Upper and lower bound for percentile estimate
        """
        if p90 is not None:
            pulumi.set(__self__, "p90", p90)
        if p95 is not None:
            pulumi.set(__self__, "p95", p95)
        if p99 is not None:
            pulumi.set(__self__, "p99", p99)

    @_builtins.property
    @pulumi.getter
    def p90(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args']]:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p90")

    @p90.setter
    def p90(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args']]):
        pulumi.set(self, "p90", value)

    @_builtins.property
    @pulumi.getter
    def p95(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args']]:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p95")

    @p95.setter
    def p95(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args']]):
        pulumi.set(self, "p95", value)

    @_builtins.property
    @pulumi.getter
    def p99(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args']]:
        """
        Upper and lower bound for percentile estimate
        """
        return pulumi.get(self, "p99")

    @p99.setter
    def p99(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args']]):
        pulumi.set(self, "p99", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[_builtins.float]]
        """
        Lower bound for percentile estimate
        """
        upper: NotRequired[pulumi.Input[_builtins.float]]
        """
        Upper bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP90Args:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[_builtins.float]] = None,
                 upper: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lower: Lower bound for percentile estimate
        :param pulumi.Input[_builtins.float] upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @_builtins.property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lower", value)

    @_builtins.property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[_builtins.float]]
        """
        Lower bound for percentile estimate
        """
        upper: NotRequired[pulumi.Input[_builtins.float]]
        """
        Upper bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP95Args:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[_builtins.float]] = None,
                 upper: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lower: Lower bound for percentile estimate
        :param pulumi.Input[_builtins.float] upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @_builtins.property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lower", value)

    @_builtins.property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict(TypedDict):
        lower: NotRequired[pulumi.Input[_builtins.float]]
        """
        Lower bound for percentile estimate
        """
        upper: NotRequired[pulumi.Input[_builtins.float]]
        """
        Upper bound for percentile estimate
        """
elif False:
    ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesConfidenceIntervalsSuggestedThresholdConfidenceIntervalsP99Args:
    def __init__(__self__, *,
                 lower: Optional[pulumi.Input[_builtins.float]] = None,
                 upper: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] lower: Lower bound for percentile estimate
        :param pulumi.Input[_builtins.float] upper: Upper bound for percentile estimate
        """
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)

    @_builtins.property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Lower bound for percentile estimate
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lower", value)

    @_builtins.property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Upper bound for percentile estimate
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "upper", value)


if not MYPY:
    class ApiShieldOperationFeaturesParameterSchemasArgsDict(TypedDict):
        last_updated: NotRequired[pulumi.Input[_builtins.str]]
        parameter_schemas: NotRequired[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict']]
        """
        An operation schema object containing a response.
        """
elif False:
    ApiShieldOperationFeaturesParameterSchemasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesParameterSchemasArgs:
    def __init__(__self__, *,
                 last_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 parameter_schemas: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs']] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs'] parameter_schemas: An operation schema object containing a response.
        """
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if parameter_schemas is not None:
            pulumi.set(__self__, "parameter_schemas", parameter_schemas)

    @_builtins.property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated", value)

    @_builtins.property
    @pulumi.getter(name="parameterSchemas")
    def parameter_schemas(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs']]:
        """
        An operation schema object containing a response.
        """
        return pulumi.get(self, "parameter_schemas")

    @parameter_schemas.setter
    def parameter_schemas(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs']]):
        pulumi.set(self, "parameter_schemas", value)


if not MYPY:
    class ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the learned parameter schemas.
        """
        responses: NotRequired[pulumi.Input[_builtins.str]]
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
elif False:
    ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesParameterSchemasParameterSchemasArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 responses: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] parameters: An array containing the learned parameter schemas.
        :param pulumi.Input[_builtins.str] responses: An empty response object. This field is required to yield a valid operation schema.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the learned parameter schemas.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An empty response object. This field is required to yield a valid operation schema.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class ApiShieldOperationFeaturesSchemaInfoArgsDict(TypedDict):
        active_schema: NotRequired[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict']]
        """
        Schema active on endpoint.
        """
        learned_available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        mitigation_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action taken on requests failing validation.
        Available values: "none", "log", "block".
        """
elif False:
    ApiShieldOperationFeaturesSchemaInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesSchemaInfoArgs:
    def __init__(__self__, *,
                 active_schema: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs']] = None,
                 learned_available: Optional[pulumi.Input[_builtins.bool]] = None,
                 mitigation_action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs'] active_schema: Schema active on endpoint.
        :param pulumi.Input[_builtins.bool] learned_available: True if a Cloudflare-provided learned schema is available for this endpoint.
        :param pulumi.Input[_builtins.str] mitigation_action: Action taken on requests failing validation.
               Available values: "none", "log", "block".
        """
        if active_schema is not None:
            pulumi.set(__self__, "active_schema", active_schema)
        if learned_available is not None:
            pulumi.set(__self__, "learned_available", learned_available)
        if mitigation_action is not None:
            pulumi.set(__self__, "mitigation_action", mitigation_action)

    @_builtins.property
    @pulumi.getter(name="activeSchema")
    def active_schema(self) -> Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs']]:
        """
        Schema active on endpoint.
        """
        return pulumi.get(self, "active_schema")

    @active_schema.setter
    def active_schema(self, value: Optional[pulumi.Input['ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs']]):
        pulumi.set(self, "active_schema", value)

    @_builtins.property
    @pulumi.getter(name="learnedAvailable")
    def learned_available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if a Cloudflare-provided learned schema is available for this endpoint.
        """
        return pulumi.get(self, "learned_available")

    @learned_available.setter
    def learned_available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "learned_available", value)

    @_builtins.property
    @pulumi.getter(name="mitigationAction")
    def mitigation_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action taken on requests failing validation.
        Available values: "none", "log", "block".
        """
        return pulumi.get(self, "mitigation_action")

    @mitigation_action.setter
    def mitigation_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mitigation_action", value)


if not MYPY:
    class ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID.
        """
        is_learned: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if schema is Cloudflare-provided.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema file name.
        """
elif False:
    ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesSchemaInfoActiveSchemaArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_learned: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: UUID.
        :param pulumi.Input[_builtins.bool] is_learned: True if schema is Cloudflare-provided.
        :param pulumi.Input[_builtins.str] name: Schema file name.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_learned is not None:
            pulumi.set(__self__, "is_learned", is_learned)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isLearned")
    def is_learned(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if schema is Cloudflare-provided.
        """
        return pulumi.get(self, "is_learned")

    @is_learned.setter
    def is_learned(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_learned", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema file name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApiShieldOperationFeaturesThresholdsArgsDict(TypedDict):
        auth_id_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of auth-ids seen across this calculation.
        """
        data_points: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of data points used for the threshold suggestion calculation.
        """
        last_updated: NotRequired[pulumi.Input[_builtins.str]]
        p50: NotRequired[pulumi.Input[_builtins.int]]
        """
        The p50 quantile of requests (in period_seconds).
        """
        p90: NotRequired[pulumi.Input[_builtins.int]]
        """
        The p90 quantile of requests (in period_seconds).
        """
        p99: NotRequired[pulumi.Input[_builtins.int]]
        """
        The p99 quantile of requests (in period_seconds).
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The period over which this threshold is suggested.
        """
        requests: NotRequired[pulumi.Input[_builtins.int]]
        """
        The estimated number of requests covered by these calculations.
        """
        suggested_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
elif False:
    ApiShieldOperationFeaturesThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldOperationFeaturesThresholdsArgs:
    def __init__(__self__, *,
                 auth_id_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 data_points: Optional[pulumi.Input[_builtins.int]] = None,
                 last_updated: Optional[pulumi.Input[_builtins.str]] = None,
                 p50: Optional[pulumi.Input[_builtins.int]] = None,
                 p90: Optional[pulumi.Input[_builtins.int]] = None,
                 p99: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 requests: Optional[pulumi.Input[_builtins.int]] = None,
                 suggested_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] auth_id_tokens: The total number of auth-ids seen across this calculation.
        :param pulumi.Input[_builtins.int] data_points: The number of data points used for the threshold suggestion calculation.
        :param pulumi.Input[_builtins.int] p50: The p50 quantile of requests (in period_seconds).
        :param pulumi.Input[_builtins.int] p90: The p90 quantile of requests (in period_seconds).
        :param pulumi.Input[_builtins.int] p99: The p99 quantile of requests (in period_seconds).
        :param pulumi.Input[_builtins.int] period_seconds: The period over which this threshold is suggested.
        :param pulumi.Input[_builtins.int] requests: The estimated number of requests covered by these calculations.
        :param pulumi.Input[_builtins.int] suggested_threshold: The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        if auth_id_tokens is not None:
            pulumi.set(__self__, "auth_id_tokens", auth_id_tokens)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if p50 is not None:
            pulumi.set(__self__, "p50", p50)
        if p90 is not None:
            pulumi.set(__self__, "p90", p90)
        if p99 is not None:
            pulumi.set(__self__, "p99", p99)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if suggested_threshold is not None:
            pulumi.set(__self__, "suggested_threshold", suggested_threshold)

    @_builtins.property
    @pulumi.getter(name="authIdTokens")
    def auth_id_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of auth-ids seen across this calculation.
        """
        return pulumi.get(self, "auth_id_tokens")

    @auth_id_tokens.setter
    def auth_id_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "auth_id_tokens", value)

    @_builtins.property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of data points used for the threshold suggestion calculation.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_points", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated", value)

    @_builtins.property
    @pulumi.getter
    def p50(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The p50 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p50")

    @p50.setter
    def p50(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "p50", value)

    @_builtins.property
    @pulumi.getter
    def p90(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The p90 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p90")

    @p90.setter
    def p90(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "p90", value)

    @_builtins.property
    @pulumi.getter
    def p99(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The p99 quantile of requests (in period_seconds).
        """
        return pulumi.get(self, "p99")

    @p99.setter
    def p99(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "p99", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The period over which this threshold is suggested.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The estimated number of requests covered by these calculations.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "requests", value)

    @_builtins.property
    @pulumi.getter(name="suggestedThreshold")
    def suggested_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The suggested threshold in requests done by the same auth*id or period*seconds.
        """
        return pulumi.get(self, "suggested_threshold")

    @suggested_threshold.setter
    def suggested_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "suggested_threshold", value)


if not MYPY:
    class ApiShieldSchemaSchemaArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind of schema
        Available values: "openapi_v3".
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the schema
        """
        schema_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source of the schema
        """
        validation_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag whether schema is enabled for validation.
        """
elif False:
    ApiShieldSchemaSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldSchemaSchemaArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 validation_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: Kind of schema
               Available values: "openapi_v3".
        :param pulumi.Input[_builtins.str] name: Name of the schema
        :param pulumi.Input[_builtins.str] schema_id: UUID.
        :param pulumi.Input[_builtins.str] source: Source of the schema
        :param pulumi.Input[_builtins.bool] validation_enabled: Flag whether schema is enabled for validation.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if validation_enabled is not None:
            pulumi.set(__self__, "validation_enabled", validation_enabled)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind of schema
        Available values: "openapi_v3".
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the schema
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID.
        """
        return pulumi.get(self, "schema_id")

    @schema_id.setter
    def schema_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_id", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source of the schema
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="validationEnabled")
    def validation_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag whether schema is enabled for validation.
        """
        return pulumi.get(self, "validation_enabled")

    @validation_enabled.setter
    def validation_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "validation_enabled", value)


if not MYPY:
    class ApiShieldSchemaUploadDetailsArgsDict(TypedDict):
        warnings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgsDict']]]]
        """
        Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
elif False:
    ApiShieldSchemaUploadDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldSchemaUploadDetailsArgs:
    def __init__(__self__, *,
                 warnings: Optional[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]] warnings: Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @_builtins.property
    @pulumi.getter
    def warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]]]:
        """
        Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
        """
        return pulumi.get(self, "warnings")

    @warnings.setter
    def warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiShieldSchemaUploadDetailsWarningArgs']]]]):
        pulumi.set(self, "warnings", value)


if not MYPY:
    class ApiShieldSchemaUploadDetailsWarningArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Code that identifies the event that occurred.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Diagnostic message that describes the event.
        """
elif False:
    ApiShieldSchemaUploadDetailsWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiShieldSchemaUploadDetailsWarningArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] code: Code that identifies the event that occurred.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        :param pulumi.Input[_builtins.str] message: Diagnostic message that describes the event.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Code that identifies the event that occurred.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Diagnostic message that describes the event.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class ApiTokenConditionArgsDict(TypedDict):
        request_ip: NotRequired[pulumi.Input['ApiTokenConditionRequestIpArgsDict']]
        """
        Client IP restrictions.
        """
elif False:
    ApiTokenConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenConditionArgs:
    def __init__(__self__, *,
                 request_ip: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']] = None):
        """
        :param pulumi.Input['ApiTokenConditionRequestIpArgs'] request_ip: Client IP restrictions.
        """
        if request_ip is not None:
            pulumi.set(__self__, "request_ip", request_ip)

    @_builtins.property
    @pulumi.getter(name="requestIp")
    def request_ip(self) -> Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]:
        """
        Client IP restrictions.
        """
        return pulumi.get(self, "request_ip")

    @request_ip.setter
    def request_ip(self, value: Optional[pulumi.Input['ApiTokenConditionRequestIpArgs']]):
        pulumi.set(self, "request_ip", value)


if not MYPY:
    class ApiTokenConditionRequestIpArgsDict(TypedDict):
        ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        not_ins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IPv4/IPv6 CIDR addresses.
        """
elif False:
    ApiTokenConditionRequestIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenConditionRequestIpArgs:
    def __init__(__self__, *,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_ins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ins: List of IPv4/IPv6 CIDR addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_ins: List of IPv4/IPv6 CIDR addresses.
        """
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if not_ins is not None:
            pulumi.set(__self__, "not_ins", not_ins)

    @_builtins.property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ins", value)

    @_builtins.property
    @pulumi.getter(name="notIns")
    def not_ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IPv4/IPv6 CIDR addresses.
        """
        return pulumi.get(self, "not_ins")

    @not_ins.setter
    def not_ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_ins", value)


if not MYPY:
    class ApiTokenPolicyArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Allow or deny operations against the resources.
        Available values: "allow", "deny".
        """
        permission_groups: pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgsDict']]]
        """
        A set of permission groups that are specified to the policy.
        """
        resources: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        A list of resource names that the policy applies to.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Policy identifier.
        """
elif False:
    ApiTokenPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 permission_groups: pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]],
                 resources: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Allow or deny operations against the resources.
               Available values: "allow", "deny".
        :param pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]] permission_groups: A set of permission groups that are specified to the policy.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] resources: A list of resource names that the policy applies to.
        :param pulumi.Input[_builtins.str] id: Policy identifier.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "permission_groups", permission_groups)
        pulumi.set(__self__, "resources", resources)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Allow or deny operations against the resources.
        Available values: "allow", "deny".
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter(name="permissionGroups")
    def permission_groups(self) -> pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]]:
        """
        A set of permission groups that are specified to the policy.
        """
        return pulumi.get(self, "permission_groups")

    @permission_groups.setter
    def permission_groups(self, value: pulumi.Input[Sequence[pulumi.Input['ApiTokenPolicyPermissionGroupArgs']]]):
        pulumi.set(self, "permission_groups", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        A list of resource names that the policy applies to.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Policy identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ApiTokenPolicyPermissionGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Identifier of the permission group.
        """
        meta: NotRequired[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgsDict']]
        """
        Attributes associated to the permission group.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the permission group.
        """
elif False:
    ApiTokenPolicyPermissionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyPermissionGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 meta: Optional[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier of the permission group.
        :param pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs'] meta: Attributes associated to the permission group.
        :param pulumi.Input[_builtins.str] name: Name of the permission group.
        """
        pulumi.set(__self__, "id", id)
        if meta is not None:
            pulumi.set(__self__, "meta", meta)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the permission group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Optional[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs']]:
        """
        Attributes associated to the permission group.
        """
        return pulumi.get(self, "meta")

    @meta.setter
    def meta(self, value: Optional[pulumi.Input['ApiTokenPolicyPermissionGroupMetaArgs']]):
        pulumi.set(self, "meta", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the permission group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ApiTokenPolicyPermissionGroupMetaArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApiTokenPolicyPermissionGroupMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiTokenPolicyPermissionGroupMetaArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AuthenticatedOriginPullsConfigArgsDict(TypedDict):
        cert_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate identifier tag.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname on the origin for which the client certificate uploaded will be used.
        """
elif False:
    AuthenticatedOriginPullsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticatedOriginPullsConfigArgs:
    def __init__(__self__, *,
                 cert_id: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert_id: Certificate identifier tag.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        :param pulumi.Input[_builtins.str] hostname: The hostname on the origin for which the client certificate uploaded will be used.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate identifier tag.
        """
        return pulumi.get(self, "cert_id")

    @cert_id.setter
    def cert_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_id", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname on the origin for which the client certificate uploaded will be used.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class BotManagementStaleZoneConfigurationArgsDict(TypedDict):
        fight_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the zone's Bot Fight Mode is turned on.
        """
        optimize_wordpress: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the zone's wordpress optimization for SBFM is turned on.
        """
        sbfm_definitely_automated: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates that the zone's definitely automated requests are being blocked or challenged.
        """
        sbfm_likely_automated: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates that the zone's likely automated requests are being blocked or challenged.
        """
        sbfm_static_resource_protection: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates that the zone's static resource protection is turned on.
        """
        sbfm_verified_bots: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates that the zone's verified bot requests are being blocked.
        """
        suppress_session_score: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the zone's session score tracking is disabled.
        """
elif False:
    BotManagementStaleZoneConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotManagementStaleZoneConfigurationArgs:
    def __init__(__self__, *,
                 fight_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 optimize_wordpress: Optional[pulumi.Input[_builtins.bool]] = None,
                 sbfm_definitely_automated: Optional[pulumi.Input[_builtins.str]] = None,
                 sbfm_likely_automated: Optional[pulumi.Input[_builtins.str]] = None,
                 sbfm_static_resource_protection: Optional[pulumi.Input[_builtins.str]] = None,
                 sbfm_verified_bots: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_session_score: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] fight_mode: Indicates that the zone's Bot Fight Mode is turned on.
        :param pulumi.Input[_builtins.bool] optimize_wordpress: Indicates that the zone's wordpress optimization for SBFM is turned on.
        :param pulumi.Input[_builtins.str] sbfm_definitely_automated: Indicates that the zone's definitely automated requests are being blocked or challenged.
        :param pulumi.Input[_builtins.str] sbfm_likely_automated: Indicates that the zone's likely automated requests are being blocked or challenged.
        :param pulumi.Input[_builtins.str] sbfm_static_resource_protection: Indicates that the zone's static resource protection is turned on.
        :param pulumi.Input[_builtins.str] sbfm_verified_bots: Indicates that the zone's verified bot requests are being blocked.
        :param pulumi.Input[_builtins.bool] suppress_session_score: Indicates that the zone's session score tracking is disabled.
        """
        if fight_mode is not None:
            pulumi.set(__self__, "fight_mode", fight_mode)
        if optimize_wordpress is not None:
            pulumi.set(__self__, "optimize_wordpress", optimize_wordpress)
        if sbfm_definitely_automated is not None:
            pulumi.set(__self__, "sbfm_definitely_automated", sbfm_definitely_automated)
        if sbfm_likely_automated is not None:
            pulumi.set(__self__, "sbfm_likely_automated", sbfm_likely_automated)
        if sbfm_static_resource_protection is not None:
            pulumi.set(__self__, "sbfm_static_resource_protection", sbfm_static_resource_protection)
        if sbfm_verified_bots is not None:
            pulumi.set(__self__, "sbfm_verified_bots", sbfm_verified_bots)
        if suppress_session_score is not None:
            pulumi.set(__self__, "suppress_session_score", suppress_session_score)

    @_builtins.property
    @pulumi.getter(name="fightMode")
    def fight_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the zone's Bot Fight Mode is turned on.
        """
        return pulumi.get(self, "fight_mode")

    @fight_mode.setter
    def fight_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fight_mode", value)

    @_builtins.property
    @pulumi.getter(name="optimizeWordpress")
    def optimize_wordpress(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the zone's wordpress optimization for SBFM is turned on.
        """
        return pulumi.get(self, "optimize_wordpress")

    @optimize_wordpress.setter
    def optimize_wordpress(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optimize_wordpress", value)

    @_builtins.property
    @pulumi.getter(name="sbfmDefinitelyAutomated")
    def sbfm_definitely_automated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates that the zone's definitely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_definitely_automated")

    @sbfm_definitely_automated.setter
    def sbfm_definitely_automated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sbfm_definitely_automated", value)

    @_builtins.property
    @pulumi.getter(name="sbfmLikelyAutomated")
    def sbfm_likely_automated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates that the zone's likely automated requests are being blocked or challenged.
        """
        return pulumi.get(self, "sbfm_likely_automated")

    @sbfm_likely_automated.setter
    def sbfm_likely_automated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sbfm_likely_automated", value)

    @_builtins.property
    @pulumi.getter(name="sbfmStaticResourceProtection")
    def sbfm_static_resource_protection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates that the zone's static resource protection is turned on.
        """
        return pulumi.get(self, "sbfm_static_resource_protection")

    @sbfm_static_resource_protection.setter
    def sbfm_static_resource_protection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sbfm_static_resource_protection", value)

    @_builtins.property
    @pulumi.getter(name="sbfmVerifiedBots")
    def sbfm_verified_bots(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates that the zone's verified bot requests are being blocked.
        """
        return pulumi.get(self, "sbfm_verified_bots")

    @sbfm_verified_bots.setter
    def sbfm_verified_bots(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sbfm_verified_bots", value)

    @_builtins.property
    @pulumi.getter(name="suppressSessionScore")
    def suppress_session_score(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the zone's session score tracking is disabled.
        """
        return pulumi.get(self, "suppress_session_score")

    @suppress_session_score.setter
    def suppress_session_score(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suppress_session_score", value)


if not MYPY:
    class CertificatePackValidationErrorArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A domain validation error.
        """
elif False:
    CertificatePackValidationErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatePackValidationErrorArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message: A domain validation error.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A domain validation error.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class CertificatePackValidationRecordArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        """
        http_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        """
        http_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url that will be checked during domain validation.
        """
        txt_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        """
        txt_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The TXT record that the certificate authority (CA) will check during domain validation.
        """
elif False:
    CertificatePackValidationRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatePackValidationRecordArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_body: Optional[pulumi.Input[_builtins.str]] = None,
                 http_url: Optional[pulumi.Input[_builtins.str]] = None,
                 txt_name: Optional[pulumi.Input[_builtins.str]] = None,
                 txt_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        :param pulumi.Input[_builtins.str] http_body: The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        :param pulumi.Input[_builtins.str] http_url: The url that will be checked during domain validation.
        :param pulumi.Input[_builtins.str] txt_name: The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        :param pulumi.Input[_builtins.str] txt_value: The TXT record that the certificate authority (CA) will check during domain validation.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of email addresses that the certificate authority (CA) will use to complete domain validation.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
        """
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_body", value)

    @_builtins.property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url that will be checked during domain validation.
        """
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_url", value)

    @_builtins.property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
        """
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txt_name", value)

    @_builtins.property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The TXT record that the certificate authority (CA) will check during domain validation.
        """
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txt_value", value)


if not MYPY:
    class CloudConnectorRulesRuleArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        expression: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        parameters: NotRequired[pulumi.Input['CloudConnectorRulesRuleParametersArgsDict']]
        """
        Parameters of Cloud Connector Rule
        """
        provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud Provider type
        Available values: "aws*s3", "cloudflare*r2", "gcp*storage", "azure*storage".
        """
elif False:
    CloudConnectorRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']] = None,
                 provider: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CloudConnectorRulesRuleParametersArgs'] parameters: Parameters of Cloud Connector Rule
        :param pulumi.Input[_builtins.str] provider: Cloud Provider type
               Available values: "aws*s3", "cloudflare*r2", "gcp*storage", "azure*storage".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']]:
        """
        Parameters of Cloud Connector Rule
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['CloudConnectorRulesRuleParametersArgs']]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud Provider type
        Available values: "aws*s3", "cloudflare*r2", "gcp*storage", "azure*storage".
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider", value)


if not MYPY:
    class CloudConnectorRulesRuleParametersArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host to perform Cloud Connection to
        """
elif False:
    CloudConnectorRulesRuleParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudConnectorRulesRuleParametersArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: Host to perform Cloud Connection to
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host to perform Cloud Connection to
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ContentScanningExpressionBodyArgsDict(TypedDict):
        payload: pulumi.Input[_builtins.str]
        """
        Defines the ruleset expression to use in matching content objects.
        """
elif False:
    ContentScanningExpressionBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContentScanningExpressionBodyArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] payload: Defines the ruleset expression to use in matching content objects.
        """
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Input[_builtins.str]:
        """
        Defines the ruleset expression to use in matching content objects.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class CustomHostnameOwnershipVerificationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS Name for record.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS Record type.
        Available values: "txt".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content for the record.
        """
elif False:
    CustomHostnameOwnershipVerificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameOwnershipVerificationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: DNS Name for record.
        :param pulumi.Input[_builtins.str] type: DNS Record type.
               Available values: "txt".
        :param pulumi.Input[_builtins.str] value: Content for the record.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS Name for record.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS Record type.
        Available values: "txt".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content for the record.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomHostnameOwnershipVerificationHttpArgsDict(TypedDict):
        http_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Token to be served.
        """
        http_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
elif False:
    CustomHostnameOwnershipVerificationHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameOwnershipVerificationHttpArgs:
    def __init__(__self__, *,
                 http_body: Optional[pulumi.Input[_builtins.str]] = None,
                 http_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] http_body: Token to be served.
        :param pulumi.Input[_builtins.str] http_url: The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        if http_body is not None:
            pulumi.set(__self__, "http_body", http_body)
        if http_url is not None:
            pulumi.set(__self__, "http_url", http_url)

    @_builtins.property
    @pulumi.getter(name="httpBody")
    def http_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Token to be served.
        """
        return pulumi.get(self, "http_body")

    @http_body.setter
    def http_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_body", value)

    @_builtins.property
    @pulumi.getter(name="httpUrl")
    def http_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
        """
        return pulumi.get(self, "http_url")

    @http_url.setter
    def http_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_url", value)


if not MYPY:
    class CustomHostnameSslArgsDict(TypedDict):
        bundle_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        Available values: "ubiquitous", "optimal", "force".
        """
        certificate_authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Certificate Authority that will issue the certificate
        Available values: "digicert", "google", "lets*encrypt", "ssl*com".
        """
        cloudflare_branding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        """
        custom_cert_bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgsDict']]]]
        """
        Array of custom certificate and key pairs (1 or 2 pairs allowed)
        """
        custom_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        If a custom uploaded certificate is used.
        """
        custom_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key for a custom uploaded certificate.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain control validation (DCV) method used for this hostname.
        Available values: "http", "txt", "email".
        """
        settings: NotRequired[pulumi.Input['CustomHostnameSslSettingsArgsDict']]
        """
        SSL specific settings.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        Available values: "dv".
        """
        wildcard: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the certificate covers a wildcard.
        """
elif False:
    CustomHostnameSslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslArgs:
    def __init__(__self__, *,
                 bundle_method: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_authority: Optional[pulumi.Input[_builtins.str]] = None,
                 cloudflare_branding: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_cert_bundles: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]]] = None,
                 custom_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_key: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input['CustomHostnameSslSettingsArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bundle_method: A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
               Available values: "ubiquitous", "optimal", "force".
        :param pulumi.Input[_builtins.str] certificate_authority: The Certificate Authority that will issue the certificate
               Available values: "digicert", "google", "lets*encrypt", "ssl*com".
        :param pulumi.Input[_builtins.bool] cloudflare_branding: Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        :param pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]] custom_cert_bundles: Array of custom certificate and key pairs (1 or 2 pairs allowed)
        :param pulumi.Input[_builtins.str] custom_certificate: If a custom uploaded certificate is used.
        :param pulumi.Input[_builtins.str] custom_key: The key for a custom uploaded certificate.
        :param pulumi.Input[_builtins.str] method: Domain control validation (DCV) method used for this hostname.
               Available values: "http", "txt", "email".
        :param pulumi.Input['CustomHostnameSslSettingsArgs'] settings: SSL specific settings.
        :param pulumi.Input[_builtins.str] type: Level of validation to be used for this hostname. Domain validation (dv) must be used.
               Available values: "dv".
        :param pulumi.Input[_builtins.bool] wildcard: Indicates whether the certificate covers a wildcard.
        """
        if bundle_method is not None:
            pulumi.set(__self__, "bundle_method", bundle_method)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if cloudflare_branding is not None:
            pulumi.set(__self__, "cloudflare_branding", cloudflare_branding)
        if custom_cert_bundles is not None:
            pulumi.set(__self__, "custom_cert_bundles", custom_cert_bundles)
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)

    @_builtins.property
    @pulumi.getter(name="bundleMethod")
    def bundle_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
        Available values: "ubiquitous", "optimal", "force".
        """
        return pulumi.get(self, "bundle_method")

    @bundle_method.setter
    def bundle_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bundle_method", value)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Certificate Authority that will issue the certificate
        Available values: "digicert", "google", "lets*encrypt", "ssl*com".
        """
        return pulumi.get(self, "certificate_authority")

    @certificate_authority.setter
    def certificate_authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority", value)

    @_builtins.property
    @pulumi.getter(name="cloudflareBranding")
    def cloudflare_branding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
        """
        return pulumi.get(self, "cloudflare_branding")

    @cloudflare_branding.setter
    def cloudflare_branding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloudflare_branding", value)

    @_builtins.property
    @pulumi.getter(name="customCertBundles")
    def custom_cert_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]]]:
        """
        Array of custom certificate and key pairs (1 or 2 pairs allowed)
        """
        return pulumi.get(self, "custom_cert_bundles")

    @custom_cert_bundles.setter
    def custom_cert_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomHostnameSslCustomCertBundleArgs']]]]):
        pulumi.set(self, "custom_cert_bundles", value)

    @_builtins.property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_certificate", value)

    @_builtins.property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_key", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain control validation (DCV) method used for this hostname.
        Available values: "http", "txt", "email".
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['CustomHostnameSslSettingsArgs']]:
        """
        SSL specific settings.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['CustomHostnameSslSettingsArgs']]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Level of validation to be used for this hostname. Domain validation (dv) must be used.
        Available values: "dv".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the certificate covers a wildcard.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wildcard", value)


if not MYPY:
    class CustomHostnameSslCustomCertBundleArgsDict(TypedDict):
        custom_certificate: pulumi.Input[_builtins.str]
        """
        If a custom uploaded certificate is used.
        """
        custom_key: pulumi.Input[_builtins.str]
        """
        The key for a custom uploaded certificate.
        """
elif False:
    CustomHostnameSslCustomCertBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslCustomCertBundleArgs:
    def __init__(__self__, *,
                 custom_certificate: pulumi.Input[_builtins.str],
                 custom_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] custom_certificate: If a custom uploaded certificate is used.
        :param pulumi.Input[_builtins.str] custom_key: The key for a custom uploaded certificate.
        """
        pulumi.set(__self__, "custom_certificate", custom_certificate)
        pulumi.set(__self__, "custom_key", custom_key)

    @_builtins.property
    @pulumi.getter(name="customCertificate")
    def custom_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        If a custom uploaded certificate is used.
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "custom_certificate", value)

    @_builtins.property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> pulumi.Input[_builtins.str]:
        """
        The key for a custom uploaded certificate.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "custom_key", value)


if not MYPY:
    class CustomHostnameSslSettingsArgsDict(TypedDict):
        ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        early_hints: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether or not Early Hints is enabled.
        Available values: "on", "off".
        """
        http2: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether or not HTTP2 is enabled.
        Available values: "on", "off".
        """
        min_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The minimum TLS version supported.
        Available values: "1.0", "1.1", "1.2", "1.3".
        """
        tls13: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether or not TLS 1.3 is enabled.
        Available values: "on", "off".
        """
elif False:
    CustomHostnameSslSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomHostnameSslSettingsArgs:
    def __init__(__self__, *,
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 early_hints: Optional[pulumi.Input[_builtins.str]] = None,
                 http2: Optional[pulumi.Input[_builtins.str]] = None,
                 min_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 tls13: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ciphers: An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        :param pulumi.Input[_builtins.str] early_hints: Whether or not Early Hints is enabled.
               Available values: "on", "off".
        :param pulumi.Input[_builtins.str] http2: Whether or not HTTP2 is enabled.
               Available values: "on", "off".
        :param pulumi.Input[_builtins.str] min_tls_version: The minimum TLS version supported.
               Available values: "1.0", "1.1", "1.2", "1.3".
        :param pulumi.Input[_builtins.str] tls13: Whether or not TLS 1.3 is enabled.
               Available values: "on", "off".
        """
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if early_hints is not None:
            pulumi.set(__self__, "early_hints", early_hints)
        if http2 is not None:
            pulumi.set(__self__, "http2", http2)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if tls13 is not None:
            pulumi.set(__self__, "tls13", tls13)

    @_builtins.property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
        """
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ciphers", value)

    @_builtins.property
    @pulumi.getter(name="earlyHints")
    def early_hints(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether or not Early Hints is enabled.
        Available values: "on", "off".
        """
        return pulumi.get(self, "early_hints")

    @early_hints.setter
    def early_hints(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "early_hints", value)

    @_builtins.property
    @pulumi.getter
    def http2(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether or not HTTP2 is enabled.
        Available values: "on", "off".
        """
        return pulumi.get(self, "http2")

    @http2.setter
    def http2(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http2", value)

    @_builtins.property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The minimum TLS version supported.
        Available values: "1.0", "1.1", "1.2", "1.3".
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_tls_version", value)

    @_builtins.property
    @pulumi.getter
    def tls13(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether or not TLS 1.3 is enabled.
        Available values: "on", "off".
        """
        return pulumi.get(self, "tls13")

    @tls13.setter
    def tls13(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls13", value)


if not MYPY:
    class CustomSslGeoRestrictionsArgsDict(TypedDict):
        label: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "us", "eu", "highest_security".
        """
elif False:
    CustomSslGeoRestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslGeoRestrictionsArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] label: Available values: "us", "eu", "highest_security".
        """
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "us", "eu", "highest_security".
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class CustomSslKeylessServerArgsDict(TypedDict):
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the Keyless SSL was created.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not the Keyless SSL is on or off.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The keyless SSL name.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Keyless certificate identifier tag.
        """
        modified_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the Keyless SSL was last modified.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The keyless SSL name.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        port: NotRequired[pulumi.Input[_builtins.float]]
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the Keyless SSL.
        Available values: "active", "deleted".
        """
        tunnel: NotRequired[pulumi.Input['CustomSslKeylessServerTunnelArgsDict']]
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
elif False:
    CustomSslKeylessServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslKeylessServerArgs:
    def __init__(__self__, *,
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 modified_on: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 port: Optional[pulumi.Input[_builtins.float]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 tunnel: Optional[pulumi.Input['CustomSslKeylessServerTunnelArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] created_on: When the Keyless SSL was created.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not the Keyless SSL is on or off.
        :param pulumi.Input[_builtins.str] host: The keyless SSL name.
        :param pulumi.Input[_builtins.str] id: Keyless certificate identifier tag.
        :param pulumi.Input[_builtins.str] modified_on: When the Keyless SSL was last modified.
        :param pulumi.Input[_builtins.str] name: The keyless SSL name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: Available permissions for the Keyless SSL for the current user requesting the item.
        :param pulumi.Input[_builtins.float] port: The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        :param pulumi.Input[_builtins.str] status: Status of the Keyless SSL.
               Available values: "active", "deleted".
        :param pulumi.Input['CustomSslKeylessServerTunnelArgs'] tunnel: Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel is not None:
            pulumi.set(__self__, "tunnel", tunnel)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the Keyless SSL was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not the Keyless SSL is on or off.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Keyless certificate identifier tag.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the Keyless SSL was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modified_on", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The keyless SSL name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Available permissions for the Keyless SSL for the current user requesting the item.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the Keyless SSL.
        Available values: "active", "deleted".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def tunnel(self) -> Optional[pulumi.Input['CustomSslKeylessServerTunnelArgs']]:
        """
        Configuration for using Keyless SSL through a Cloudflare Tunnel
        """
        return pulumi.get(self, "tunnel")

    @tunnel.setter
    def tunnel(self, value: Optional[pulumi.Input['CustomSslKeylessServerTunnelArgs']]):
        pulumi.set(self, "tunnel", value)


if not MYPY:
    class CustomSslKeylessServerTunnelArgsDict(TypedDict):
        private_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private IP of the Key Server Host
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloudflare Tunnel Virtual Network ID
        """
elif False:
    CustomSslKeylessServerTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomSslKeylessServerTunnelArgs:
    def __init__(__self__, *,
                 private_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_ip: Private IP of the Key Server Host
        :param pulumi.Input[_builtins.str] vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class D1DatabaseReadReplicationArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
        Available values: "auto", "disabled".
        """
elif False:
    D1DatabaseReadReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class D1DatabaseReadReplicationArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
               Available values: "auto", "disabled".
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
        Available values: "auto", "disabled".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class DeviceManagedNetworksConfigArgsDict(TypedDict):
        tls_sockaddr: pulumi.Input[_builtins.str]
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
elif False:
    DeviceManagedNetworksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceManagedNetworksConfigArgs:
    def __init__(__self__, *,
                 tls_sockaddr: pulumi.Input[_builtins.str],
                 sha256: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        :param pulumi.Input[_builtins.str] sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> pulumi.Input[_builtins.str]:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @tls_sockaddr.setter
    def tls_sockaddr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_sockaddr", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class DevicePostureIntegrationConfigArgsDict(TypedDict):
        access_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
        """
        access_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
        """
        api_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        auth_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One Authorization URL depending on your region.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Uptycs client secret.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        customer_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Crowdstrike customer ID.
        """
elif False:
    DevicePostureIntegrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureIntegrationConfigArgs:
    def __init__(__self__, *,
                 access_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 access_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 api_url: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_url: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 customer_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_client_id: If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
        :param pulumi.Input[_builtins.str] access_client_secret: If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
        :param pulumi.Input[_builtins.str] api_url: The Workspace One API URL provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[_builtins.str] auth_url: The Workspace One Authorization URL depending on your region.
        :param pulumi.Input[_builtins.str] client_id: The Workspace One client ID provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[_builtins.str] client_key: The Uptycs client secret.
        :param pulumi.Input[_builtins.str] client_secret: The Workspace One client secret provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[_builtins.str] customer_id: The Crowdstrike customer ID.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @_builtins.property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_client_id", value)

    @_builtins.property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_client_secret", value)

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_url", value)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One Authorization URL depending on your region.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Uptycs client secret.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Crowdstrike customer ID.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_id", value)


if not MYPY:
    class DevicePostureRuleInputArgsDict(TypedDict):
        active_threats: NotRequired[pulumi.Input[_builtins.float]]
        """
        The Number of active threats.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of Cloudflare managed certificate.
        """
        check_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of volume names to be checked for encryption.
        """
        check_private_key: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        cn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Common Name that is protected by the certificate.
        """
        compliance_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compliance Status.
        Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
        """
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Posture Integration ID.
        """
        count_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Count Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain.
        """
        eid_last_seen: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled.
        """
        exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not file exists.
        """
        extended_key_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of values indicating purposes for which the certificate public key can be used.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        List ID.
        """
        infected: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether device is infected.
        """
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether device is active.
        """
        issue_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Number of Issues.
        """
        last_seen: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        locations: NotRequired[pulumi.Input['DevicePostureRuleInputLocationsArgsDict']]
        network_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network status of device.
        Available values: "connected", "disconnected", "disconnecting", "connecting".
        """
        operating_system: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operating system.
        Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
        """
        operational_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent operational state.
        Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        os: NotRequired[pulumi.Input[_builtins.str]]
        """
        Os Version.
        """
        os_distro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operating System Distribution Name (linux only).
        """
        os_distro_revision: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of OS Distribution (linux only).
        """
        os_version_extra: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
        """
        overall: NotRequired[pulumi.Input[_builtins.str]]
        """
        Overall.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        File path.
        """
        require_all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to check all disks for encryption.
        """
        risk_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on risk level, refer to the Tanium documentation.
        Available values: "low", "medium", "high", "critical".
        """
        score: NotRequired[pulumi.Input[_builtins.float]]
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        score_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Score Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        sensor_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        SensorConfig.
        """
        sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        SHA-256.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on state, please refer to the Crowdstrike documentation.
        Available values: "online", "offline", "unknown".
        """
        subject_alternative_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of certificate Subject Alternative Names.
        """
        thumbprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Signing certificate thumbprint.
        """
        total_score: NotRequired[pulumi.Input[_builtins.float]]
        """
        For more details on total score, refer to the Tanium documentation.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of OS.
        """
        version_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
elif False:
    DevicePostureRuleInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureRuleInputArgs:
    def __init__(__self__, *,
                 active_threats: Optional[pulumi.Input[_builtins.float]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 check_private_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 cn: Optional[pulumi.Input[_builtins.str]] = None,
                 compliance_status: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 count_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 eid_last_seen: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 exists: Optional[pulumi.Input[_builtins.bool]] = None,
                 extended_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 infected: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None,
                 issue_count: Optional[pulumi.Input[_builtins.str]] = None,
                 last_seen: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input['DevicePostureRuleInputLocationsArgs']] = None,
                 network_status: Optional[pulumi.Input[_builtins.str]] = None,
                 operating_system: Optional[pulumi.Input[_builtins.str]] = None,
                 operational_state: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 os: Optional[pulumi.Input[_builtins.str]] = None,
                 os_distro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 os_distro_revision: Optional[pulumi.Input[_builtins.str]] = None,
                 os_version_extra: Optional[pulumi.Input[_builtins.str]] = None,
                 overall: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 require_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 risk_level: Optional[pulumi.Input[_builtins.str]] = None,
                 score: Optional[pulumi.Input[_builtins.float]] = None,
                 score_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 sensor_config: Optional[pulumi.Input[_builtins.str]] = None,
                 sha256: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 thumbprint: Optional[pulumi.Input[_builtins.str]] = None,
                 total_score: Optional[pulumi.Input[_builtins.float]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None,
                 version_operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] active_threats: The Number of active threats.
        :param pulumi.Input[_builtins.str] certificate_id: UUID of Cloudflare managed certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] check_disks: List of volume names to be checked for encryption.
        :param pulumi.Input[_builtins.bool] check_private_key: Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        :param pulumi.Input[_builtins.str] cn: Common Name that is protected by the certificate.
        :param pulumi.Input[_builtins.str] compliance_status: Compliance Status.
               Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
        :param pulumi.Input[_builtins.str] connection_id: Posture Integration ID.
        :param pulumi.Input[_builtins.str] count_operator: Count Operator.
               Available values: "<", "<=", ">", ">=", "==".
        :param pulumi.Input[_builtins.str] domain: Domain.
        :param pulumi.Input[_builtins.str] eid_last_seen: For more details on eid last seen, refer to the Tanium documentation.
        :param pulumi.Input[_builtins.bool] enabled: Enabled.
        :param pulumi.Input[_builtins.bool] exists: Whether or not file exists.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] extended_key_usages: List of values indicating purposes for which the certificate public key can be used.
        :param pulumi.Input[_builtins.str] id: List ID.
        :param pulumi.Input[_builtins.bool] infected: Whether device is infected.
        :param pulumi.Input[_builtins.bool] is_active: Whether device is active.
        :param pulumi.Input[_builtins.str] issue_count: The Number of Issues.
        :param pulumi.Input[_builtins.str] last_seen: For more details on last seen, please refer to the Crowdstrike documentation.
        :param pulumi.Input[_builtins.str] network_status: Network status of device.
               Available values: "connected", "disconnected", "disconnecting", "connecting".
        :param pulumi.Input[_builtins.str] operating_system: Operating system.
               Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
        :param pulumi.Input[_builtins.str] operational_state: Agent operational state.
               Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
        :param pulumi.Input[_builtins.str] operator: Operator.
               Available values: "<", "<=", ">", ">=", "==".
        :param pulumi.Input[_builtins.str] os: Os Version.
        :param pulumi.Input[_builtins.str] os_distro_name: Operating System Distribution Name (linux only).
        :param pulumi.Input[_builtins.str] os_distro_revision: Version of OS Distribution (linux only).
        :param pulumi.Input[_builtins.str] os_version_extra: Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
        :param pulumi.Input[_builtins.str] overall: Overall.
        :param pulumi.Input[_builtins.str] path: File path.
        :param pulumi.Input[_builtins.bool] require_all: Whether to check all disks for encryption.
        :param pulumi.Input[_builtins.str] risk_level: For more details on risk level, refer to the Tanium documentation.
               Available values: "low", "medium", "high", "critical".
        :param pulumi.Input[_builtins.float] score: A value between 0-100 assigned to devices set by the 3rd party posture provider.
        :param pulumi.Input[_builtins.str] score_operator: Score Operator.
               Available values: "<", "<=", ">", ">=", "==".
        :param pulumi.Input[_builtins.str] sensor_config: SensorConfig.
        :param pulumi.Input[_builtins.str] sha256: SHA-256.
        :param pulumi.Input[_builtins.str] state: For more details on state, please refer to the Crowdstrike documentation.
               Available values: "online", "offline", "unknown".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subject_alternative_names: List of certificate Subject Alternative Names.
        :param pulumi.Input[_builtins.str] thumbprint: Signing certificate thumbprint.
        :param pulumi.Input[_builtins.float] total_score: For more details on total score, refer to the Tanium documentation.
        :param pulumi.Input[_builtins.str] version: Version of OS.
        :param pulumi.Input[_builtins.str] version_operator: Version Operator.
               Available values: "<", "<=", ">", ">=", "==".
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if score_operator is not None:
            pulumi.set(__self__, "score_operator", score_operator)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @_builtins.property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The Number of active threats.
        """
        return pulumi.get(self, "active_threats")

    @active_threats.setter
    def active_threats(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "active_threats", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of volume names to be checked for encryption.
        """
        return pulumi.get(self, "check_disks")

    @check_disks.setter
    def check_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "check_disks", value)

    @_builtins.property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        return pulumi.get(self, "check_private_key")

    @check_private_key.setter
    def check_private_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "check_private_key", value)

    @_builtins.property
    @pulumi.getter
    def cn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Common Name that is protected by the certificate.
        """
        return pulumi.get(self, "cn")

    @cn.setter
    def cn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cn", value)

    @_builtins.property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compliance Status.
        Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
        """
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compliance_status", value)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Posture Integration ID.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Count Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "count_operator")

    @count_operator.setter
    def count_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "count_operator", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        return pulumi.get(self, "eid_last_seen")

    @eid_last_seen.setter
    def eid_last_seen(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eid_last_seen", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not file exists.
        """
        return pulumi.get(self, "exists")

    @exists.setter
    def exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exists", value)

    @_builtins.property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of values indicating purposes for which the certificate public key can be used.
        """
        return pulumi.get(self, "extended_key_usages")

    @extended_key_usages.setter
    def extended_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extended_key_usages", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        List ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def infected(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether device is infected.
        """
        return pulumi.get(self, "infected")

    @infected.setter
    def infected(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "infected", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether device is active.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Number of Issues.
        """
        return pulumi.get(self, "issue_count")

    @issue_count.setter
    def issue_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issue_count", value)

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "last_seen")

    @last_seen.setter
    def last_seen(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_seen", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['DevicePostureRuleInputLocationsArgs']]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['DevicePostureRuleInputLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network status of device.
        Available values: "connected", "disconnected", "disconnecting", "connecting".
        """
        return pulumi.get(self, "network_status")

    @network_status.setter
    def network_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_status", value)

    @_builtins.property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operating system.
        Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operating_system", value)

    @_builtins.property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent operational state.
        Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operational_state", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Os Version.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os", value)

    @_builtins.property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operating System Distribution Name (linux only).
        """
        return pulumi.get(self, "os_distro_name")

    @os_distro_name.setter
    def os_distro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_distro_name", value)

    @_builtins.property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of OS Distribution (linux only).
        """
        return pulumi.get(self, "os_distro_revision")

    @os_distro_revision.setter
    def os_distro_revision(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_distro_revision", value)

    @_builtins.property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
        """
        return pulumi.get(self, "os_version_extra")

    @os_version_extra.setter
    def os_version_extra(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_version_extra", value)

    @_builtins.property
    @pulumi.getter
    def overall(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Overall.
        """
        return pulumi.get(self, "overall")

    @overall.setter
    def overall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overall", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        File path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to check all disks for encryption.
        """
        return pulumi.get(self, "require_all")

    @require_all.setter
    def require_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_all", value)

    @_builtins.property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on risk level, refer to the Tanium documentation.
        Available values: "low", "medium", "high", "critical".
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "risk_level", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "score", value)

    @_builtins.property
    @pulumi.getter(name="scoreOperator")
    def score_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Score Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "score_operator")

    @score_operator.setter
    def score_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "score_operator", value)

    @_builtins.property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SensorConfig.
        """
        return pulumi.get(self, "sensor_config")

    @sensor_config.setter
    def sensor_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensor_config", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SHA-256.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on state, please refer to the Crowdstrike documentation.
        Available values: "online", "offline", "unknown".
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of certificate Subject Alternative Names.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subject_alternative_names", value)

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Signing certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "thumbprint", value)

    @_builtins.property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        For more details on total score, refer to the Tanium documentation.
        """
        return pulumi.get(self, "total_score")

    @total_score.setter
    def total_score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "total_score", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of OS.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "version_operator")

    @version_operator.setter
    def version_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_operator", value)


if not MYPY:
    class DevicePostureRuleInputLocationsArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of paths to check for client certificate on linux.
        """
        trust_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of trust stores to check for client certificate.
        """
elif False:
    DevicePostureRuleInputLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureRuleInputLocationsArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 trust_stores: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] paths: List of paths to check for client certificate on linux.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] trust_stores: List of trust stores to check for client certificate.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of paths to check for client certificate on linux.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of trust stores to check for client certificate.
        """
        return pulumi.get(self, "trust_stores")

    @trust_stores.setter
    def trust_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "trust_stores", value)


if not MYPY:
    class DevicePostureRuleMatchArgsDict(TypedDict):
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
        """
elif False:
    DevicePostureRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePostureRuleMatchArgs:
    def __init__(__self__, *,
                 platform: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] platform: Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)


if not MYPY:
    class DlpCustomProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['DlpCustomProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    DlpCustomProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpCustomProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 skip: pulumi.Input['DlpCustomProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['DlpCustomProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def skip(self) -> pulumi.Input['DlpCustomProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['DlpCustomProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class DlpCustomProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[_builtins.bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    DlpCustomProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpCustomProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @_builtins.property
    @pulumi.getter
    def files(self) -> pulumi.Input[_builtins.bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class DlpCustomProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        name: pulumi.Input[_builtins.str]
        pattern: pulumi.Input['DlpCustomProfileEntryPatternArgsDict']
        entry_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DlpCustomProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpCustomProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str],
                 pattern: pulumi.Input['DlpCustomProfileEntryPatternArgs'],
                 entry_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input['DlpCustomProfileEntryPatternArgs']:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input['DlpCustomProfileEntryPatternArgs']):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry_id", value)


if not MYPY:
    class DlpCustomProfileEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[_builtins.str]
        validation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "luhn".
        """
elif False:
    DlpCustomProfileEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpCustomProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[_builtins.str],
                 validation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] validation: Available values: "luhn".
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""validation is deprecated: This attribute is deprecated.""")
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute is deprecated.""")
    def validation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "luhn".
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class DlpCustomProfileSharedEntryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        entry_id: pulumi.Input[_builtins.str]
        entry_type: pulumi.Input[_builtins.str]
        """
        Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
        """
elif False:
    DlpCustomProfileSharedEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpCustomProfileSharedEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 entry_id: pulumi.Input[_builtins.str],
                 entry_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] entry_type: Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "entry_type", entry_type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entry_id", value)

    @_builtins.property
    @pulumi.getter(name="entryType")
    def entry_type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
        """
        return pulumi.get(self, "entry_type")

    @entry_type.setter
    def entry_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entry_type", value)


if not MYPY:
    class DlpPredefinedProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['DlpPredefinedProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    DlpPredefinedProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpPredefinedProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 skip: pulumi.Input['DlpPredefinedProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['DlpPredefinedProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def skip(self) -> pulumi.Input['DlpPredefinedProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['DlpPredefinedProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class DlpPredefinedProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[_builtins.bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    DlpPredefinedProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpPredefinedProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @_builtins.property
    @pulumi.getter
    def files(self) -> pulumi.Input[_builtins.bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class DlpPredefinedProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        id: pulumi.Input[_builtins.str]
elif False:
    DlpPredefinedProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DlpPredefinedProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DnsFirewallAttackMitigationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        only_when_upstream_unhealthy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
elif False:
    DnsFirewallAttackMitigationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsFirewallAttackMitigationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 only_when_upstream_unhealthy: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        :param pulumi.Input[_builtins.bool] only_when_upstream_unhealthy: Only mitigate attacks when upstream servers seem unhealthy
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if only_when_upstream_unhealthy is not None:
            pulumi.set(__self__, "only_when_upstream_unhealthy", only_when_upstream_unhealthy)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="onlyWhenUpstreamUnhealthy")
    def only_when_upstream_unhealthy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Only mitigate attacks when upstream servers seem unhealthy
        """
        return pulumi.get(self, "only_when_upstream_unhealthy")

    @only_when_upstream_unhealthy.setter
    def only_when_upstream_unhealthy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "only_when_upstream_unhealthy", value)


if not MYPY:
    class DnsRecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.float]]
        """
        Algorithm.
        """
        altitude: NotRequired[pulumi.Input[_builtins.float]]
        """
        Altitude of location in meters.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate.
        """
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        Digest.
        """
        digest_type: NotRequired[pulumi.Input[_builtins.float]]
        """
        Digest Type.
        """
        fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fingerprint.
        """
        flags: NotRequired[Any]
        """
        Flags for the CAA record.
        """
        key_tag: NotRequired[pulumi.Input[_builtins.float]]
        """
        Key Tag.
        """
        lat_degrees: NotRequired[pulumi.Input[_builtins.float]]
        """
        Degrees of latitude.
        """
        lat_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Latitude direction.
        Available values: "N", "S".
        """
        lat_minutes: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minutes of latitude.
        """
        lat_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Seconds of latitude.
        """
        long_degrees: NotRequired[pulumi.Input[_builtins.float]]
        """
        Degrees of longitude.
        """
        long_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Longitude direction.
        Available values: "E", "W".
        """
        long_minutes: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minutes of longitude.
        """
        long_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Seconds of longitude.
        """
        matching_type: NotRequired[pulumi.Input[_builtins.float]]
        """
        Matching Type.
        """
        order: NotRequired[pulumi.Input[_builtins.float]]
        """
        Order.
        """
        port: NotRequired[pulumi.Input[_builtins.float]]
        """
        The port of the service.
        """
        precision_horz: NotRequired[pulumi.Input[_builtins.float]]
        """
        Horizontal precision of location.
        """
        precision_vert: NotRequired[pulumi.Input[_builtins.float]]
        """
        Vertical precision of location.
        """
        preference: NotRequired[pulumi.Input[_builtins.float]]
        """
        Preference.
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        Priority.
        """
        protocol: NotRequired[pulumi.Input[_builtins.float]]
        """
        Protocol.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public Key.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex.
        """
        replacement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Replacement.
        """
        selector: NotRequired[pulumi.Input[_builtins.float]]
        """
        Selector.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service.
        """
        size: NotRequired[pulumi.Input[_builtins.float]]
        """
        Size of location in meters.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target.
        """
        type: NotRequired[pulumi.Input[_builtins.float]]
        """
        Type.
        """
        usage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Usage.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The record weight.
        """
elif False:
    DnsRecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsRecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.float]] = None,
                 altitude: Optional[pulumi.Input[_builtins.float]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 digest_type: Optional[pulumi.Input[_builtins.float]] = None,
                 fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 flags: Optional[Any] = None,
                 key_tag: Optional[pulumi.Input[_builtins.float]] = None,
                 lat_degrees: Optional[pulumi.Input[_builtins.float]] = None,
                 lat_direction: Optional[pulumi.Input[_builtins.str]] = None,
                 lat_minutes: Optional[pulumi.Input[_builtins.float]] = None,
                 lat_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 long_degrees: Optional[pulumi.Input[_builtins.float]] = None,
                 long_direction: Optional[pulumi.Input[_builtins.str]] = None,
                 long_minutes: Optional[pulumi.Input[_builtins.float]] = None,
                 long_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 matching_type: Optional[pulumi.Input[_builtins.float]] = None,
                 order: Optional[pulumi.Input[_builtins.float]] = None,
                 port: Optional[pulumi.Input[_builtins.float]] = None,
                 precision_horz: Optional[pulumi.Input[_builtins.float]] = None,
                 precision_vert: Optional[pulumi.Input[_builtins.float]] = None,
                 preference: Optional[pulumi.Input[_builtins.float]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 protocol: Optional[pulumi.Input[_builtins.float]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None,
                 replacement: Optional[pulumi.Input[_builtins.str]] = None,
                 selector: Optional[pulumi.Input[_builtins.float]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.float]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.float]] = None,
                 usage: Optional[pulumi.Input[_builtins.float]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] algorithm: Algorithm.
        :param pulumi.Input[_builtins.float] altitude: Altitude of location in meters.
        :param pulumi.Input[_builtins.str] certificate: Certificate.
        :param pulumi.Input[_builtins.str] digest: Digest.
        :param pulumi.Input[_builtins.float] digest_type: Digest Type.
        :param pulumi.Input[_builtins.str] fingerprint: Fingerprint.
        :param Any flags: Flags for the CAA record.
        :param pulumi.Input[_builtins.float] key_tag: Key Tag.
        :param pulumi.Input[_builtins.float] lat_degrees: Degrees of latitude.
        :param pulumi.Input[_builtins.str] lat_direction: Latitude direction.
               Available values: "N", "S".
        :param pulumi.Input[_builtins.float] lat_minutes: Minutes of latitude.
        :param pulumi.Input[_builtins.float] lat_seconds: Seconds of latitude.
        :param pulumi.Input[_builtins.float] long_degrees: Degrees of longitude.
        :param pulumi.Input[_builtins.str] long_direction: Longitude direction.
               Available values: "E", "W".
        :param pulumi.Input[_builtins.float] long_minutes: Minutes of longitude.
        :param pulumi.Input[_builtins.float] long_seconds: Seconds of longitude.
        :param pulumi.Input[_builtins.float] matching_type: Matching Type.
        :param pulumi.Input[_builtins.float] order: Order.
        :param pulumi.Input[_builtins.float] port: The port of the service.
        :param pulumi.Input[_builtins.float] precision_horz: Horizontal precision of location.
        :param pulumi.Input[_builtins.float] precision_vert: Vertical precision of location.
        :param pulumi.Input[_builtins.float] preference: Preference.
        :param pulumi.Input[_builtins.float] priority: Priority.
        :param pulumi.Input[_builtins.float] protocol: Protocol.
        :param pulumi.Input[_builtins.str] public_key: Public Key.
        :param pulumi.Input[_builtins.str] regex: Regex.
        :param pulumi.Input[_builtins.str] replacement: Replacement.
        :param pulumi.Input[_builtins.float] selector: Selector.
        :param pulumi.Input[_builtins.str] service: Service.
        :param pulumi.Input[_builtins.float] size: Size of location in meters.
        :param pulumi.Input[_builtins.str] tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param pulumi.Input[_builtins.str] target: Target.
        :param pulumi.Input[_builtins.float] type: Type.
        :param pulumi.Input[_builtins.float] usage: Usage.
        :param pulumi.Input[_builtins.str] value: Value of the record. This field's semantics depend on the chosen tag.
        :param pulumi.Input[_builtins.float] weight: The record weight.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def altitude(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @altitude.setter
    def altitude(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "altitude", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @digest_type.setter
    def digest_type(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "digest_type", value)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @_builtins.property
    @pulumi.getter
    def flags(self) -> Optional[Any]:
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[Any]):
        pulumi.set(self, "flags", value)

    @_builtins.property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "key_tag", value)

    @_builtins.property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @lat_degrees.setter
    def lat_degrees(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat_degrees", value)

    @_builtins.property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Latitude direction.
        Available values: "N", "S".
        """
        return pulumi.get(self, "lat_direction")

    @lat_direction.setter
    def lat_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lat_direction", value)

    @_builtins.property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @lat_minutes.setter
    def lat_minutes(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat_minutes", value)

    @_builtins.property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @lat_seconds.setter
    def lat_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat_seconds", value)

    @_builtins.property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @long_degrees.setter
    def long_degrees(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "long_degrees", value)

    @_builtins.property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Longitude direction.
        Available values: "E", "W".
        """
        return pulumi.get(self, "long_direction")

    @long_direction.setter
    def long_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "long_direction", value)

    @_builtins.property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @long_minutes.setter
    def long_minutes(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "long_minutes", value)

    @_builtins.property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @long_seconds.setter
    def long_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "long_seconds", value)

    @_builtins.property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "matching_type", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @precision_horz.setter
    def precision_horz(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "precision_horz", value)

    @_builtins.property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @precision_vert.setter
    def precision_vert(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "precision_vert", value)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "preference", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replacement", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "usage", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class DnsRecordSettingsArgsDict(TypedDict):
        flatten_cname: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        ipv4_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        ipv6_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
elif False:
    DnsRecordSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsRecordSettingsArgs:
    def __init__(__self__, *,
                 flatten_cname: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv4_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param pulumi.Input[_builtins.bool] ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param pulumi.Input[_builtins.bool] ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        if flatten_cname is not None:
            pulumi.set(__self__, "flatten_cname", flatten_cname)
        if ipv4_only is not None:
            pulumi.set(__self__, "ipv4_only", ipv4_only)
        if ipv6_only is not None:
            pulumi.set(__self__, "ipv6_only", ipv6_only)

    @_builtins.property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @flatten_cname.setter
    def flatten_cname(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flatten_cname", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @ipv4_only.setter
    def ipv4_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv4_only", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")

    @ipv6_only.setter
    def ipv6_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_only", value)


if not MYPY:
    class EmailRoutingCatchAllActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of action for catch-all rule.
        Available values: "drop", "forward", "worker".
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    EmailRoutingCatchAllActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingCatchAllActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of action for catch-all rule.
               Available values: "drop", "forward", "worker".
        """
        pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of action for catch-all rule.
        Available values: "drop", "forward", "worker".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EmailRoutingCatchAllMatcherArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of matcher. Default is 'all'.
        Available values: "all".
        """
elif False:
    EmailRoutingCatchAllMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingCatchAllMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Type of matcher. Default is 'all'.
               Available values: "all".
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of matcher. Default is 'all'.
        Available values: "all".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingDnsErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        documentation_url: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input['EmailRoutingDnsErrorSourceArgsDict']]
elif False:
    EmailRoutingDnsErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 documentation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['EmailRoutingDnsErrorSourceArgs']] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "documentation_url")

    @documentation_url.setter
    def documentation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "documentation_url", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['EmailRoutingDnsErrorSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['EmailRoutingDnsErrorSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class EmailRoutingDnsErrorSourceArgsDict(TypedDict):
        pointer: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EmailRoutingDnsErrorSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsErrorSourceArgs:
    def __init__(__self__, *,
                 pointer: Optional[pulumi.Input[_builtins.str]] = None):
        if pointer is not None:
            pulumi.set(__self__, "pointer", pointer)

    @_builtins.property
    @pulumi.getter
    def pointer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "pointer")

    @pointer.setter
    def pointer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pointer", value)


if not MYPY:
    class EmailRoutingDnsMessageArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        documentation_url: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input['EmailRoutingDnsMessageSourceArgsDict']]
elif False:
    EmailRoutingDnsMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsMessageArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 documentation_url: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['EmailRoutingDnsMessageSourceArgs']] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "documentation_url")

    @documentation_url.setter
    def documentation_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "documentation_url", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['EmailRoutingDnsMessageSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['EmailRoutingDnsMessageSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class EmailRoutingDnsMessageSourceArgsDict(TypedDict):
        pointer: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EmailRoutingDnsMessageSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsMessageSourceArgs:
    def __init__(__self__, *,
                 pointer: Optional[pulumi.Input[_builtins.str]] = None):
        if pointer is not None:
            pulumi.set(__self__, "pointer", pointer)

    @_builtins.property
    @pulumi.getter
    def pointer(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "pointer")

    @pointer.setter
    def pointer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pointer", value)


if not MYPY:
    class EmailRoutingDnsResultArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record content.
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgsDict']]]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record name (or @ for the zone apex).
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        records: NotRequired[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgsDict']]]]
        ttl: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record type.
        Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
elif False:
    EmailRoutingDnsResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 records: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgs']]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.float]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: DNS record content.
        :param pulumi.Input[_builtins.str] name: DNS record name (or @ for the zone apex).
        :param pulumi.Input[_builtins.float] priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param pulumi.Input[_builtins.float] ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param pulumi.Input[_builtins.str] type: DNS record type.
               Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgs']]]]:
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultErrorArgs']]]]):
        pulumi.set(self, "errors", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgs']]]]:
        return pulumi.get(self, "records")

    @records.setter
    def records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EmailRoutingDnsResultRecordArgs']]]]):
        pulumi.set(self, "records", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record type.
        Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingDnsResultErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        missing: NotRequired[pulumi.Input['EmailRoutingDnsResultErrorMissingArgsDict']]
        """
        List of records needed to enable an Email Routing zone.
        """
elif False:
    EmailRoutingDnsResultErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 missing: Optional[pulumi.Input['EmailRoutingDnsResultErrorMissingArgs']] = None):
        """
        :param pulumi.Input['EmailRoutingDnsResultErrorMissingArgs'] missing: List of records needed to enable an Email Routing zone.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if missing is not None:
            pulumi.set(__self__, "missing", missing)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def missing(self) -> Optional[pulumi.Input['EmailRoutingDnsResultErrorMissingArgs']]:
        """
        List of records needed to enable an Email Routing zone.
        """
        return pulumi.get(self, "missing")

    @missing.setter
    def missing(self, value: Optional[pulumi.Input['EmailRoutingDnsResultErrorMissingArgs']]):
        pulumi.set(self, "missing", value)


if not MYPY:
    class EmailRoutingDnsResultErrorMissingArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record content.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record name (or @ for the zone apex).
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        ttl: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record type.
        Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
elif False:
    EmailRoutingDnsResultErrorMissingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultErrorMissingArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 ttl: Optional[pulumi.Input[_builtins.float]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: DNS record content.
        :param pulumi.Input[_builtins.str] name: DNS record name (or @ for the zone apex).
        :param pulumi.Input[_builtins.float] priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param pulumi.Input[_builtins.float] ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param pulumi.Input[_builtins.str] type: DNS record type.
               Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record type.
        Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingDnsResultInfoArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[_builtins.float]]
        """
        Total number of results for the requested service.
        """
        page: NotRequired[pulumi.Input[_builtins.float]]
        """
        Current page within paginated list of results.
        """
        per_page: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of results per page of results.
        """
        total_count: NotRequired[pulumi.Input[_builtins.float]]
        """
        Total results available without any search parameters.
        """
elif False:
    EmailRoutingDnsResultInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultInfoArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[_builtins.float]] = None,
                 page: Optional[pulumi.Input[_builtins.float]] = None,
                 per_page: Optional[pulumi.Input[_builtins.float]] = None,
                 total_count: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] count: Total number of results for the requested service.
        :param pulumi.Input[_builtins.float] page: Current page within paginated list of results.
        :param pulumi.Input[_builtins.float] per_page: Number of results per page of results.
        :param pulumi.Input[_builtins.float] total_count: Total results available without any search parameters.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if page is not None:
            pulumi.set(__self__, "page", page)
        if per_page is not None:
            pulumi.set(__self__, "per_page", per_page)
        if total_count is not None:
            pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Total number of results for the requested service.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def page(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Current page within paginated list of results.
        """
        return pulumi.get(self, "page")

    @page.setter
    def page(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "page", value)

    @_builtins.property
    @pulumi.getter(name="perPage")
    def per_page(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of results per page of results.
        """
        return pulumi.get(self, "per_page")

    @per_page.setter
    def per_page(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "per_page", value)

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Total results available without any search parameters.
        """
        return pulumi.get(self, "total_count")

    @total_count.setter
    def total_count(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "total_count", value)


if not MYPY:
    class EmailRoutingDnsResultRecordArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record content.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record name (or @ for the zone apex).
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        ttl: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS record type.
        Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
elif False:
    EmailRoutingDnsResultRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingDnsResultRecordArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 ttl: Optional[pulumi.Input[_builtins.float]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: DNS record content.
        :param pulumi.Input[_builtins.str] name: DNS record name (or @ for the zone apex).
        :param pulumi.Input[_builtins.float] priority: Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        :param pulumi.Input[_builtins.float] ttl: Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        :param pulumi.Input[_builtins.str] type: DNS record type.
               Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record name (or @ for the zone apex).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS record type.
        Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EmailRoutingRuleActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of supported action.
        Available values: "drop", "forward", "worker".
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    EmailRoutingRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of supported action.
               Available values: "drop", "forward", "worker".
        """
        pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of supported action.
        Available values: "drop", "forward", "worker".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EmailRoutingRuleMatcherArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of matcher.
        Available values: "all", "literal".
        """
        field: NotRequired[pulumi.Input[_builtins.str]]
        """
        Field for type matcher.
        Available values: "to".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value for matcher.
        """
elif False:
    EmailRoutingRuleMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailRoutingRuleMatcherArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 field: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of matcher.
               Available values: "all", "literal".
        :param pulumi.Input[_builtins.str] field: Field for type matcher.
               Available values: "to".
        :param pulumi.Input[_builtins.str] value: Value for matcher.
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of matcher.
        Available values: "all", "literal".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Field for type matcher.
        Available values: "to".
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value for matcher.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EmailSecurityTrustedDomainsBodyArgsDict(TypedDict):
        is_recent: pulumi.Input[_builtins.bool]
        """
        Select to prevent recently registered domains from triggering a
        Suspicious or Malicious disposition.
        """
        is_regex: pulumi.Input[_builtins.bool]
        is_similarity: pulumi.Input[_builtins.bool]
        """
        Select for partner or other approved domains that have similar
        spelling to your connected domains. Prevents listed domains from
        triggering a Spoof disposition.
        """
        pattern: pulumi.Input[_builtins.str]
        comments: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EmailSecurityTrustedDomainsBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailSecurityTrustedDomainsBodyArgs:
    def __init__(__self__, *,
                 is_recent: pulumi.Input[_builtins.bool],
                 is_regex: pulumi.Input[_builtins.bool],
                 is_similarity: pulumi.Input[_builtins.bool],
                 pattern: pulumi.Input[_builtins.str],
                 comments: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_recent: Select to prevent recently registered domains from triggering a
               Suspicious or Malicious disposition.
        :param pulumi.Input[_builtins.bool] is_similarity: Select for partner or other approved domains that have similar
               spelling to your connected domains. Prevents listed domains from
               triggering a Spoof disposition.
        """
        pulumi.set(__self__, "is_recent", is_recent)
        pulumi.set(__self__, "is_regex", is_regex)
        pulumi.set(__self__, "is_similarity", is_similarity)
        pulumi.set(__self__, "pattern", pattern)
        if comments is not None:
            pulumi.set(__self__, "comments", comments)

    @_builtins.property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> pulumi.Input[_builtins.bool]:
        """
        Select to prevent recently registered domains from triggering a
        Suspicious or Malicious disposition.
        """
        return pulumi.get(self, "is_recent")

    @is_recent.setter
    def is_recent(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_recent", value)

    @_builtins.property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "is_regex")

    @is_regex.setter
    def is_regex(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_regex", value)

    @_builtins.property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> pulumi.Input[_builtins.bool]:
        """
        Select for partner or other approved domains that have similar
        spelling to your connected domains. Prevents listed domains from
        triggering a Spoof disposition.
        """
        return pulumi.get(self, "is_similarity")

    @is_similarity.setter
    def is_similarity(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_similarity", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def comments(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "comments")

    @comments.setter
    def comments(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comments", value)


if not MYPY:
    class FilterBodyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        An informative summary of the filter.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the filter.
        """
        paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, indicates that the filter is currently paused.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        A short reference tag. Allows you to select related filters.
        """
elif False:
    FilterBodyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterBodyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: An informative summary of the filter.
        :param pulumi.Input[_builtins.str] expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param pulumi.Input[_builtins.str] id: The unique identifier of the filter.
        :param pulumi.Input[_builtins.bool] paused: When true, indicates that the filter is currently paused.
        :param pulumi.Input[_builtins.str] ref: A short reference tag. Allows you to select related filters.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "paused", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class FirewallRuleActionArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to perform.
        Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
        """
        response: NotRequired[pulumi.Input['FirewallRuleActionResponseArgsDict']]
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        timeout: NotRequired[pulumi.Input[_builtins.float]]
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
elif False:
    FirewallRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleActionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input['FirewallRuleActionResponseArgs']] = None,
                 timeout: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The action to perform.
               Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
        :param pulumi.Input['FirewallRuleActionResponseArgs'] response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param pulumi.Input[_builtins.float] timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to perform.
        Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['FirewallRuleActionResponseArgs']]:
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['FirewallRuleActionResponseArgs']]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class FirewallRuleActionResponseArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The response body to return. The value must conform to the configured content type.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
elif False:
    FirewallRuleActionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleActionResponseArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: The response body to return. The value must conform to the configured content type.
        :param pulumi.Input[_builtins.str] content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class FirewallRuleFilterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        An informative summary of the filter.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the filter.
        """
        paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, indicates that the filter is currently paused.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        A short reference tag. Allows you to select related filters.
        """
elif False:
    FirewallRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRuleFilterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: An informative summary of the filter.
        :param pulumi.Input[_builtins.str] expression: The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        :param pulumi.Input[_builtins.str] id: The unique identifier of the filter.
        :param pulumi.Input[_builtins.bool] paused: When true, indicates that the filter is currently paused.
        :param pulumi.Input[_builtins.str] ref: A short reference tag. Allows you to select related filters.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An informative summary of the filter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "paused", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A short reference tag. Allows you to select related filters.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class HealthcheckHttpConfigArgsDict(TypedDict):
        allow_insecure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        expected_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        expected_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        follow_redirects: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP method to use for the health check.
        Available values: "GET", "HEAD".
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint path to health check against.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
elif False:
    HealthcheckHttpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthcheckHttpConfigArgs:
    def __init__(__self__, *,
                 allow_insecure: Optional[pulumi.Input[_builtins.bool]] = None,
                 expected_body: Optional[pulumi.Input[_builtins.str]] = None,
                 expected_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 follow_redirects: Optional[pulumi.Input[_builtins.bool]] = None,
                 header: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_insecure: Do not validate the certificate when the health check uses HTTPS.
        :param pulumi.Input[_builtins.str] expected_body: A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expected_codes: The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        :param pulumi.Input[_builtins.bool] follow_redirects: Follow redirects if the origin returns a 3xx status code.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] header: The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        :param pulumi.Input[_builtins.str] method: The HTTP method to use for the health check.
               Available values: "GET", "HEAD".
        :param pulumi.Input[_builtins.str] path: The endpoint path to health check against.
        :param pulumi.Input[_builtins.int] port: Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if expected_body is not None:
            pulumi.set(__self__, "expected_body", expected_body)
        if expected_codes is not None:
            pulumi.set(__self__, "expected_codes", expected_codes)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not validate the certificate when the health check uses HTTPS.
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_insecure", value)

    @_builtins.property
    @pulumi.getter(name="expectedBody")
    def expected_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
        """
        return pulumi.get(self, "expected_body")

    @expected_body.setter
    def expected_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_body", value)

    @_builtins.property
    @pulumi.getter(name="expectedCodes")
    def expected_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
        """
        return pulumi.get(self, "expected_codes")

    @expected_codes.setter
    def expected_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expected_codes", value)

    @_builtins.property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Follow redirects if the origin returns a 3xx status code.
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "follow_redirects", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP method to use for the health check.
        Available values: "GET", "HEAD".
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint path to health check against.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HealthcheckTcpConfigArgsDict(TypedDict):
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The TCP connection method to use for the health check.
        Available values: "connection_established".
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port number to connect to for the health check. Defaults to 80.
        """
elif False:
    HealthcheckTcpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthcheckTcpConfigArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] method: The TCP connection method to use for the health check.
               Available values: "connection_established".
        :param pulumi.Input[_builtins.int] port: Port number to connect to for the health check. Defaults to 80.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The TCP connection method to use for the health check.
        Available values: "connection_established".
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port number to connect to for the health check. Defaults to 80.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class HyperdriveConfigCachingArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to disable caching of SQL responses. Default is false.
        """
        max_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
        """
        stale_while_revalidate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
        """
elif False:
    HyperdriveConfigCachingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigCachingArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None,
                 stale_while_revalidate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Set to true to disable caching of SQL responses. Default is false.
        :param pulumi.Input[_builtins.int] max_age: Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
        :param pulumi.Input[_builtins.int] stale_while_revalidate: Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if stale_while_revalidate is not None:
            pulumi.set(__self__, "stale_while_revalidate", stale_while_revalidate)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to disable caching of SQL responses. Default is false.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)

    @_builtins.property
    @pulumi.getter(name="staleWhileRevalidate")
    def stale_while_revalidate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
        """
        return pulumi.get(self, "stale_while_revalidate")

    @stale_while_revalidate.setter
    def stale_while_revalidate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stale_while_revalidate", value)


if not MYPY:
    class HyperdriveConfigMtlsArgsDict(TypedDict):
        ca_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Define CA certificate ID obtained after uploading CA cert.
        """
        mtls_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Define mTLS certificate ID obtained after uploading client cert.
        """
        sslmode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
        """
elif False:
    HyperdriveConfigMtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigMtlsArgs:
    def __init__(__self__, *,
                 ca_certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mtls_certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 sslmode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ca_certificate_id: Define CA certificate ID obtained after uploading CA cert.
        :param pulumi.Input[_builtins.str] mtls_certificate_id: Define mTLS certificate ID obtained after uploading client cert.
        :param pulumi.Input[_builtins.str] sslmode: Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
        """
        if ca_certificate_id is not None:
            pulumi.set(__self__, "ca_certificate_id", ca_certificate_id)
        if mtls_certificate_id is not None:
            pulumi.set(__self__, "mtls_certificate_id", mtls_certificate_id)
        if sslmode is not None:
            pulumi.set(__self__, "sslmode", sslmode)

    @_builtins.property
    @pulumi.getter(name="caCertificateId")
    def ca_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Define CA certificate ID obtained after uploading CA cert.
        """
        return pulumi.get(self, "ca_certificate_id")

    @ca_certificate_id.setter
    def ca_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="mtlsCertificateId")
    def mtls_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Define mTLS certificate ID obtained after uploading client cert.
        """
        return pulumi.get(self, "mtls_certificate_id")

    @mtls_certificate_id.setter
    def mtls_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mtls_certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def sslmode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
        """
        return pulumi.get(self, "sslmode")

    @sslmode.setter
    def sslmode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sslmode", value)


if not MYPY:
    class HyperdriveConfigOriginArgsDict(TypedDict):
        database: pulumi.Input[_builtins.str]
        """
        Set the name of your origin database.
        """
        host: pulumi.Input[_builtins.str]
        """
        Defines the host (hostname or IP) of your origin database.
        """
        password: pulumi.Input[_builtins.str]
        """
        Set the password needed to access your origin database. The API never returns this write-only value.
        """
        scheme: pulumi.Input[_builtins.str]
        """
        Specifies the URL scheme used to connect to your origin database.
        Available values: "postgres", "postgresql", "mysql".
        """
        user: pulumi.Input[_builtins.str]
        """
        Set the user of your origin database.
        """
        access_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the Client ID of the Access token to use when connecting to the origin database.
        """
        access_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Defines the port (default: 5432 for Postgres) of your origin database.
        """
elif False:
    HyperdriveConfigOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HyperdriveConfigOriginArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 scheme: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 access_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 access_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] database: Set the name of your origin database.
        :param pulumi.Input[_builtins.str] host: Defines the host (hostname or IP) of your origin database.
        :param pulumi.Input[_builtins.str] password: Set the password needed to access your origin database. The API never returns this write-only value.
        :param pulumi.Input[_builtins.str] scheme: Specifies the URL scheme used to connect to your origin database.
               Available values: "postgres", "postgresql", "mysql".
        :param pulumi.Input[_builtins.str] user: Set the user of your origin database.
        :param pulumi.Input[_builtins.str] access_client_id: Defines the Client ID of the Access token to use when connecting to the origin database.
        :param pulumi.Input[_builtins.str] access_client_secret: Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
        :param pulumi.Input[_builtins.int] port: Defines the port (default: 5432 for Postgres) of your origin database.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "scheme", scheme)
        pulumi.set(__self__, "user", user)
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        Set the name of your origin database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Defines the host (hostname or IP) of your origin database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Set the password needed to access your origin database. The API never returns this write-only value.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL scheme used to connect to your origin database.
        Available values: "postgres", "postgresql", "mysql".
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        Set the user of your origin database.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the Client ID of the Access token to use when connecting to the origin database.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_client_id", value)

    @_builtins.property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Defines the port (default: 5432 for Postgres) of your origin database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ImageVariantOptionsArgsDict(TypedDict):
        fit: pulumi.Input[_builtins.str]
        """
        The fit property describes how the width and height dimensions should be interpreted.
        Available values: "scale-down", "contain", "cover", "crop", "pad".
        """
        height: pulumi.Input[_builtins.float]
        """
        Maximum height in image pixels.
        """
        metadata: pulumi.Input[_builtins.str]
        """
        What EXIF data should be preserved in the output image.
        Available values: "keep", "copyright", "none".
        """
        width: pulumi.Input[_builtins.float]
        """
        Maximum width in image pixels.
        """
elif False:
    ImageVariantOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageVariantOptionsArgs:
    def __init__(__self__, *,
                 fit: pulumi.Input[_builtins.str],
                 height: pulumi.Input[_builtins.float],
                 metadata: pulumi.Input[_builtins.str],
                 width: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.str] fit: The fit property describes how the width and height dimensions should be interpreted.
               Available values: "scale-down", "contain", "cover", "crop", "pad".
        :param pulumi.Input[_builtins.float] height: Maximum height in image pixels.
        :param pulumi.Input[_builtins.str] metadata: What EXIF data should be preserved in the output image.
               Available values: "keep", "copyright", "none".
        :param pulumi.Input[_builtins.float] width: Maximum width in image pixels.
        """
        pulumi.set(__self__, "fit", fit)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def fit(self) -> pulumi.Input[_builtins.str]:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        Available values: "scale-down", "contain", "cover", "crop", "pad".
        """
        return pulumi.get(self, "fit")

    @fit.setter
    def fit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fit", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> pulumi.Input[_builtins.float]:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> pulumi.Input[_builtins.str]:
        """
        What EXIF data should be preserved in the output image.
        Available values: "keep", "copyright", "none".
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> pulumi.Input[_builtins.float]:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "width", value)


if not MYPY:
    class ImageVariantVariantArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        never_require_signed_urls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the variant can access an image without a signature, regardless of image access control.
        """
        options: NotRequired[pulumi.Input['ImageVariantVariantOptionsArgsDict']]
        """
        Allows you to define image resizing sizes for different use cases.
        """
elif False:
    ImageVariantVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageVariantVariantArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 never_require_signed_urls: Optional[pulumi.Input[_builtins.bool]] = None,
                 options: Optional[pulumi.Input['ImageVariantVariantOptionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] never_require_signed_urls: Indicates whether the variant can access an image without a signature, regardless of image access control.
        :param pulumi.Input['ImageVariantVariantOptionsArgs'] options: Allows you to define image resizing sizes for different use cases.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if never_require_signed_urls is not None:
            pulumi.set(__self__, "never_require_signed_urls", never_require_signed_urls)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="neverRequireSignedUrls")
    def never_require_signed_urls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the variant can access an image without a signature, regardless of image access control.
        """
        return pulumi.get(self, "never_require_signed_urls")

    @never_require_signed_urls.setter
    def never_require_signed_urls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "never_require_signed_urls", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input['ImageVariantVariantOptionsArgs']]:
        """
        Allows you to define image resizing sizes for different use cases.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input['ImageVariantVariantOptionsArgs']]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ImageVariantVariantOptionsArgsDict(TypedDict):
        fit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fit property describes how the width and height dimensions should be interpreted.
        Available values: "scale-down", "contain", "cover", "crop", "pad".
        """
        height: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum height in image pixels.
        """
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        What EXIF data should be preserved in the output image.
        Available values: "keep", "copyright", "none".
        """
        width: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum width in image pixels.
        """
elif False:
    ImageVariantVariantOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageVariantVariantOptionsArgs:
    def __init__(__self__, *,
                 fit: Optional[pulumi.Input[_builtins.str]] = None,
                 height: Optional[pulumi.Input[_builtins.float]] = None,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None,
                 width: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] fit: The fit property describes how the width and height dimensions should be interpreted.
               Available values: "scale-down", "contain", "cover", "crop", "pad".
        :param pulumi.Input[_builtins.float] height: Maximum height in image pixels.
        :param pulumi.Input[_builtins.str] metadata: What EXIF data should be preserved in the output image.
               Available values: "keep", "copyright", "none".
        :param pulumi.Input[_builtins.float] width: Maximum width in image pixels.
        """
        if fit is not None:
            pulumi.set(__self__, "fit", fit)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def fit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fit property describes how the width and height dimensions should be interpreted.
        Available values: "scale-down", "contain", "cover", "crop", "pad".
        """
        return pulumi.get(self, "fit")

    @fit.setter
    def fit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fit", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum height in image pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        What EXIF data should be preserved in the output image.
        Available values: "keep", "copyright", "none".
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum width in image pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class KeylessCertificateTunnelArgsDict(TypedDict):
        private_ip: pulumi.Input[_builtins.str]
        """
        Private IP of the Key Server Host
        """
        vnet_id: pulumi.Input[_builtins.str]
        """
        Cloudflare Tunnel Virtual Network ID
        """
elif False:
    KeylessCertificateTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeylessCertificateTunnelArgs:
    def __init__(__self__, *,
                 private_ip: pulumi.Input[_builtins.str],
                 vnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] private_ip: Private IP of the Key Server Host
        :param pulumi.Input[_builtins.str] vnet_id: Cloudflare Tunnel Virtual Network ID
        """
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Private IP of the Key Server Host
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_ip", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Cloudflare Tunnel Virtual Network ID
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ListItemArgsDict(TypedDict):
        asn: NotRequired[pulumi.Input[_builtins.int]]
        """
        A non-negative 32 bit integer
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        An informative summary of the list item.
        """
        hostname: NotRequired[pulumi.Input['ListItemHostnameArgsDict']]
        """
        Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
        """
        redirect: NotRequired[pulumi.Input['ListItemRedirectArgsDict']]
        """
        The definition of the redirect.
        """
elif False:
    ListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input[_builtins.int]] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input['ListItemHostnameArgs']] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect: Optional[pulumi.Input['ListItemRedirectArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] asn: A non-negative 32 bit integer
        :param pulumi.Input[_builtins.str] comment: An informative summary of the list item.
        :param pulumi.Input['ListItemHostnameArgs'] hostname: Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
        :param pulumi.Input[_builtins.str] ip: An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
        :param pulumi.Input['ListItemRedirectArgs'] redirect: The definition of the redirect.
        """
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A non-negative 32 bit integer
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An informative summary of the list item.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input['ListItemHostnameArgs']]:
        """
        Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input['ListItemHostnameArgs']]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['ListItemRedirectArgs']]:
        """
        The definition of the redirect.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['ListItemRedirectArgs']]):
        pulumi.set(self, "redirect", value)


if not MYPY:
    class ListItemHostnameArgsDict(TypedDict):
        url_hostname: pulumi.Input[_builtins.str]
        exclude_exact_hostname: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
        """
elif False:
    ListItemHostnameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemHostnameArgs:
    def __init__(__self__, *,
                 url_hostname: pulumi.Input[_builtins.str],
                 exclude_exact_hostname: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] exclude_exact_hostname: Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
        """
        pulumi.set(__self__, "url_hostname", url_hostname)
        if exclude_exact_hostname is not None:
            pulumi.set(__self__, "exclude_exact_hostname", exclude_exact_hostname)

    @_builtins.property
    @pulumi.getter(name="urlHostname")
    def url_hostname(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "url_hostname")

    @url_hostname.setter
    def url_hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url_hostname", value)

    @_builtins.property
    @pulumi.getter(name="excludeExactHostname")
    def exclude_exact_hostname(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
        """
        return pulumi.get(self, "exclude_exact_hostname")

    @exclude_exact_hostname.setter
    def exclude_exact_hostname(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_exact_hostname", value)


if not MYPY:
    class ListItemRedirectArgsDict(TypedDict):
        source_url: pulumi.Input[_builtins.str]
        target_url: pulumi.Input[_builtins.str]
        include_subdomains: NotRequired[pulumi.Input[_builtins.bool]]
        preserve_path_suffix: NotRequired[pulumi.Input[_builtins.bool]]
        preserve_query_string: NotRequired[pulumi.Input[_builtins.bool]]
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Available values: 301, 302, 307, 308.
        """
        subpath_matching: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ListItemRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListItemRedirectArgs:
    def __init__(__self__, *,
                 source_url: pulumi.Input[_builtins.str],
                 target_url: pulumi.Input[_builtins.str],
                 include_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 preserve_path_suffix: Optional[pulumi.Input[_builtins.bool]] = None,
                 preserve_query_string: Optional[pulumi.Input[_builtins.bool]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None,
                 subpath_matching: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] status_code: Available values: 301, 302, 307, 308.
        """
        pulumi.set(__self__, "source_url", source_url)
        pulumi.set(__self__, "target_url", target_url)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if preserve_path_suffix is not None:
            pulumi.set(__self__, "preserve_path_suffix", preserve_path_suffix)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if subpath_matching is not None:
            pulumi.set(__self__, "subpath_matching", subpath_matching)

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_url", value)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_url", value)

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_subdomains", value)

    @_builtins.property
    @pulumi.getter(name="preservePathSuffix")
    def preserve_path_suffix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "preserve_path_suffix")

    @preserve_path_suffix.setter
    def preserve_path_suffix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_suffix", value)

    @_builtins.property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Available values: 301, 302, 307, 308.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter(name="subpathMatching")
    def subpath_matching(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "subpath_matching")

    @subpath_matching.setter
    def subpath_matching(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "subpath_matching", value)


if not MYPY:
    class LoadBalancerAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
elif False:
    LoadBalancerAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @_builtins.property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerLocationStrategyArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        prefer_ecs: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
elif False:
    LoadBalancerLocationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 prefer_ecs: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param pulumi.Input[_builtins.str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefer_ecs", value)


if not MYPY:
    class LoadBalancerPoolLoadSheddingArgsDict(TypedDict):
        default_percent: NotRequired[pulumi.Input[_builtins.float]]
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        default_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        Available values: "random", "hash".
        """
        session_percent: NotRequired[pulumi.Input[_builtins.float]]
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        session_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        Available values: "hash".
        """
elif False:
    LoadBalancerPoolLoadSheddingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolLoadSheddingArgs:
    def __init__(__self__, *,
                 default_percent: Optional[pulumi.Input[_builtins.float]] = None,
                 default_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 session_percent: Optional[pulumi.Input[_builtins.float]] = None,
                 session_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] default_percent: The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        :param pulumi.Input[_builtins.str] default_policy: The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
               Available values: "random", "hash".
        :param pulumi.Input[_builtins.float] session_percent: The percent of existing sessions to shed from the pool, according to the session policy.
        :param pulumi.Input[_builtins.str] session_policy: Only the hash policy is supported for existing sessions (to avoid exponential decay).
               Available values: "hash".
        """
        if default_percent is not None:
            pulumi.set(__self__, "default_percent", default_percent)
        if default_policy is not None:
            pulumi.set(__self__, "default_policy", default_policy)
        if session_percent is not None:
            pulumi.set(__self__, "session_percent", session_percent)
        if session_policy is not None:
            pulumi.set(__self__, "session_policy", session_policy)

    @_builtins.property
    @pulumi.getter(name="defaultPercent")
    def default_percent(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
        """
        return pulumi.get(self, "default_percent")

    @default_percent.setter
    def default_percent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "default_percent", value)

    @_builtins.property
    @pulumi.getter(name="defaultPolicy")
    def default_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
        Available values: "random", "hash".
        """
        return pulumi.get(self, "default_policy")

    @default_policy.setter
    def default_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_policy", value)

    @_builtins.property
    @pulumi.getter(name="sessionPercent")
    def session_percent(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The percent of existing sessions to shed from the pool, according to the session policy.
        """
        return pulumi.get(self, "session_percent")

    @session_percent.setter
    def session_percent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "session_percent", value)

    @_builtins.property
    @pulumi.getter(name="sessionPolicy")
    def session_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only the hash policy is supported for existing sessions (to avoid exponential decay).
        Available values: "hash".
        """
        return pulumi.get(self, "session_policy")

    @session_policy.setter
    def session_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_policy", value)


if not MYPY:
    class LoadBalancerPoolNotificationFilterArgsDict(TypedDict):
        origin: NotRequired[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgsDict']]
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        pool: NotRequired[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgsDict']]
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
elif False:
    LoadBalancerPoolNotificationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolNotificationFilterArgs:
    def __init__(__self__, *,
                 origin: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs']] = None,
                 pool: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs']] = None):
        """
        :param pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs'] origin: Filter options for a particular resource type (pool or origin). Use null to reset.
        :param pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs'] pool: Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs']]:
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterOriginArgs']]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs']]:
        """
        Filter options for a particular resource type (pool or origin). Use null to reset.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: Optional[pulumi.Input['LoadBalancerPoolNotificationFilterPoolArgs']]):
        pulumi.set(self, "pool", value)


if not MYPY:
    class LoadBalancerPoolNotificationFilterOriginArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        healthy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
elif False:
    LoadBalancerPoolNotificationFilterOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolNotificationFilterOriginArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[_builtins.bool]] = None,
                 healthy: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable: If set true, disable notifications for this type of resource (pool or origin).
        :param pulumi.Input[_builtins.bool] healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable", value)

    @_builtins.property
    @pulumi.getter
    def healthy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")

    @healthy.setter
    def healthy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "healthy", value)


if not MYPY:
    class LoadBalancerPoolNotificationFilterPoolArgsDict(TypedDict):
        disable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        healthy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
elif False:
    LoadBalancerPoolNotificationFilterPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolNotificationFilterPoolArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input[_builtins.bool]] = None,
                 healthy: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable: If set true, disable notifications for this type of resource (pool or origin).
        :param pulumi.Input[_builtins.bool] healthy: If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if healthy is not None:
            pulumi.set(__self__, "healthy", healthy)

    @_builtins.property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set true, disable notifications for this type of resource (pool or origin).
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable", value)

    @_builtins.property
    @pulumi.getter
    def healthy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
        """
        return pulumi.get(self, "healthy")

    @healthy.setter
    def healthy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "healthy", value)


if not MYPY:
    class LoadBalancerPoolOriginArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        disabled_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        header: NotRequired[pulumi.Input['LoadBalancerPoolOriginHeaderArgsDict']]
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human-identifiable name for the origin.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port for upstream connections. A value of 0 means the default port for the protocol will be used.
        """
        virtual_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
elif False:
    LoadBalancerPoolOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled_at: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 header: Optional[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 virtual_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        :param pulumi.Input[_builtins.str] disabled_at: This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        :param pulumi.Input['LoadBalancerPoolOriginHeaderArgs'] header: The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        :param pulumi.Input[_builtins.str] name: A human-identifiable name for the origin.
        :param pulumi.Input[_builtins.int] port: The port for upstream connections. A value of 0 means the default port for the protocol will be used.
        :param pulumi.Input[_builtins.str] virtual_network_id: The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        :param pulumi.Input[_builtins.float] weight: The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if disabled_at is not None:
            pulumi.set(__self__, "disabled_at", disabled_at)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual*network*id must also be set.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="disabledAt")
    def disabled_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
        """
        return pulumi.get(self, "disabled_at")

    @disabled_at.setter
    def disabled_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disabled_at", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]:
        """
        The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['LoadBalancerPoolOriginHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human-identifiable name for the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port for upstream connections. A value of 0 means the default port for the protocol will be used.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_network_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class LoadBalancerPoolOriginHeaderArgsDict(TypedDict):
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
elif False:
    LoadBalancerPoolOriginHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginHeaderArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] hosts: The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "hosts", value)


if not MYPY:
    class LoadBalancerPoolOriginSteeringArgsDict(TypedDict):
        policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of origin steering policy to use.
        """
elif False:
    LoadBalancerPoolOriginSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerPoolOriginSteeringArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] policy: The type of origin steering policy to use.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of origin steering policy to use.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class LoadBalancerRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
elif False:
    LoadBalancerRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[_builtins.float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]] = None):
        """
        :param pulumi.Input[_builtins.float] default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @_builtins.property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "default_weight", value)

    @_builtins.property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRuleArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        fixed_response: NotRequired[pulumi.Input['LoadBalancerRuleFixedResponseArgsDict']]
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of this rule. Only used for human readability.
        """
        overrides: NotRequired[pulumi.Input['LoadBalancerRuleOverridesArgsDict']]
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        terminates: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
elif False:
    LoadBalancerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 fixed_response: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 overrides: Optional[pulumi.Input['LoadBalancerRuleOverridesArgs']] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 terminates: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] condition: The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        :param pulumi.Input[_builtins.bool] disabled: Disable this specific rule. It will no longer be evaluated by this load balancer.
        :param pulumi.Input['LoadBalancerRuleFixedResponseArgs'] fixed_response: A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        :param pulumi.Input[_builtins.str] name: Name of this rule. Only used for human readability.
        :param pulumi.Input['LoadBalancerRuleOverridesArgs'] overrides: A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        :param pulumi.Input[_builtins.int] priority: The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        :param pulumi.Input[_builtins.bool] terminates: If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if terminates is not None:
            pulumi.set(__self__, "terminates", terminates)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable this specific rule. It will no longer be evaluated by this load balancer.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]:
        """
        A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed*response is supplied the rule will be marked as terminates.
        """
        return pulumi.get(self, "fixed_response")

    @fixed_response.setter
    def fixed_response(self, value: Optional[pulumi.Input['LoadBalancerRuleFixedResponseArgs']]):
        pulumi.set(self, "fixed_response", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of this rule. Only used for human readability.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesArgs']]:
        """
        A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def terminates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
        """
        return pulumi.get(self, "terminates")

    @terminates.setter
    def terminates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "terminates", value)


if not MYPY:
    class LoadBalancerRuleFixedResponseArgsDict(TypedDict):
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The http 'Content-Type' header to include in the response.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The http 'Location' header to include in the response.
        """
        message_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text to include as the http body.
        """
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The http status code to respond with.
        """
elif False:
    LoadBalancerRuleFixedResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleFixedResponseArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 message_body: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] content_type: The http 'Content-Type' header to include in the response.
        :param pulumi.Input[_builtins.str] location: The http 'Location' header to include in the response.
        :param pulumi.Input[_builtins.str] message_body: Text to include as the http body.
        :param pulumi.Input[_builtins.int] status_code: The http status code to respond with.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The http 'Content-Type' header to include in the response.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The http 'Location' header to include in the response.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text to include as the http body.
        """
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_body", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The http status code to respond with.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class LoadBalancerRuleOverridesArgsDict(TypedDict):
        adaptive_routing: NotRequired[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgsDict']]
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        country_pools: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        default_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        fallback_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        location_strategy: NotRequired[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgsDict']]
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        pop_pools: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        random_steering: NotRequired[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgsDict']]
        """
        Configures pool weights.
        """
        region_pools: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        session_affinity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ip_cookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `session_affinity_ttl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `session_affinity_attributes` for additional required configuration.
        Available values: "none", "cookie", "ip_cookie", "header".
        """
        session_affinity_attributes: NotRequired[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict']]
        """
        Configures attributes for session affinity.
        """
        session_affinity_ttl: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are: - `"cookie"` / `"ip_cookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
        """
        steering_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Steering Policy for this load balancer.
        """
        ttl: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
elif False:
    LoadBalancerRuleOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesArgs:
    def __init__(__self__, *,
                 adaptive_routing: Optional[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs']] = None,
                 country_pools: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 default_pools: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 fallback_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 location_strategy: Optional[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs']] = None,
                 pop_pools: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 random_steering: Optional[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs']] = None,
                 region_pools: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 session_affinity: Optional[pulumi.Input[_builtins.str]] = None,
                 session_affinity_attributes: Optional[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs']] = None,
                 session_affinity_ttl: Optional[pulumi.Input[_builtins.float]] = None,
                 steering_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs'] adaptive_routing: Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] country_pools: A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] default_pools: A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        :param pulumi.Input[_builtins.str] fallback_pool: The pool ID to use when all other pools are detected as unhealthy.
        :param pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs'] location_strategy: Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] pop_pools: Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        :param pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs'] random_steering: Configures pool weights.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] region_pools: A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        :param pulumi.Input[_builtins.str] session_affinity: Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ip_cookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `session_affinity_ttl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `session_affinity_attributes` for additional required configuration.
               Available values: "none", "cookie", "ip_cookie", "header".
        :param pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs'] session_affinity_attributes: Configures attributes for session affinity.
        :param pulumi.Input[_builtins.float] session_affinity_ttl: Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are: - `"cookie"` / `"ip_cookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
        :param pulumi.Input[_builtins.str] steering_policy: Steering Policy for this load balancer.
        :param pulumi.Input[_builtins.float] ttl: Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        if adaptive_routing is not None:
            pulumi.set(__self__, "adaptive_routing", adaptive_routing)
        if country_pools is not None:
            pulumi.set(__self__, "country_pools", country_pools)
        if default_pools is not None:
            pulumi.set(__self__, "default_pools", default_pools)
        if fallback_pool is not None:
            pulumi.set(__self__, "fallback_pool", fallback_pool)
        if location_strategy is not None:
            pulumi.set(__self__, "location_strategy", location_strategy)
        if pop_pools is not None:
            pulumi.set(__self__, "pop_pools", pop_pools)
        if random_steering is not None:
            pulumi.set(__self__, "random_steering", random_steering)
        if region_pools is not None:
            pulumi.set(__self__, "region_pools", region_pools)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_attributes is not None:
            pulumi.set(__self__, "session_affinity_attributes", session_affinity_attributes)
        if session_affinity_ttl is not None:
            pulumi.set(__self__, "session_affinity_ttl", session_affinity_ttl)
        if steering_policy is not None:
            pulumi.set(__self__, "steering_policy", steering_policy)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="adaptiveRouting")
    def adaptive_routing(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs']]:
        """
        Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
        """
        return pulumi.get(self, "adaptive_routing")

    @adaptive_routing.setter
    def adaptive_routing(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesAdaptiveRoutingArgs']]):
        pulumi.set(self, "adaptive_routing", value)

    @_builtins.property
    @pulumi.getter(name="countryPools")
    def country_pools(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region*pool mapping if it exists else to default*pools.
        """
        return pulumi.get(self, "country_pools")

    @country_pools.setter
    def country_pools(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "country_pools", value)

    @_builtins.property
    @pulumi.getter(name="defaultPools")
    def default_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
        """
        return pulumi.get(self, "default_pools")

    @default_pools.setter
    def default_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "default_pools", value)

    @_builtins.property
    @pulumi.getter(name="fallbackPool")
    def fallback_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pool ID to use when all other pools are detected as unhealthy.
        """
        return pulumi.get(self, "fallback_pool")

    @fallback_pool.setter
    def fallback_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_pool", value)

    @_builtins.property
    @pulumi.getter(name="locationStrategy")
    def location_strategy(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs']]:
        """
        Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
        """
        return pulumi.get(self, "location_strategy")

    @location_strategy.setter
    def location_strategy(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesLocationStrategyArgs']]):
        pulumi.set(self, "location_strategy", value)

    @_builtins.property
    @pulumi.getter(name="popPools")
    def pop_pools(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country*pool, then region*pool mapping if it exists else to default_pools.
        """
        return pulumi.get(self, "pop_pools")

    @pop_pools.setter
    def pop_pools(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "pop_pools", value)

    @_builtins.property
    @pulumi.getter(name="randomSteering")
    def random_steering(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs']]:
        """
        Configures pool weights.
        """
        return pulumi.get(self, "random_steering")

    @random_steering.setter
    def random_steering(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesRandomSteeringArgs']]):
        pulumi.set(self, "random_steering", value)

    @_builtins.property
    @pulumi.getter(name="regionPools")
    def region_pools(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
        """
        return pulumi.get(self, "region_pools")

    @region_pools.setter
    def region_pools(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "region_pools", value)

    @_builtins.property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are: - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - `"ip_cookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address. - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `session_affinity_ttl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `session_affinity_attributes` for additional required configuration.
        Available values: "none", "cookie", "ip_cookie", "header".
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_affinity", value)

    @_builtins.property
    @pulumi.getter(name="sessionAffinityAttributes")
    def session_affinity_attributes(self) -> Optional[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs']]:
        """
        Configures attributes for session affinity.
        """
        return pulumi.get(self, "session_affinity_attributes")

    @session_affinity_attributes.setter
    def session_affinity_attributes(self, value: Optional[pulumi.Input['LoadBalancerRuleOverridesSessionAffinityAttributesArgs']]):
        pulumi.set(self, "session_affinity_attributes", value)

    @_builtins.property
    @pulumi.getter(name="sessionAffinityTtl")
    def session_affinity_ttl(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are: - `"cookie"` / `"ip_cookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
        """
        return pulumi.get(self, "session_affinity_ttl")

    @session_affinity_ttl.setter
    def session_affinity_ttl(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "session_affinity_ttl", value)

    @_builtins.property
    @pulumi.getter(name="steeringPolicy")
    def steering_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Steering Policy for this load balancer.
        """
        return pulumi.get(self, "steering_policy")

    @steering_policy.setter
    def steering_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "steering_policy", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class LoadBalancerRuleOverridesAdaptiveRoutingArgsDict(TypedDict):
        failover_across_pools: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
elif False:
    LoadBalancerRuleOverridesAdaptiveRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesAdaptiveRoutingArgs:
    def __init__(__self__, *,
                 failover_across_pools: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] failover_across_pools: Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        if failover_across_pools is not None:
            pulumi.set(__self__, "failover_across_pools", failover_across_pools)

    @_builtins.property
    @pulumi.getter(name="failoverAcrossPools")
    def failover_across_pools(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
        """
        return pulumi.get(self, "failover_across_pools")

    @failover_across_pools.setter
    def failover_across_pools(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "failover_across_pools", value)


if not MYPY:
    class LoadBalancerRuleOverridesLocationStrategyArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        prefer_ecs: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
elif False:
    LoadBalancerRuleOverridesLocationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesLocationStrategyArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 prefer_ecs: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        :param pulumi.Input[_builtins.str] prefer_ecs: Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if prefer_ecs is not None:
            pulumi.set(__self__, "prefer_ecs", prefer_ecs)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="preferEcs")
    def prefer_ecs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
        """
        return pulumi.get(self, "prefer_ecs")

    @prefer_ecs.setter
    def prefer_ecs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefer_ecs", value)


if not MYPY:
    class LoadBalancerRuleOverridesRandomSteeringArgsDict(TypedDict):
        default_weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        pool_weights: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
elif False:
    LoadBalancerRuleOverridesRandomSteeringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesRandomSteeringArgs:
    def __init__(__self__, *,
                 default_weight: Optional[pulumi.Input[_builtins.float]] = None,
                 pool_weights: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]] = None):
        """
        :param pulumi.Input[_builtins.float] default_weight: The default weight for pools in the load balancer that are not specified in the pool_weights map.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]] pool_weights: A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        if default_weight is not None:
            pulumi.set(__self__, "default_weight", default_weight)
        if pool_weights is not None:
            pulumi.set(__self__, "pool_weights", pool_weights)

    @_builtins.property
    @pulumi.getter(name="defaultWeight")
    def default_weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The default weight for pools in the load balancer that are not specified in the pool_weights map.
        """
        return pulumi.get(self, "default_weight")

    @default_weight.setter
    def default_weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "default_weight", value)

    @_builtins.property
    @pulumi.getter(name="poolWeights")
    def pool_weights(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]:
        """
        A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
        """
        return pulumi.get(self, "pool_weights")

    @pool_weights.setter
    def pool_weights(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.float]]]]):
        pulumi.set(self, "pool_weights", value)


if not MYPY:
    class LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict(TypedDict):
        drain_duration: NotRequired[pulumi.Input[_builtins.float]]
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        require_all_headers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
        """
        samesite: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        Available values: "Auto", "Lax", "None", "Strict".
        """
        secure: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        Available values: "Auto", "Always", "Never".
        """
        zero_downtime_failover: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
        Available values: "none", "temporary", "sticky".
        """
elif False:
    LoadBalancerRuleOverridesSessionAffinityAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerRuleOverridesSessionAffinityAttributesArgs:
    def __init__(__self__, *,
                 drain_duration: Optional[pulumi.Input[_builtins.float]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[_builtins.bool]] = None,
                 samesite: Optional[pulumi.Input[_builtins.str]] = None,
                 secure: Optional[pulumi.Input[_builtins.str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param pulumi.Input[_builtins.bool] require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
        :param pulumi.Input[_builtins.str] samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
               Available values: "Auto", "Lax", "None", "Strict".
        :param pulumi.Input[_builtins.str] secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
               Available values: "Auto", "Always", "Never".
        :param pulumi.Input[_builtins.str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
               Available values: "none", "temporary", "sticky".
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @_builtins.property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @drain_duration.setter
    def drain_duration(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "drain_duration", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_all_headers", value)

    @_builtins.property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        Available values: "Auto", "Lax", "None", "Strict".
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "samesite", value)

    @_builtins.property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        Available values: "Auto", "Always", "Never".
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure", value)

    @_builtins.property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
        Available values: "none", "temporary", "sticky".
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zero_downtime_failover", value)


if not MYPY:
    class LoadBalancerSessionAffinityAttributesArgsDict(TypedDict):
        drain_duration: NotRequired[pulumi.Input[_builtins.float]]
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        require_all_headers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
        """
        samesite: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        Available values: "Auto", "Lax", "None", "Strict".
        """
        secure: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        Available values: "Auto", "Always", "Never".
        """
        zero_downtime_failover: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
        Available values: "none", "temporary", "sticky".
        """
elif False:
    LoadBalancerSessionAffinityAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerSessionAffinityAttributesArgs:
    def __init__(__self__, *,
                 drain_duration: Optional[pulumi.Input[_builtins.float]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 require_all_headers: Optional[pulumi.Input[_builtins.bool]] = None,
                 samesite: Optional[pulumi.Input[_builtins.str]] = None,
                 secure: Optional[pulumi.Input[_builtins.str]] = None,
                 zero_downtime_failover: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] drain_duration: Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        :param pulumi.Input[_builtins.bool] require_all_headers: When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
        :param pulumi.Input[_builtins.str] samesite: Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
               Available values: "Auto", "Lax", "None", "Strict".
        :param pulumi.Input[_builtins.str] secure: Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
               Available values: "Auto", "Always", "Never".
        :param pulumi.Input[_builtins.str] zero_downtime_failover: Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
               Available values: "none", "temporary", "sticky".
        """
        if drain_duration is not None:
            pulumi.set(__self__, "drain_duration", drain_duration)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if require_all_headers is not None:
            pulumi.set(__self__, "require_all_headers", require_all_headers)
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if zero_downtime_failover is not None:
            pulumi.set(__self__, "zero_downtime_failover", zero_downtime_failover)

    @_builtins.property
    @pulumi.getter(name="drainDuration")
    def drain_duration(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
        """
        return pulumi.get(self, "drain_duration")

    @drain_duration.setter
    def drain_duration(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "drain_duration", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="requireAllHeaders")
    def require_all_headers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created. - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
        """
        return pulumi.get(self, "require_all_headers")

    @require_all_headers.setter
    def require_all_headers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_all_headers", value)

    @_builtins.property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
        Available values: "Auto", "Lax", "None", "Strict".
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "samesite", value)

    @_builtins.property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
        Available values: "Auto", "Always", "Never".
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure", value)

    @_builtins.property
    @pulumi.getter(name="zeroDowntimeFailover")
    def zero_downtime_failover(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - `"none"`: No failover takes place for sessions pinned to the origin (default). - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
        Available values: "none", "temporary", "sticky".
        """
        return pulumi.get(self, "zero_downtime_failover")

    @zero_downtime_failover.setter
    def zero_downtime_failover(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zero_downtime_failover", value)


if not MYPY:
    class LogpushJobOutputOptionsArgsDict(TypedDict):
        batch_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be prepended before each batch.
        """
        batch_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be appended after each batch.
        """
        cve202144228: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        field_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        output_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        Available values: "ndjson", "csv".
        """
        record_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be inserted in-between the records as separator.
        """
        record_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be prepended before each record.
        """
        record_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to be appended after each record.
        """
        record_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        sample_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        Available values: "unixnano", "unix", "rfc3339".
        """
elif False:
    LogpushJobOutputOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogpushJobOutputOptionsArgs:
    def __init__(__self__, *,
                 batch_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 batch_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 cve202144228: Optional[pulumi.Input[_builtins.bool]] = None,
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 output_type: Optional[pulumi.Input[_builtins.str]] = None,
                 record_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 record_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 record_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 record_template: Optional[pulumi.Input[_builtins.str]] = None,
                 sample_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] batch_prefix: String to be prepended before each batch.
        :param pulumi.Input[_builtins.str] batch_suffix: String to be appended after each batch.
        :param pulumi.Input[_builtins.bool] cve202144228: If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        :param pulumi.Input[_builtins.str] field_delimiter: String to join fields. This field be ignored when `record_template` is set.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] field_names: List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        :param pulumi.Input[_builtins.str] output_type: Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
               Available values: "ndjson", "csv".
        :param pulumi.Input[_builtins.str] record_delimiter: String to be inserted in-between the records as separator.
        :param pulumi.Input[_builtins.str] record_prefix: String to be prepended before each record.
        :param pulumi.Input[_builtins.str] record_suffix: String to be appended after each record.
        :param pulumi.Input[_builtins.str] record_template: String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        :param pulumi.Input[_builtins.float] sample_rate: Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        :param pulumi.Input[_builtins.str] timestamp_format: String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
               Available values: "unixnano", "unix", "rfc3339".
        """
        if batch_prefix is not None:
            pulumi.set(__self__, "batch_prefix", batch_prefix)
        if batch_suffix is not None:
            pulumi.set(__self__, "batch_suffix", batch_suffix)
        if cve202144228 is not None:
            pulumi.set(__self__, "cve202144228", cve202144228)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if output_type is not None:
            pulumi.set(__self__, "output_type", output_type)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if record_prefix is not None:
            pulumi.set(__self__, "record_prefix", record_prefix)
        if record_suffix is not None:
            pulumi.set(__self__, "record_suffix", record_suffix)
        if record_template is not None:
            pulumi.set(__self__, "record_template", record_template)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="batchPrefix")
    def batch_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be prepended before each batch.
        """
        return pulumi.get(self, "batch_prefix")

    @batch_prefix.setter
    def batch_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "batch_prefix", value)

    @_builtins.property
    @pulumi.getter(name="batchSuffix")
    def batch_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be appended after each batch.
        """
        return pulumi.get(self, "batch_suffix")

    @batch_suffix.setter
    def batch_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "batch_suffix", value)

    @_builtins.property
    @pulumi.getter
    def cve202144228(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
        """
        return pulumi.get(self, "cve202144228")

    @cve202144228.setter
    def cve202144228(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cve202144228", value)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to join fields. This field be ignored when `record_template` is set.
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "field_names", value)

    @_builtins.property
    @pulumi.getter(name="outputType")
    def output_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
        Available values: "ndjson", "csv".
        """
        return pulumi.get(self, "output_type")

    @output_type.setter
    def output_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_type", value)

    @_builtins.property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be inserted in-between the records as separator.
        """
        return pulumi.get(self, "record_delimiter")

    @record_delimiter.setter
    def record_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="recordPrefix")
    def record_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be prepended before each record.
        """
        return pulumi.get(self, "record_prefix")

    @record_prefix.setter
    def record_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_prefix", value)

    @_builtins.property
    @pulumi.getter(name="recordSuffix")
    def record_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to be appended after each record.
        """
        return pulumi.get(self, "record_suffix")

    @record_suffix.setter
    def record_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_suffix", value)

    @_builtins.property
    @pulumi.getter(name="recordTemplate")
    def record_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
        """
        return pulumi.get(self, "record_template")

    @record_template.setter
    def record_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_template", value)

    @_builtins.property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "sample_rate", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
        Available values: "unixnano", "unix", "rfc3339".
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class MagicNetworkMonitoringConfigurationWarpDeviceArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for the warp device.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the warp device.
        """
        router_ip: pulumi.Input[_builtins.str]
        """
        IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
elif False:
    MagicNetworkMonitoringConfigurationWarpDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicNetworkMonitoringConfigurationWarpDeviceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 router_ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Unique identifier for the warp device.
        :param pulumi.Input[_builtins.str] name: Name of the warp device.
        :param pulumi.Input[_builtins.str] router_ip: IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "router_ip", router_ip)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for the warp device.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the warp device.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="routerIp")
    def router_ip(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
        """
        return pulumi.get(self, "router_ip")

    @router_ip.setter
    def router_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "router_ip", value)


if not MYPY:
    class MagicTransitConnectorDeviceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        serial_number: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    MagicTransitConnectorDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitConnectorDeviceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)


if not MYPY:
    class MagicTransitSiteAclLan1ArgsDict(TypedDict):
        lan_id: pulumi.Input[_builtins.str]
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        lan_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the LAN based on the provided lan_id.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
elif False:
    MagicTransitSiteAclLan1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteAclLan1Args:
    def __init__(__self__, *,
                 lan_id: pulumi.Input[_builtins.str],
                 lan_name: Optional[pulumi.Input[_builtins.str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param pulumi.Input[_builtins.str] lan_name: The name of the LAN based on the provided lan_id.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lan_id", value)

    @_builtins.property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @lan_name.setter
    def lan_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_name", value)

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "port_ranges", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class MagicTransitSiteAclLan2ArgsDict(TypedDict):
        lan_id: pulumi.Input[_builtins.str]
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        lan_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the LAN based on the provided lan_id.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
elif False:
    MagicTransitSiteAclLan2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteAclLan2Args:
    def __init__(__self__, *,
                 lan_id: pulumi.Input[_builtins.str],
                 lan_name: Optional[pulumi.Input[_builtins.str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] lan_id: The identifier for the LAN you want to create an ACL policy with.
        :param pulumi.Input[_builtins.str] lan_name: The name of the LAN based on the provided lan_id.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] port_ranges: Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ports: Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnets: Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        pulumi.set(__self__, "lan_id", lan_id)
        if lan_name is not None:
            pulumi.set(__self__, "lan_name", lan_name)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="lanId")
    def lan_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for the LAN you want to create an ACL policy with.
        """
        return pulumi.get(self, "lan_id")

    @lan_id.setter
    def lan_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lan_id", value)

    @_builtins.property
    @pulumi.getter(name="lanName")
    def lan_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the LAN based on the provided lan_id.
        """
        return pulumi.get(self, "lan_name")

    @lan_name.setter
    def lan_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lan_name", value)

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "port_ranges", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class MagicTransitSiteLanNatArgsDict(TypedDict):
        static_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteLanNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanNatArgs:
    def __init__(__self__, *,
                 static_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] static_prefix: A valid CIDR notation representing an IP range.
        """
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")

    @static_prefix.setter
    def static_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_prefix", value)


if not MYPY:
    class MagicTransitSiteLanRoutedSubnetArgsDict(TypedDict):
        next_hop: pulumi.Input[_builtins.str]
        """
        A valid IPv4 address.
        """
        prefix: pulumi.Input[_builtins.str]
        """
        A valid CIDR notation representing an IP range.
        """
        nat: NotRequired[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgsDict']]
elif False:
    MagicTransitSiteLanRoutedSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanRoutedSubnetArgs:
    def __init__(__self__, *,
                 next_hop: pulumi.Input[_builtins.str],
                 prefix: pulumi.Input[_builtins.str],
                 nat: Optional[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] next_hop: A valid IPv4 address.
        :param pulumi.Input[_builtins.str] prefix: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "next_hop", next_hop)
        pulumi.set(__self__, "prefix", prefix)
        if nat is not None:
            pulumi.set(__self__, "nat", nat)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> pulumi.Input[_builtins.str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "next_hop", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def nat(self) -> Optional[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgs']]:
        return pulumi.get(self, "nat")

    @nat.setter
    def nat(self, value: Optional[pulumi.Input['MagicTransitSiteLanRoutedSubnetNatArgs']]):
        pulumi.set(self, "nat", value)


if not MYPY:
    class MagicTransitSiteLanRoutedSubnetNatArgsDict(TypedDict):
        static_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteLanRoutedSubnetNatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanRoutedSubnetNatArgs:
    def __init__(__self__, *,
                 static_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] static_prefix: A valid CIDR notation representing an IP range.
        """
        if static_prefix is not None:
            pulumi.set(__self__, "static_prefix", static_prefix)

    @_builtins.property
    @pulumi.getter(name="staticPrefix")
    def static_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "static_prefix")

    @static_prefix.setter
    def static_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "static_prefix", value)


if not MYPY:
    class MagicTransitSiteLanStaticAddressingArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        A valid CIDR notation representing an IP range.
        """
        dhcp_relay: NotRequired[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict']]
        dhcp_server: NotRequired[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgsDict']]
        secondary_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid CIDR notation representing an IP range.
        """
        virtual_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteLanStaticAddressingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanStaticAddressingArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 dhcp_relay: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgs']] = None,
                 dhcp_server: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgs']] = None,
                 secondary_address: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: A valid CIDR notation representing an IP range.
        :param pulumi.Input[_builtins.str] secondary_address: A valid CIDR notation representing an IP range.
        :param pulumi.Input[_builtins.str] virtual_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        if dhcp_relay is not None:
            pulumi.set(__self__, "dhcp_relay", dhcp_relay)
        if dhcp_server is not None:
            pulumi.set(__self__, "dhcp_server", dhcp_server)
        if secondary_address is not None:
            pulumi.set(__self__, "secondary_address", secondary_address)
        if virtual_address is not None:
            pulumi.set(__self__, "virtual_address", virtual_address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="dhcpRelay")
    def dhcp_relay(self) -> Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgs']]:
        return pulumi.get(self, "dhcp_relay")

    @dhcp_relay.setter
    def dhcp_relay(self, value: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpRelayArgs']]):
        pulumi.set(self, "dhcp_relay", value)

    @_builtins.property
    @pulumi.getter(name="dhcpServer")
    def dhcp_server(self) -> Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgs']]:
        return pulumi.get(self, "dhcp_server")

    @dhcp_server.setter
    def dhcp_server(self, value: Optional[pulumi.Input['MagicTransitSiteLanStaticAddressingDhcpServerArgs']]):
        pulumi.set(self, "dhcp_server", value)

    @_builtins.property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @secondary_address.setter
    def secondary_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_address", value)

    @_builtins.property
    @pulumi.getter(name="virtualAddress")
    def virtual_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "virtual_address")

    @virtual_address.setter
    def virtual_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_address", value)


if not MYPY:
    class MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict(TypedDict):
        server_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of DHCP server IPs.
        """
elif False:
    MagicTransitSiteLanStaticAddressingDhcpRelayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanStaticAddressingDhcpRelayArgs:
    def __init__(__self__, *,
                 server_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] server_addresses: List of DHCP server IPs.
        """
        if server_addresses is not None:
            pulumi.set(__self__, "server_addresses", server_addresses)

    @_builtins.property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of DHCP server IPs.
        """
        return pulumi.get(self, "server_addresses")

    @server_addresses.setter
    def server_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "server_addresses", value)


if not MYPY:
    class MagicTransitSiteLanStaticAddressingDhcpServerArgsDict(TypedDict):
        dhcp_pool_end: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid IPv4 address.
        """
        dhcp_pool_start: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid IPv4 address.
        """
        dns_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid IPv4 address.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        reservations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Mapping of MAC addresses to IP addresses
        """
elif False:
    MagicTransitSiteLanStaticAddressingDhcpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLanStaticAddressingDhcpServerArgs:
    def __init__(__self__, *,
                 dhcp_pool_end: Optional[pulumi.Input[_builtins.str]] = None,
                 dhcp_pool_start: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_server: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 reservations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] dhcp_pool_end: A valid IPv4 address.
        :param pulumi.Input[_builtins.str] dhcp_pool_start: A valid IPv4 address.
        :param pulumi.Input[_builtins.str] dns_server: A valid IPv4 address.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] reservations: Mapping of MAC addresses to IP addresses
        """
        if dhcp_pool_end is not None:
            pulumi.set(__self__, "dhcp_pool_end", dhcp_pool_end)
        if dhcp_pool_start is not None:
            pulumi.set(__self__, "dhcp_pool_start", dhcp_pool_start)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if reservations is not None:
            pulumi.set(__self__, "reservations", reservations)

    @_builtins.property
    @pulumi.getter(name="dhcpPoolEnd")
    def dhcp_pool_end(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_end")

    @dhcp_pool_end.setter
    def dhcp_pool_end(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dhcp_pool_end", value)

    @_builtins.property
    @pulumi.getter(name="dhcpPoolStart")
    def dhcp_pool_start(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dhcp_pool_start")

    @dhcp_pool_start.setter
    def dhcp_pool_start(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dhcp_pool_start", value)

    @_builtins.property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "dns_server")

    @dns_server.setter
    def dns_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_server", value)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @_builtins.property
    @pulumi.getter
    def reservations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Mapping of MAC addresses to IP addresses
        """
        return pulumi.get(self, "reservations")

    @reservations.setter
    def reservations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "reservations", value)


if not MYPY:
    class MagicTransitSiteLocationArgsDict(TypedDict):
        lat: NotRequired[pulumi.Input[_builtins.str]]
        """
        Latitude
        """
        lon: NotRequired[pulumi.Input[_builtins.str]]
        """
        Longitude
        """
elif False:
    MagicTransitSiteLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteLocationArgs:
    def __init__(__self__, *,
                 lat: Optional[pulumi.Input[_builtins.str]] = None,
                 lon: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] lat: Latitude
        :param pulumi.Input[_builtins.str] lon: Longitude
        """
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Latitude
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lon(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Longitude
        """
        return pulumi.get(self, "lon")

    @lon.setter
    def lon(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lon", value)


if not MYPY:
    class MagicTransitSiteWanStaticAddressingArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        A valid CIDR notation representing an IP range.
        """
        gateway_address: pulumi.Input[_builtins.str]
        """
        A valid IPv4 address.
        """
        secondary_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        A valid CIDR notation representing an IP range.
        """
elif False:
    MagicTransitSiteWanStaticAddressingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicTransitSiteWanStaticAddressingArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 gateway_address: pulumi.Input[_builtins.str],
                 secondary_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: A valid CIDR notation representing an IP range.
        :param pulumi.Input[_builtins.str] gateway_address: A valid IPv4 address.
        :param pulumi.Input[_builtins.str] secondary_address: A valid CIDR notation representing an IP range.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "gateway_address", gateway_address)
        if secondary_address is not None:
            pulumi.set(__self__, "secondary_address", secondary_address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="gatewayAddress")
    def gateway_address(self) -> pulumi.Input[_builtins.str]:
        """
        A valid IPv4 address.
        """
        return pulumi.get(self, "gateway_address")

    @gateway_address.setter
    def gateway_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "gateway_address", value)

    @_builtins.property
    @pulumi.getter(name="secondaryAddress")
    def secondary_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A valid CIDR notation representing an IP range.
        """
        return pulumi.get(self, "secondary_address")

    @secondary_address.setter
    def secondary_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_address", value)


if not MYPY:
    class MagicWanGreTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        Available values: "unidirectional", "bidirectional".
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[_builtins.str]]
        """
        How frequent the health check is run. The default value is `mid`.
        Available values: "low", "mid", "high".
        """
        target: NotRequired[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        Available values: "reply", "request".
        """
elif False:
    MagicWanGreTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 rate: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
               Available values: "unidirectional", "bidirectional".
        :param pulumi.Input[_builtins.bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[_builtins.str] rate: How frequent the health check is run. The default value is `mid`.
               Available values: "low", "mid", "high".
        :param pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[_builtins.str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
               Available values: "reply", "request".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        Available values: "unidirectional", "bidirectional".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        Available values: "low", "mid", "high".
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rate", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanGreTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        Available values: "reply", "request".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanGreTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[_builtins.str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[_builtins.str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanGreTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanGreTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[_builtins.str]] = None,
                 saved: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[_builtins.str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective", value)

    @_builtins.property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanIpsecTunnelHealthCheckArgsDict(TypedDict):
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        Available values: "unidirectional", "bidirectional".
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether to run healthchecks for a tunnel.
        """
        rate: NotRequired[pulumi.Input[_builtins.str]]
        """
        How frequent the health check is run. The default value is `mid`.
        Available values: "low", "mid", "high".
        """
        target: NotRequired[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgsDict']]
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        Available values: "reply", "request".
        """
elif False:
    MagicWanIpsecTunnelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelHealthCheckArgs:
    def __init__(__self__, *,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 rate: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] direction: The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
               Available values: "unidirectional", "bidirectional".
        :param pulumi.Input[_builtins.bool] enabled: Determines whether to run healthchecks for a tunnel.
        :param pulumi.Input[_builtins.str] rate: How frequent the health check is run. The default value is `mid`.
               Available values: "low", "mid", "high".
        :param pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs'] target: The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        :param pulumi.Input[_builtins.str] type: The type of healthcheck to run, reply or request. The default value is `reply`.
               Available values: "reply", "request".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
        Available values: "unidirectional", "bidirectional".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to run healthchecks for a tunnel.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def rate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How frequent the health check is run. The default value is `mid`.
        Available values: "low", "mid", "high".
        """
        return pulumi.get(self, "rate")

    @rate.setter
    def rate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rate", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs']]:
        """
        The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface*address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MagicWanIpsecTunnelHealthCheckTargetArgs']]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of healthcheck to run, reply or request. The default value is `reply`.
        Available values: "reply", "request".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MagicWanIpsecTunnelHealthCheckTargetArgsDict(TypedDict):
        effective: NotRequired[pulumi.Input[_builtins.str]]
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        saved: NotRequired[pulumi.Input[_builtins.str]]
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
elif False:
    MagicWanIpsecTunnelHealthCheckTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelHealthCheckTargetArgs:
    def __init__(__self__, *,
                 effective: Optional[pulumi.Input[_builtins.str]] = None,
                 saved: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effective: The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        :param pulumi.Input[_builtins.str] saved: The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        if effective is not None:
            pulumi.set(__self__, "effective", effective)
        if saved is not None:
            pulumi.set(__self__, "saved", saved)

    @_builtins.property
    @pulumi.getter
    def effective(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
        """
        return pulumi.get(self, "effective")

    @effective.setter
    def effective(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective", value)

    @_builtins.property
    @pulumi.getter
    def saved(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
        """
        return pulumi.get(self, "saved")

    @saved.setter
    def saved(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "saved", value)


if not MYPY:
    class MagicWanIpsecTunnelPskMetadataArgsDict(TypedDict):
        last_generated_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time the tunnel was last modified.
        """
elif False:
    MagicWanIpsecTunnelPskMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanIpsecTunnelPskMetadataArgs:
    def __init__(__self__, *,
                 last_generated_on: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_generated_on: The date and time the tunnel was last modified.
        """
        if last_generated_on is not None:
            pulumi.set(__self__, "last_generated_on", last_generated_on)

    @_builtins.property
    @pulumi.getter(name="lastGeneratedOn")
    def last_generated_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time the tunnel was last modified.
        """
        return pulumi.get(self, "last_generated_on")

    @last_generated_on.setter
    def last_generated_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_generated_on", value)


if not MYPY:
    class MagicWanStaticRouteScopeArgsDict(TypedDict):
        colo_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of colo names for the ECMP scope.
        """
        colo_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of colo regions for the ECMP scope.
        """
elif False:
    MagicWanStaticRouteScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MagicWanStaticRouteScopeArgs:
    def __init__(__self__, *,
                 colo_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 colo_regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] colo_names: List of colo names for the ECMP scope.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @_builtins.property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @colo_names.setter
    def colo_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "colo_names", value)

    @_builtins.property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")

    @colo_regions.setter
    def colo_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "colo_regions", value)


if not MYPY:
    class ManagedHeadersManagedRequestHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the Managed Transform is enabled.
        """
        id: pulumi.Input[_builtins.str]
        """
        The human-readable identifier of the Managed Transform.
        """
elif False:
    ManagedHeadersManagedRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedHeadersManagedRequestHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the Managed Transform is enabled.
        :param pulumi.Input[_builtins.str] id: The human-readable identifier of the Managed Transform.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedHeadersManagedResponseHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the Managed Transform is enabled.
        """
        id: pulumi.Input[_builtins.str]
        """
        The human-readable identifier of the Managed Transform.
        """
elif False:
    ManagedHeadersManagedResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedHeadersManagedResponseHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the Managed Transform is enabled.
        :param pulumi.Input[_builtins.str] id: The human-readable identifier of the Managed Transform.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedTransformsManagedRequestHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the Managed Transform is enabled.
        """
        id: pulumi.Input[_builtins.str]
        """
        The human-readable identifier of the Managed Transform.
        """
elif False:
    ManagedTransformsManagedRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedTransformsManagedRequestHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the Managed Transform is enabled.
        :param pulumi.Input[_builtins.str] id: The human-readable identifier of the Managed Transform.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ManagedTransformsManagedResponseHeaderArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the Managed Transform is enabled.
        """
        id: pulumi.Input[_builtins.str]
        """
        The human-readable identifier of the Managed Transform.
        """
elif False:
    ManagedTransformsManagedResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedTransformsManagedResponseHeaderArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the Managed Transform is enabled.
        :param pulumi.Input[_builtins.str] id: The human-readable identifier of the Managed Transform.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the Managed Transform is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The human-readable identifier of the Managed Transform.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NotificationPolicyFiltersArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        affected_asns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring radar_notification
        """
        affected_components: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring incident_alert
        """
        affected_locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring radar_notification
        """
        airport_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring maintenance*event*notification
        """
        alert_trigger_preferences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        alert_trigger_preferences_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        enableds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring pages*event*alert
        """
        event_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring load*balancing*health_alert
        """
        event_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring pages*event*alert
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        health_check_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring health*check*status_notification
        """
        incident_impacts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring incident_alert
        """
        input_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring stream*live*notifications
        """
        insight_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring security*insights*alert
        """
        limits: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring billing*usage*alert
        """
        logo_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring logo*match*alert
        """
        megabits_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        new_healths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring load*balancing*health_alert
        """
        new_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring tunnel*health*event
        """
        packets_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        pool_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        pop_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring billing*usage*alert
        """
        project_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring pages*event*alert
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        query_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        requests_per_seconds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        slos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring health*check*status_notification
        """
        target_hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        target_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        target_zone_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        traffic_exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring traffic*anomalies*alert
        """
        tunnel_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Used for configuring tunnel*health*event
        """
        tunnel_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        wheres: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
        zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Usage depends on specific alert type
        """
elif False:
    NotificationPolicyFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyFiltersArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 affected_asns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 affected_components: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 affected_locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 airport_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 alert_trigger_preferences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 alert_trigger_preferences_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 enableds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 event_sources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 event_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 health_check_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 incident_impacts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 input_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 insight_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 limits: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 logo_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 megabits_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_healths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 packets_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pop_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 query_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 requests_per_seconds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 target_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 target_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 target_zone_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 traffic_exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tunnel_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tunnel_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 wheres: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] affected_asns: Used for configuring radar_notification
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] affected_components: Used for configuring incident_alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] affected_locations: Used for configuring radar_notification
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] airport_codes: Used for configuring maintenance*event*notification
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alert_trigger_preferences: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alert_trigger_preferences_values: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enableds: Used for configuring load*balancing*pool*enablement*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] environments: Used for configuring pages*event*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] event_sources: Used for configuring load*balancing*health_alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] event_types: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] events: Used for configuring pages*event*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] health_check_ids: Used for configuring health*check*status_notification
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] incident_impacts: Used for configuring incident_alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] input_ids: Used for configuring stream*live*notifications
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] insight_classes: Used for configuring security*insights*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] limits: Used for configuring billing*usage*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] logo_tags: Used for configuring logo*match*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] megabits_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] new_healths: Used for configuring load*balancing*health_alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] new_statuses: Used for configuring tunnel*health*event
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] packets_per_seconds: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pool_ids: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pop_names: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: Used for configuring billing*usage*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] project_ids: Used for configuring pages*event*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] protocols: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] query_tags: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requests_per_seconds: Used for configuring advanced*ddos*attack*l7*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selectors: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: Used for configuring clickhouse*alert*fw*ent*anomaly
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] slos: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] statuses: Used for configuring health*check*status_notification
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] target_hostnames: Used for configuring advanced*ddos*attack*l7*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] target_ips: Used for configuring advanced*ddos*attack*l4*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] target_zone_names: Used for configuring advanced*ddos*attack*l7*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] traffic_exclusions: Used for configuring traffic*anomalies*alert
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tunnel_ids: Used for configuring tunnel*health*event
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tunnel_names: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] wheres: Usage depends on specific alert type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Usage depends on specific alert type
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if affected_asns is not None:
            pulumi.set(__self__, "affected_asns", affected_asns)
        if affected_components is not None:
            pulumi.set(__self__, "affected_components", affected_components)
        if affected_locations is not None:
            pulumi.set(__self__, "affected_locations", affected_locations)
        if airport_codes is not None:
            pulumi.set(__self__, "airport_codes", airport_codes)
        if alert_trigger_preferences is not None:
            pulumi.set(__self__, "alert_trigger_preferences", alert_trigger_preferences)
        if alert_trigger_preferences_values is not None:
            pulumi.set(__self__, "alert_trigger_preferences_values", alert_trigger_preferences_values)
        if enableds is not None:
            pulumi.set(__self__, "enableds", enableds)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if event_sources is not None:
            pulumi.set(__self__, "event_sources", event_sources)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if health_check_ids is not None:
            pulumi.set(__self__, "health_check_ids", health_check_ids)
        if incident_impacts is not None:
            pulumi.set(__self__, "incident_impacts", incident_impacts)
        if input_ids is not None:
            pulumi.set(__self__, "input_ids", input_ids)
        if insight_classes is not None:
            pulumi.set(__self__, "insight_classes", insight_classes)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if logo_tags is not None:
            pulumi.set(__self__, "logo_tags", logo_tags)
        if megabits_per_seconds is not None:
            pulumi.set(__self__, "megabits_per_seconds", megabits_per_seconds)
        if new_healths is not None:
            pulumi.set(__self__, "new_healths", new_healths)
        if new_statuses is not None:
            pulumi.set(__self__, "new_statuses", new_statuses)
        if packets_per_seconds is not None:
            pulumi.set(__self__, "packets_per_seconds", packets_per_seconds)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if pop_names is not None:
            pulumi.set(__self__, "pop_names", pop_names)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if project_ids is not None:
            pulumi.set(__self__, "project_ids", project_ids)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if query_tags is not None:
            pulumi.set(__self__, "query_tags", query_tags)
        if requests_per_seconds is not None:
            pulumi.set(__self__, "requests_per_seconds", requests_per_seconds)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if slos is not None:
            pulumi.set(__self__, "slos", slos)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if target_hostnames is not None:
            pulumi.set(__self__, "target_hostnames", target_hostnames)
        if target_ips is not None:
            pulumi.set(__self__, "target_ips", target_ips)
        if target_zone_names is not None:
            pulumi.set(__self__, "target_zone_names", target_zone_names)
        if traffic_exclusions is not None:
            pulumi.set(__self__, "traffic_exclusions", traffic_exclusions)
        if tunnel_ids is not None:
            pulumi.set(__self__, "tunnel_ids", tunnel_ids)
        if tunnel_names is not None:
            pulumi.set(__self__, "tunnel_names", tunnel_names)
        if wheres is not None:
            pulumi.set(__self__, "wheres", wheres)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="affectedAsns")
    def affected_asns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_asns")

    @affected_asns.setter
    def affected_asns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "affected_asns", value)

    @_builtins.property
    @pulumi.getter(name="affectedComponents")
    def affected_components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "affected_components")

    @affected_components.setter
    def affected_components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "affected_components", value)

    @_builtins.property
    @pulumi.getter(name="affectedLocations")
    def affected_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring radar_notification
        """
        return pulumi.get(self, "affected_locations")

    @affected_locations.setter
    def affected_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "affected_locations", value)

    @_builtins.property
    @pulumi.getter(name="airportCodes")
    def airport_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring maintenance*event*notification
        """
        return pulumi.get(self, "airport_codes")

    @airport_codes.setter
    def airport_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "airport_codes", value)

    @_builtins.property
    @pulumi.getter(name="alertTriggerPreferences")
    def alert_trigger_preferences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences")

    @alert_trigger_preferences.setter
    def alert_trigger_preferences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alert_trigger_preferences", value)

    @_builtins.property
    @pulumi.getter(name="alertTriggerPreferencesValues")
    def alert_trigger_preferences_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "alert_trigger_preferences_values")

    @alert_trigger_preferences_values.setter
    def alert_trigger_preferences_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alert_trigger_preferences_values", value)

    @_builtins.property
    @pulumi.getter
    def enableds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring load*balancing*pool*enablement*alert
        """
        return pulumi.get(self, "enableds")

    @enableds.setter
    def enableds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enableds", value)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environments", value)

    @_builtins.property
    @pulumi.getter(name="eventSources")
    def event_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "event_sources")

    @event_sources.setter
    def event_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "event_sources", value)

    @_builtins.property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "event_types")

    @event_types.setter
    def event_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "event_types", value)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter(name="healthCheckIds")
    def health_check_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "health_check_ids")

    @health_check_ids.setter
    def health_check_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "health_check_ids", value)

    @_builtins.property
    @pulumi.getter(name="incidentImpacts")
    def incident_impacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring incident_alert
        """
        return pulumi.get(self, "incident_impacts")

    @incident_impacts.setter
    def incident_impacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "incident_impacts", value)

    @_builtins.property
    @pulumi.getter(name="inputIds")
    def input_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring stream*live*notifications
        """
        return pulumi.get(self, "input_ids")

    @input_ids.setter
    def input_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_ids", value)

    @_builtins.property
    @pulumi.getter(name="insightClasses")
    def insight_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring security*insights*alert
        """
        return pulumi.get(self, "insight_classes")

    @insight_classes.setter
    def insight_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "insight_classes", value)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter(name="logoTags")
    def logo_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring logo*match*alert
        """
        return pulumi.get(self, "logo_tags")

    @logo_tags.setter
    def logo_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "logo_tags", value)

    @_builtins.property
    @pulumi.getter(name="megabitsPerSeconds")
    def megabits_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "megabits_per_seconds")

    @megabits_per_seconds.setter
    def megabits_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "megabits_per_seconds", value)

    @_builtins.property
    @pulumi.getter(name="newHealths")
    def new_healths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring load*balancing*health_alert
        """
        return pulumi.get(self, "new_healths")

    @new_healths.setter
    def new_healths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "new_healths", value)

    @_builtins.property
    @pulumi.getter(name="newStatuses")
    def new_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "new_statuses")

    @new_statuses.setter
    def new_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "new_statuses", value)

    @_builtins.property
    @pulumi.getter(name="packetsPerSeconds")
    def packets_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "packets_per_seconds")

    @packets_per_seconds.setter
    def packets_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "packets_per_seconds", value)

    @_builtins.property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "pool_ids", value)

    @_builtins.property
    @pulumi.getter(name="popNames")
    def pop_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "pop_names")

    @pop_names.setter
    def pop_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "pop_names", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring billing*usage*alert
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)

    @_builtins.property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring pages*event*alert
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "project_ids", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="queryTags")
    def query_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "query_tags")

    @query_tags.setter
    def query_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "query_tags", value)

    @_builtins.property
    @pulumi.getter(name="requestsPerSeconds")
    def requests_per_seconds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "requests_per_seconds")

    @requests_per_seconds.setter
    def requests_per_seconds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests_per_seconds", value)

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "selectors", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring clickhouse*alert*fw*ent*anomaly
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter
    def slos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "slos")

    @slos.setter
    def slos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "slos", value)

    @_builtins.property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring health*check*status_notification
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "statuses", value)

    @_builtins.property
    @pulumi.getter(name="targetHostnames")
    def target_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_hostnames")

    @target_hostnames.setter
    def target_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "target_hostnames", value)

    @_builtins.property
    @pulumi.getter(name="targetIps")
    def target_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l4*alert
        """
        return pulumi.get(self, "target_ips")

    @target_ips.setter
    def target_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "target_ips", value)

    @_builtins.property
    @pulumi.getter(name="targetZoneNames")
    def target_zone_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring advanced*ddos*attack*l7*alert
        """
        return pulumi.get(self, "target_zone_names")

    @target_zone_names.setter
    def target_zone_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "target_zone_names", value)

    @_builtins.property
    @pulumi.getter(name="trafficExclusions")
    def traffic_exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring traffic*anomalies*alert
        """
        return pulumi.get(self, "traffic_exclusions")

    @traffic_exclusions.setter
    def traffic_exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "traffic_exclusions", value)

    @_builtins.property
    @pulumi.getter(name="tunnelIds")
    def tunnel_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Used for configuring tunnel*health*event
        """
        return pulumi.get(self, "tunnel_ids")

    @tunnel_ids.setter
    def tunnel_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tunnel_ids", value)

    @_builtins.property
    @pulumi.getter(name="tunnelNames")
    def tunnel_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "tunnel_names")

    @tunnel_names.setter
    def tunnel_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tunnel_names", value)

    @_builtins.property
    @pulumi.getter
    def wheres(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "wheres")

    @wheres.setter
    def wheres(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "wheres", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Usage depends on specific alert type
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class NotificationPolicyMechanismsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgsDict']]]]
        pagerduties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgsDict']]]]
        webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgsDict']]]]
elif False:
    NotificationPolicyMechanismsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgs']]]] = None,
                 pagerduties: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgs']]]] = None,
                 webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgs']]]] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if pagerduties is not None:
            pulumi.set(__self__, "pagerduties", pagerduties)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgs']]]]:
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsEmailArgs']]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def pagerduties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgs']]]]:
        return pulumi.get(self, "pagerduties")

    @pagerduties.setter
    def pagerduties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsPagerdutyArgs']]]]):
        pulumi.set(self, "pagerduties", value)

    @_builtins.property
    @pulumi.getter
    def webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgs']]]]:
        return pulumi.get(self, "webhooks")

    @webhooks.setter
    def webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationPolicyMechanismsWebhookArgs']]]]):
        pulumi.set(self, "webhooks", value)


if not MYPY:
    class NotificationPolicyMechanismsEmailArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email address
        """
elif False:
    NotificationPolicyMechanismsEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsEmailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The email address
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email address
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NotificationPolicyMechanismsPagerdutyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID
        """
elif False:
    NotificationPolicyMechanismsPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsPagerdutyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: UUID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NotificationPolicyMechanismsWebhookArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID
        """
elif False:
    NotificationPolicyMechanismsWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPolicyMechanismsWebhookArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: UUID
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ObservatoryScheduledTestScheduleArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The frequency of the test.
        Available values: "DAILY", "WEEKLY".
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        A test region.
        Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A URL.
        """
elif False:
    ObservatoryScheduledTestScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestScheduleArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] frequency: The frequency of the test.
               Available values: "DAILY", "WEEKLY".
        :param pulumi.Input[_builtins.str] region: A test region.
               Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
        :param pulumi.Input[_builtins.str] url: A URL.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The frequency of the test.
        Available values: "DAILY", "WEEKLY".
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A test region.
        Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ObservatoryScheduledTestTestArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        desktop_report: NotRequired[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgsDict']]
        """
        The Lighthouse report.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID.
        """
        mobile_report: NotRequired[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgsDict']]
        """
        The Lighthouse report.
        """
        region: NotRequired[pulumi.Input['ObservatoryScheduledTestTestRegionArgsDict']]
        """
        A test region with a label.
        """
        schedule_frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The frequency of the test.
        Available values: "DAILY", "WEEKLY".
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A URL.
        """
elif False:
    ObservatoryScheduledTestTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 desktop_report: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 mobile_report: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs']] = None,
                 region: Optional[pulumi.Input['ObservatoryScheduledTestTestRegionArgs']] = None,
                 schedule_frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs'] desktop_report: The Lighthouse report.
        :param pulumi.Input[_builtins.str] id: UUID.
        :param pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs'] mobile_report: The Lighthouse report.
        :param pulumi.Input['ObservatoryScheduledTestTestRegionArgs'] region: A test region with a label.
        :param pulumi.Input[_builtins.str] schedule_frequency: The frequency of the test.
               Available values: "DAILY", "WEEKLY".
        :param pulumi.Input[_builtins.str] url: A URL.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if desktop_report is not None:
            pulumi.set(__self__, "desktop_report", desktop_report)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mobile_report is not None:
            pulumi.set(__self__, "mobile_report", mobile_report)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if schedule_frequency is not None:
            pulumi.set(__self__, "schedule_frequency", schedule_frequency)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter(name="desktopReport")
    def desktop_report(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs']]:
        """
        The Lighthouse report.
        """
        return pulumi.get(self, "desktop_report")

    @desktop_report.setter
    def desktop_report(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportArgs']]):
        pulumi.set(self, "desktop_report", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="mobileReport")
    def mobile_report(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs']]:
        """
        The Lighthouse report.
        """
        return pulumi.get(self, "mobile_report")

    @mobile_report.setter
    def mobile_report(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportArgs']]):
        pulumi.set(self, "mobile_report", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestRegionArgs']]:
        """
        A test region with a label.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestRegionArgs']]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The frequency of the test.
        Available values: "DAILY", "WEEKLY".
        """
        return pulumi.get(self, "schedule_frequency")

    @schedule_frequency.setter
    def schedule_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule_frequency", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ObservatoryScheduledTestTestDesktopReportArgsDict(TypedDict):
        cls: NotRequired[pulumi.Input[_builtins.float]]
        """
        Cumulative Layout Shift.
        """
        device_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of device.
        Available values: "DESKTOP", "MOBILE".
        """
        error: NotRequired[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgsDict']]
        fcp: NotRequired[pulumi.Input[_builtins.float]]
        """
        First Contentful Paint.
        """
        json_report_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to the full Lighthouse JSON report.
        """
        lcp: NotRequired[pulumi.Input[_builtins.float]]
        """
        Largest Contentful Paint.
        """
        performance_score: NotRequired[pulumi.Input[_builtins.float]]
        """
        The Lighthouse performance score.
        """
        si: NotRequired[pulumi.Input[_builtins.float]]
        """
        Speed Index.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the Lighthouse report.
        Available values: "RUNNING", "COMPLETE", "FAILED".
        """
        tbt: NotRequired[pulumi.Input[_builtins.float]]
        """
        Total Blocking Time.
        """
        ttfb: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time To First Byte.
        """
        tti: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time To Interactive.
        """
elif False:
    ObservatoryScheduledTestTestDesktopReportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestDesktopReportArgs:
    def __init__(__self__, *,
                 cls: Optional[pulumi.Input[_builtins.float]] = None,
                 device_type: Optional[pulumi.Input[_builtins.str]] = None,
                 error: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgs']] = None,
                 fcp: Optional[pulumi.Input[_builtins.float]] = None,
                 json_report_url: Optional[pulumi.Input[_builtins.str]] = None,
                 lcp: Optional[pulumi.Input[_builtins.float]] = None,
                 performance_score: Optional[pulumi.Input[_builtins.float]] = None,
                 si: Optional[pulumi.Input[_builtins.float]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 tbt: Optional[pulumi.Input[_builtins.float]] = None,
                 ttfb: Optional[pulumi.Input[_builtins.float]] = None,
                 tti: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] cls: Cumulative Layout Shift.
        :param pulumi.Input[_builtins.str] device_type: The type of device.
               Available values: "DESKTOP", "MOBILE".
        :param pulumi.Input[_builtins.float] fcp: First Contentful Paint.
        :param pulumi.Input[_builtins.str] json_report_url: The URL to the full Lighthouse JSON report.
        :param pulumi.Input[_builtins.float] lcp: Largest Contentful Paint.
        :param pulumi.Input[_builtins.float] performance_score: The Lighthouse performance score.
        :param pulumi.Input[_builtins.float] si: Speed Index.
        :param pulumi.Input[_builtins.str] state: The state of the Lighthouse report.
               Available values: "RUNNING", "COMPLETE", "FAILED".
        :param pulumi.Input[_builtins.float] tbt: Total Blocking Time.
        :param pulumi.Input[_builtins.float] ttfb: Time To First Byte.
        :param pulumi.Input[_builtins.float] tti: Time To Interactive.
        """
        if cls is not None:
            pulumi.set(__self__, "cls", cls)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fcp is not None:
            pulumi.set(__self__, "fcp", fcp)
        if json_report_url is not None:
            pulumi.set(__self__, "json_report_url", json_report_url)
        if lcp is not None:
            pulumi.set(__self__, "lcp", lcp)
        if performance_score is not None:
            pulumi.set(__self__, "performance_score", performance_score)
        if si is not None:
            pulumi.set(__self__, "si", si)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tbt is not None:
            pulumi.set(__self__, "tbt", tbt)
        if ttfb is not None:
            pulumi.set(__self__, "ttfb", ttfb)
        if tti is not None:
            pulumi.set(__self__, "tti", tti)

    @_builtins.property
    @pulumi.getter
    def cls(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Cumulative Layout Shift.
        """
        return pulumi.get(self, "cls")

    @cls.setter
    def cls(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cls", value)

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of device.
        Available values: "DESKTOP", "MOBILE".
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_type", value)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgs']]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestDesktopReportErrorArgs']]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter
    def fcp(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        First Contentful Paint.
        """
        return pulumi.get(self, "fcp")

    @fcp.setter
    def fcp(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fcp", value)

    @_builtins.property
    @pulumi.getter(name="jsonReportUrl")
    def json_report_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to the full Lighthouse JSON report.
        """
        return pulumi.get(self, "json_report_url")

    @json_report_url.setter
    def json_report_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json_report_url", value)

    @_builtins.property
    @pulumi.getter
    def lcp(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Largest Contentful Paint.
        """
        return pulumi.get(self, "lcp")

    @lcp.setter
    def lcp(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lcp", value)

    @_builtins.property
    @pulumi.getter(name="performanceScore")
    def performance_score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The Lighthouse performance score.
        """
        return pulumi.get(self, "performance_score")

    @performance_score.setter
    def performance_score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "performance_score", value)

    @_builtins.property
    @pulumi.getter
    def si(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Speed Index.
        """
        return pulumi.get(self, "si")

    @si.setter
    def si(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "si", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the Lighthouse report.
        Available values: "RUNNING", "COMPLETE", "FAILED".
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def tbt(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Total Blocking Time.
        """
        return pulumi.get(self, "tbt")

    @tbt.setter
    def tbt(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tbt", value)

    @_builtins.property
    @pulumi.getter
    def ttfb(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time To First Byte.
        """
        return pulumi.get(self, "ttfb")

    @ttfb.setter
    def ttfb(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ttfb", value)

    @_builtins.property
    @pulumi.getter
    def tti(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time To Interactive.
        """
        return pulumi.get(self, "tti")

    @tti.setter
    def tti(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tti", value)


if not MYPY:
    class ObservatoryScheduledTestTestDesktopReportErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The error code of the Lighthouse result.
        Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
        """
        detail: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detailed error message.
        """
        final_displayed_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The final URL displayed to the user.
        """
elif False:
    ObservatoryScheduledTestTestDesktopReportErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestDesktopReportErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 final_displayed_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: The error code of the Lighthouse result.
               Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
        :param pulumi.Input[_builtins.str] detail: Detailed error message.
        :param pulumi.Input[_builtins.str] final_displayed_url: The final URL displayed to the user.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if final_displayed_url is not None:
            pulumi.set(__self__, "final_displayed_url", final_displayed_url)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The error code of the Lighthouse result.
        Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detailed error message.
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="finalDisplayedUrl")
    def final_displayed_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The final URL displayed to the user.
        """
        return pulumi.get(self, "final_displayed_url")

    @final_displayed_url.setter
    def final_displayed_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "final_displayed_url", value)


if not MYPY:
    class ObservatoryScheduledTestTestMobileReportArgsDict(TypedDict):
        cls: NotRequired[pulumi.Input[_builtins.float]]
        """
        Cumulative Layout Shift.
        """
        device_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of device.
        Available values: "DESKTOP", "MOBILE".
        """
        error: NotRequired[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgsDict']]
        fcp: NotRequired[pulumi.Input[_builtins.float]]
        """
        First Contentful Paint.
        """
        json_report_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to the full Lighthouse JSON report.
        """
        lcp: NotRequired[pulumi.Input[_builtins.float]]
        """
        Largest Contentful Paint.
        """
        performance_score: NotRequired[pulumi.Input[_builtins.float]]
        """
        The Lighthouse performance score.
        """
        si: NotRequired[pulumi.Input[_builtins.float]]
        """
        Speed Index.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the Lighthouse report.
        Available values: "RUNNING", "COMPLETE", "FAILED".
        """
        tbt: NotRequired[pulumi.Input[_builtins.float]]
        """
        Total Blocking Time.
        """
        ttfb: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time To First Byte.
        """
        tti: NotRequired[pulumi.Input[_builtins.float]]
        """
        Time To Interactive.
        """
elif False:
    ObservatoryScheduledTestTestMobileReportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestMobileReportArgs:
    def __init__(__self__, *,
                 cls: Optional[pulumi.Input[_builtins.float]] = None,
                 device_type: Optional[pulumi.Input[_builtins.str]] = None,
                 error: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgs']] = None,
                 fcp: Optional[pulumi.Input[_builtins.float]] = None,
                 json_report_url: Optional[pulumi.Input[_builtins.str]] = None,
                 lcp: Optional[pulumi.Input[_builtins.float]] = None,
                 performance_score: Optional[pulumi.Input[_builtins.float]] = None,
                 si: Optional[pulumi.Input[_builtins.float]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 tbt: Optional[pulumi.Input[_builtins.float]] = None,
                 ttfb: Optional[pulumi.Input[_builtins.float]] = None,
                 tti: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] cls: Cumulative Layout Shift.
        :param pulumi.Input[_builtins.str] device_type: The type of device.
               Available values: "DESKTOP", "MOBILE".
        :param pulumi.Input[_builtins.float] fcp: First Contentful Paint.
        :param pulumi.Input[_builtins.str] json_report_url: The URL to the full Lighthouse JSON report.
        :param pulumi.Input[_builtins.float] lcp: Largest Contentful Paint.
        :param pulumi.Input[_builtins.float] performance_score: The Lighthouse performance score.
        :param pulumi.Input[_builtins.float] si: Speed Index.
        :param pulumi.Input[_builtins.str] state: The state of the Lighthouse report.
               Available values: "RUNNING", "COMPLETE", "FAILED".
        :param pulumi.Input[_builtins.float] tbt: Total Blocking Time.
        :param pulumi.Input[_builtins.float] ttfb: Time To First Byte.
        :param pulumi.Input[_builtins.float] tti: Time To Interactive.
        """
        if cls is not None:
            pulumi.set(__self__, "cls", cls)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fcp is not None:
            pulumi.set(__self__, "fcp", fcp)
        if json_report_url is not None:
            pulumi.set(__self__, "json_report_url", json_report_url)
        if lcp is not None:
            pulumi.set(__self__, "lcp", lcp)
        if performance_score is not None:
            pulumi.set(__self__, "performance_score", performance_score)
        if si is not None:
            pulumi.set(__self__, "si", si)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tbt is not None:
            pulumi.set(__self__, "tbt", tbt)
        if ttfb is not None:
            pulumi.set(__self__, "ttfb", ttfb)
        if tti is not None:
            pulumi.set(__self__, "tti", tti)

    @_builtins.property
    @pulumi.getter
    def cls(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Cumulative Layout Shift.
        """
        return pulumi.get(self, "cls")

    @cls.setter
    def cls(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cls", value)

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of device.
        Available values: "DESKTOP", "MOBILE".
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_type", value)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgs']]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ObservatoryScheduledTestTestMobileReportErrorArgs']]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter
    def fcp(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        First Contentful Paint.
        """
        return pulumi.get(self, "fcp")

    @fcp.setter
    def fcp(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "fcp", value)

    @_builtins.property
    @pulumi.getter(name="jsonReportUrl")
    def json_report_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to the full Lighthouse JSON report.
        """
        return pulumi.get(self, "json_report_url")

    @json_report_url.setter
    def json_report_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json_report_url", value)

    @_builtins.property
    @pulumi.getter
    def lcp(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Largest Contentful Paint.
        """
        return pulumi.get(self, "lcp")

    @lcp.setter
    def lcp(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lcp", value)

    @_builtins.property
    @pulumi.getter(name="performanceScore")
    def performance_score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The Lighthouse performance score.
        """
        return pulumi.get(self, "performance_score")

    @performance_score.setter
    def performance_score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "performance_score", value)

    @_builtins.property
    @pulumi.getter
    def si(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Speed Index.
        """
        return pulumi.get(self, "si")

    @si.setter
    def si(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "si", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the Lighthouse report.
        Available values: "RUNNING", "COMPLETE", "FAILED".
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def tbt(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Total Blocking Time.
        """
        return pulumi.get(self, "tbt")

    @tbt.setter
    def tbt(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tbt", value)

    @_builtins.property
    @pulumi.getter
    def ttfb(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time To First Byte.
        """
        return pulumi.get(self, "ttfb")

    @ttfb.setter
    def ttfb(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ttfb", value)

    @_builtins.property
    @pulumi.getter
    def tti(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Time To Interactive.
        """
        return pulumi.get(self, "tti")

    @tti.setter
    def tti(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tti", value)


if not MYPY:
    class ObservatoryScheduledTestTestMobileReportErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The error code of the Lighthouse result.
        Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
        """
        detail: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detailed error message.
        """
        final_displayed_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The final URL displayed to the user.
        """
elif False:
    ObservatoryScheduledTestTestMobileReportErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestMobileReportErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 final_displayed_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: The error code of the Lighthouse result.
               Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
        :param pulumi.Input[_builtins.str] detail: Detailed error message.
        :param pulumi.Input[_builtins.str] final_displayed_url: The final URL displayed to the user.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if final_displayed_url is not None:
            pulumi.set(__self__, "final_displayed_url", final_displayed_url)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The error code of the Lighthouse result.
        Available values: "NOT*REACHABLE", "DNS*FAILURE", "NOT*HTML", "LIGHTHOUSE*TIMEOUT", "UNKNOWN".
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detailed error message.
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="finalDisplayedUrl")
    def final_displayed_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The final URL displayed to the user.
        """
        return pulumi.get(self, "final_displayed_url")

    @final_displayed_url.setter
    def final_displayed_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "final_displayed_url", value)


if not MYPY:
    class ObservatoryScheduledTestTestRegionArgsDict(TypedDict):
        label: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        A test region.
        Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
        """
elif False:
    ObservatoryScheduledTestTestRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObservatoryScheduledTestTestRegionArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: A test region.
               Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A test region.
        Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PageRuleActionsArgsDict(TypedDict):
        always_use_https: NotRequired[pulumi.Input[_builtins.bool]]
        automatic_https_rewrites: NotRequired[pulumi.Input[_builtins.str]]
        browser_cache_ttl: NotRequired[pulumi.Input[_builtins.int]]
        browser_check: NotRequired[pulumi.Input[_builtins.str]]
        bypass_cache_on_cookie: NotRequired[pulumi.Input[_builtins.str]]
        cache_by_device_type: NotRequired[pulumi.Input[_builtins.str]]
        cache_deception_armor: NotRequired[pulumi.Input[_builtins.str]]
        cache_key_fields: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsArgsDict']]
        cache_level: NotRequired[pulumi.Input[_builtins.str]]
        cache_on_cookie: NotRequired[pulumi.Input[_builtins.str]]
        cache_ttl_by_status: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        disable_apps: NotRequired[pulumi.Input[_builtins.bool]]
        disable_performance: NotRequired[pulumi.Input[_builtins.bool]]
        disable_security: NotRequired[pulumi.Input[_builtins.bool]]
        disable_zaraz: NotRequired[pulumi.Input[_builtins.bool]]
        edge_cache_ttl: NotRequired[pulumi.Input[_builtins.int]]
        email_obfuscation: NotRequired[pulumi.Input[_builtins.str]]
        explicit_cache_control: NotRequired[pulumi.Input[_builtins.str]]
        forwarding_url: NotRequired[pulumi.Input['PageRuleActionsForwardingUrlArgsDict']]
        host_header_override: NotRequired[pulumi.Input[_builtins.str]]
        ip_geolocation: NotRequired[pulumi.Input[_builtins.str]]
        mirage: NotRequired[pulumi.Input[_builtins.str]]
        opportunistic_encryption: NotRequired[pulumi.Input[_builtins.str]]
        origin_error_page_pass_thru: NotRequired[pulumi.Input[_builtins.str]]
        polish: NotRequired[pulumi.Input[_builtins.str]]
        resolve_override: NotRequired[pulumi.Input[_builtins.str]]
        respect_strong_etag: NotRequired[pulumi.Input[_builtins.str]]
        response_buffering: NotRequired[pulumi.Input[_builtins.str]]
        rocket_loader: NotRequired[pulumi.Input[_builtins.str]]
        security_level: NotRequired[pulumi.Input[_builtins.str]]
        sort_query_string_for_cache: NotRequired[pulumi.Input[_builtins.str]]
        ssl: NotRequired[pulumi.Input[_builtins.str]]
        true_client_ip_header: NotRequired[pulumi.Input[_builtins.str]]
        waf: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PageRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsArgs:
    def __init__(__self__, *,
                 always_use_https: Optional[pulumi.Input[_builtins.bool]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[_builtins.str]] = None,
                 browser_cache_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 browser_check: Optional[pulumi.Input[_builtins.str]] = None,
                 bypass_cache_on_cookie: Optional[pulumi.Input[_builtins.str]] = None,
                 cache_by_device_type: Optional[pulumi.Input[_builtins.str]] = None,
                 cache_deception_armor: Optional[pulumi.Input[_builtins.str]] = None,
                 cache_key_fields: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']] = None,
                 cache_level: Optional[pulumi.Input[_builtins.str]] = None,
                 cache_on_cookie: Optional[pulumi.Input[_builtins.str]] = None,
                 cache_ttl_by_status: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 disable_apps: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_performance: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_security: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[_builtins.bool]] = None,
                 edge_cache_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 email_obfuscation: Optional[pulumi.Input[_builtins.str]] = None,
                 explicit_cache_control: Optional[pulumi.Input[_builtins.str]] = None,
                 forwarding_url: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']] = None,
                 host_header_override: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_geolocation: Optional[pulumi.Input[_builtins.str]] = None,
                 mirage: Optional[pulumi.Input[_builtins.str]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_error_page_pass_thru: Optional[pulumi.Input[_builtins.str]] = None,
                 polish: Optional[pulumi.Input[_builtins.str]] = None,
                 resolve_override: Optional[pulumi.Input[_builtins.str]] = None,
                 respect_strong_etag: Optional[pulumi.Input[_builtins.str]] = None,
                 response_buffering: Optional[pulumi.Input[_builtins.str]] = None,
                 rocket_loader: Optional[pulumi.Input[_builtins.str]] = None,
                 security_level: Optional[pulumi.Input[_builtins.str]] = None,
                 sort_query_string_for_cache: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl: Optional[pulumi.Input[_builtins.str]] = None,
                 true_client_ip_header: Optional[pulumi.Input[_builtins.str]] = None,
                 waf: Optional[pulumi.Input[_builtins.str]] = None):
        if always_use_https is not None:
            pulumi.set(__self__, "always_use_https", always_use_https)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if browser_cache_ttl is not None:
            pulumi.set(__self__, "browser_cache_ttl", browser_cache_ttl)
        if browser_check is not None:
            pulumi.set(__self__, "browser_check", browser_check)
        if bypass_cache_on_cookie is not None:
            pulumi.set(__self__, "bypass_cache_on_cookie", bypass_cache_on_cookie)
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if cache_key_fields is not None:
            pulumi.set(__self__, "cache_key_fields", cache_key_fields)
        if cache_level is not None:
            pulumi.set(__self__, "cache_level", cache_level)
        if cache_on_cookie is not None:
            pulumi.set(__self__, "cache_on_cookie", cache_on_cookie)
        if cache_ttl_by_status is not None:
            pulumi.set(__self__, "cache_ttl_by_status", cache_ttl_by_status)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_performance is not None:
            pulumi.set(__self__, "disable_performance", disable_performance)
        if disable_security is not None:
            pulumi.set(__self__, "disable_security", disable_security)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_cache_ttl is not None:
            pulumi.set(__self__, "edge_cache_ttl", edge_cache_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if explicit_cache_control is not None:
            pulumi.set(__self__, "explicit_cache_control", explicit_cache_control)
        if forwarding_url is not None:
            pulumi.set(__self__, "forwarding_url", forwarding_url)
        if host_header_override is not None:
            pulumi.set(__self__, "host_header_override", host_header_override)
        if ip_geolocation is not None:
            pulumi.set(__self__, "ip_geolocation", ip_geolocation)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin_error_page_pass_thru is not None:
            pulumi.set(__self__, "origin_error_page_pass_thru", origin_error_page_pass_thru)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if resolve_override is not None:
            pulumi.set(__self__, "resolve_override", resolve_override)
        if respect_strong_etag is not None:
            pulumi.set(__self__, "respect_strong_etag", respect_strong_etag)
        if response_buffering is not None:
            pulumi.set(__self__, "response_buffering", response_buffering)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if sort_query_string_for_cache is not None:
            pulumi.set(__self__, "sort_query_string_for_cache", sort_query_string_for_cache)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if true_client_ip_header is not None:
            pulumi.set(__self__, "true_client_ip_header", true_client_ip_header)
        if waf is not None:
            pulumi.set(__self__, "waf", waf)

    @_builtins.property
    @pulumi.getter(name="alwaysUseHttps")
    def always_use_https(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "always_use_https")

    @always_use_https.setter
    def always_use_https(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "always_use_https", value)

    @_builtins.property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @_builtins.property
    @pulumi.getter(name="browserCacheTtl")
    def browser_cache_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "browser_cache_ttl")

    @browser_cache_ttl.setter
    def browser_cache_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "browser_cache_ttl", value)

    @_builtins.property
    @pulumi.getter(name="browserCheck")
    def browser_check(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "browser_check")

    @browser_check.setter
    def browser_check(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "browser_check", value)

    @_builtins.property
    @pulumi.getter(name="bypassCacheOnCookie")
    def bypass_cache_on_cookie(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bypass_cache_on_cookie")

    @bypass_cache_on_cookie.setter
    def bypass_cache_on_cookie(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bypass_cache_on_cookie", value)

    @_builtins.property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_by_device_type", value)

    @_builtins.property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_deception_armor", value)

    @_builtins.property
    @pulumi.getter(name="cacheKeyFields")
    def cache_key_fields(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]:
        return pulumi.get(self, "cache_key_fields")

    @cache_key_fields.setter
    def cache_key_fields(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsArgs']]):
        pulumi.set(self, "cache_key_fields", value)

    @_builtins.property
    @pulumi.getter(name="cacheLevel")
    def cache_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_level")

    @cache_level.setter
    def cache_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_level", value)

    @_builtins.property
    @pulumi.getter(name="cacheOnCookie")
    def cache_on_cookie(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cache_on_cookie")

    @cache_on_cookie.setter
    def cache_on_cookie(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_on_cookie", value)

    @_builtins.property
    @pulumi.getter(name="cacheTtlByStatus")
    def cache_ttl_by_status(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "cache_ttl_by_status")

    @cache_ttl_by_status.setter
    def cache_ttl_by_status(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cache_ttl_by_status", value)

    @_builtins.property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_apps", value)

    @_builtins.property
    @pulumi.getter(name="disablePerformance")
    def disable_performance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_performance")

    @disable_performance.setter
    def disable_performance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_performance", value)

    @_builtins.property
    @pulumi.getter(name="disableSecurity")
    def disable_security(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_security")

    @disable_security.setter
    def disable_security(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_security", value)

    @_builtins.property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @_builtins.property
    @pulumi.getter(name="edgeCacheTtl")
    def edge_cache_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "edge_cache_ttl")

    @edge_cache_ttl.setter
    def edge_cache_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "edge_cache_ttl", value)

    @_builtins.property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_obfuscation", value)

    @_builtins.property
    @pulumi.getter(name="explicitCacheControl")
    def explicit_cache_control(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "explicit_cache_control")

    @explicit_cache_control.setter
    def explicit_cache_control(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "explicit_cache_control", value)

    @_builtins.property
    @pulumi.getter(name="forwardingUrl")
    def forwarding_url(self) -> Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]:
        return pulumi.get(self, "forwarding_url")

    @forwarding_url.setter
    def forwarding_url(self, value: Optional[pulumi.Input['PageRuleActionsForwardingUrlArgs']]):
        pulumi.set(self, "forwarding_url", value)

    @_builtins.property
    @pulumi.getter(name="hostHeaderOverride")
    def host_header_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "host_header_override")

    @host_header_override.setter
    def host_header_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_header_override", value)

    @_builtins.property
    @pulumi.getter(name="ipGeolocation")
    def ip_geolocation(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_geolocation")

    @ip_geolocation.setter
    def ip_geolocation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_geolocation", value)

    @_builtins.property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mirage", value)

    @_builtins.property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @_builtins.property
    @pulumi.getter(name="originErrorPagePassThru")
    def origin_error_page_pass_thru(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_error_page_pass_thru")

    @origin_error_page_pass_thru.setter
    def origin_error_page_pass_thru(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_error_page_pass_thru", value)

    @_builtins.property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "polish", value)

    @_builtins.property
    @pulumi.getter(name="resolveOverride")
    def resolve_override(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resolve_override")

    @resolve_override.setter
    def resolve_override(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolve_override", value)

    @_builtins.property
    @pulumi.getter(name="respectStrongEtag")
    def respect_strong_etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "respect_strong_etag")

    @respect_strong_etag.setter
    def respect_strong_etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "respect_strong_etag", value)

    @_builtins.property
    @pulumi.getter(name="responseBuffering")
    def response_buffering(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "response_buffering")

    @response_buffering.setter
    def response_buffering(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_buffering", value)

    @_builtins.property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rocket_loader", value)

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_level", value)

    @_builtins.property
    @pulumi.getter(name="sortQueryStringForCache")
    def sort_query_string_for_cache(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sort_query_string_for_cache")

    @sort_query_string_for_cache.setter
    def sort_query_string_for_cache(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sort_query_string_for_cache", value)

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl", value)

    @_builtins.property
    @pulumi.getter(name="trueClientIpHeader")
    def true_client_ip_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "true_client_ip_header")

    @true_client_ip_header.setter
    def true_client_ip_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "true_client_ip_header", value)

    @_builtins.property
    @pulumi.getter
    def waf(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "waf")

    @waf.setter
    def waf(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "waf", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgsDict']]
        header: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgsDict']]
        host: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgsDict']]
        query_string: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgsDict']]
        user: NotRequired[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgsDict']]
elif False:
    PageRuleActionsCacheKeyFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']] = None,
                 header: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']] = None,
                 host: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']] = None,
                 query_string: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']] = None,
                 user: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']] = None):
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]:
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsHostArgs']]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['PageRuleActionsCacheKeyFieldsUserArgs']]):
        pulumi.set(self, "user", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsCookieArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PageRuleActionsCacheKeyFieldsCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "check_presences", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsHeaderArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PageRuleActionsCacheKeyFieldsHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "check_presences", value)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsHostArgsDict(TypedDict):
        resolved: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PageRuleActionsCacheKeyFieldsHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[_builtins.bool]] = None):
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @_builtins.property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "resolved", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsQueryStringArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PageRuleActionsCacheKeyFieldsQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsQueryStringArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PageRuleActionsCacheKeyFieldsUserArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[_builtins.bool]]
        geo: NotRequired[pulumi.Input[_builtins.bool]]
        lang: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PageRuleActionsCacheKeyFieldsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsCacheKeyFieldsUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[_builtins.bool]] = None,
                 geo: Optional[pulumi.Input[_builtins.bool]] = None,
                 lang: Optional[pulumi.Input[_builtins.bool]] = None):
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "device_type", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class PageRuleActionsForwardingUrlArgsDict(TypedDict):
        status_code: pulumi.Input[_builtins.int]
        url: pulumi.Input[_builtins.str]
elif False:
    PageRuleActionsForwardingUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PageRuleActionsForwardingUrlArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[_builtins.int],
                 url: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "status_code", status_code)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesDomainValidationDataArgsDict(TypedDict):
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "http", "txt".
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "initializing", "pending", "active", "deactivated", "error".
        """
        txt_name: NotRequired[pulumi.Input[_builtins.str]]
        txt_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesDomainValidationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesDomainValidationDataArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 txt_name: Optional[pulumi.Input[_builtins.str]] = None,
                 txt_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] method: Available values: "http", "txt".
        :param pulumi.Input[_builtins.str] status: Available values: "initializing", "pending", "active", "deactivated", "error".
        """
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if txt_name is not None:
            pulumi.set(__self__, "txt_name", txt_name)
        if txt_value is not None:
            pulumi.set(__self__, "txt_value", txt_value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "http", "txt".
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "initializing", "pending", "active", "deactivated", "error".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="txtName")
    def txt_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "txt_name")

    @txt_name.setter
    def txt_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txt_name", value)

    @_builtins.property
    @pulumi.getter(name="txtValue")
    def txt_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "txt_value")

    @txt_value.setter
    def txt_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "txt_value", value)


if not MYPY:
    class PagesDomainVerificationDataArgsDict(TypedDict):
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "pending", "active", "deactivated", "blocked", "error".
        """
elif False:
    PagesDomainVerificationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesDomainVerificationDataArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Available values: "pending", "active", "deactivated", "blocked", "error".
        """
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "pending", "active", "deactivated", "blocked", "error".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Directory to run the command.
        """
        web_analytics_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[_builtins.bool]] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 root_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 web_analytics_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[_builtins.str] build_command: Command used to build project.
        :param pulumi.Input[_builtins.str] destination_dir: Output directory of the build.
        :param pulumi.Input[_builtins.str] root_dir: Directory to run the command.
        :param pulumi.Input[_builtins.str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[_builtins.str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @_builtins.property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "build_caching", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_dir", value)

    @_builtins.property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_dir", value)

    @_builtins.property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @_builtins.property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentArgsDict(TypedDict):
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alias URLs pointing to this deployment.
        """
        build_config: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgsDict']]
        """
        Configs for the project build process.
        """
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the deployment was created.
        """
        deployment_trigger: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict']]
        """
        Info about what caused the deployment.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgsDict']]]]
        """
        Environment variables used for builds and Pages Functions.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of deploy.
        Available values: "preview", "production".
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the deployment.
        """
        is_skipped: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the deployment has been skipped.
        """
        latest_stage: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgsDict']]
        """
        The status of the deployment.
        """
        modified_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the deployment was last modified.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the project.
        """
        project_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the project.
        """
        short_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Short Id (8 character) of the deployment.
        """
        source: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgsDict']]
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgsDict']]]]
        """
        List of past stages.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The live URL to view this deployment.
        """
elif False:
    PagesProjectCanonicalDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentArgs:
    def __init__(__self__, *,
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 build_config: Optional[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs']] = None,
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 deployment_trigger: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs']] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_skipped: Optional[pulumi.Input[_builtins.bool]] = None,
                 latest_stage: Optional[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs']] = None,
                 modified_on: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_name: Optional[pulumi.Input[_builtins.str]] = None,
                 short_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgs']] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aliases: A list of alias URLs pointing to this deployment.
        :param pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs'] build_config: Configs for the project build process.
        :param pulumi.Input[_builtins.str] created_on: When the deployment was created.
        :param pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs'] deployment_trigger: Info about what caused the deployment.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]] env_vars: Environment variables used for builds and Pages Functions.
        :param pulumi.Input[_builtins.str] environment: Type of deploy.
               Available values: "preview", "production".
        :param pulumi.Input[_builtins.str] id: Id of the deployment.
        :param pulumi.Input[_builtins.bool] is_skipped: If the deployment has been skipped.
        :param pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs'] latest_stage: The status of the deployment.
        :param pulumi.Input[_builtins.str] modified_on: When the deployment was last modified.
        :param pulumi.Input[_builtins.str] project_id: Id of the project.
        :param pulumi.Input[_builtins.str] project_name: Name of the project.
        :param pulumi.Input[_builtins.str] short_id: Short Id (8 character) of the deployment.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]] stages: List of past stages.
        :param pulumi.Input[_builtins.str] url: The live URL to view this deployment.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if build_config is not None:
            pulumi.set(__self__, "build_config", build_config)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if deployment_trigger is not None:
            pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_skipped is not None:
            pulumi.set(__self__, "is_skipped", is_skipped)
        if latest_stage is not None:
            pulumi.set(__self__, "latest_stage", latest_stage)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "aliases", value)

    @_builtins.property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs']]:
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @build_config.setter
    def build_config(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentBuildConfigArgs']]):
        pulumi.set(self, "build_config", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs']]:
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @deployment_trigger.setter
    def deployment_trigger(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerArgs']]):
        pulumi.set(self, "deployment_trigger", value)

    @_builtins.property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]]]:
        """
        Environment variables used for builds and Pages Functions.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectCanonicalDeploymentEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of deploy.
        Available values: "preview", "production".
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @is_skipped.setter
    def is_skipped(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_skipped", value)

    @_builtins.property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs']]:
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @latest_stage.setter
    def latest_stage(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentLatestStageArgs']]):
        pulumi.set(self, "latest_stage", value)

    @_builtins.property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modified_on", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_name", value)

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_id", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceArgs']]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]]]:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectCanonicalDeploymentStageArgs']]]]):
        pulumi.set(self, "stages", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Directory to run the command.
        """
        web_analytics_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectCanonicalDeploymentBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[_builtins.bool]] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 root_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 web_analytics_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[_builtins.str] build_command: Command used to build project.
        :param pulumi.Input[_builtins.str] destination_dir: Output directory of the build.
        :param pulumi.Input[_builtins.str] root_dir: Directory to run the command.
        :param pulumi.Input[_builtins.str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[_builtins.str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @_builtins.property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "build_caching", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_dir", value)

    @_builtins.property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_dir", value)

    @_builtins.property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @_builtins.property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict']]
        """
        Additional info about the trigger.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        What caused the deployment.
        Available values: "push", "ad_hoc".
        """
elif False:
    PagesProjectCanonicalDeploymentDeploymentTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentDeploymentTriggerArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs'] metadata: Additional info about the trigger.
        :param pulumi.Input[_builtins.str] type: What caused the deployment.
               Available values: "push", "ad_hoc".
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs']]:
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        What caused the deployment.
        Available values: "push", "ad_hoc".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where the trigger happened.
        """
        commit_hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hash of the deployment trigger commit.
        """
        commit_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message of the deployment trigger commit.
        """
elif False:
    PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentDeploymentTriggerMetadataArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_hash: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: Where the trigger happened.
        :param pulumi.Input[_builtins.str] commit_hash: Hash of the deployment trigger commit.
        :param pulumi.Input[_builtins.str] commit_message: Message of the deployment trigger commit.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @commit_hash.setter
    def commit_hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_hash", value)

    @_builtins.property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_message", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentEnvVarsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "plain*text", "secret*text".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Environment variable value.
        """
elif False:
    PagesProjectCanonicalDeploymentEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentEnvVarsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "plain*text", "secret*text".
        :param pulumi.Input[_builtins.str] value: Environment variable value.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "plain*text", "secret*text".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentLatestStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        started_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
elif False:
    PagesProjectCanonicalDeploymentLatestStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentLatestStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 started_on: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ended_on: When the stage ended.
        :param pulumi.Input[_builtins.str] name: The current build stage.
               Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        :param pulumi.Input[_builtins.str] started_on: When the stage started.
        :param pulumi.Input[_builtins.str] status: State of the current stage.
               Available values: "success", "idle", "active", "failure", "canceled".
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ended_on", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_on", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgsDict']]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectCanonicalDeploymentSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectCanonicalDeploymentSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentSourceConfigArgsDict(TypedDict):
        deployments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        path_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        path_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        pr_comments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        preview_deployment_setting: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "all", "none", "custom".
        """
        production_branch: NotRequired[pulumi.Input[_builtins.str]]
        production_deployments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        repo_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectCanonicalDeploymentSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentSourceConfigArgs:
    def __init__(__self__, *,
                 deployments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 path_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 path_includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[_builtins.str]] = None,
                 production_branch: Optional[pulumi.Input[_builtins.str]] = None,
                 production_deployments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] preview_deployment_setting: Available values: "all", "none", "custom".
        """
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @_builtins.property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_excludes")

    @path_excludes.setter
    def path_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_excludes", value)

    @_builtins.property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_includes")

    @path_includes.setter
    def path_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_includes", value)

    @_builtins.property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @_builtins.property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @_builtins.property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @_builtins.property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "all", "none", "custom".
        """
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @_builtins.property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "production_branch", value)

    @_builtins.property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "production_deployments_enabled")

    @production_deployments_enabled.setter
    def production_deployments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "production_deployments_enabled", value)

    @_builtins.property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class PagesProjectCanonicalDeploymentStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        started_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
elif False:
    PagesProjectCanonicalDeploymentStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectCanonicalDeploymentStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 started_on: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ended_on: When the stage ended.
        :param pulumi.Input[_builtins.str] name: The current build stage.
               Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        :param pulumi.Input[_builtins.str] started_on: When the stage started.
        :param pulumi.Input[_builtins.str] status: State of the current stage.
               Available values: "success", "idle", "active", "failure", "canceled".
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ended_on", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_on", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectDeploymentConfigsArgsDict(TypedDict):
        preview: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgsDict']]
        """
        Configs for preview deploys.
        """
        production: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsProductionArgsDict']]
        """
        Configs for production deploys.
        """
elif False:
    PagesProjectDeploymentConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsArgs:
    def __init__(__self__, *,
                 preview: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']] = None,
                 production: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']] = None):
        """
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs'] preview: Configs for preview deploys.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionArgs'] production: Configs for production deploys.
        """
        if preview is not None:
            pulumi.set(__self__, "preview", preview)
        if production is not None:
            pulumi.set(__self__, "production", production)

    @_builtins.property
    @pulumi.getter
    def preview(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]:
        """
        Configs for preview deploys.
        """
        return pulumi.get(self, "preview")

    @preview.setter
    def preview(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewArgs']]):
        pulumi.set(self, "preview", value)

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]:
        """
        Configs for production deploys.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionArgs']]):
        pulumi.set(self, "production", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewArgsDict(TypedDict):
        ai_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict']]]]
        """
        Constellation bindings used for Pages Functions.
        """
        analytics_engine_datasets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict']]]]
        """
        Analytics Engine bindings used for Pages Functions.
        """
        browsers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgsDict']]]]
        """
        Browser bindings used for Pages Functions.
        """
        compatibility_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compatibility date used for Pages Functions.
        """
        compatibility_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Compatibility flags used for Pages Functions.
        """
        d1_databases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict']]]]
        """
        D1 databases used for Pages Functions.
        """
        durable_object_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict']]]]
        """
        Durable Object namespaces used for Pages Functions.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict']]]]
        """
        Environment variables used for builds and Pages Functions.
        """
        hyperdrive_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict']]]]
        """
        Hyperdrive bindings used for Pages Functions.
        """
        kv_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict']]]]
        """
        KV namespaces used for Pages Functions.
        """
        mtls_certificates: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict']]]]
        """
        mTLS bindings used for Pages Functions.
        """
        placement: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgsDict']]
        """
        Placement setting used for Pages Functions.
        """
        queue_producers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict']]]]
        """
        Queue Producer bindings used for Pages Functions.
        """
        r2_buckets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict']]]]
        """
        R2 buckets used for Pages Functions.
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgsDict']]]]
        """
        Services used for Pages Functions.
        """
        vectorize_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict']]]]
        """
        Vectorize bindings used for Pages Functions.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewArgs:
    def __init__(__self__, *,
                 ai_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]]] = None,
                 analytics_engine_datasets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]]] = None,
                 browsers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]]] = None,
                 compatibility_date: Optional[pulumi.Input[_builtins.str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]]] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]]] = None,
                 hyperdrive_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]]] = None,
                 mtls_certificates: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']] = None,
                 queue_producers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]]] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]]] = None,
                 vectorize_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]] ai_bindings: Constellation bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]] browsers: Browser bindings used for Pages Functions.
        :param pulumi.Input[_builtins.str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]] d1_databases: D1 databases used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]] durable_object_namespaces: Durable Object namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]] env_vars: Environment variables used for builds and Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]] kv_namespaces: KV namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]] mtls_certificates: mTLS bindings used for Pages Functions.
        :param pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs'] placement: Placement setting used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]] queue_producers: Queue Producer bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]] r2_buckets: R2 buckets used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]] services: Services used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        if ai_bindings is not None:
            pulumi.set(__self__, "ai_bindings", ai_bindings)
        if analytics_engine_datasets is not None:
            pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        if browsers is not None:
            pulumi.set(__self__, "browsers", browsers)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if hyperdrive_bindings is not None:
            pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if mtls_certificates is not None:
            pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if queue_producers is not None:
            pulumi.set(__self__, "queue_producers", queue_producers)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vectorize_bindings is not None:
            pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @_builtins.property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]]]:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @ai_bindings.setter
    def ai_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAiBindingsArgs']]]]):
        pulumi.set(self, "ai_bindings", value)

    @_builtins.property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]]]:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @analytics_engine_datasets.setter
    def analytics_engine_datasets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs']]]]):
        pulumi.set(self, "analytics_engine_datasets", value)

    @_builtins.property
    @pulumi.getter
    def browsers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]]]:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @browsers.setter
    def browsers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewBrowsersArgs']]]]):
        pulumi.set(self, "browsers", value)

    @_builtins.property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compatibility_date", value)

    @_builtins.property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @_builtins.property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]]]:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewD1DatabasesArgs']]]]):
        pulumi.set(self, "d1_databases", value)

    @_builtins.property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]]]:
        """
        Durable Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs']]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]]]:
        """
        Environment variables used for builds and Pages Functions.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @_builtins.property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]]]:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @hyperdrive_bindings.setter
    def hyperdrive_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs']]]]):
        pulumi.set(self, "hyperdrive_bindings", value)

    @_builtins.property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]]]:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewKvNamespacesArgs']]]]):
        pulumi.set(self, "kv_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]]]:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @mtls_certificates.setter
    def mtls_certificates(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs']]]]):
        pulumi.set(self, "mtls_certificates", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]:
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsPreviewPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]]]:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @queue_producers.setter
    def queue_producers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewQueueProducersArgs']]]]):
        pulumi.set(self, "queue_producers", value)

    @_builtins.property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]]]:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewR2BucketsArgs']]]]):
        pulumi.set(self, "r2_buckets", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewServicesArgs']]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]]]:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")

    @vectorize_bindings.setter
    def vectorize_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs']]]]):
        pulumi.set(self, "vectorize_bindings", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict(TypedDict):
        project_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsPreviewAiBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewAiBindingsArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the dataset.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewAnalyticsEngineDatasetsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: Name of the dataset.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewBrowsersArgsDict(TypedDict):
        pass
elif False:
    PagesProjectDeploymentConfigsPreviewBrowsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewBrowsersArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the D1 database.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewD1DatabasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewD1DatabasesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: UUID of the D1 database.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Durable Object namespace.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewDurableObjectNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace_id: ID of the Durable Object namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Durable Object namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Available values: "plain*text", "secret*text".
        """
        value: pulumi.Input[_builtins.str]
        """
        Environment variable value.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewEnvVarsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "plain*text", "secret*text".
        :param pulumi.Input[_builtins.str] value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "plain*text", "secret*text".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewHyperdriveBindingsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the KV namespace.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewKvNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewKvNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace_id: ID of the KV namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewMtlsCertificatesArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Placement mode.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Placement mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Queue.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewQueueProducersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewQueueProducersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Queue.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict(TypedDict):
        jurisdiction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Jurisdiction of the R2 bucket.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the R2 bucket.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewR2BucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewR2BucketsArgs:
    def __init__(__self__, *,
                 jurisdiction: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] jurisdiction: Jurisdiction of the R2 bucket.
        :param pulumi.Input[_builtins.str] name: Name of the R2 bucket.
        """
        if jurisdiction is not None:
            pulumi.set(__self__, "jurisdiction", jurisdiction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def jurisdiction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @jurisdiction.setter
    def jurisdiction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jurisdiction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewServicesArgsDict(TypedDict):
        entrypoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entrypoint to bind to.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Service environment.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Service name.
        """
elif False:
    PagesProjectDeploymentConfigsPreviewServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewServicesArgs:
    def __init__(__self__, *,
                 entrypoint: Optional[pulumi.Input[_builtins.str]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] entrypoint: The entrypoint to bind to.
        :param pulumi.Input[_builtins.str] environment: The Service environment.
        :param pulumi.Input[_builtins.str] service: The Service name.
        """
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def entrypoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @entrypoint.setter
    def entrypoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entrypoint", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict(TypedDict):
        index_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsPreviewVectorizeBindingsArgs:
    def __init__(__self__, *,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionArgsDict(TypedDict):
        ai_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgsDict']]]]
        """
        Constellation bindings used for Pages Functions.
        """
        analytics_engine_datasets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict']]]]
        """
        Analytics Engine bindings used for Pages Functions.
        """
        browsers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgsDict']]]]
        """
        Browser bindings used for Pages Functions.
        """
        compatibility_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compatibility date used for Pages Functions.
        """
        compatibility_flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Compatibility flags used for Pages Functions.
        """
        d1_databases: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict']]]]
        """
        D1 databases used for Pages Functions.
        """
        durable_object_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict']]]]
        """
        Durable Object namespaces used for Pages Functions.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgsDict']]]]
        """
        Environment variables used for builds and Pages Functions.
        """
        hyperdrive_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict']]]]
        """
        Hyperdrive bindings used for Pages Functions.
        """
        kv_namespaces: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict']]]]
        """
        KV namespaces used for Pages Functions.
        """
        mtls_certificates: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict']]]]
        """
        mTLS bindings used for Pages Functions.
        """
        placement: NotRequired[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgsDict']]
        """
        Placement setting used for Pages Functions.
        """
        queue_producers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgsDict']]]]
        """
        Queue Producer bindings used for Pages Functions.
        """
        r2_buckets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgsDict']]]]
        """
        R2 buckets used for Pages Functions.
        """
        services: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgsDict']]]]
        """
        Services used for Pages Functions.
        """
        vectorize_bindings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict']]]]
        """
        Vectorize bindings used for Pages Functions.
        """
elif False:
    PagesProjectDeploymentConfigsProductionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionArgs:
    def __init__(__self__, *,
                 ai_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]]] = None,
                 analytics_engine_datasets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]]] = None,
                 browsers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]]] = None,
                 compatibility_date: Optional[pulumi.Input[_builtins.str]] = None,
                 compatibility_flags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 d1_databases: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]]] = None,
                 durable_object_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]]] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]]] = None,
                 hyperdrive_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]]] = None,
                 kv_namespaces: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]]] = None,
                 mtls_certificates: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]]] = None,
                 placement: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']] = None,
                 queue_producers: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]]] = None,
                 r2_buckets: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]]] = None,
                 services: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]]] = None,
                 vectorize_bindings: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]] ai_bindings: Constellation bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]] analytics_engine_datasets: Analytics Engine bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]] browsers: Browser bindings used for Pages Functions.
        :param pulumi.Input[_builtins.str] compatibility_date: Compatibility date used for Pages Functions.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] compatibility_flags: Compatibility flags used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]] d1_databases: D1 databases used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]] durable_object_namespaces: Durable Object namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]] env_vars: Environment variables used for builds and Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]] hyperdrive_bindings: Hyperdrive bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]] kv_namespaces: KV namespaces used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]] mtls_certificates: mTLS bindings used for Pages Functions.
        :param pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs'] placement: Placement setting used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]] queue_producers: Queue Producer bindings used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]] r2_buckets: R2 buckets used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]] services: Services used for Pages Functions.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]] vectorize_bindings: Vectorize bindings used for Pages Functions.
        """
        if ai_bindings is not None:
            pulumi.set(__self__, "ai_bindings", ai_bindings)
        if analytics_engine_datasets is not None:
            pulumi.set(__self__, "analytics_engine_datasets", analytics_engine_datasets)
        if browsers is not None:
            pulumi.set(__self__, "browsers", browsers)
        if compatibility_date is not None:
            pulumi.set(__self__, "compatibility_date", compatibility_date)
        if compatibility_flags is not None:
            pulumi.set(__self__, "compatibility_flags", compatibility_flags)
        if d1_databases is not None:
            pulumi.set(__self__, "d1_databases", d1_databases)
        if durable_object_namespaces is not None:
            pulumi.set(__self__, "durable_object_namespaces", durable_object_namespaces)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if hyperdrive_bindings is not None:
            pulumi.set(__self__, "hyperdrive_bindings", hyperdrive_bindings)
        if kv_namespaces is not None:
            pulumi.set(__self__, "kv_namespaces", kv_namespaces)
        if mtls_certificates is not None:
            pulumi.set(__self__, "mtls_certificates", mtls_certificates)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if queue_producers is not None:
            pulumi.set(__self__, "queue_producers", queue_producers)
        if r2_buckets is not None:
            pulumi.set(__self__, "r2_buckets", r2_buckets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if vectorize_bindings is not None:
            pulumi.set(__self__, "vectorize_bindings", vectorize_bindings)

    @_builtins.property
    @pulumi.getter(name="aiBindings")
    def ai_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]]]:
        """
        Constellation bindings used for Pages Functions.
        """
        return pulumi.get(self, "ai_bindings")

    @ai_bindings.setter
    def ai_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAiBindingsArgs']]]]):
        pulumi.set(self, "ai_bindings", value)

    @_builtins.property
    @pulumi.getter(name="analyticsEngineDatasets")
    def analytics_engine_datasets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]]]:
        """
        Analytics Engine bindings used for Pages Functions.
        """
        return pulumi.get(self, "analytics_engine_datasets")

    @analytics_engine_datasets.setter
    def analytics_engine_datasets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs']]]]):
        pulumi.set(self, "analytics_engine_datasets", value)

    @_builtins.property
    @pulumi.getter
    def browsers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]]]:
        """
        Browser bindings used for Pages Functions.
        """
        return pulumi.get(self, "browsers")

    @browsers.setter
    def browsers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionBrowsersArgs']]]]):
        pulumi.set(self, "browsers", value)

    @_builtins.property
    @pulumi.getter(name="compatibilityDate")
    def compatibility_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compatibility date used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_date")

    @compatibility_date.setter
    def compatibility_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compatibility_date", value)

    @_builtins.property
    @pulumi.getter(name="compatibilityFlags")
    def compatibility_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Compatibility flags used for Pages Functions.
        """
        return pulumi.get(self, "compatibility_flags")

    @compatibility_flags.setter
    def compatibility_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "compatibility_flags", value)

    @_builtins.property
    @pulumi.getter(name="d1Databases")
    def d1_databases(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]]]:
        """
        D1 databases used for Pages Functions.
        """
        return pulumi.get(self, "d1_databases")

    @d1_databases.setter
    def d1_databases(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionD1DatabasesArgs']]]]):
        pulumi.set(self, "d1_databases", value)

    @_builtins.property
    @pulumi.getter(name="durableObjectNamespaces")
    def durable_object_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]]]:
        """
        Durable Object namespaces used for Pages Functions.
        """
        return pulumi.get(self, "durable_object_namespaces")

    @durable_object_namespaces.setter
    def durable_object_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs']]]]):
        pulumi.set(self, "durable_object_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]]]:
        """
        Environment variables used for builds and Pages Functions.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @_builtins.property
    @pulumi.getter(name="hyperdriveBindings")
    def hyperdrive_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]]]:
        """
        Hyperdrive bindings used for Pages Functions.
        """
        return pulumi.get(self, "hyperdrive_bindings")

    @hyperdrive_bindings.setter
    def hyperdrive_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs']]]]):
        pulumi.set(self, "hyperdrive_bindings", value)

    @_builtins.property
    @pulumi.getter(name="kvNamespaces")
    def kv_namespaces(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]]]:
        """
        KV namespaces used for Pages Functions.
        """
        return pulumi.get(self, "kv_namespaces")

    @kv_namespaces.setter
    def kv_namespaces(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionKvNamespacesArgs']]]]):
        pulumi.set(self, "kv_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="mtlsCertificates")
    def mtls_certificates(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]]]:
        """
        mTLS bindings used for Pages Functions.
        """
        return pulumi.get(self, "mtls_certificates")

    @mtls_certificates.setter
    def mtls_certificates(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs']]]]):
        pulumi.set(self, "mtls_certificates", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]:
        """
        Placement setting used for Pages Functions.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['PagesProjectDeploymentConfigsProductionPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="queueProducers")
    def queue_producers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]]]:
        """
        Queue Producer bindings used for Pages Functions.
        """
        return pulumi.get(self, "queue_producers")

    @queue_producers.setter
    def queue_producers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionQueueProducersArgs']]]]):
        pulumi.set(self, "queue_producers", value)

    @_builtins.property
    @pulumi.getter(name="r2Buckets")
    def r2_buckets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]]]:
        """
        R2 buckets used for Pages Functions.
        """
        return pulumi.get(self, "r2_buckets")

    @r2_buckets.setter
    def r2_buckets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionR2BucketsArgs']]]]):
        pulumi.set(self, "r2_buckets", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]]]:
        """
        Services used for Pages Functions.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionServicesArgs']]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="vectorizeBindings")
    def vectorize_bindings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]]]:
        """
        Vectorize bindings used for Pages Functions.
        """
        return pulumi.get(self, "vectorize_bindings")

    @vectorize_bindings.setter
    def vectorize_bindings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs']]]]):
        pulumi.set(self, "vectorize_bindings", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionAiBindingsArgsDict(TypedDict):
        project_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsProductionAiBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionAiBindingsArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the dataset.
        """
elif False:
    PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionAnalyticsEngineDatasetsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: Name of the dataset.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionBrowsersArgsDict(TypedDict):
        pass
elif False:
    PagesProjectDeploymentConfigsProductionBrowsersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionBrowsersArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the D1 database.
        """
elif False:
    PagesProjectDeploymentConfigsProductionD1DatabasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionD1DatabasesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: UUID of the D1 database.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the D1 database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Durable Object namespace.
        """
elif False:
    PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionDurableObjectNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace_id: ID of the Durable Object namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Durable Object namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionEnvVarsArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Available values: "plain*text", "secret*text".
        """
        value: pulumi.Input[_builtins.str]
        """
        Environment variable value.
        """
elif False:
    PagesProjectDeploymentConfigsProductionEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionEnvVarsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "plain*text", "secret*text".
        :param pulumi.Input[_builtins.str] value: Environment variable value.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "plain*text", "secret*text".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionHyperdriveBindingsArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict(TypedDict):
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the KV namespace.
        """
elif False:
    PagesProjectDeploymentConfigsProductionKvNamespacesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionKvNamespacesArgs:
    def __init__(__self__, *,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace_id: ID of the KV namespace.
        """
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the KV namespace.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict(TypedDict):
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsProductionMtlsCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionMtlsCertificatesArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None):
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Placement mode.
        """
elif False:
    PagesProjectDeploymentConfigsProductionPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Placement mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Placement mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionQueueProducersArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Queue.
        """
elif False:
    PagesProjectDeploymentConfigsProductionQueueProducersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionQueueProducersArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Queue.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Queue.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionR2BucketsArgsDict(TypedDict):
        jurisdiction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Jurisdiction of the R2 bucket.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the R2 bucket.
        """
elif False:
    PagesProjectDeploymentConfigsProductionR2BucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionR2BucketsArgs:
    def __init__(__self__, *,
                 jurisdiction: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] jurisdiction: Jurisdiction of the R2 bucket.
        :param pulumi.Input[_builtins.str] name: Name of the R2 bucket.
        """
        if jurisdiction is not None:
            pulumi.set(__self__, "jurisdiction", jurisdiction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def jurisdiction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Jurisdiction of the R2 bucket.
        """
        return pulumi.get(self, "jurisdiction")

    @jurisdiction.setter
    def jurisdiction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jurisdiction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the R2 bucket.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionServicesArgsDict(TypedDict):
        entrypoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entrypoint to bind to.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Service environment.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Service name.
        """
elif False:
    PagesProjectDeploymentConfigsProductionServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionServicesArgs:
    def __init__(__self__, *,
                 entrypoint: Optional[pulumi.Input[_builtins.str]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] entrypoint: The entrypoint to bind to.
        :param pulumi.Input[_builtins.str] environment: The Service environment.
        :param pulumi.Input[_builtins.str] service: The Service name.
        """
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def entrypoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entrypoint to bind to.
        """
        return pulumi.get(self, "entrypoint")

    @entrypoint.setter
    def entrypoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entrypoint", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Service environment.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict(TypedDict):
        index_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectDeploymentConfigsProductionVectorizeBindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectDeploymentConfigsProductionVectorizeBindingsArgs:
    def __init__(__self__, *,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class PagesProjectLatestDeploymentArgsDict(TypedDict):
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of alias URLs pointing to this deployment.
        """
        build_config: NotRequired[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgsDict']]
        """
        Configs for the project build process.
        """
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the deployment was created.
        """
        deployment_trigger: NotRequired[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgsDict']]
        """
        Info about what caused the deployment.
        """
        env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgsDict']]]]
        """
        Environment variables used for builds and Pages Functions.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of deploy.
        Available values: "preview", "production".
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the deployment.
        """
        is_skipped: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the deployment has been skipped.
        """
        latest_stage: NotRequired[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgsDict']]
        """
        The status of the deployment.
        """
        modified_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the deployment was last modified.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Id of the project.
        """
        project_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the project.
        """
        short_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Short Id (8 character) of the deployment.
        """
        source: NotRequired[pulumi.Input['PagesProjectLatestDeploymentSourceArgsDict']]
        stages: NotRequired[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgsDict']]]]
        """
        List of past stages.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The live URL to view this deployment.
        """
elif False:
    PagesProjectLatestDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentArgs:
    def __init__(__self__, *,
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 build_config: Optional[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs']] = None,
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 deployment_trigger: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs']] = None,
                 env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_skipped: Optional[pulumi.Input[_builtins.bool]] = None,
                 latest_stage: Optional[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs']] = None,
                 modified_on: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 project_name: Optional[pulumi.Input[_builtins.str]] = None,
                 short_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceArgs']] = None,
                 stages: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aliases: A list of alias URLs pointing to this deployment.
        :param pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs'] build_config: Configs for the project build process.
        :param pulumi.Input[_builtins.str] created_on: When the deployment was created.
        :param pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs'] deployment_trigger: Info about what caused the deployment.
        :param pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]] env_vars: Environment variables used for builds and Pages Functions.
        :param pulumi.Input[_builtins.str] environment: Type of deploy.
               Available values: "preview", "production".
        :param pulumi.Input[_builtins.str] id: Id of the deployment.
        :param pulumi.Input[_builtins.bool] is_skipped: If the deployment has been skipped.
        :param pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs'] latest_stage: The status of the deployment.
        :param pulumi.Input[_builtins.str] modified_on: When the deployment was last modified.
        :param pulumi.Input[_builtins.str] project_id: Id of the project.
        :param pulumi.Input[_builtins.str] project_name: Name of the project.
        :param pulumi.Input[_builtins.str] short_id: Short Id (8 character) of the deployment.
        :param pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]] stages: List of past stages.
        :param pulumi.Input[_builtins.str] url: The live URL to view this deployment.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if build_config is not None:
            pulumi.set(__self__, "build_config", build_config)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if deployment_trigger is not None:
            pulumi.set(__self__, "deployment_trigger", deployment_trigger)
        if env_vars is not None:
            pulumi.set(__self__, "env_vars", env_vars)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_skipped is not None:
            pulumi.set(__self__, "is_skipped", is_skipped)
        if latest_stage is not None:
            pulumi.set(__self__, "latest_stage", latest_stage)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if short_id is not None:
            pulumi.set(__self__, "short_id", short_id)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if stages is not None:
            pulumi.set(__self__, "stages", stages)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of alias URLs pointing to this deployment.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "aliases", value)

    @_builtins.property
    @pulumi.getter(name="buildConfig")
    def build_config(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs']]:
        """
        Configs for the project build process.
        """
        return pulumi.get(self, "build_config")

    @build_config.setter
    def build_config(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentBuildConfigArgs']]):
        pulumi.set(self, "build_config", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the deployment was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter(name="deploymentTrigger")
    def deployment_trigger(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs']]:
        """
        Info about what caused the deployment.
        """
        return pulumi.get(self, "deployment_trigger")

    @deployment_trigger.setter
    def deployment_trigger(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerArgs']]):
        pulumi.set(self, "deployment_trigger", value)

    @_builtins.property
    @pulumi.getter(name="envVars")
    def env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]]]:
        """
        Environment variables used for builds and Pages Functions.
        """
        return pulumi.get(self, "env_vars")

    @env_vars.setter
    def env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['PagesProjectLatestDeploymentEnvVarsArgs']]]]):
        pulumi.set(self, "env_vars", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of deploy.
        Available values: "preview", "production".
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the deployment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isSkipped")
    def is_skipped(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the deployment has been skipped.
        """
        return pulumi.get(self, "is_skipped")

    @is_skipped.setter
    def is_skipped(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_skipped", value)

    @_builtins.property
    @pulumi.getter(name="latestStage")
    def latest_stage(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs']]:
        """
        The status of the deployment.
        """
        return pulumi.get(self, "latest_stage")

    @latest_stage.setter
    def latest_stage(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentLatestStageArgs']]):
        pulumi.set(self, "latest_stage", value)

    @_builtins.property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the deployment was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modified_on", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Id of the project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the project.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_name", value)

    @_builtins.property
    @pulumi.getter(name="shortId")
    def short_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Short Id (8 character) of the deployment.
        """
        return pulumi.get(self, "short_id")

    @short_id.setter
    def short_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "short_id", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceArgs']]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]]]:
        """
        List of past stages.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PagesProjectLatestDeploymentStageArgs']]]]):
        pulumi.set(self, "stages", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The live URL to view this deployment.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PagesProjectLatestDeploymentBuildConfigArgsDict(TypedDict):
        build_caching: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable build caching for the project.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Command used to build project.
        """
        destination_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Output directory of the build.
        """
        root_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Directory to run the command.
        """
        web_analytics_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The classifying tag for analytics.
        """
        web_analytics_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The auth token for analytics.
        """
elif False:
    PagesProjectLatestDeploymentBuildConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentBuildConfigArgs:
    def __init__(__self__, *,
                 build_caching: Optional[pulumi.Input[_builtins.bool]] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 root_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 web_analytics_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 web_analytics_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] build_caching: Enable build caching for the project.
        :param pulumi.Input[_builtins.str] build_command: Command used to build project.
        :param pulumi.Input[_builtins.str] destination_dir: Output directory of the build.
        :param pulumi.Input[_builtins.str] root_dir: Directory to run the command.
        :param pulumi.Input[_builtins.str] web_analytics_tag: The classifying tag for analytics.
        :param pulumi.Input[_builtins.str] web_analytics_token: The auth token for analytics.
        """
        if build_caching is not None:
            pulumi.set(__self__, "build_caching", build_caching)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if destination_dir is not None:
            pulumi.set(__self__, "destination_dir", destination_dir)
        if root_dir is not None:
            pulumi.set(__self__, "root_dir", root_dir)
        if web_analytics_tag is not None:
            pulumi.set(__self__, "web_analytics_tag", web_analytics_tag)
        if web_analytics_token is not None:
            pulumi.set(__self__, "web_analytics_token", web_analytics_token)

    @_builtins.property
    @pulumi.getter(name="buildCaching")
    def build_caching(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable build caching for the project.
        """
        return pulumi.get(self, "build_caching")

    @build_caching.setter
    def build_caching(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "build_caching", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Command used to build project.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter(name="destinationDir")
    def destination_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Output directory of the build.
        """
        return pulumi.get(self, "destination_dir")

    @destination_dir.setter
    def destination_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_dir", value)

    @_builtins.property
    @pulumi.getter(name="rootDir")
    def root_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Directory to run the command.
        """
        return pulumi.get(self, "root_dir")

    @root_dir.setter
    def root_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_dir", value)

    @_builtins.property
    @pulumi.getter(name="webAnalyticsTag")
    def web_analytics_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The classifying tag for analytics.
        """
        return pulumi.get(self, "web_analytics_tag")

    @web_analytics_tag.setter
    def web_analytics_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_analytics_tag", value)

    @_builtins.property
    @pulumi.getter(name="webAnalyticsToken")
    def web_analytics_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The auth token for analytics.
        """
        return pulumi.get(self, "web_analytics_token")

    @web_analytics_token.setter
    def web_analytics_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_analytics_token", value)


if not MYPY:
    class PagesProjectLatestDeploymentDeploymentTriggerArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict']]
        """
        Additional info about the trigger.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        What caused the deployment.
        Available values: "push", "ad_hoc".
        """
elif False:
    PagesProjectLatestDeploymentDeploymentTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentDeploymentTriggerArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs'] metadata: Additional info about the trigger.
        :param pulumi.Input[_builtins.str] type: What caused the deployment.
               Available values: "push", "ad_hoc".
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs']]:
        """
        Additional info about the trigger.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        What caused the deployment.
        Available values: "push", "ad_hoc".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where the trigger happened.
        """
        commit_hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hash of the deployment trigger commit.
        """
        commit_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Message of the deployment trigger commit.
        """
elif False:
    PagesProjectLatestDeploymentDeploymentTriggerMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentDeploymentTriggerMetadataArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_hash: Optional[pulumi.Input[_builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: Where the trigger happened.
        :param pulumi.Input[_builtins.str] commit_hash: Hash of the deployment trigger commit.
        :param pulumi.Input[_builtins.str] commit_message: Message of the deployment trigger commit.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_hash is not None:
            pulumi.set(__self__, "commit_hash", commit_hash)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where the trigger happened.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="commitHash")
    def commit_hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hash of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_hash")

    @commit_hash.setter
    def commit_hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_hash", value)

    @_builtins.property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Message of the deployment trigger commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "commit_message", value)


if not MYPY:
    class PagesProjectLatestDeploymentEnvVarsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "plain*text", "secret*text".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Environment variable value.
        """
elif False:
    PagesProjectLatestDeploymentEnvVarsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentEnvVarsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "plain*text", "secret*text".
        :param pulumi.Input[_builtins.str] value: Environment variable value.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "plain*text", "secret*text".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PagesProjectLatestDeploymentLatestStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        started_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
elif False:
    PagesProjectLatestDeploymentLatestStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentLatestStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 started_on: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ended_on: When the stage ended.
        :param pulumi.Input[_builtins.str] name: The current build stage.
               Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        :param pulumi.Input[_builtins.str] started_on: When the stage started.
        :param pulumi.Input[_builtins.str] status: State of the current stage.
               Available values: "success", "idle", "active", "failure", "canceled".
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ended_on", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_on", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectLatestDeploymentSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgsDict']]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectLatestDeploymentSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectLatestDeploymentSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectLatestDeploymentSourceConfigArgsDict(TypedDict):
        deployments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        path_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        path_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        pr_comments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        preview_deployment_setting: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "all", "none", "custom".
        """
        production_branch: NotRequired[pulumi.Input[_builtins.str]]
        production_deployments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        repo_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectLatestDeploymentSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentSourceConfigArgs:
    def __init__(__self__, *,
                 deployments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 path_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 path_includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[_builtins.str]] = None,
                 production_branch: Optional[pulumi.Input[_builtins.str]] = None,
                 production_deployments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] preview_deployment_setting: Available values: "all", "none", "custom".
        """
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @_builtins.property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_excludes")

    @path_excludes.setter
    def path_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_excludes", value)

    @_builtins.property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_includes")

    @path_includes.setter
    def path_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_includes", value)

    @_builtins.property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @_builtins.property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @_builtins.property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @_builtins.property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "all", "none", "custom".
        """
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @_builtins.property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "production_branch", value)

    @_builtins.property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "production_deployments_enabled")

    @production_deployments_enabled.setter
    def production_deployments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "production_deployments_enabled", value)

    @_builtins.property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class PagesProjectLatestDeploymentStageArgsDict(TypedDict):
        ended_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage ended.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        started_on: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the stage started.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
elif False:
    PagesProjectLatestDeploymentStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectLatestDeploymentStageArgs:
    def __init__(__self__, *,
                 ended_on: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 started_on: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ended_on: When the stage ended.
        :param pulumi.Input[_builtins.str] name: The current build stage.
               Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        :param pulumi.Input[_builtins.str] started_on: When the stage started.
        :param pulumi.Input[_builtins.str] status: State of the current stage.
               Available values: "success", "idle", "active", "failure", "canceled".
        """
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage ended.
        """
        return pulumi.get(self, "ended_on")

    @ended_on.setter
    def ended_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ended_on", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current build stage.
        Available values: "queued", "initialize", "clone_repo", "build", "deploy".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the stage started.
        """
        return pulumi.get(self, "started_on")

    @started_on.setter
    def started_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_on", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State of the current stage.
        Available values: "success", "idle", "active", "failure", "canceled".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PagesProjectSourceArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['PagesProjectSourceConfigArgsDict']]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectSourceArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['PagesProjectSourceConfigArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['PagesProjectSourceConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['PagesProjectSourceConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PagesProjectSourceConfigArgsDict(TypedDict):
        deployments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        owner: NotRequired[pulumi.Input[_builtins.str]]
        path_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        path_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        pr_comments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        preview_branch_excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        preview_branch_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        preview_deployment_setting: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "all", "none", "custom".
        """
        production_branch: NotRequired[pulumi.Input[_builtins.str]]
        production_deployments_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        repo_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PagesProjectSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagesProjectSourceConfigArgs:
    def __init__(__self__, *,
                 deployments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 owner: Optional[pulumi.Input[_builtins.str]] = None,
                 path_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 path_includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pr_comments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 preview_branch_excludes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preview_branch_includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preview_deployment_setting: Optional[pulumi.Input[_builtins.str]] = None,
                 production_branch: Optional[pulumi.Input[_builtins.str]] = None,
                 production_deployments_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] preview_deployment_setting: Available values: "all", "none", "custom".
        """
        if deployments_enabled is not None:
            pulumi.set(__self__, "deployments_enabled", deployments_enabled)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if path_excludes is not None:
            pulumi.set(__self__, "path_excludes", path_excludes)
        if path_includes is not None:
            pulumi.set(__self__, "path_includes", path_includes)
        if pr_comments_enabled is not None:
            pulumi.set(__self__, "pr_comments_enabled", pr_comments_enabled)
        if preview_branch_excludes is not None:
            pulumi.set(__self__, "preview_branch_excludes", preview_branch_excludes)
        if preview_branch_includes is not None:
            pulumi.set(__self__, "preview_branch_includes", preview_branch_includes)
        if preview_deployment_setting is not None:
            pulumi.set(__self__, "preview_deployment_setting", preview_deployment_setting)
        if production_branch is not None:
            pulumi.set(__self__, "production_branch", production_branch)
        if production_deployments_enabled is not None:
            pulumi.set(__self__, "production_deployments_enabled", production_deployments_enabled)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @_builtins.property
    @pulumi.getter(name="deploymentsEnabled")
    def deployments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "deployments_enabled")

    @deployments_enabled.setter
    def deployments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deployments_enabled", value)

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "owner", value)

    @_builtins.property
    @pulumi.getter(name="pathExcludes")
    def path_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_excludes")

    @path_excludes.setter
    def path_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_excludes", value)

    @_builtins.property
    @pulumi.getter(name="pathIncludes")
    def path_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "path_includes")

    @path_includes.setter
    def path_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "path_includes", value)

    @_builtins.property
    @pulumi.getter(name="prCommentsEnabled")
    def pr_comments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "pr_comments_enabled")

    @pr_comments_enabled.setter
    def pr_comments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pr_comments_enabled", value)

    @_builtins.property
    @pulumi.getter(name="previewBranchExcludes")
    def preview_branch_excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "preview_branch_excludes")

    @preview_branch_excludes.setter
    def preview_branch_excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preview_branch_excludes", value)

    @_builtins.property
    @pulumi.getter(name="previewBranchIncludes")
    def preview_branch_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "preview_branch_includes")

    @preview_branch_includes.setter
    def preview_branch_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preview_branch_includes", value)

    @_builtins.property
    @pulumi.getter(name="previewDeploymentSetting")
    def preview_deployment_setting(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "all", "none", "custom".
        """
        return pulumi.get(self, "preview_deployment_setting")

    @preview_deployment_setting.setter
    def preview_deployment_setting(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preview_deployment_setting", value)

    @_builtins.property
    @pulumi.getter(name="productionBranch")
    def production_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "production_branch")

    @production_branch.setter
    def production_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "production_branch", value)

    @_builtins.property
    @pulumi.getter(name="productionDeploymentsEnabled")
    def production_deployments_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "production_deployments_enabled")

    @production_deployments_enabled.setter
    def production_deployments_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "production_deployments_enabled", value)

    @_builtins.property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class QueueConsumerArgsDict(TypedDict):
        consumer_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Resource identifier.
        """
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        queue_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Resource identifier.
        """
        script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Worker
        """
        script_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a Worker
        """
        settings: NotRequired[pulumi.Input['QueueConsumerSettingsArgsDict']]
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "worker", "http_pull".
        """
elif False:
    QueueConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueConsumerArgs:
    def __init__(__self__, *,
                 consumer_id: Optional[pulumi.Input[_builtins.str]] = None,
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_id: Optional[pulumi.Input[_builtins.str]] = None,
                 script: Optional[pulumi.Input[_builtins.str]] = None,
                 script_name: Optional[pulumi.Input[_builtins.str]] = None,
                 settings: Optional[pulumi.Input['QueueConsumerSettingsArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] consumer_id: A Resource identifier.
        :param pulumi.Input[_builtins.str] queue_id: A Resource identifier.
        :param pulumi.Input[_builtins.str] script: Name of a Worker
        :param pulumi.Input[_builtins.str] script_name: Name of a Worker
        :param pulumi.Input[_builtins.str] type: Available values: "worker", "http_pull".
        """
        if consumer_id is not None:
            pulumi.set(__self__, "consumer_id", consumer_id)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if queue_id is not None:
            pulumi.set(__self__, "queue_id", queue_id)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="consumerId")
    def consumer_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "consumer_id")

    @consumer_id.setter
    def consumer_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_id", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Resource identifier.
        """
        return pulumi.get(self, "queue_id")

    @queue_id.setter
    def queue_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "queue_id", value)

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script", value)

    @_builtins.property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a Worker
        """
        return pulumi.get(self, "script_name")

    @script_name.setter
    def script_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script_name", value)

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['QueueConsumerSettingsArgs']]:
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['QueueConsumerSettingsArgs']]):
        pulumi.set(self, "settings", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "worker", "http_pull".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class QueueConsumerSettingsArgsDict(TypedDict):
        batch_size: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum number of messages to include in a batch.
        """
        max_concurrency: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        max_retries: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum number of retries
        """
        max_wait_time_ms: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        retry_delay: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        visibility_timeout_ms: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
elif False:
    QueueConsumerSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueConsumerSettingsArgs:
    def __init__(__self__, *,
                 batch_size: Optional[pulumi.Input[_builtins.float]] = None,
                 max_concurrency: Optional[pulumi.Input[_builtins.float]] = None,
                 max_retries: Optional[pulumi.Input[_builtins.float]] = None,
                 max_wait_time_ms: Optional[pulumi.Input[_builtins.float]] = None,
                 retry_delay: Optional[pulumi.Input[_builtins.float]] = None,
                 visibility_timeout_ms: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] batch_size: The maximum number of messages to include in a batch.
        :param pulumi.Input[_builtins.float] max_concurrency: Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        :param pulumi.Input[_builtins.float] max_retries: The maximum number of retries
        :param pulumi.Input[_builtins.float] max_wait_time_ms: The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        :param pulumi.Input[_builtins.float] retry_delay: The number of seconds to delay before making the message available for another attempt.
        :param pulumi.Input[_builtins.float] visibility_timeout_ms: The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if max_wait_time_ms is not None:
            pulumi.set(__self__, "max_wait_time_ms", max_wait_time_ms)
        if retry_delay is not None:
            pulumi.set(__self__, "retry_delay", retry_delay)
        if visibility_timeout_ms is not None:
            pulumi.set(__self__, "visibility_timeout_ms", visibility_timeout_ms)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum number of messages to include in a batch.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "batch_size", value)

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_concurrency", value)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_retries", value)

    @_builtins.property
    @pulumi.getter(name="maxWaitTimeMs")
    def max_wait_time_ms(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of milliseconds to wait for a batch to fill up before attempting to deliver it
        """
        return pulumi.get(self, "max_wait_time_ms")

    @max_wait_time_ms.setter
    def max_wait_time_ms(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_wait_time_ms", value)

    @_builtins.property
    @pulumi.getter(name="retryDelay")
    def retry_delay(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of seconds to delay before making the message available for another attempt.
        """
        return pulumi.get(self, "retry_delay")

    @retry_delay.setter
    def retry_delay(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "retry_delay", value)

    @_builtins.property
    @pulumi.getter(name="visibilityTimeoutMs")
    def visibility_timeout_ms(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        """
        return pulumi.get(self, "visibility_timeout_ms")

    @visibility_timeout_ms.setter
    def visibility_timeout_ms(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "visibility_timeout_ms", value)


if not MYPY:
    class QueueProducerArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        script: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "worker", "r2_bucket".
        """
elif False:
    QueueProducerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueProducerArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 script: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "worker", "r2_bucket".
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "worker", "r2_bucket".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class QueueSettingsArgsDict(TypedDict):
        delivery_delay: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        delivery_paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if message delivery to consumers is currently paused.
        """
        message_retention_period: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
elif False:
    QueueSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueSettingsArgs:
    def __init__(__self__, *,
                 delivery_delay: Optional[pulumi.Input[_builtins.float]] = None,
                 delivery_paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 message_retention_period: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] delivery_delay: Number of seconds to delay delivery of all messages to consumers.
        :param pulumi.Input[_builtins.bool] delivery_paused: Indicates if message delivery to consumers is currently paused.
        :param pulumi.Input[_builtins.float] message_retention_period: Number of seconds after which an unconsumed message will be delayed.
        """
        if delivery_delay is not None:
            pulumi.set(__self__, "delivery_delay", delivery_delay)
        if delivery_paused is not None:
            pulumi.set(__self__, "delivery_paused", delivery_paused)
        if message_retention_period is not None:
            pulumi.set(__self__, "message_retention_period", message_retention_period)

    @_builtins.property
    @pulumi.getter(name="deliveryDelay")
    def delivery_delay(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of seconds to delay delivery of all messages to consumers.
        """
        return pulumi.get(self, "delivery_delay")

    @delivery_delay.setter
    def delivery_delay(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "delivery_delay", value)

    @_builtins.property
    @pulumi.getter(name="deliveryPaused")
    def delivery_paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if message delivery to consumers is currently paused.
        """
        return pulumi.get(self, "delivery_paused")

    @delivery_paused.setter
    def delivery_paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delivery_paused", value)

    @_builtins.property
    @pulumi.getter(name="messageRetentionPeriod")
    def message_retention_period(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of seconds after which an unconsumed message will be delayed.
        """
        return pulumi.get(self, "message_retention_period")

    @message_retention_period.setter
    def message_retention_period(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "message_retention_period", value)


if not MYPY:
    class R2BucketCorsRuleArgsDict(TypedDict):
        allowed: pulumi.Input['R2BucketCorsRuleAllowedArgsDict']
        """
        Object specifying allowed origins, methods and headers for this CORS rule.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier for this rule.
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
elif False:
    R2BucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed: pulumi.Input['R2BucketCorsRuleAllowedArgs'],
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input['R2BucketCorsRuleAllowedArgs'] allowed: Object specifying allowed origins, methods and headers for this CORS rule.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        :param pulumi.Input[_builtins.str] id: Identifier for this rule.
        :param pulumi.Input[_builtins.float] max_age_seconds: Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        pulumi.set(__self__, "allowed", allowed)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter
    def allowed(self) -> pulumi.Input['R2BucketCorsRuleAllowedArgs']:
        """
        Object specifying allowed origins, methods and headers for this CORS rule.
        """
        return pulumi.get(self, "allowed")

    @allowed.setter
    def allowed(self, value: pulumi.Input['R2BucketCorsRuleAllowedArgs']):
        pulumi.set(self, "allowed", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier for this rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class R2BucketCorsRuleAllowedArgsDict(TypedDict):
        methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        """
        origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
elif False:
    R2BucketCorsRuleAllowedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketCorsRuleAllowedArgs:
    def __init__(__self__, *,
                 methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] origins: Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "origins", origins)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "origins", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class R2BucketEventNotificationRuleArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Array of R2 object actions that will trigger notifications.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description that can be used to identify the event notification rule after creation.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notifications will be sent only for objects with this prefix.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Notifications will be sent only for objects with this suffix.
        """
elif False:
    R2BucketEventNotificationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketEventNotificationRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: Array of R2 object actions that will trigger notifications.
        :param pulumi.Input[_builtins.str] description: A description that can be used to identify the event notification rule after creation.
        :param pulumi.Input[_builtins.str] prefix: Notifications will be sent only for objects with this prefix.
        :param pulumi.Input[_builtins.str] suffix: Notifications will be sent only for objects with this suffix.
        """
        pulumi.set(__self__, "actions", actions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Array of R2 object actions that will trigger notifications.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description that can be used to identify the event notification rule after creation.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notifications will be sent only for objects with this prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Notifications will be sent only for objects with this suffix.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class R2BucketLifecycleRuleArgsDict(TypedDict):
        conditions: pulumi.Input['R2BucketLifecycleRuleConditionsArgsDict']
        """
        Conditions that apply to all transitions of this rule.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether or not this rule is in effect.
        """
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for this rule.
        """
        abort_multipart_uploads_transition: NotRequired[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict']]
        """
        Transition to abort ongoing multipart uploads.
        """
        delete_objects_transition: NotRequired[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict']]
        """
        Transition to delete objects.
        """
        storage_class_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgsDict']]]]
        """
        Transitions to change the storage class of objects.
        """
elif False:
    R2BucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input['R2BucketLifecycleRuleConditionsArgs'],
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str],
                 abort_multipart_uploads_transition: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs']] = None,
                 delete_objects_transition: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs']] = None,
                 storage_class_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]]] = None):
        """
        :param pulumi.Input['R2BucketLifecycleRuleConditionsArgs'] conditions: Conditions that apply to all transitions of this rule.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not this rule is in effect.
        :param pulumi.Input[_builtins.str] id: Unique identifier for this rule.
        :param pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs'] abort_multipart_uploads_transition: Transition to abort ongoing multipart uploads.
        :param pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs'] delete_objects_transition: Transition to delete objects.
        :param pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]] storage_class_transitions: Transitions to change the storage class of objects.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if abort_multipart_uploads_transition is not None:
            pulumi.set(__self__, "abort_multipart_uploads_transition", abort_multipart_uploads_transition)
        if delete_objects_transition is not None:
            pulumi.set(__self__, "delete_objects_transition", delete_objects_transition)
        if storage_class_transitions is not None:
            pulumi.set(__self__, "storage_class_transitions", storage_class_transitions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input['R2BucketLifecycleRuleConditionsArgs']:
        """
        Conditions that apply to all transitions of this rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input['R2BucketLifecycleRuleConditionsArgs']):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether or not this rule is in effect.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for this rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="abortMultipartUploadsTransition")
    def abort_multipart_uploads_transition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs']]:
        """
        Transition to abort ongoing multipart uploads.
        """
        return pulumi.get(self, "abort_multipart_uploads_transition")

    @abort_multipart_uploads_transition.setter
    def abort_multipart_uploads_transition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs']]):
        pulumi.set(self, "abort_multipart_uploads_transition", value)

    @_builtins.property
    @pulumi.getter(name="deleteObjectsTransition")
    def delete_objects_transition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs']]:
        """
        Transition to delete objects.
        """
        return pulumi.get(self, "delete_objects_transition")

    @delete_objects_transition.setter
    def delete_objects_transition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionArgs']]):
        pulumi.set(self, "delete_objects_transition", value)

    @_builtins.property
    @pulumi.getter(name="storageClassTransitions")
    def storage_class_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]]]:
        """
        Transitions to change the storage class of objects.
        """
        return pulumi.get(self, "storage_class_transitions")

    @storage_class_transitions.setter
    def storage_class_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionArgs']]]]):
        pulumi.set(self, "storage_class_transitions", value)


if not MYPY:
    class R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict']]
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
elif False:
    R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleAbortMultipartUploadsTransitionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs']] = None):
        """
        :param pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs'] condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs']]:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict(TypedDict):
        max_age: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        """
        Available values: "Age".
        """
elif False:
    R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleAbortMultipartUploadsTransitionConditionArgs:
    def __init__(__self__, *,
                 max_age: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "Age".
        """
        pulumi.set(__self__, "max_age", max_age)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_age", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "Age".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class R2BucketLifecycleRuleConditionsArgsDict(TypedDict):
        prefix: pulumi.Input[_builtins.str]
        """
        Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
        """
elif False:
    R2BucketLifecycleRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleConditionsArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] prefix: Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
        """
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict']]
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
elif False:
    R2BucketLifecycleRuleDeleteObjectsTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleDeleteObjectsTransitionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs']] = None):
        """
        :param pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs'] condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs']]:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Available values: "Age", "Date".
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        max_age: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleDeleteObjectsTransitionConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "Age", "Date".
        """
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "Age", "Date".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class R2BucketLifecycleRuleStorageClassTransitionArgsDict(TypedDict):
        condition: pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict']
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
        storage_class: pulumi.Input[_builtins.str]
        """
        Available values: "InfrequentAccess".
        """
elif False:
    R2BucketLifecycleRuleStorageClassTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleStorageClassTransitionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs'],
                 storage_class: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs'] condition: Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        :param pulumi.Input[_builtins.str] storage_class: Available values: "InfrequentAccess".
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs']:
        """
        Condition for lifecycle transitions to apply after an object reaches an age in seconds.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['R2BucketLifecycleRuleStorageClassTransitionConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "InfrequentAccess".
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Available values: "Age", "Date".
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        max_age: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    R2BucketLifecycleRuleStorageClassTransitionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLifecycleRuleStorageClassTransitionConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "Age", "Date".
        """
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "Age", "Date".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class R2BucketLockRuleArgsDict(TypedDict):
        condition: pulumi.Input['R2BucketLockRuleConditionArgsDict']
        """
        Condition to apply a lock rule to an object for how long in seconds.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether or not this rule is in effect.
        """
        id: pulumi.Input[_builtins.str]
        """
        Unique identifier for this rule.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
        """
elif False:
    R2BucketLockRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLockRuleArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['R2BucketLockRuleConditionArgs'],
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str],
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['R2BucketLockRuleConditionArgs'] condition: Condition to apply a lock rule to an object for how long in seconds.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not this rule is in effect.
        :param pulumi.Input[_builtins.str] id: Unique identifier for this rule.
        :param pulumi.Input[_builtins.str] prefix: Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['R2BucketLockRuleConditionArgs']:
        """
        Condition to apply a lock rule to an object for how long in seconds.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['R2BucketLockRuleConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether or not this rule is in effect.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Unique identifier for this rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class R2BucketLockRuleConditionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Available values: "Age", "Date", "Indefinite".
        """
        date: NotRequired[pulumi.Input[_builtins.str]]
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    R2BucketLockRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketLockRuleConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Available values: "Age", "Date", "Indefinite".
        """
        pulumi.set(__self__, "type", type)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "Age", "Date", "Indefinite".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class R2BucketSippyDestinationArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of a Cloudflare API token.
        This is the value labelled "Access Key ID" when creating an API.
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        """
        cloud_provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "r2".
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of a Cloudflare API token.
        This is the value labelled "Secret Access Key" when creating an API.
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).

        Sippy will use this token when writing objects to R2, so it is
        best to scope this token to the bucket you're enabling Sippy for.
        """
elif False:
    R2BucketSippyDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketSippyDestinationArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key_id: ID of a Cloudflare API token.
               This is the value labelled "Access Key ID" when creating an API.
               token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        :param pulumi.Input[_builtins.str] cloud_provider: Available values: "r2".
        :param pulumi.Input[_builtins.str] secret_access_key: Value of a Cloudflare API token.
               This is the value labelled "Secret Access Key" when creating an API.
               token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
               
               Sippy will use this token when writing objects to R2, so it is
               best to scope this token to the bucket you're enabling Sippy for.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of a Cloudflare API token.
        This is the value labelled "Access Key ID" when creating an API.
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "r2".
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_provider", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of a Cloudflare API token.
        This is the value labelled "Secret Access Key" when creating an API.
        token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).

        Sippy will use this token when writing objects to R2, so it is
        best to scope this token to the bucket you're enabling Sippy for.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class R2BucketSippySourceArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access Key ID of an IAM credential (ideally scoped to a single S3 bucket).
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the AWS S3 bucket.
        """
        client_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client email of an IAM credential (ideally scoped to a single GCS bucket).
        """
        cloud_provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "aws", "gcs".
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private Key of an IAM credential (ideally scoped to a single GCS bucket).
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the AWS availability zone.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket).
        """
elif False:
    R2BucketSippySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2BucketSippySourceArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 client_email: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_provider: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key_id: Access Key ID of an IAM credential (ideally scoped to a single S3 bucket).
        :param pulumi.Input[_builtins.str] bucket: Name of the AWS S3 bucket.
        :param pulumi.Input[_builtins.str] client_email: Client email of an IAM credential (ideally scoped to a single GCS bucket).
        :param pulumi.Input[_builtins.str] cloud_provider: Available values: "aws", "gcs".
        :param pulumi.Input[_builtins.str] private_key: Private Key of an IAM credential (ideally scoped to a single GCS bucket).
        :param pulumi.Input[_builtins.str] region: Name of the AWS availability zone.
        :param pulumi.Input[_builtins.str] secret_access_key: Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket).
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access Key ID of an IAM credential (ideally scoped to a single S3 bucket).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the AWS S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client email of an IAM credential (ideally scoped to a single GCS bucket).
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_email", value)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "aws", "gcs".
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_provider", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private Key of an IAM credential (ideally scoped to a single GCS bucket).
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the AWS availability zone.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket).
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class R2CustomDomainStatusArgsDict(TypedDict):
        ownership: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ownership status of the domain.
        Available values: "pending", "active", "deactivated", "blocked", "error", "unknown".
        """
        ssl: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSL certificate status.
        Available values: "initializing", "pending", "active", "deactivated", "error", "unknown".
        """
elif False:
    R2CustomDomainStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class R2CustomDomainStatusArgs:
    def __init__(__self__, *,
                 ownership: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ownership: Ownership status of the domain.
               Available values: "pending", "active", "deactivated", "blocked", "error", "unknown".
        :param pulumi.Input[_builtins.str] ssl: SSL certificate status.
               Available values: "initializing", "pending", "active", "deactivated", "error", "unknown".
        """
        if ownership is not None:
            pulumi.set(__self__, "ownership", ownership)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)

    @_builtins.property
    @pulumi.getter
    def ownership(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ownership status of the domain.
        Available values: "pending", "active", "deactivated", "blocked", "error", "unknown".
        """
        return pulumi.get(self, "ownership")

    @ownership.setter
    def ownership(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ownership", value)

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSL certificate status.
        Available values: "initializing", "pending", "active", "deactivated", "error", "unknown".
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl", value)


if not MYPY:
    class RateLimitActionArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to perform.
        Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
        """
        response: NotRequired[pulumi.Input['RateLimitActionResponseArgsDict']]
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        timeout: NotRequired[pulumi.Input[_builtins.float]]
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
elif False:
    RateLimitActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitActionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input['RateLimitActionResponseArgs']] = None,
                 timeout: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The action to perform.
               Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
        :param pulumi.Input['RateLimitActionResponseArgs'] response: A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
               Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        :param pulumi.Input[_builtins.float] timeout: The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
               Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to perform.
        Available values: "simulate", "ban", "challenge", "js*challenge", "managed*challenge".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitActionResponseArgs']]:
        """
        A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
        Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitActionResponseArgs']]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
        Notes: If "mode" is "challenge", "managed*challenge", or "js*challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RateLimitActionResponseArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.str]]
        """
        The response body to return. The value must conform to the configured content type.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
elif False:
    RateLimitActionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitActionResponseArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: The response body to return. The value must conform to the configured content type.
        :param pulumi.Input[_builtins.str] content_type: The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The response body to return. The value must conform to the configured content type.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class RateLimitBypassArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "url".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to bypass.
        """
elif False:
    RateLimitBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitBypassArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Available values: "url".
        :param pulumi.Input[_builtins.str] value: The URL to bypass.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "url".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to bypass.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RateLimitMatchArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgsDict']]]]
        request: NotRequired[pulumi.Input['RateLimitMatchRequestArgsDict']]
        response: NotRequired[pulumi.Input['RateLimitMatchResponseArgsDict']]
elif False:
    RateLimitMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgs']]]] = None,
                 request: Optional[pulumi.Input['RateLimitMatchRequestArgs']] = None,
                 response: Optional[pulumi.Input['RateLimitMatchResponseArgs']] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgs']]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitMatchHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['RateLimitMatchRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['RateLimitMatchRequestArgs']]):
        pulumi.set(self, "request", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RateLimitMatchResponseArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RateLimitMatchResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class RateLimitMatchHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the response header to match.
        """
        op: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        Available values: "eq", "ne".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the response header, which must match exactly.
        """
elif False:
    RateLimitMatchHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 op: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the response header to match.
        :param pulumi.Input[_builtins.str] op: The operator used when matching: `eq` means "equal" and `ne` means "not equal".
               Available values: "eq", "ne".
        :param pulumi.Input[_builtins.str] value: The value of the response header, which must match exactly.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the response header to match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operator used when matching: `eq` means "equal" and `ne` means "not equal".
        Available values: "eq", "ne".
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the response header, which must match exactly.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RateLimitMatchRequestArgsDict(TypedDict):
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        schemes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
elif False:
    RateLimitMatchRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchRequestArgs:
    def __init__(__self__, *,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 schemes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] schemes: The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        :param pulumi.Input[_builtins.str] url: The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if schemes is not None:
            pulumi.set(__self__, "schemes", schemes)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def schemes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
        """
        return pulumi.get(self, "schemes")

    @schemes.setter
    def schemes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "schemes", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class RateLimitMatchResponseArgsDict(TypedDict):
        origin_traffic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
elif False:
    RateLimitMatchResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RateLimitMatchResponseArgs:
    def __init__(__self__, *,
                 origin_traffic: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] origin_traffic: When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
               Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        if origin_traffic is not None:
            pulumi.set(__self__, "origin_traffic", origin_traffic)

    @_builtins.property
    @pulumi.getter(name="originTraffic")
    def origin_traffic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
        Notes: This field is deprecated. Instead, use response headers and set "origin*traffic" to "false" to avoid legacy behaviour interacting with the "response*headers" property.
        """
        return pulumi.get(self, "origin_traffic")

    @origin_traffic.setter
    def origin_traffic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "origin_traffic", value)


if not MYPY:
    class RecordDataArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[_builtins.float]]
        """
        Algorithm.
        """
        altitude: NotRequired[pulumi.Input[_builtins.float]]
        """
        Altitude of location in meters.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate.
        """
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        Digest.
        """
        digest_type: NotRequired[pulumi.Input[_builtins.float]]
        """
        Digest Type.
        """
        fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fingerprint.
        """
        flags: NotRequired[Any]
        """
        Flags for the CAA record.
        """
        key_tag: NotRequired[pulumi.Input[_builtins.float]]
        """
        Key Tag.
        """
        lat_degrees: NotRequired[pulumi.Input[_builtins.float]]
        """
        Degrees of latitude.
        """
        lat_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Latitude direction.
        Available values: "N", "S".
        """
        lat_minutes: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minutes of latitude.
        """
        lat_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Seconds of latitude.
        """
        long_degrees: NotRequired[pulumi.Input[_builtins.float]]
        """
        Degrees of longitude.
        """
        long_direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Longitude direction.
        Available values: "E", "W".
        """
        long_minutes: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minutes of longitude.
        """
        long_seconds: NotRequired[pulumi.Input[_builtins.float]]
        """
        Seconds of longitude.
        """
        matching_type: NotRequired[pulumi.Input[_builtins.float]]
        """
        Matching Type.
        """
        order: NotRequired[pulumi.Input[_builtins.float]]
        """
        Order.
        """
        port: NotRequired[pulumi.Input[_builtins.float]]
        """
        The port of the service.
        """
        precision_horz: NotRequired[pulumi.Input[_builtins.float]]
        """
        Horizontal precision of location.
        """
        precision_vert: NotRequired[pulumi.Input[_builtins.float]]
        """
        Vertical precision of location.
        """
        preference: NotRequired[pulumi.Input[_builtins.float]]
        """
        Preference.
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        Priority.
        """
        protocol: NotRequired[pulumi.Input[_builtins.float]]
        """
        Protocol.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public Key.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regex.
        """
        replacement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Replacement.
        """
        selector: NotRequired[pulumi.Input[_builtins.float]]
        """
        Selector.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Service.
        """
        size: NotRequired[pulumi.Input[_builtins.float]]
        """
        Size of location in meters.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Target.
        """
        type: NotRequired[pulumi.Input[_builtins.float]]
        """
        Type.
        """
        usage: NotRequired[pulumi.Input[_builtins.float]]
        """
        Usage.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The record weight.
        """
elif False:
    RecordDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordDataArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[_builtins.float]] = None,
                 altitude: Optional[pulumi.Input[_builtins.float]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 digest_type: Optional[pulumi.Input[_builtins.float]] = None,
                 fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 flags: Optional[Any] = None,
                 key_tag: Optional[pulumi.Input[_builtins.float]] = None,
                 lat_degrees: Optional[pulumi.Input[_builtins.float]] = None,
                 lat_direction: Optional[pulumi.Input[_builtins.str]] = None,
                 lat_minutes: Optional[pulumi.Input[_builtins.float]] = None,
                 lat_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 long_degrees: Optional[pulumi.Input[_builtins.float]] = None,
                 long_direction: Optional[pulumi.Input[_builtins.str]] = None,
                 long_minutes: Optional[pulumi.Input[_builtins.float]] = None,
                 long_seconds: Optional[pulumi.Input[_builtins.float]] = None,
                 matching_type: Optional[pulumi.Input[_builtins.float]] = None,
                 order: Optional[pulumi.Input[_builtins.float]] = None,
                 port: Optional[pulumi.Input[_builtins.float]] = None,
                 precision_horz: Optional[pulumi.Input[_builtins.float]] = None,
                 precision_vert: Optional[pulumi.Input[_builtins.float]] = None,
                 preference: Optional[pulumi.Input[_builtins.float]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 protocol: Optional[pulumi.Input[_builtins.float]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None,
                 replacement: Optional[pulumi.Input[_builtins.str]] = None,
                 selector: Optional[pulumi.Input[_builtins.float]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.float]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.float]] = None,
                 usage: Optional[pulumi.Input[_builtins.float]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] algorithm: Algorithm.
        :param pulumi.Input[_builtins.float] altitude: Altitude of location in meters.
        :param pulumi.Input[_builtins.str] certificate: Certificate.
        :param pulumi.Input[_builtins.str] digest: Digest.
        :param pulumi.Input[_builtins.float] digest_type: Digest Type.
        :param pulumi.Input[_builtins.str] fingerprint: Fingerprint.
        :param Any flags: Flags for the CAA record.
        :param pulumi.Input[_builtins.float] key_tag: Key Tag.
        :param pulumi.Input[_builtins.float] lat_degrees: Degrees of latitude.
        :param pulumi.Input[_builtins.str] lat_direction: Latitude direction.
               Available values: "N", "S".
        :param pulumi.Input[_builtins.float] lat_minutes: Minutes of latitude.
        :param pulumi.Input[_builtins.float] lat_seconds: Seconds of latitude.
        :param pulumi.Input[_builtins.float] long_degrees: Degrees of longitude.
        :param pulumi.Input[_builtins.str] long_direction: Longitude direction.
               Available values: "E", "W".
        :param pulumi.Input[_builtins.float] long_minutes: Minutes of longitude.
        :param pulumi.Input[_builtins.float] long_seconds: Seconds of longitude.
        :param pulumi.Input[_builtins.float] matching_type: Matching Type.
        :param pulumi.Input[_builtins.float] order: Order.
        :param pulumi.Input[_builtins.float] port: The port of the service.
        :param pulumi.Input[_builtins.float] precision_horz: Horizontal precision of location.
        :param pulumi.Input[_builtins.float] precision_vert: Vertical precision of location.
        :param pulumi.Input[_builtins.float] preference: Preference.
        :param pulumi.Input[_builtins.float] priority: Priority.
        :param pulumi.Input[_builtins.float] protocol: Protocol.
        :param pulumi.Input[_builtins.str] public_key: Public Key.
        :param pulumi.Input[_builtins.str] regex: Regex.
        :param pulumi.Input[_builtins.str] replacement: Replacement.
        :param pulumi.Input[_builtins.float] selector: Selector.
        :param pulumi.Input[_builtins.str] service: Service.
        :param pulumi.Input[_builtins.float] size: Size of location in meters.
        :param pulumi.Input[_builtins.str] tag: Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        :param pulumi.Input[_builtins.str] target: Target.
        :param pulumi.Input[_builtins.float] type: Type.
        :param pulumi.Input[_builtins.float] usage: Usage.
        :param pulumi.Input[_builtins.str] value: Value of the record. This field's semantics depend on the chosen tag.
        :param pulumi.Input[_builtins.float] weight: The record weight.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if digest_type is not None:
            pulumi.set(__self__, "digest_type", digest_type)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if key_tag is not None:
            pulumi.set(__self__, "key_tag", key_tag)
        if lat_degrees is not None:
            pulumi.set(__self__, "lat_degrees", lat_degrees)
        if lat_direction is not None:
            pulumi.set(__self__, "lat_direction", lat_direction)
        if lat_minutes is not None:
            pulumi.set(__self__, "lat_minutes", lat_minutes)
        if lat_seconds is not None:
            pulumi.set(__self__, "lat_seconds", lat_seconds)
        if long_degrees is not None:
            pulumi.set(__self__, "long_degrees", long_degrees)
        if long_direction is not None:
            pulumi.set(__self__, "long_direction", long_direction)
        if long_minutes is not None:
            pulumi.set(__self__, "long_minutes", long_minutes)
        if long_seconds is not None:
            pulumi.set(__self__, "long_seconds", long_seconds)
        if matching_type is not None:
            pulumi.set(__self__, "matching_type", matching_type)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if precision_horz is not None:
            pulumi.set(__self__, "precision_horz", precision_horz)
        if precision_vert is not None:
            pulumi.set(__self__, "precision_vert", precision_vert)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if replacement is not None:
            pulumi.set(__self__, "replacement", replacement)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if usage is not None:
            pulumi.set(__self__, "usage", usage)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Algorithm.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter
    def altitude(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Altitude of location in meters.
        """
        return pulumi.get(self, "altitude")

    @altitude.setter
    def altitude(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "altitude", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Digest.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter(name="digestType")
    def digest_type(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Digest Type.
        """
        return pulumi.get(self, "digest_type")

    @digest_type.setter
    def digest_type(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "digest_type", value)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fingerprint.
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @_builtins.property
    @pulumi.getter
    def flags(self) -> Optional[Any]:
        """
        Flags for the CAA record.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[Any]):
        pulumi.set(self, "flags", value)

    @_builtins.property
    @pulumi.getter(name="keyTag")
    def key_tag(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Key Tag.
        """
        return pulumi.get(self, "key_tag")

    @key_tag.setter
    def key_tag(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "key_tag", value)

    @_builtins.property
    @pulumi.getter(name="latDegrees")
    def lat_degrees(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Degrees of latitude.
        """
        return pulumi.get(self, "lat_degrees")

    @lat_degrees.setter
    def lat_degrees(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat_degrees", value)

    @_builtins.property
    @pulumi.getter(name="latDirection")
    def lat_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Latitude direction.
        Available values: "N", "S".
        """
        return pulumi.get(self, "lat_direction")

    @lat_direction.setter
    def lat_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lat_direction", value)

    @_builtins.property
    @pulumi.getter(name="latMinutes")
    def lat_minutes(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minutes of latitude.
        """
        return pulumi.get(self, "lat_minutes")

    @lat_minutes.setter
    def lat_minutes(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat_minutes", value)

    @_builtins.property
    @pulumi.getter(name="latSeconds")
    def lat_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Seconds of latitude.
        """
        return pulumi.get(self, "lat_seconds")

    @lat_seconds.setter
    def lat_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat_seconds", value)

    @_builtins.property
    @pulumi.getter(name="longDegrees")
    def long_degrees(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Degrees of longitude.
        """
        return pulumi.get(self, "long_degrees")

    @long_degrees.setter
    def long_degrees(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "long_degrees", value)

    @_builtins.property
    @pulumi.getter(name="longDirection")
    def long_direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Longitude direction.
        Available values: "E", "W".
        """
        return pulumi.get(self, "long_direction")

    @long_direction.setter
    def long_direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "long_direction", value)

    @_builtins.property
    @pulumi.getter(name="longMinutes")
    def long_minutes(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minutes of longitude.
        """
        return pulumi.get(self, "long_minutes")

    @long_minutes.setter
    def long_minutes(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "long_minutes", value)

    @_builtins.property
    @pulumi.getter(name="longSeconds")
    def long_seconds(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Seconds of longitude.
        """
        return pulumi.get(self, "long_seconds")

    @long_seconds.setter
    def long_seconds(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "long_seconds", value)

    @_builtins.property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Matching Type.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "matching_type", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="precisionHorz")
    def precision_horz(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Horizontal precision of location.
        """
        return pulumi.get(self, "precision_horz")

    @precision_horz.setter
    def precision_horz(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "precision_horz", value)

    @_builtins.property
    @pulumi.getter(name="precisionVert")
    def precision_vert(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Vertical precision of location.
        """
        return pulumi.get(self, "precision_vert")

    @precision_vert.setter
    def precision_vert(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "precision_vert", value)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "preference", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regex.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    def replacement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Replacement.
        """
        return pulumi.get(self, "replacement")

    @replacement.setter
    def replacement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replacement", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Selector.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Size of location in meters.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def usage(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Usage.
        """
        return pulumi.get(self, "usage")

    @usage.setter
    def usage(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "usage", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the record. This field's semantics depend on the chosen tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The record weight.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class RecordSettingsArgsDict(TypedDict):
        flatten_cname: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        ipv4_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        ipv6_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
elif False:
    RecordSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordSettingsArgs:
    def __init__(__self__, *,
                 flatten_cname: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv4_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] flatten_cname: If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        :param pulumi.Input[_builtins.bool] ipv4_only: When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        :param pulumi.Input[_builtins.bool] ipv6_only: When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        if flatten_cname is not None:
            pulumi.set(__self__, "flatten_cname", flatten_cname)
        if ipv4_only is not None:
            pulumi.set(__self__, "ipv4_only", ipv4_only)
        if ipv6_only is not None:
            pulumi.set(__self__, "ipv6_only", ipv6_only)

    @_builtins.property
    @pulumi.getter(name="flattenCname")
    def flatten_cname(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
        """
        return pulumi.get(self, "flatten_cname")

    @flatten_cname.setter
    def flatten_cname(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flatten_cname", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Only")
    def ipv4_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv4_only")

    @ipv4_only.setter
    def ipv4_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv4_only", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Only")
    def ipv6_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
        """
        return pulumi.get(self, "ipv6_only")

    @ipv6_only.setter
    def ipv6_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_only", value)


if not MYPY:
    class RiskBehaviorBehaviorsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        risk_level: pulumi.Input[_builtins.str]
        """
        Available values: "low", "medium", "high".
        """
elif False:
    RiskBehaviorBehaviorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RiskBehaviorBehaviorsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 risk_level: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] risk_level: Available values: "low", "medium", "high".
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "risk_level", risk_level)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "low", "medium", "high".
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class RulesetRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to perform when the rule matches.
        Available values: "block", "challenge", "compress*response", "ddos*dynamic", "execute", "force*connection*close", "js*challenge", "log", "log*custom*field", "managed*challenge", "redirect", "rewrite", "route", "score", "serve*error", "set*cache*settings", "set*config", "skip".
        """
        expression: pulumi.Input[_builtins.str]
        """
        The expression defining which traffic will match the rule.
        """
        action_parameters: NotRequired[pulumi.Input['RulesetRuleActionParametersArgsDict']]
        """
        The parameters configuring the rule's action.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        An informative description of the rule.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the rule should be executed.
        """
        exposed_credential_check: NotRequired[pulumi.Input['RulesetRuleExposedCredentialCheckArgsDict']]
        """
        Configuration for exposed credential checking.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ID of the rule.
        """
        logging: NotRequired[pulumi.Input['RulesetRuleLoggingArgsDict']]
        """
        An object configuring the rule's logging behavior.
        """
        ratelimit: NotRequired[pulumi.Input['RulesetRuleRatelimitArgsDict']]
        """
        An object configuring the rule's rate limit behavior.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reference of the rule (the rule's ID by default).
        """
elif False:
    RulesetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 expression: pulumi.Input[_builtins.str],
                 action_parameters: Optional[pulumi.Input['RulesetRuleActionParametersArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 exposed_credential_check: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 logging: Optional[pulumi.Input['RulesetRuleLoggingArgs']] = None,
                 ratelimit: Optional[pulumi.Input['RulesetRuleRatelimitArgs']] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action to perform when the rule matches.
               Available values: "block", "challenge", "compress*response", "ddos*dynamic", "execute", "force*connection*close", "js*challenge", "log", "log*custom*field", "managed*challenge", "redirect", "rewrite", "route", "score", "serve*error", "set*cache*settings", "set*config", "skip".
        :param pulumi.Input[_builtins.str] expression: The expression defining which traffic will match the rule.
        :param pulumi.Input['RulesetRuleActionParametersArgs'] action_parameters: The parameters configuring the rule's action.
        :param pulumi.Input[_builtins.str] description: An informative description of the rule.
        :param pulumi.Input[_builtins.bool] enabled: Whether the rule should be executed.
        :param pulumi.Input['RulesetRuleExposedCredentialCheckArgs'] exposed_credential_check: Configuration for exposed credential checking.
        :param pulumi.Input[_builtins.str] id: The unique ID of the rule.
        :param pulumi.Input['RulesetRuleLoggingArgs'] logging: An object configuring the rule's logging behavior.
        :param pulumi.Input['RulesetRuleRatelimitArgs'] ratelimit: An object configuring the rule's rate limit behavior.
        :param pulumi.Input[_builtins.str] ref: The reference of the rule (the rule's ID by default).
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if action_parameters is not None:
            pulumi.set(__self__, "action_parameters", action_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exposed_credential_check is not None:
            pulumi.set(__self__, "exposed_credential_check", exposed_credential_check)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if ratelimit is not None:
            pulumi.set(__self__, "ratelimit", ratelimit)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to perform when the rule matches.
        Available values: "block", "challenge", "compress*response", "ddos*dynamic", "execute", "force*connection*close", "js*challenge", "log", "log*custom*field", "managed*challenge", "redirect", "rewrite", "route", "score", "serve*error", "set*cache*settings", "set*config", "skip".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        The expression defining which traffic will match the rule.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="actionParameters")
    def action_parameters(self) -> Optional[pulumi.Input['RulesetRuleActionParametersArgs']]:
        """
        The parameters configuring the rule's action.
        """
        return pulumi.get(self, "action_parameters")

    @action_parameters.setter
    def action_parameters(self, value: Optional[pulumi.Input['RulesetRuleActionParametersArgs']]):
        pulumi.set(self, "action_parameters", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An informative description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the rule should be executed.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="exposedCredentialCheck")
    def exposed_credential_check(self) -> Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]:
        """
        Configuration for exposed credential checking.
        """
        return pulumi.get(self, "exposed_credential_check")

    @exposed_credential_check.setter
    def exposed_credential_check(self, value: Optional[pulumi.Input['RulesetRuleExposedCredentialCheckArgs']]):
        pulumi.set(self, "exposed_credential_check", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ID of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['RulesetRuleLoggingArgs']]:
        """
        An object configuring the rule's logging behavior.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['RulesetRuleLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @_builtins.property
    @pulumi.getter
    def ratelimit(self) -> Optional[pulumi.Input['RulesetRuleRatelimitArgs']]:
        """
        An object configuring the rule's rate limit behavior.
        """
        return pulumi.get(self, "ratelimit")

    @ratelimit.setter
    def ratelimit(self, value: Optional[pulumi.Input['RulesetRuleRatelimitArgs']]):
        pulumi.set(self, "ratelimit", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reference of the rule (the rule's ID by default).
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class RulesetRuleActionParametersArgsDict(TypedDict):
        additional_cacheable_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        A list of additional ports that caching should be enabled on.
        """
        algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgsDict']]]]
        """
        Custom order for compression algorithms.
        """
        asset_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of a custom asset to serve as the response.
        """
        automatic_https_rewrites: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Automatic HTTPS Rewrites.
        """
        autominify: NotRequired[pulumi.Input['RulesetRuleActionParametersAutominifyArgsDict']]
        """
        Which file extensions to minify automatically.
        """
        bic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Browser Integrity Check (BIC).
        """
        browser_ttl: NotRequired[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgsDict']]
        """
        How long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        """
        cache: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
        """
        cache_key: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyArgsDict']]
        """
        Which components of the request are included in or excluded from the cache key Cloudflare uses to store the response in cache.
        """
        cache_reserve: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheReserveArgsDict']]
        """
        Settings to determine whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        The response content.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content type header to set with the error response.
        Available values: "application/json", "text/html", "text/plain", "text/xml".
        """
        cookie_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgsDict']]]]
        """
        The cookie fields to log.
        """
        disable_apps: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable Cloudflare Apps.
        """
        disable_rum: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable Real User Monitoring (RUM).
        """
        disable_zaraz: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable Zaraz.
        """
        edge_ttl: NotRequired[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgsDict']]
        """
        How long the Cloudflare edge network should cache the response.
        """
        email_obfuscation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Email Obfuscation.
        """
        fonts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Cloudflare Fonts.
        """
        from_list: NotRequired[pulumi.Input['RulesetRuleActionParametersFromListArgsDict']]
        """
        A redirect based on a bulk list lookup.
        """
        from_value: NotRequired[pulumi.Input['RulesetRuleActionParametersFromValueArgsDict']]
        """
        A redirect based on the request properties.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgsDict']]]]
        """
        A map of headers to rewrite.
        """
        host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        A value to rewrite the HTTP host header to.
        """
        hotlink_protection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Hotlink Protection.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the ruleset to execute.
        """
        increment: NotRequired[pulumi.Input[_builtins.int]]
        """
        A delta to change the score by, which can be either positive or negative.
        """
        matched_data: NotRequired[pulumi.Input['RulesetRuleActionParametersMatchedDataArgsDict']]
        """
        The configuration to use for matched data logging.
        """
        mirage: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Mirage.
        """
        opportunistic_encryption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Opportunistic Encryption.
        """
        origin: NotRequired[pulumi.Input['RulesetRuleActionParametersOriginArgsDict']]
        """
        An origin to route to.
        """
        origin_cache_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Cloudflare will aim to strictly adhere to RFC 7234.
        """
        origin_error_page_passthru: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to generate Cloudflare error pages for issues from the origin server.
        """
        overrides: NotRequired[pulumi.Input['RulesetRuleActionParametersOverridesArgsDict']]
        """
        A set of overrides to apply to the target ruleset.
        """
        phases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of phases to skip the execution of. This option is incompatible with the rulesets option.
        Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
        """
        polish: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Polish level to configure.
        Available values: "off", "lossless", "lossy", "webp".
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of legacy security products to skip the execution of.
        Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
        """
        raw_response_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRawResponseFieldArgsDict']]]]
        """
        The raw response fields to log.
        """
        read_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        """
        request_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgsDict']]]]
        """
        The raw request fields to log.
        """
        respect_strong_etags: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
        """
        response: NotRequired[pulumi.Input['RulesetRuleActionParametersResponseArgsDict']]
        """
        The response to show when the block is applied.
        """
        response_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgsDict']]]]
        """
        The transformed response fields to log.
        """
        rocket_loader: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Rocket Loader.
        """
        rules: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        """
        ruleset: NotRequired[pulumi.Input[_builtins.str]]
        """
        A ruleset to skip the execution of. This option is incompatible with the rulesets option.
        Available values: "current".
        """
        rulesets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        """
        security_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Security Level to configure.
        Available values: "off", "essentially*off", "low", "medium", "high", "under*attack".
        """
        serve_stale: NotRequired[pulumi.Input['RulesetRuleActionParametersServeStaleArgsDict']]
        """
        When to serve stale content from cache.
        """
        server_side_excludes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Server-Side Excludes.
        """
        sni: NotRequired[pulumi.Input['RulesetRuleActionParametersSniArgsDict']]
        """
        A Server Name Indication (SNI) override.
        """
        ssl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSL level to configure.
        Available values: "off", "flexible", "full", "strict", "origin_pull".
        """
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code to use for the error.
        """
        sxg: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Signed Exchanges (SXG).
        """
        transformed_request_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersTransformedRequestFieldArgsDict']]]]
        """
        The transformed request fields to log.
        """
        uri: NotRequired[pulumi.Input['RulesetRuleActionParametersUriArgsDict']]
        """
        A URI rewrite.
        """
elif False:
    RulesetRuleActionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersArgs:
    def __init__(__self__, *,
                 additional_cacheable_ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]] = None,
                 asset_name: Optional[pulumi.Input[_builtins.str]] = None,
                 automatic_https_rewrites: Optional[pulumi.Input[_builtins.bool]] = None,
                 autominify: Optional[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']] = None,
                 bic: Optional[pulumi.Input[_builtins.bool]] = None,
                 browser_ttl: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']] = None,
                 cache: Optional[pulumi.Input[_builtins.bool]] = None,
                 cache_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']] = None,
                 cache_reserve: Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']] = None,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 cookie_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]]] = None,
                 disable_apps: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_rum: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_zaraz: Optional[pulumi.Input[_builtins.bool]] = None,
                 edge_ttl: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']] = None,
                 email_obfuscation: Optional[pulumi.Input[_builtins.bool]] = None,
                 fonts: Optional[pulumi.Input[_builtins.bool]] = None,
                 from_list: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']] = None,
                 from_value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]]] = None,
                 host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 hotlink_protection: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 increment: Optional[pulumi.Input[_builtins.int]] = None,
                 matched_data: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']] = None,
                 mirage: Optional[pulumi.Input[_builtins.bool]] = None,
                 opportunistic_encryption: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']] = None,
                 origin_cache_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_error_page_passthru: Optional[pulumi.Input[_builtins.bool]] = None,
                 overrides: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']] = None,
                 phases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 polish: Optional[pulumi.Input[_builtins.str]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 raw_response_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRawResponseFieldArgs']]]] = None,
                 read_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 request_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]]] = None,
                 respect_strong_etags: Optional[pulumi.Input[_builtins.bool]] = None,
                 response: Optional[pulumi.Input['RulesetRuleActionParametersResponseArgs']] = None,
                 response_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]]] = None,
                 rocket_loader: Optional[pulumi.Input[_builtins.bool]] = None,
                 rules: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 ruleset: Optional[pulumi.Input[_builtins.str]] = None,
                 rulesets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_level: Optional[pulumi.Input[_builtins.str]] = None,
                 serve_stale: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']] = None,
                 server_side_excludes: Optional[pulumi.Input[_builtins.bool]] = None,
                 sni: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']] = None,
                 ssl: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None,
                 sxg: Optional[pulumi.Input[_builtins.bool]] = None,
                 transformed_request_fields: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersTransformedRequestFieldArgs']]]] = None,
                 uri: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] additional_cacheable_ports: A list of additional ports that caching should be enabled on.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]] algorithms: Custom order for compression algorithms.
        :param pulumi.Input[_builtins.str] asset_name: The name of a custom asset to serve as the response.
        :param pulumi.Input[_builtins.bool] automatic_https_rewrites: Whether to enable Automatic HTTPS Rewrites.
        :param pulumi.Input['RulesetRuleActionParametersAutominifyArgs'] autominify: Which file extensions to minify automatically.
        :param pulumi.Input[_builtins.bool] bic: Whether to enable Browser Integrity Check (BIC).
        :param pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs'] browser_ttl: How long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        :param pulumi.Input[_builtins.bool] cache: Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyArgs'] cache_key: Which components of the request are included in or excluded from the cache key Cloudflare uses to store the response in cache.
        :param pulumi.Input['RulesetRuleActionParametersCacheReserveArgs'] cache_reserve: Settings to determine whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        :param pulumi.Input[_builtins.str] content: The response content.
        :param pulumi.Input[_builtins.str] content_type: The content type header to set with the error response.
               Available values: "application/json", "text/html", "text/plain", "text/xml".
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]] cookie_fields: The cookie fields to log.
        :param pulumi.Input[_builtins.bool] disable_apps: Whether to disable Cloudflare Apps.
        :param pulumi.Input[_builtins.bool] disable_rum: Whether to disable Real User Monitoring (RUM).
        :param pulumi.Input[_builtins.bool] disable_zaraz: Whether to disable Zaraz.
        :param pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs'] edge_ttl: How long the Cloudflare edge network should cache the response.
        :param pulumi.Input[_builtins.bool] email_obfuscation: Whether to enable Email Obfuscation.
        :param pulumi.Input[_builtins.bool] fonts: Whether to enable Cloudflare Fonts.
        :param pulumi.Input['RulesetRuleActionParametersFromListArgs'] from_list: A redirect based on a bulk list lookup.
        :param pulumi.Input['RulesetRuleActionParametersFromValueArgs'] from_value: A redirect based on the request properties.
        :param pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]] headers: A map of headers to rewrite.
        :param pulumi.Input[_builtins.str] host_header: A value to rewrite the HTTP host header to.
        :param pulumi.Input[_builtins.bool] hotlink_protection: Whether to enable Hotlink Protection.
        :param pulumi.Input[_builtins.str] id: The ID of the ruleset to execute.
        :param pulumi.Input[_builtins.int] increment: A delta to change the score by, which can be either positive or negative.
        :param pulumi.Input['RulesetRuleActionParametersMatchedDataArgs'] matched_data: The configuration to use for matched data logging.
        :param pulumi.Input[_builtins.bool] mirage: Whether to enable Mirage.
        :param pulumi.Input[_builtins.bool] opportunistic_encryption: Whether to enable Opportunistic Encryption.
        :param pulumi.Input['RulesetRuleActionParametersOriginArgs'] origin: An origin to route to.
        :param pulumi.Input[_builtins.bool] origin_cache_control: Whether Cloudflare will aim to strictly adhere to RFC 7234.
        :param pulumi.Input[_builtins.bool] origin_error_page_passthru: Whether to generate Cloudflare error pages for issues from the origin server.
        :param pulumi.Input['RulesetRuleActionParametersOverridesArgs'] overrides: A set of overrides to apply to the target ruleset.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] phases: A list of phases to skip the execution of. This option is incompatible with the rulesets option.
               Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
        :param pulumi.Input[_builtins.str] polish: The Polish level to configure.
               Available values: "off", "lossless", "lossy", "webp".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: A list of legacy security products to skip the execution of.
               Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRawResponseFieldArgs']]] raw_response_fields: The raw response fields to log.
        :param pulumi.Input[_builtins.int] read_timeout: A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]] request_fields: The raw request fields to log.
        :param pulumi.Input[_builtins.bool] respect_strong_etags: Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
        :param pulumi.Input['RulesetRuleActionParametersResponseArgs'] response: The response to show when the block is applied.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]] response_fields: The transformed response fields to log.
        :param pulumi.Input[_builtins.bool] rocket_loader: Whether to enable Rocket Loader.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] rules: A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        :param pulumi.Input[_builtins.str] ruleset: A ruleset to skip the execution of. This option is incompatible with the rulesets option.
               Available values: "current".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] rulesets: A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        :param pulumi.Input[_builtins.str] security_level: The Security Level to configure.
               Available values: "off", "essentially*off", "low", "medium", "high", "under*attack".
        :param pulumi.Input['RulesetRuleActionParametersServeStaleArgs'] serve_stale: When to serve stale content from cache.
        :param pulumi.Input[_builtins.bool] server_side_excludes: Whether to enable Server-Side Excludes.
        :param pulumi.Input['RulesetRuleActionParametersSniArgs'] sni: A Server Name Indication (SNI) override.
        :param pulumi.Input[_builtins.str] ssl: The SSL level to configure.
               Available values: "off", "flexible", "full", "strict", "origin_pull".
        :param pulumi.Input[_builtins.int] status_code: The status code to use for the error.
        :param pulumi.Input[_builtins.bool] sxg: Whether to enable Signed Exchanges (SXG).
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersTransformedRequestFieldArgs']]] transformed_request_fields: The transformed request fields to log.
        :param pulumi.Input['RulesetRuleActionParametersUriArgs'] uri: A URI rewrite.
        """
        if additional_cacheable_ports is not None:
            pulumi.set(__self__, "additional_cacheable_ports", additional_cacheable_ports)
        if algorithms is not None:
            pulumi.set(__self__, "algorithms", algorithms)
        if asset_name is not None:
            pulumi.set(__self__, "asset_name", asset_name)
        if automatic_https_rewrites is not None:
            pulumi.set(__self__, "automatic_https_rewrites", automatic_https_rewrites)
        if autominify is not None:
            pulumi.set(__self__, "autominify", autominify)
        if bic is not None:
            pulumi.set(__self__, "bic", bic)
        if browser_ttl is not None:
            pulumi.set(__self__, "browser_ttl", browser_ttl)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if cache_key is not None:
            pulumi.set(__self__, "cache_key", cache_key)
        if cache_reserve is not None:
            pulumi.set(__self__, "cache_reserve", cache_reserve)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if cookie_fields is not None:
            pulumi.set(__self__, "cookie_fields", cookie_fields)
        if disable_apps is not None:
            pulumi.set(__self__, "disable_apps", disable_apps)
        if disable_rum is not None:
            pulumi.set(__self__, "disable_rum", disable_rum)
        if disable_zaraz is not None:
            pulumi.set(__self__, "disable_zaraz", disable_zaraz)
        if edge_ttl is not None:
            pulumi.set(__self__, "edge_ttl", edge_ttl)
        if email_obfuscation is not None:
            pulumi.set(__self__, "email_obfuscation", email_obfuscation)
        if fonts is not None:
            pulumi.set(__self__, "fonts", fonts)
        if from_list is not None:
            pulumi.set(__self__, "from_list", from_list)
        if from_value is not None:
            pulumi.set(__self__, "from_value", from_value)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if hotlink_protection is not None:
            pulumi.set(__self__, "hotlink_protection", hotlink_protection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if increment is not None:
            pulumi.set(__self__, "increment", increment)
        if matched_data is not None:
            pulumi.set(__self__, "matched_data", matched_data)
        if mirage is not None:
            pulumi.set(__self__, "mirage", mirage)
        if opportunistic_encryption is not None:
            pulumi.set(__self__, "opportunistic_encryption", opportunistic_encryption)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_cache_control is not None:
            pulumi.set(__self__, "origin_cache_control", origin_cache_control)
        if origin_error_page_passthru is not None:
            pulumi.set(__self__, "origin_error_page_passthru", origin_error_page_passthru)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)
        if polish is not None:
            pulumi.set(__self__, "polish", polish)
        if products is not None:
            pulumi.set(__self__, "products", products)
        if raw_response_fields is not None:
            pulumi.set(__self__, "raw_response_fields", raw_response_fields)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if request_fields is not None:
            pulumi.set(__self__, "request_fields", request_fields)
        if respect_strong_etags is not None:
            pulumi.set(__self__, "respect_strong_etags", respect_strong_etags)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if response_fields is not None:
            pulumi.set(__self__, "response_fields", response_fields)
        if rocket_loader is not None:
            pulumi.set(__self__, "rocket_loader", rocket_loader)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if ruleset is not None:
            pulumi.set(__self__, "ruleset", ruleset)
        if rulesets is not None:
            pulumi.set(__self__, "rulesets", rulesets)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if serve_stale is not None:
            pulumi.set(__self__, "serve_stale", serve_stale)
        if server_side_excludes is not None:
            pulumi.set(__self__, "server_side_excludes", server_side_excludes)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if sxg is not None:
            pulumi.set(__self__, "sxg", sxg)
        if transformed_request_fields is not None:
            pulumi.set(__self__, "transformed_request_fields", transformed_request_fields)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="additionalCacheablePorts")
    def additional_cacheable_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        A list of additional ports that caching should be enabled on.
        """
        return pulumi.get(self, "additional_cacheable_ports")

    @additional_cacheable_ports.setter
    def additional_cacheable_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "additional_cacheable_ports", value)

    @_builtins.property
    @pulumi.getter
    def algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]:
        """
        Custom order for compression algorithms.
        """
        return pulumi.get(self, "algorithms")

    @algorithms.setter
    def algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersAlgorithmArgs']]]]):
        pulumi.set(self, "algorithms", value)

    @_builtins.property
    @pulumi.getter(name="assetName")
    def asset_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of a custom asset to serve as the response.
        """
        return pulumi.get(self, "asset_name")

    @asset_name.setter
    def asset_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "asset_name", value)

    @_builtins.property
    @pulumi.getter(name="automaticHttpsRewrites")
    def automatic_https_rewrites(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Automatic HTTPS Rewrites.
        """
        return pulumi.get(self, "automatic_https_rewrites")

    @automatic_https_rewrites.setter
    def automatic_https_rewrites(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "automatic_https_rewrites", value)

    @_builtins.property
    @pulumi.getter
    def autominify(self) -> Optional[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]:
        """
        Which file extensions to minify automatically.
        """
        return pulumi.get(self, "autominify")

    @autominify.setter
    def autominify(self, value: Optional[pulumi.Input['RulesetRuleActionParametersAutominifyArgs']]):
        pulumi.set(self, "autominify", value)

    @_builtins.property
    @pulumi.getter
    def bic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Browser Integrity Check (BIC).
        """
        return pulumi.get(self, "bic")

    @bic.setter
    def bic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bic", value)

    @_builtins.property
    @pulumi.getter(name="browserTtl")
    def browser_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]:
        """
        How long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
        """
        return pulumi.get(self, "browser_ttl")

    @browser_ttl.setter
    def browser_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersBrowserTtlArgs']]):
        pulumi.set(self, "browser_ttl", value)

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cache", value)

    @_builtins.property
    @pulumi.getter(name="cacheKey")
    def cache_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]:
        """
        Which components of the request are included in or excluded from the cache key Cloudflare uses to store the response in cache.
        """
        return pulumi.get(self, "cache_key")

    @cache_key.setter
    def cache_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyArgs']]):
        pulumi.set(self, "cache_key", value)

    @_builtins.property
    @pulumi.getter(name="cacheReserve")
    def cache_reserve(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']]:
        """
        Settings to determine whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
        """
        return pulumi.get(self, "cache_reserve")

    @cache_reserve.setter
    def cache_reserve(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheReserveArgs']]):
        pulumi.set(self, "cache_reserve", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The response content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content type header to set with the error response.
        Available values: "application/json", "text/html", "text/plain", "text/xml".
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="cookieFields")
    def cookie_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]]]:
        """
        The cookie fields to log.
        """
        return pulumi.get(self, "cookie_fields")

    @cookie_fields.setter
    def cookie_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersCookieFieldArgs']]]]):
        pulumi.set(self, "cookie_fields", value)

    @_builtins.property
    @pulumi.getter(name="disableApps")
    def disable_apps(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable Cloudflare Apps.
        """
        return pulumi.get(self, "disable_apps")

    @disable_apps.setter
    def disable_apps(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_apps", value)

    @_builtins.property
    @pulumi.getter(name="disableRum")
    def disable_rum(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable Real User Monitoring (RUM).
        """
        return pulumi.get(self, "disable_rum")

    @disable_rum.setter
    def disable_rum(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_rum", value)

    @_builtins.property
    @pulumi.getter(name="disableZaraz")
    def disable_zaraz(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable Zaraz.
        """
        return pulumi.get(self, "disable_zaraz")

    @disable_zaraz.setter
    def disable_zaraz(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_zaraz", value)

    @_builtins.property
    @pulumi.getter(name="edgeTtl")
    def edge_ttl(self) -> Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]:
        """
        How long the Cloudflare edge network should cache the response.
        """
        return pulumi.get(self, "edge_ttl")

    @edge_ttl.setter
    def edge_ttl(self, value: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlArgs']]):
        pulumi.set(self, "edge_ttl", value)

    @_builtins.property
    @pulumi.getter(name="emailObfuscation")
    def email_obfuscation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Email Obfuscation.
        """
        return pulumi.get(self, "email_obfuscation")

    @email_obfuscation.setter
    def email_obfuscation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "email_obfuscation", value)

    @_builtins.property
    @pulumi.getter
    def fonts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Cloudflare Fonts.
        """
        return pulumi.get(self, "fonts")

    @fonts.setter
    def fonts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fonts", value)

    @_builtins.property
    @pulumi.getter(name="fromList")
    def from_list(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]:
        """
        A redirect based on a bulk list lookup.
        """
        return pulumi.get(self, "from_list")

    @from_list.setter
    def from_list(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromListArgs']]):
        pulumi.set(self, "from_list", value)

    @_builtins.property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]:
        """
        A redirect based on the request properties.
        """
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: Optional[pulumi.Input['RulesetRuleActionParametersFromValueArgs']]):
        pulumi.set(self, "from_value", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]]]:
        """
        A map of headers to rewrite.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RulesetRuleActionParametersHeadersArgs']]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A value to rewrite the HTTP host header to.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_header", value)

    @_builtins.property
    @pulumi.getter(name="hotlinkProtection")
    def hotlink_protection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Hotlink Protection.
        """
        return pulumi.get(self, "hotlink_protection")

    @hotlink_protection.setter
    def hotlink_protection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hotlink_protection", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the ruleset to execute.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def increment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A delta to change the score by, which can be either positive or negative.
        """
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "increment", value)

    @_builtins.property
    @pulumi.getter(name="matchedData")
    def matched_data(self) -> Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]:
        """
        The configuration to use for matched data logging.
        """
        return pulumi.get(self, "matched_data")

    @matched_data.setter
    def matched_data(self, value: Optional[pulumi.Input['RulesetRuleActionParametersMatchedDataArgs']]):
        pulumi.set(self, "matched_data", value)

    @_builtins.property
    @pulumi.getter
    def mirage(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Mirage.
        """
        return pulumi.get(self, "mirage")

    @mirage.setter
    def mirage(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mirage", value)

    @_builtins.property
    @pulumi.getter(name="opportunisticEncryption")
    def opportunistic_encryption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Opportunistic Encryption.
        """
        return pulumi.get(self, "opportunistic_encryption")

    @opportunistic_encryption.setter
    def opportunistic_encryption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "opportunistic_encryption", value)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]:
        """
        An origin to route to.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOriginArgs']]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="originCacheControl")
    def origin_cache_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Cloudflare will aim to strictly adhere to RFC 7234.
        """
        return pulumi.get(self, "origin_cache_control")

    @origin_cache_control.setter
    def origin_cache_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "origin_cache_control", value)

    @_builtins.property
    @pulumi.getter(name="originErrorPagePassthru")
    def origin_error_page_passthru(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to generate Cloudflare error pages for issues from the origin server.
        """
        return pulumi.get(self, "origin_error_page_passthru")

    @origin_error_page_passthru.setter
    def origin_error_page_passthru(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "origin_error_page_passthru", value)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]:
        """
        A set of overrides to apply to the target ruleset.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['RulesetRuleActionParametersOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @_builtins.property
    @pulumi.getter
    def phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of phases to skip the execution of. This option is incompatible with the rulesets option.
        Available values: "ddos*l4", "ddos*l7", "http*config*settings", "http*custom*errors", "http*log*custom*fields", "http*ratelimit", "http*request*cache*settings", "http*request*dynamic*redirect", "http*request*firewall*custom", "http*request*firewall*managed", "http*request*late*transform", "http*request*origin", "http*request*redirect", "http*request*sanitize", "http*request*sbfm", "http*request*transform", "http*response*compression", "http*response*firewall*managed", "http*response*headers*transform", "magic*transit", "magic*transit*ids*managed", "magic*transit*managed", "magic*transit_ratelimit".
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "phases", value)

    @_builtins.property
    @pulumi.getter
    def polish(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Polish level to configure.
        Available values: "off", "lossless", "lossy", "webp".
        """
        return pulumi.get(self, "polish")

    @polish.setter
    def polish(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "polish", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of legacy security products to skip the execution of.
        Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)

    @_builtins.property
    @pulumi.getter(name="rawResponseFields")
    def raw_response_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRawResponseFieldArgs']]]]:
        """
        The raw response fields to log.
        """
        return pulumi.get(self, "raw_response_fields")

    @raw_response_fields.setter
    def raw_response_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRawResponseFieldArgs']]]]):
        pulumi.set(self, "raw_response_fields", value)

    @_builtins.property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
        """
        return pulumi.get(self, "read_timeout")

    @read_timeout.setter
    def read_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_timeout", value)

    @_builtins.property
    @pulumi.getter(name="requestFields")
    def request_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]]]:
        """
        The raw request fields to log.
        """
        return pulumi.get(self, "request_fields")

    @request_fields.setter
    def request_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersRequestFieldArgs']]]]):
        pulumi.set(self, "request_fields", value)

    @_builtins.property
    @pulumi.getter(name="respectStrongEtags")
    def respect_strong_etags(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
        """
        return pulumi.get(self, "respect_strong_etags")

    @respect_strong_etags.setter
    def respect_strong_etags(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "respect_strong_etags", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['RulesetRuleActionParametersResponseArgs']]:
        """
        The response to show when the block is applied.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['RulesetRuleActionParametersResponseArgs']]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter(name="responseFields")
    def response_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]]]:
        """
        The transformed response fields to log.
        """
        return pulumi.get(self, "response_fields")

    @response_fields.setter
    def response_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersResponseFieldArgs']]]]):
        pulumi.set(self, "response_fields", value)

    @_builtins.property
    @pulumi.getter(name="rocketLoader")
    def rocket_loader(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Rocket Loader.
        """
        return pulumi.get(self, "rocket_loader")

    @rocket_loader.setter
    def rocket_loader(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rocket_loader", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def ruleset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A ruleset to skip the execution of. This option is incompatible with the rulesets option.
        Available values: "current".
        """
        return pulumi.get(self, "ruleset")

    @ruleset.setter
    def ruleset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ruleset", value)

    @_builtins.property
    @pulumi.getter
    def rulesets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
        """
        return pulumi.get(self, "rulesets")

    @rulesets.setter
    def rulesets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "rulesets", value)

    @_builtins.property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Security Level to configure.
        Available values: "off", "essentially*off", "low", "medium", "high", "under*attack".
        """
        return pulumi.get(self, "security_level")

    @security_level.setter
    def security_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_level", value)

    @_builtins.property
    @pulumi.getter(name="serveStale")
    def serve_stale(self) -> Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]:
        """
        When to serve stale content from cache.
        """
        return pulumi.get(self, "serve_stale")

    @serve_stale.setter
    def serve_stale(self, value: Optional[pulumi.Input['RulesetRuleActionParametersServeStaleArgs']]):
        pulumi.set(self, "serve_stale", value)

    @_builtins.property
    @pulumi.getter(name="serverSideExcludes")
    def server_side_excludes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Server-Side Excludes.
        """
        return pulumi.get(self, "server_side_excludes")

    @server_side_excludes.setter
    def server_side_excludes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_side_excludes", value)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]:
        """
        A Server Name Indication (SNI) override.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input['RulesetRuleActionParametersSniArgs']]):
        pulumi.set(self, "sni", value)

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSL level to configure.
        Available values: "off", "flexible", "full", "strict", "origin_pull".
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code to use for the error.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def sxg(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Signed Exchanges (SXG).
        """
        return pulumi.get(self, "sxg")

    @sxg.setter
    def sxg(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sxg", value)

    @_builtins.property
    @pulumi.getter(name="transformedRequestFields")
    def transformed_request_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersTransformedRequestFieldArgs']]]]:
        """
        The transformed request fields to log.
        """
        return pulumi.get(self, "transformed_request_fields")

    @transformed_request_fields.setter
    def transformed_request_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersTransformedRequestFieldArgs']]]]):
        pulumi.set(self, "transformed_request_fields", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]:
        """
        A URI rewrite.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriArgs']]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class RulesetRuleActionParametersAlgorithmArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the compression algorithm to enable.
        Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
        """
elif False:
    RulesetRuleActionParametersAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersAlgorithmArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the compression algorithm to enable.
               Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the compression algorithm to enable.
        Available values: "none", "auto", "default", "gzip", "brotli", "zstd".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersAutominifyArgsDict(TypedDict):
        css: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to minify CSS files.
        """
        html: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to minify HTML files.
        """
        js: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to minify JavaScript files.
        """
elif False:
    RulesetRuleActionParametersAutominifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersAutominifyArgs:
    def __init__(__self__, *,
                 css: Optional[pulumi.Input[_builtins.bool]] = None,
                 html: Optional[pulumi.Input[_builtins.bool]] = None,
                 js: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] css: Whether to minify CSS files.
        :param pulumi.Input[_builtins.bool] html: Whether to minify HTML files.
        :param pulumi.Input[_builtins.bool] js: Whether to minify JavaScript files.
        """
        if css is not None:
            pulumi.set(__self__, "css", css)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if js is not None:
            pulumi.set(__self__, "js", js)

    @_builtins.property
    @pulumi.getter
    def css(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to minify CSS files.
        """
        return pulumi.get(self, "css")

    @css.setter
    def css(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "css", value)

    @_builtins.property
    @pulumi.getter
    def html(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to minify HTML files.
        """
        return pulumi.get(self, "html")

    @html.setter
    def html(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "html", value)

    @_builtins.property
    @pulumi.getter
    def js(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to minify JavaScript files.
        """
        return pulumi.get(self, "js")

    @js.setter
    def js(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "js", value)


if not MYPY:
    class RulesetRuleActionParametersBrowserTtlArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The browser TTL mode.
        Available values: "respect*origin", "bypass*by*default", "override*origin", "bypass".
        """
        default: NotRequired[pulumi.Input[_builtins.int]]
        """
        The browser TTL (in seconds) if you choose the "override_origin" mode.
        """
elif False:
    RulesetRuleActionParametersBrowserTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersBrowserTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 default: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The browser TTL mode.
               Available values: "respect*origin", "bypass*by*default", "override*origin", "bypass".
        :param pulumi.Input[_builtins.int] default: The browser TTL (in seconds) if you choose the "override_origin" mode.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The browser TTL mode.
        Available values: "respect*origin", "bypass*by*default", "override*origin", "bypass".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The browser TTL (in seconds) if you choose the "override_origin" mode.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyArgsDict(TypedDict):
        cache_by_device_type: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to separate cached content based on the visitor's device type.
        """
        cache_deception_armor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to protect from web cache deception attacks, while allowing static assets to be cached.
        """
        custom_key: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgsDict']]
        """
        Which components of the request are included or excluded from the cache key.
        """
        ignore_query_strings_order: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
        """
elif False:
    RulesetRuleActionParametersCacheKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyArgs:
    def __init__(__self__, *,
                 cache_by_device_type: Optional[pulumi.Input[_builtins.bool]] = None,
                 cache_deception_armor: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_key: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']] = None,
                 ignore_query_strings_order: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] cache_by_device_type: Whether to separate cached content based on the visitor's device type.
        :param pulumi.Input[_builtins.bool] cache_deception_armor: Whether to protect from web cache deception attacks, while allowing static assets to be cached.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs'] custom_key: Which components of the request are included or excluded from the cache key.
        :param pulumi.Input[_builtins.bool] ignore_query_strings_order: Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
        """
        if cache_by_device_type is not None:
            pulumi.set(__self__, "cache_by_device_type", cache_by_device_type)
        if cache_deception_armor is not None:
            pulumi.set(__self__, "cache_deception_armor", cache_deception_armor)
        if custom_key is not None:
            pulumi.set(__self__, "custom_key", custom_key)
        if ignore_query_strings_order is not None:
            pulumi.set(__self__, "ignore_query_strings_order", ignore_query_strings_order)

    @_builtins.property
    @pulumi.getter(name="cacheByDeviceType")
    def cache_by_device_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to separate cached content based on the visitor's device type.
        """
        return pulumi.get(self, "cache_by_device_type")

    @cache_by_device_type.setter
    def cache_by_device_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cache_by_device_type", value)

    @_builtins.property
    @pulumi.getter(name="cacheDeceptionArmor")
    def cache_deception_armor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to protect from web cache deception attacks, while allowing static assets to be cached.
        """
        return pulumi.get(self, "cache_deception_armor")

    @cache_deception_armor.setter
    def cache_deception_armor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cache_deception_armor", value)

    @_builtins.property
    @pulumi.getter(name="customKey")
    def custom_key(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]:
        """
        Which components of the request are included or excluded from the cache key.
        """
        return pulumi.get(self, "custom_key")

    @custom_key.setter
    def custom_key(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyArgs']]):
        pulumi.set(self, "custom_key", value)

    @_builtins.property
    @pulumi.getter(name="ignoreQueryStringsOrder")
    def ignore_query_strings_order(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
        """
        return pulumi.get(self, "ignore_query_strings_order")

    @ignore_query_strings_order.setter
    def ignore_query_strings_order(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_query_strings_order", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyArgsDict(TypedDict):
        cookie: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict']]
        """
        Which cookies to include in the cache key.
        """
        header: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict']]
        """
        Which headers to include in the cache key.
        """
        host: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict']]
        """
        How to use the host in the cache key.
        """
        query_string: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict']]
        """
        Which query string parameters to include in or exclude from the cache key.
        """
        user: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict']]
        """
        How to use characteristics of the request user agent in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyArgs:
    def __init__(__self__, *,
                 cookie: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']] = None,
                 header: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']] = None,
                 host: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']] = None,
                 query_string: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']] = None,
                 user: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs'] cookie: Which cookies to include in the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs'] header: Which headers to include in the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs'] host: How to use the host in the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs'] query_string: Which query string parameters to include in or exclude from the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs'] user: How to use characteristics of the request user agent in the cache key.
        """
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]:
        """
        Which cookies to include in the cache key.
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]:
        """
        Which headers to include in the cache key.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]:
        """
        How to use the host in the cache key.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyHostArgs']]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]:
        """
        Which query string parameters to include in or exclude from the cache key.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs']]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]:
        """
        How to use characteristics of the request user agent in the cache key.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyUserArgs']]):
        pulumi.set(self, "user", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of cookies to include in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] check_presences: A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes: A list of cookies to include in the cache key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "check_presences", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of cookies to include in the cache key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict(TypedDict):
        check_presences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of headers to check for the presence of. The presence of these headers is included in the cache key.
        """
        contains: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
        """
        exclude_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to exclude the origin header in the cache key.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of headers to include in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs:
    def __init__(__self__, *,
                 check_presences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 contains: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 exclude_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] check_presences: A list of headers to check for the presence of. The presence of these headers is included in the cache key.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] contains: A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
        :param pulumi.Input[_builtins.bool] exclude_origin: Whether to exclude the origin header in the cache key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes: A list of headers to include in the cache key.
        """
        if check_presences is not None:
            pulumi.set(__self__, "check_presences", check_presences)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exclude_origin is not None:
            pulumi.set(__self__, "exclude_origin", exclude_origin)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter(name="checkPresences")
    def check_presences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of headers to check for the presence of. The presence of these headers is included in the cache key.
        """
        return pulumi.get(self, "check_presences")

    @check_presences.setter
    def check_presences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "check_presences", value)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter(name="excludeOrigin")
    def exclude_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to exclude the origin header in the cache key.
        """
        return pulumi.get(self, "exclude_origin")

    @exclude_origin.setter
    def exclude_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_origin", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of headers to include in the cache key.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict(TypedDict):
        resolved: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the resolved host in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyHostArgs:
    def __init__(__self__, *,
                 resolved: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] resolved: Whether to use the resolved host in the cache key.
        """
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)

    @_builtins.property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the resolved host in the cache key.
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "resolved", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict(TypedDict):
        exclude: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict']]
        """
        Which query string parameters to exclude from the cache key.
        """
        include: NotRequired[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict']]
        """
        Which query string parameters to include in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs']] = None,
                 include: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs'] exclude: Which query string parameters to exclude from the cache key.
        :param pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs'] include: Which query string parameters to include in the cache key.
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)

    @_builtins.property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs']]:
        """
        Which query string parameters to exclude from the cache key.
        """
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs']]):
        pulumi.set(self, "exclude", value)

    @_builtins.property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs']]:
        """
        Which query string parameters to include in the cache key.
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input['RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs']]):
        pulumi.set(self, "include", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to exclude all query string parameters from the cache key.
        """
        lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of query string parameters to exclude from the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringExcludeArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[_builtins.bool]] = None,
                 lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all: Whether to exclude all query string parameters from the cache key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] lists: A list of query string parameters to exclude from the cache key.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to exclude all query string parameters from the cache key.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of query string parameters to exclude from the cache key.
        """
        return pulumi.get(self, "lists")

    @lists.setter
    def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "lists", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to include all query string parameters in the cache key.
        """
        lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of query string parameters to include in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyQueryStringIncludeArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[_builtins.bool]] = None,
                 lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all: Whether to include all query string parameters in the cache key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] lists: A list of query string parameters to include in the cache key.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if lists is not None:
            pulumi.set(__self__, "lists", lists)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to include all query string parameters in the cache key.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of query string parameters to include in the cache key.
        """
        return pulumi.get(self, "lists")

    @lists.setter
    def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "lists", value)


if not MYPY:
    class RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the user agent's device type in the cache key.
        """
        geo: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the user agents's country in the cache key.
        """
        lang: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the user agent's language in the cache key.
        """
elif False:
    RulesetRuleActionParametersCacheKeyCustomKeyUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheKeyCustomKeyUserArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[_builtins.bool]] = None,
                 geo: Optional[pulumi.Input[_builtins.bool]] = None,
                 lang: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] device_type: Whether to use the user agent's device type in the cache key.
        :param pulumi.Input[_builtins.bool] geo: Whether to use the user agents's country in the cache key.
        :param pulumi.Input[_builtins.bool] lang: Whether to use the user agent's language in the cache key.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the user agent's device type in the cache key.
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "device_type", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the user agents's country in the cache key.
        """
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the user agent's language in the cache key.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class RulesetRuleActionParametersCacheReserveArgsDict(TypedDict):
        eligible: pulumi.Input[_builtins.bool]
        """
        Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
        """
        minimum_file_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum file size eligible for storage in Cache Reserve.
        """
elif False:
    RulesetRuleActionParametersCacheReserveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCacheReserveArgs:
    def __init__(__self__, *,
                 eligible: pulumi.Input[_builtins.bool],
                 minimum_file_size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] eligible: Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
        :param pulumi.Input[_builtins.int] minimum_file_size: The minimum file size eligible for storage in Cache Reserve.
        """
        pulumi.set(__self__, "eligible", eligible)
        if minimum_file_size is not None:
            pulumi.set(__self__, "minimum_file_size", minimum_file_size)

    @_builtins.property
    @pulumi.getter
    def eligible(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
        """
        return pulumi.get(self, "eligible")

    @eligible.setter
    def eligible(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "eligible", value)

    @_builtins.property
    @pulumi.getter(name="minimumFileSize")
    def minimum_file_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum file size eligible for storage in Cache Reserve.
        """
        return pulumi.get(self, "minimum_file_size")

    @minimum_file_size.setter
    def minimum_file_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum_file_size", value)


if not MYPY:
    class RulesetRuleActionParametersCookieFieldArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the cookie.
        """
elif False:
    RulesetRuleActionParametersCookieFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersCookieFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the cookie.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the cookie.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The edge TTL mode.
        Available values: "respect*origin", "bypass*by*default", "override*origin".
        """
        default: NotRequired[pulumi.Input[_builtins.int]]
        """
        The edge TTL (in seconds) if you choose the "override_origin" mode.
        """
        status_code_ttls: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict']]]]
        """
        A list of TTLs to apply to specific status codes or status code ranges.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 default: Optional[pulumi.Input[_builtins.int]] = None,
                 status_code_ttls: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The edge TTL mode.
               Available values: "respect*origin", "bypass*by*default", "override*origin".
        :param pulumi.Input[_builtins.int] default: The edge TTL (in seconds) if you choose the "override_origin" mode.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]] status_code_ttls: A list of TTLs to apply to specific status codes or status code ranges.
        """
        pulumi.set(__self__, "mode", mode)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if status_code_ttls is not None:
            pulumi.set(__self__, "status_code_ttls", status_code_ttls)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The edge TTL mode.
        Available values: "respect*origin", "bypass*by*default", "override*origin".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The edge TTL (in seconds) if you choose the "override_origin" mode.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter(name="statusCodeTtls")
    def status_code_ttls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]:
        """
        A list of TTLs to apply to specific status codes or status code ranges.
        """
        return pulumi.get(self, "status_code_ttls")

    @status_code_ttls.setter
    def status_code_ttls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs']]]]):
        pulumi.set(self, "status_code_ttls", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict(TypedDict):
        value: pulumi.Input[_builtins.int]
        """
        The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
        """
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        A single status code to apply the TTL to.
        """
        status_code_range: NotRequired[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict']]
        """
        A range of status codes to apply the TTL to.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.int],
                 status_code: Optional[pulumi.Input[_builtins.int]] = None,
                 status_code_range: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] value: The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
        :param pulumi.Input[_builtins.int] status_code: A single status code to apply the TTL to.
        :param pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs'] status_code_range: A range of status codes to apply the TTL to.
        """
        pulumi.set(__self__, "value", value)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if status_code_range is not None:
            pulumi.set(__self__, "status_code_range", status_code_range)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A single status code to apply the TTL to.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter(name="statusCodeRange")
    def status_code_range(self) -> Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]:
        """
        A range of status codes to apply the TTL to.
        """
        return pulumi.get(self, "status_code_range")

    @status_code_range.setter
    def status_code_range(self, value: Optional[pulumi.Input['RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs']]):
        pulumi.set(self, "status_code_range", value)


if not MYPY:
    class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lower bound of the range.
        """
        to: NotRequired[pulumi.Input[_builtins.int]]
        """
        The upper bound of the range.
        """
elif False:
    RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersEdgeTtlStatusCodeTtlStatusCodeRangeArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.int]] = None,
                 to: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] from_: The lower bound of the range.
        :param pulumi.Input[_builtins.int] to: The upper bound of the range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lower bound of the range.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The upper bound of the range.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class RulesetRuleActionParametersFromListArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        An expression that evaluates to the list lookup key.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the list to match against.
        """
elif False:
    RulesetRuleActionParametersFromListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromListArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: An expression that evaluates to the list lookup key.
        :param pulumi.Input[_builtins.str] name: The name of the list to match against.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An expression that evaluates to the list lookup key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the list to match against.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersFromValueArgsDict(TypedDict):
        target_url: pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgsDict']
        """
        A URL to redirect the request to.
        """
        preserve_query_string: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to keep the query string of the original request.
        """
        status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code to use for the redirect.
        """
elif False:
    RulesetRuleActionParametersFromValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromValueArgs:
    def __init__(__self__, *,
                 target_url: pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs'],
                 preserve_query_string: Optional[pulumi.Input[_builtins.bool]] = None,
                 status_code: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs'] target_url: A URL to redirect the request to.
        :param pulumi.Input[_builtins.bool] preserve_query_string: Whether to keep the query string of the original request.
        :param pulumi.Input[_builtins.int] status_code: The status code to use for the redirect.
        """
        pulumi.set(__self__, "target_url", target_url)
        if preserve_query_string is not None:
            pulumi.set(__self__, "preserve_query_string", preserve_query_string)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']:
        """
        A URL to redirect the request to.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input['RulesetRuleActionParametersFromValueTargetUrlArgs']):
        pulumi.set(self, "target_url", value)

    @_builtins.property
    @pulumi.getter(name="preserveQueryString")
    def preserve_query_string(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to keep the query string of the original request.
        """
        return pulumi.get(self, "preserve_query_string")

    @preserve_query_string.setter
    def preserve_query_string(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_query_string", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code to use for the redirect.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class RulesetRuleActionParametersFromValueTargetUrlArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        An expression that evaluates to a URL to redirect the request to.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        A URL to redirect the request to.
        """
elif False:
    RulesetRuleActionParametersFromValueTargetUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersFromValueTargetUrlArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: An expression that evaluates to a URL to redirect the request to.
        :param pulumi.Input[_builtins.str] value: A URL to redirect the request to.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An expression that evaluates to a URL to redirect the request to.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A URL to redirect the request to.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersHeadersArgsDict(TypedDict):
        operation: pulumi.Input[_builtins.str]
        """
        The operation to perform on the header.
        Available values: "add", "set", "remove".
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        An expression that evaluates to a value for the header.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        A static value for the header.
        """
elif False:
    RulesetRuleActionParametersHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersHeadersArgs:
    def __init__(__self__, *,
                 operation: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] operation: The operation to perform on the header.
               Available values: "add", "set", "remove".
        :param pulumi.Input[_builtins.str] expression: An expression that evaluates to a value for the header.
        :param pulumi.Input[_builtins.str] value: A static value for the header.
        """
        pulumi.set(__self__, "operation", operation)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        The operation to perform on the header.
        Available values: "add", "set", "remove".
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An expression that evaluates to a value for the header.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A static value for the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersMatchedDataArgsDict(TypedDict):
        public_key: pulumi.Input[_builtins.str]
        """
        The public key to encrypt matched data logs with.
        """
elif False:
    RulesetRuleActionParametersMatchedDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersMatchedDataArgs:
    def __init__(__self__, *,
                 public_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] public_key: The public key to encrypt matched data logs with.
        """
        pulumi.set(__self__, "public_key", public_key)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[_builtins.str]:
        """
        The public key to encrypt matched data logs with.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class RulesetRuleActionParametersOriginArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        A resolved host to route to.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A destination port to route to.
        """
elif False:
    RulesetRuleActionParametersOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOriginArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: A resolved host to route to.
        :param pulumi.Input[_builtins.int] port: A destination port to route to.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A resolved host to route to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A destination port to route to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        An action to override all rules with. This option has lower precedence than rule and category overrides.
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgsDict']]]]
        """
        A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgsDict']]]]
        """
        A list of rule-level overrides. This option has the highest precedence.
        """
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        Available values: "default", "medium", "low", "eoff".
        """
elif False:
    RulesetRuleActionParametersOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: An action to override all rules with. This option has lower precedence than rule and category overrides.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]] categories: A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]] rules: A list of rule-level overrides. This option has the highest precedence.
        :param pulumi.Input[_builtins.str] sensitivity_level: A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
               Available values: "default", "medium", "low", "eoff".
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An action to override all rules with. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]:
        """
        A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesCategoryArgs']]]]):
        pulumi.set(self, "categories", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]:
        """
        A list of rule-level overrides. This option has the highest precedence.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionParametersOverridesRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
        Available values: "default", "medium", "low", "eoff".
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesCategoryArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        """
        The name of the category to override.
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to override rules in the category with.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable execution of rules in the category.
        """
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
        Available values: "default", "medium", "low", "eoff".
        """
elif False:
    RulesetRuleActionParametersOverridesCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesCategoryArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: The name of the category to override.
        :param pulumi.Input[_builtins.str] action: The action to override rules in the category with.
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable execution of rules in the category.
        :param pulumi.Input[_builtins.str] sensitivity_level: The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
               Available values: "default", "medium", "low", "eoff".
        """
        pulumi.set(__self__, "category", category)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the category to override.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to override rules in the category with.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable execution of rules in the category.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sensitivity level to use for rules in the category. This option is only applicable for DDoS phases.
        Available values: "default", "medium", "low", "eoff".
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersOverridesRuleArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of the rule to override.
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to override the rule with.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable execution of the rule.
        """
        score_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The score threshold to use for the rule.
        """
        sensitivity_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
        Available values: "default", "medium", "low", "eoff".
        """
elif False:
    RulesetRuleActionParametersOverridesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersOverridesRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 score_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 sensitivity_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the rule to override.
        :param pulumi.Input[_builtins.str] action: The action to override the rule with.
        :param pulumi.Input[_builtins.bool] enabled: Whether to enable execution of the rule.
        :param pulumi.Input[_builtins.int] score_threshold: The score threshold to use for the rule.
        :param pulumi.Input[_builtins.str] sensitivity_level: The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
               Available values: "default", "medium", "low", "eoff".
        """
        pulumi.set(__self__, "id", id)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if score_threshold is not None:
            pulumi.set(__self__, "score_threshold", score_threshold)
        if sensitivity_level is not None:
            pulumi.set(__self__, "sensitivity_level", sensitivity_level)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the rule to override.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to override the rule with.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable execution of the rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="scoreThreshold")
    def score_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The score threshold to use for the rule.
        """
        return pulumi.get(self, "score_threshold")

    @score_threshold.setter
    def score_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score_threshold", value)

    @_builtins.property
    @pulumi.getter(name="sensitivityLevel")
    def sensitivity_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sensitivity level to use for the rule. This option is only applicable for DDoS phases.
        Available values: "default", "medium", "low", "eoff".
        """
        return pulumi.get(self, "sensitivity_level")

    @sensitivity_level.setter
    def sensitivity_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensitivity_level", value)


if not MYPY:
    class RulesetRuleActionParametersRawResponseFieldArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the response header.
        """
        preserve_duplicates: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to log duplicate values of the same header.
        """
elif False:
    RulesetRuleActionParametersRawResponseFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersRawResponseFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 preserve_duplicates: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the response header.
        :param pulumi.Input[_builtins.bool] preserve_duplicates: Whether to log duplicate values of the same header.
        """
        pulumi.set(__self__, "name", name)
        if preserve_duplicates is not None:
            pulumi.set(__self__, "preserve_duplicates", preserve_duplicates)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the response header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="preserveDuplicates")
    def preserve_duplicates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to log duplicate values of the same header.
        """
        return pulumi.get(self, "preserve_duplicates")

    @preserve_duplicates.setter
    def preserve_duplicates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_duplicates", value)


if not MYPY:
    class RulesetRuleActionParametersRequestFieldArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the header.
        """
elif False:
    RulesetRuleActionParametersRequestFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersRequestFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the header.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersResponseArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        The content to return.
        """
        content_type: pulumi.Input[_builtins.str]
        """
        The type of the content to return.
        """
        status_code: pulumi.Input[_builtins.int]
        """
        The status code to return.
        """
elif False:
    RulesetRuleActionParametersResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersResponseArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 status_code: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] content: The content to return.
        :param pulumi.Input[_builtins.str] content_type: The type of the content to return.
        :param pulumi.Input[_builtins.int] status_code: The status code to return.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        The content to return.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the content to return.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[_builtins.int]:
        """
        The status code to return.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class RulesetRuleActionParametersResponseFieldArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the response header.
        """
        preserve_duplicates: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to log duplicate values of the same header.
        """
elif False:
    RulesetRuleActionParametersResponseFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersResponseFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 preserve_duplicates: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the response header.
        :param pulumi.Input[_builtins.bool] preserve_duplicates: Whether to log duplicate values of the same header.
        """
        pulumi.set(__self__, "name", name)
        if preserve_duplicates is not None:
            pulumi.set(__self__, "preserve_duplicates", preserve_duplicates)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the response header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="preserveDuplicates")
    def preserve_duplicates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to log duplicate values of the same header.
        """
        return pulumi.get(self, "preserve_duplicates")

    @preserve_duplicates.setter
    def preserve_duplicates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_duplicates", value)


if not MYPY:
    class RulesetRuleActionParametersServeStaleArgsDict(TypedDict):
        disable_stale_while_updating: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
        """
elif False:
    RulesetRuleActionParametersServeStaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersServeStaleArgs:
    def __init__(__self__, *,
                 disable_stale_while_updating: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_stale_while_updating: Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
        """
        if disable_stale_while_updating is not None:
            pulumi.set(__self__, "disable_stale_while_updating", disable_stale_while_updating)

    @_builtins.property
    @pulumi.getter(name="disableStaleWhileUpdating")
    def disable_stale_while_updating(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
        """
        return pulumi.get(self, "disable_stale_while_updating")

    @disable_stale_while_updating.setter
    def disable_stale_while_updating(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_stale_while_updating", value)


if not MYPY:
    class RulesetRuleActionParametersSniArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        A value to override the SNI to.
        """
elif False:
    RulesetRuleActionParametersSniArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersSniArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] value: A value to override the SNI to.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        A value to override the SNI to.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersTransformedRequestFieldArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the header.
        """
elif False:
    RulesetRuleActionParametersTransformedRequestFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersTransformedRequestFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the header.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RulesetRuleActionParametersUriArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['RulesetRuleActionParametersUriPathArgsDict']]
        """
        A URI path rewrite.
        """
        query: NotRequired[pulumi.Input['RulesetRuleActionParametersUriQueryArgsDict']]
        """
        A URI query rewrite.
        """
elif False:
    RulesetRuleActionParametersUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']] = None,
                 query: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']] = None):
        """
        :param pulumi.Input['RulesetRuleActionParametersUriPathArgs'] path: A URI path rewrite.
        :param pulumi.Input['RulesetRuleActionParametersUriQueryArgs'] query: A URI query rewrite.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]:
        """
        A URI path rewrite.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriPathArgs']]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]:
        """
        A URI query rewrite.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['RulesetRuleActionParametersUriQueryArgs']]):
        pulumi.set(self, "query", value)


if not MYPY:
    class RulesetRuleActionParametersUriPathArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        An expression that evaluates to a value to rewrite the URI path to.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        A value to rewrite the URI path to.
        """
elif False:
    RulesetRuleActionParametersUriPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriPathArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: An expression that evaluates to a value to rewrite the URI path to.
        :param pulumi.Input[_builtins.str] value: A value to rewrite the URI path to.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An expression that evaluates to a value to rewrite the URI path to.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A value to rewrite the URI path to.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionParametersUriQueryArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        An expression that evaluates to a value to rewrite the URI query to.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        A value to rewrite the URI query to.
        """
elif False:
    RulesetRuleActionParametersUriQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionParametersUriQueryArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: An expression that evaluates to a value to rewrite the URI query to.
        :param pulumi.Input[_builtins.str] value: A value to rewrite the URI query to.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An expression that evaluates to a value to rewrite the URI query to.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A value to rewrite the URI query to.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleExposedCredentialCheckArgsDict(TypedDict):
        password_expression: pulumi.Input[_builtins.str]
        """
        An expression that selects the password used in the credentials check.
        """
        username_expression: pulumi.Input[_builtins.str]
        """
        An expression that selects the user ID used in the credentials check.
        """
elif False:
    RulesetRuleExposedCredentialCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleExposedCredentialCheckArgs:
    def __init__(__self__, *,
                 password_expression: pulumi.Input[_builtins.str],
                 username_expression: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password_expression: An expression that selects the password used in the credentials check.
        :param pulumi.Input[_builtins.str] username_expression: An expression that selects the user ID used in the credentials check.
        """
        pulumi.set(__self__, "password_expression", password_expression)
        pulumi.set(__self__, "username_expression", username_expression)

    @_builtins.property
    @pulumi.getter(name="passwordExpression")
    def password_expression(self) -> pulumi.Input[_builtins.str]:
        """
        An expression that selects the password used in the credentials check.
        """
        return pulumi.get(self, "password_expression")

    @password_expression.setter
    def password_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password_expression", value)

    @_builtins.property
    @pulumi.getter(name="usernameExpression")
    def username_expression(self) -> pulumi.Input[_builtins.str]:
        """
        An expression that selects the user ID used in the credentials check.
        """
        return pulumi.get(self, "username_expression")

    @username_expression.setter
    def username_expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username_expression", value)


if not MYPY:
    class RulesetRuleLoggingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to generate a log when the rule matches.
        """
elif False:
    RulesetRuleLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleLoggingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to generate a log when the rule matches.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to generate a log when the rule matches.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class RulesetRuleRatelimitArgsDict(TypedDict):
        characteristics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Characteristics of the request on which the rate limit counter will be incremented.
        """
        period: pulumi.Input[_builtins.int]
        """
        Period in seconds over which the counter is being incremented.
        """
        counting_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
        """
        mitigation_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Period of time in seconds after which the action will be disabled following its first execution.
        """
        requests_per_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The threshold of requests per period after which the action will be executed for the first time.
        """
        requests_to_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether counting is only performed when an origin is reached.
        """
        score_per_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The score threshold per period for which the action will be executed the first time.
        """
        score_response_header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A response header name provided by the origin, which contains the score to increment rate limit counter with.
        """
elif False:
    RulesetRuleRatelimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleRatelimitArgs:
    def __init__(__self__, *,
                 characteristics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 period: pulumi.Input[_builtins.int],
                 counting_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 mitigation_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 requests_per_period: Optional[pulumi.Input[_builtins.int]] = None,
                 requests_to_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 score_per_period: Optional[pulumi.Input[_builtins.int]] = None,
                 score_response_header_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] characteristics: Characteristics of the request on which the rate limit counter will be incremented.
        :param pulumi.Input[_builtins.int] period: Period in seconds over which the counter is being incremented.
        :param pulumi.Input[_builtins.str] counting_expression: An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
        :param pulumi.Input[_builtins.int] mitigation_timeout: Period of time in seconds after which the action will be disabled following its first execution.
        :param pulumi.Input[_builtins.int] requests_per_period: The threshold of requests per period after which the action will be executed for the first time.
        :param pulumi.Input[_builtins.bool] requests_to_origin: Whether counting is only performed when an origin is reached.
        :param pulumi.Input[_builtins.int] score_per_period: The score threshold per period for which the action will be executed the first time.
        :param pulumi.Input[_builtins.str] score_response_header_name: A response header name provided by the origin, which contains the score to increment rate limit counter with.
        """
        pulumi.set(__self__, "characteristics", characteristics)
        pulumi.set(__self__, "period", period)
        if counting_expression is not None:
            pulumi.set(__self__, "counting_expression", counting_expression)
        if mitigation_timeout is not None:
            pulumi.set(__self__, "mitigation_timeout", mitigation_timeout)
        if requests_per_period is not None:
            pulumi.set(__self__, "requests_per_period", requests_per_period)
        if requests_to_origin is not None:
            pulumi.set(__self__, "requests_to_origin", requests_to_origin)
        if score_per_period is not None:
            pulumi.set(__self__, "score_per_period", score_per_period)
        if score_response_header_name is not None:
            pulumi.set(__self__, "score_response_header_name", score_response_header_name)

    @_builtins.property
    @pulumi.getter
    def characteristics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Characteristics of the request on which the rate limit counter will be incremented.
        """
        return pulumi.get(self, "characteristics")

    @characteristics.setter
    def characteristics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "characteristics", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Period in seconds over which the counter is being incremented.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="countingExpression")
    def counting_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
        """
        return pulumi.get(self, "counting_expression")

    @counting_expression.setter
    def counting_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "counting_expression", value)

    @_builtins.property
    @pulumi.getter(name="mitigationTimeout")
    def mitigation_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Period of time in seconds after which the action will be disabled following its first execution.
        """
        return pulumi.get(self, "mitigation_timeout")

    @mitigation_timeout.setter
    def mitigation_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mitigation_timeout", value)

    @_builtins.property
    @pulumi.getter(name="requestsPerPeriod")
    def requests_per_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The threshold of requests per period after which the action will be executed for the first time.
        """
        return pulumi.get(self, "requests_per_period")

    @requests_per_period.setter
    def requests_per_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "requests_per_period", value)

    @_builtins.property
    @pulumi.getter(name="requestsToOrigin")
    def requests_to_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether counting is only performed when an origin is reached.
        """
        return pulumi.get(self, "requests_to_origin")

    @requests_to_origin.setter
    def requests_to_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "requests_to_origin", value)

    @_builtins.property
    @pulumi.getter(name="scorePerPeriod")
    def score_per_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The score threshold per period for which the action will be executed the first time.
        """
        return pulumi.get(self, "score_per_period")

    @score_per_period.setter
    def score_per_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score_per_period", value)

    @_builtins.property
    @pulumi.getter(name="scoreResponseHeaderName")
    def score_response_header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A response header name provided by the origin, which contains the score to increment rate limit counter with.
        """
        return pulumi.get(self, "score_response_header_name")

    @score_response_header_name.setter
    def score_response_header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "score_response_header_name", value)


if not MYPY:
    class SnippetFileArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
elif False:
    SnippetFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetFileArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SnippetMetadataArgsDict(TypedDict):
        main_module: pulumi.Input[_builtins.str]
        """
        Name of the file that contains the main module of the snippet.
        """
elif False:
    SnippetMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetMetadataArgs:
    def __init__(__self__, *,
                 main_module: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] main_module: Name of the file that contains the main module of the snippet.
        """
        pulumi.set(__self__, "main_module", main_module)

    @_builtins.property
    @pulumi.getter(name="mainModule")
    def main_module(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the file that contains the main module of the snippet.
        """
        return pulumi.get(self, "main_module")

    @main_module.setter
    def main_module(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "main_module", value)


if not MYPY:
    class SnippetRulesRuleArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        The expression defining which traffic will match the rule.
        """
        snippet_name: pulumi.Input[_builtins.str]
        """
        The identifying name of the snippet.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        An informative description of the rule.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the rule should be executed.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ID of the rule.
        """
        last_updated: NotRequired[pulumi.Input[_builtins.str]]
        """
        The timestamp of when the rule was last modified.
        """
elif False:
    SnippetRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetRulesRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 snippet_name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 last_updated: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: The expression defining which traffic will match the rule.
        :param pulumi.Input[_builtins.str] snippet_name: The identifying name of the snippet.
        :param pulumi.Input[_builtins.str] description: An informative description of the rule.
        :param pulumi.Input[_builtins.bool] enabled: Whether the rule should be executed.
        :param pulumi.Input[_builtins.str] id: The unique ID of the rule.
        :param pulumi.Input[_builtins.str] last_updated: The timestamp of when the rule was last modified.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "snippet_name", snippet_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        The expression defining which traffic will match the rule.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="snippetName")
    def snippet_name(self) -> pulumi.Input[_builtins.str]:
        """
        The identifying name of the snippet.
        """
        return pulumi.get(self, "snippet_name")

    @snippet_name.setter
    def snippet_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "snippet_name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An informative description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the rule should be executed.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ID of the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The timestamp of when the rule was last modified.
        """
        return pulumi.get(self, "last_updated")

    @last_updated.setter
    def last_updated(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated", value)


if not MYPY:
    class SnippetsMetadataArgsDict(TypedDict):
        main_module: pulumi.Input[_builtins.str]
        """
        Name of the file that contains the main module of the snippet.
        """
elif False:
    SnippetsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnippetsMetadataArgs:
    def __init__(__self__, *,
                 main_module: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] main_module: Name of the file that contains the main module of the snippet.
        """
        pulumi.set(__self__, "main_module", main_module)

    @_builtins.property
    @pulumi.getter(name="mainModule")
    def main_module(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the file that contains the main module of the snippet.
        """
        return pulumi.get(self, "main_module")

    @main_module.setter
    def main_module(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "main_module", value)


if not MYPY:
    class SpectrumApplicationDnsArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the DNS record associated with the application.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of DNS record associated with the application.
        Available values: "CNAME", "ADDRESS".
        """
elif False:
    SpectrumApplicationDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationDnsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the DNS record associated with the application.
        :param pulumi.Input[_builtins.str] type: The type of DNS record associated with the application.
               Available values: "CNAME", "ADDRESS".
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the DNS record associated with the application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of DNS record associated with the application.
        Available values: "CNAME", "ADDRESS".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SpectrumApplicationEdgeIpsArgsDict(TypedDict):
        connectivity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs.
        Available values: "all", "ipv4", "ipv6".
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The array of customer owned IPs we broadcast via anycast for this hostname and application.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        Available values: "dynamic", "static".
        """
elif False:
    SpectrumApplicationEdgeIpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationEdgeIpsArgs:
    def __init__(__self__, *,
                 connectivity: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connectivity: The IP versions supported for inbound connections on Spectrum anycast IPs.
               Available values: "all", "ipv4", "ipv6".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: The array of customer owned IPs we broadcast via anycast for this hostname and application.
        :param pulumi.Input[_builtins.str] type: The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
               Available values: "dynamic", "static".
        """
        if connectivity is not None:
            pulumi.set(__self__, "connectivity", connectivity)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def connectivity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP versions supported for inbound connections on Spectrum anycast IPs.
        Available values: "all", "ipv4", "ipv6".
        """
        return pulumi.get(self, "connectivity")

    @connectivity.setter
    def connectivity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connectivity", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The array of customer owned IPs we broadcast via anycast for this hostname and application.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
        Available values: "dynamic", "static".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SpectrumApplicationOriginDnsArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the DNS record associated with the origin.
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        The TTL of our resolution of your DNS record in seconds.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        Available values: "", "A", "AAAA", "SRV".
        """
elif False:
    SpectrumApplicationOriginDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpectrumApplicationOriginDnsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the DNS record associated with the origin.
        :param pulumi.Input[_builtins.int] ttl: The TTL of our resolution of your DNS record in seconds.
        :param pulumi.Input[_builtins.str] type: The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
               Available values: "", "A", "AAAA", "SRV".
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the DNS record associated with the origin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The TTL of our resolution of your DNS record in seconds.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
        Available values: "", "A", "AAAA", "SRV".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StaticRouteScopeArgsDict(TypedDict):
        colo_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of colo names for the ECMP scope.
        """
        colo_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of colo regions for the ECMP scope.
        """
elif False:
    StaticRouteScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticRouteScopeArgs:
    def __init__(__self__, *,
                 colo_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 colo_regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] colo_names: List of colo names for the ECMP scope.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] colo_regions: List of colo regions for the ECMP scope.
        """
        if colo_names is not None:
            pulumi.set(__self__, "colo_names", colo_names)
        if colo_regions is not None:
            pulumi.set(__self__, "colo_regions", colo_regions)

    @_builtins.property
    @pulumi.getter(name="coloNames")
    def colo_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of colo names for the ECMP scope.
        """
        return pulumi.get(self, "colo_names")

    @colo_names.setter
    def colo_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "colo_names", value)

    @_builtins.property
    @pulumi.getter(name="coloRegions")
    def colo_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of colo regions for the ECMP scope.
        """
        return pulumi.get(self, "colo_regions")

    @colo_regions.setter
    def colo_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "colo_regions", value)


if not MYPY:
    class StreamInputArgsDict(TypedDict):
        height: NotRequired[pulumi.Input[_builtins.int]]
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        width: NotRequired[pulumi.Input[_builtins.int]]
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
elif False:
    StreamInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamInputArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[_builtins.int]] = None,
                 width: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] height: The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        :param pulumi.Input[_builtins.int] width: The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class StreamLiveInputRecordingArgsDict(TypedDict):
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        """
        hide_live_viewer_count: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables reporting the number of live viewers when this property is set to `true`.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        Available values: "off", "automatic".
        """
        require_signed_urls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
elif False:
    StreamLiveInputRecordingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputRecordingArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 hide_live_viewer_count: Optional[pulumi.Input[_builtins.bool]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 require_signed_urls: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        :param pulumi.Input[_builtins.bool] hide_live_viewer_count: Disables reporting the number of live viewers when this property is set to `true`.
        :param pulumi.Input[_builtins.str] mode: Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
               Available values: "off", "automatic".
        :param pulumi.Input[_builtins.bool] require_signed_urls: Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        :param pulumi.Input[_builtins.int] timeout_seconds: Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if hide_live_viewer_count is not None:
            pulumi.set(__self__, "hide_live_viewer_count", hide_live_viewer_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if require_signed_urls is not None:
            pulumi.set(__self__, "require_signed_urls", require_signed_urls)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="hideLiveViewerCount")
    def hide_live_viewer_count(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables reporting the number of live viewers when this property is set to `true`.
        """
        return pulumi.get(self, "hide_live_viewer_count")

    @hide_live_viewer_count.setter
    def hide_live_viewer_count(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hide_live_viewer_count", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
        Available values: "off", "automatic".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="requireSignedUrls")
    def require_signed_urls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
        """
        return pulumi.get(self, "require_signed_urls")

    @require_signed_urls.setter
    def require_signed_urls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_signed_urls", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class StreamLiveInputRtmpsArgsDict(TypedDict):
        stream_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key to use when streaming via RTMPS to a live input.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
elif False:
    StreamLiveInputRtmpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputRtmpsArgs:
    def __init__(__self__, *,
                 stream_key: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] stream_key: The secret key to use when streaming via RTMPS to a live input.
        :param pulumi.Input[_builtins.str] url: The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        if stream_key is not None:
            pulumi.set(__self__, "stream_key", stream_key)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key to use when streaming via RTMPS to a live input.
        """
        return pulumi.get(self, "stream_key")

    @stream_key.setter
    def stream_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_key", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The RTMPS URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputRtmpsPlaybackArgsDict(TypedDict):
        stream_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key to use for playback via RTMPS.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL used to play live video over RTMPS.
        """
elif False:
    StreamLiveInputRtmpsPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputRtmpsPlaybackArgs:
    def __init__(__self__, *,
                 stream_key: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] stream_key: The secret key to use for playback via RTMPS.
        :param pulumi.Input[_builtins.str] url: The URL used to play live video over RTMPS.
        """
        if stream_key is not None:
            pulumi.set(__self__, "stream_key", stream_key)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="streamKey")
    def stream_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key to use for playback via RTMPS.
        """
        return pulumi.get(self, "stream_key")

    @stream_key.setter
    def stream_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_key", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL used to play live video over RTMPS.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputSrtArgsDict(TypedDict):
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key to use when streaming via SRT to a live input.
        """
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the live input to use when streaming via SRT.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SRT URL you provide to the broadcaster, which they stream live video to.
        """
elif False:
    StreamLiveInputSrtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputSrtArgs:
    def __init__(__self__, *,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] passphrase: The secret key to use when streaming via SRT to a live input.
        :param pulumi.Input[_builtins.str] stream_id: The identifier of the live input to use when streaming via SRT.
        :param pulumi.Input[_builtins.str] url: The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key to use when streaming via SRT to a live input.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the live input to use when streaming via SRT.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SRT URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputSrtPlaybackArgsDict(TypedDict):
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key to use for playback via SRT.
        """
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the live input to use for playback via SRT.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL used to play live video over SRT.
        """
elif False:
    StreamLiveInputSrtPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputSrtPlaybackArgs:
    def __init__(__self__, *,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] passphrase: The secret key to use for playback via SRT.
        :param pulumi.Input[_builtins.str] stream_id: The identifier of the live input to use for playback via SRT.
        :param pulumi.Input[_builtins.str] url: The URL used to play live video over SRT.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key to use for playback via SRT.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the live input to use for playback via SRT.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL used to play live video over SRT.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputWebRtcArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
elif False:
    StreamLiveInputWebRtcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputWebRtcArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The WebRTC URL you provide to the broadcaster, which they stream live video to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamLiveInputWebRtcPlaybackArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL used to play live video over WebRTC.
        """
elif False:
    StreamLiveInputWebRtcPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamLiveInputWebRtcPlaybackArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL used to play live video over WebRTC.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL used to play live video over WebRTC.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class StreamPlaybackArgsDict(TypedDict):
        dash: NotRequired[pulumi.Input[_builtins.str]]
        """
        DASH Media Presentation Description for the video.
        """
        hls: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HLS manifest for the video.
        """
elif False:
    StreamPlaybackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamPlaybackArgs:
    def __init__(__self__, *,
                 dash: Optional[pulumi.Input[_builtins.str]] = None,
                 hls: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dash: DASH Media Presentation Description for the video.
        :param pulumi.Input[_builtins.str] hls: The HLS manifest for the video.
        """
        if dash is not None:
            pulumi.set(__self__, "dash", dash)
        if hls is not None:
            pulumi.set(__self__, "hls", hls)

    @_builtins.property
    @pulumi.getter
    def dash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DASH Media Presentation Description for the video.
        """
        return pulumi.get(self, "dash")

    @dash.setter
    def dash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dash", value)

    @_builtins.property
    @pulumi.getter
    def hls(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HLS manifest for the video.
        """
        return pulumi.get(self, "hls")

    @hls.setter
    def hls(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hls", value)


if not MYPY:
    class StreamStatusArgsDict(TypedDict):
        error_reason_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        error_reason_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        pct_complete: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the processing status for all quality levels for a video.
        Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
        """
elif False:
    StreamStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamStatusArgs:
    def __init__(__self__, *,
                 error_reason_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_reason_text: Optional[pulumi.Input[_builtins.str]] = None,
                 pct_complete: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_reason_code: Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        :param pulumi.Input[_builtins.str] error_reason_text: Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        :param pulumi.Input[_builtins.str] pct_complete: Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        :param pulumi.Input[_builtins.str] state: Specifies the processing status for all quality levels for a video.
               Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
        """
        if error_reason_code is not None:
            pulumi.set(__self__, "error_reason_code", error_reason_code)
        if error_reason_text is not None:
            pulumi.set(__self__, "error_reason_text", error_reason_text)
        if pct_complete is not None:
            pulumi.set(__self__, "pct_complete", pct_complete)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="errorReasonCode")
    def error_reason_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
        """
        return pulumi.get(self, "error_reason_code")

    @error_reason_code.setter
    def error_reason_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_reason_code", value)

    @_builtins.property
    @pulumi.getter(name="errorReasonText")
    def error_reason_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
        """
        return pulumi.get(self, "error_reason_text")

    @error_reason_text.setter
    def error_reason_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_reason_text", value)

    @_builtins.property
    @pulumi.getter(name="pctComplete")
    def pct_complete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
        """
        return pulumi.get(self, "pct_complete")

    @pct_complete.setter
    def pct_complete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pct_complete", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the processing status for all quality levels for a video.
        Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class StreamWatermarkArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and a time a watermark profile was created.
        """
        downloaded_from: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        height: NotRequired[pulumi.Input[_builtins.int]]
        """
        The height of the image in pixels.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A short description of the watermark profile.
        """
        opacity: NotRequired[pulumi.Input[_builtins.float]]
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        padding: NotRequired[pulumi.Input[_builtins.float]]
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        position: NotRequired[pulumi.Input[_builtins.str]]
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        scale: NotRequired[pulumi.Input[_builtins.float]]
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        size: NotRequired[pulumi.Input[_builtins.float]]
        """
        The size of the image in bytes.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier for a watermark profile.
        """
        width: NotRequired[pulumi.Input[_builtins.int]]
        """
        The width of the image in pixels.
        """
elif False:
    StreamWatermarkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamWatermarkArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[_builtins.str]] = None,
                 downloaded_from: Optional[pulumi.Input[_builtins.str]] = None,
                 height: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 opacity: Optional[pulumi.Input[_builtins.float]] = None,
                 padding: Optional[pulumi.Input[_builtins.float]] = None,
                 position: Optional[pulumi.Input[_builtins.str]] = None,
                 scale: Optional[pulumi.Input[_builtins.float]] = None,
                 size: Optional[pulumi.Input[_builtins.float]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None,
                 width: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] created: The date and a time a watermark profile was created.
        :param pulumi.Input[_builtins.str] downloaded_from: The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        :param pulumi.Input[_builtins.int] height: The height of the image in pixels.
        :param pulumi.Input[_builtins.str] name: A short description of the watermark profile.
        :param pulumi.Input[_builtins.float] opacity: The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        :param pulumi.Input[_builtins.float] padding: The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        :param pulumi.Input[_builtins.str] position: The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        :param pulumi.Input[_builtins.float] scale: The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        :param pulumi.Input[_builtins.float] size: The size of the image in bytes.
        :param pulumi.Input[_builtins.str] uid: The unique identifier for a watermark profile.
        :param pulumi.Input[_builtins.int] width: The width of the image in pixels.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if downloaded_from is not None:
            pulumi.set(__self__, "downloaded_from", downloaded_from)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if opacity is not None:
            pulumi.set(__self__, "opacity", opacity)
        if padding is not None:
            pulumi.set(__self__, "padding", padding)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and a time a watermark profile was created.
        """
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created", value)

    @_builtins.property
    @pulumi.getter(name="downloadedFrom")
    def downloaded_from(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
        """
        return pulumi.get(self, "downloaded_from")

    @downloaded_from.setter
    def downloaded_from(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "downloaded_from", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The height of the image in pixels.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A short description of the watermark profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def opacity(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
        """
        return pulumi.get(self, "opacity")

    @opacity.setter
    def opacity(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "opacity", value)

    @_builtins.property
    @pulumi.getter
    def padding(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
        """
        return pulumi.get(self, "padding")

    @padding.setter
    def padding(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "padding", value)

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "position", value)

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0`fills the entire video.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The size of the image in bytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier for a watermark profile.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The width of the image in pixels.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class TeamsAccountSettingsArgsDict(TypedDict):
        activity_log: NotRequired[pulumi.Input['TeamsAccountSettingsActivityLogArgsDict']]
        """
        Activity log settings.
        """
        antivirus: NotRequired[pulumi.Input['TeamsAccountSettingsAntivirusArgsDict']]
        """
        Anti-virus settings.
        """
        block_page: NotRequired[pulumi.Input['TeamsAccountSettingsBlockPageArgsDict']]
        """
        Block page layout settings.
        """
        body_scanning: NotRequired[pulumi.Input['TeamsAccountSettingsBodyScanningArgsDict']]
        """
        DLP body scanning settings.
        """
        browser_isolation: NotRequired[pulumi.Input['TeamsAccountSettingsBrowserIsolationArgsDict']]
        """
        Browser isolation settings.
        """
        certificate: NotRequired[pulumi.Input['TeamsAccountSettingsCertificateArgsDict']]
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        custom_certificate: NotRequired[pulumi.Input['TeamsAccountSettingsCustomCertificateArgsDict']]
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`).
        """
        extended_email_matching: NotRequired[pulumi.Input['TeamsAccountSettingsExtendedEmailMatchingArgsDict']]
        """
        Extended e-mail matching settings.
        """
        fips: NotRequired[pulumi.Input['TeamsAccountSettingsFipsArgsDict']]
        """
        FIPS settings.
        """
        host_selector: NotRequired[pulumi.Input['TeamsAccountSettingsHostSelectorArgsDict']]
        """
        Setting to enable host selector in egress policies.
        """
        inspection: NotRequired[pulumi.Input['TeamsAccountSettingsInspectionArgsDict']]
        """
        Setting to define inspection settings.
        """
        protocol_detection: NotRequired[pulumi.Input['TeamsAccountSettingsProtocolDetectionArgsDict']]
        """
        Protocol Detection settings.
        """
        sandbox: NotRequired[pulumi.Input['TeamsAccountSettingsSandboxArgsDict']]
        """
        Sandbox settings.
        """
        tls_decrypt: NotRequired[pulumi.Input['TeamsAccountSettingsTlsDecryptArgsDict']]
        """
        TLS interception settings.
        """
elif False:
    TeamsAccountSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsArgs:
    def __init__(__self__, *,
                 activity_log: Optional[pulumi.Input['TeamsAccountSettingsActivityLogArgs']] = None,
                 antivirus: Optional[pulumi.Input['TeamsAccountSettingsAntivirusArgs']] = None,
                 block_page: Optional[pulumi.Input['TeamsAccountSettingsBlockPageArgs']] = None,
                 body_scanning: Optional[pulumi.Input['TeamsAccountSettingsBodyScanningArgs']] = None,
                 browser_isolation: Optional[pulumi.Input['TeamsAccountSettingsBrowserIsolationArgs']] = None,
                 certificate: Optional[pulumi.Input['TeamsAccountSettingsCertificateArgs']] = None,
                 custom_certificate: Optional[pulumi.Input['TeamsAccountSettingsCustomCertificateArgs']] = None,
                 extended_email_matching: Optional[pulumi.Input['TeamsAccountSettingsExtendedEmailMatchingArgs']] = None,
                 fips: Optional[pulumi.Input['TeamsAccountSettingsFipsArgs']] = None,
                 host_selector: Optional[pulumi.Input['TeamsAccountSettingsHostSelectorArgs']] = None,
                 inspection: Optional[pulumi.Input['TeamsAccountSettingsInspectionArgs']] = None,
                 protocol_detection: Optional[pulumi.Input['TeamsAccountSettingsProtocolDetectionArgs']] = None,
                 sandbox: Optional[pulumi.Input['TeamsAccountSettingsSandboxArgs']] = None,
                 tls_decrypt: Optional[pulumi.Input['TeamsAccountSettingsTlsDecryptArgs']] = None):
        """
        :param pulumi.Input['TeamsAccountSettingsActivityLogArgs'] activity_log: Activity log settings.
        :param pulumi.Input['TeamsAccountSettingsAntivirusArgs'] antivirus: Anti-virus settings.
        :param pulumi.Input['TeamsAccountSettingsBlockPageArgs'] block_page: Block page layout settings.
        :param pulumi.Input['TeamsAccountSettingsBodyScanningArgs'] body_scanning: DLP body scanning settings.
        :param pulumi.Input['TeamsAccountSettingsBrowserIsolationArgs'] browser_isolation: Browser isolation settings.
        :param pulumi.Input['TeamsAccountSettingsCertificateArgs'] certificate: Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        :param pulumi.Input['TeamsAccountSettingsCustomCertificateArgs'] custom_certificate: Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`).
        :param pulumi.Input['TeamsAccountSettingsExtendedEmailMatchingArgs'] extended_email_matching: Extended e-mail matching settings.
        :param pulumi.Input['TeamsAccountSettingsFipsArgs'] fips: FIPS settings.
        :param pulumi.Input['TeamsAccountSettingsHostSelectorArgs'] host_selector: Setting to enable host selector in egress policies.
        :param pulumi.Input['TeamsAccountSettingsInspectionArgs'] inspection: Setting to define inspection settings.
        :param pulumi.Input['TeamsAccountSettingsProtocolDetectionArgs'] protocol_detection: Protocol Detection settings.
        :param pulumi.Input['TeamsAccountSettingsSandboxArgs'] sandbox: Sandbox settings.
        :param pulumi.Input['TeamsAccountSettingsTlsDecryptArgs'] tls_decrypt: TLS interception settings.
        """
        if activity_log is not None:
            pulumi.set(__self__, "activity_log", activity_log)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if block_page is not None:
            pulumi.set(__self__, "block_page", block_page)
        if body_scanning is not None:
            pulumi.set(__self__, "body_scanning", body_scanning)
        if browser_isolation is not None:
            pulumi.set(__self__, "browser_isolation", browser_isolation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if custom_certificate is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""custom_certificate is deprecated: This attribute is deprecated.""")
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if extended_email_matching is not None:
            pulumi.set(__self__, "extended_email_matching", extended_email_matching)
        if fips is not None:
            pulumi.set(__self__, "fips", fips)
        if host_selector is not None:
            pulumi.set(__self__, "host_selector", host_selector)
        if inspection is not None:
            pulumi.set(__self__, "inspection", inspection)
        if protocol_detection is not None:
            pulumi.set(__self__, "protocol_detection", protocol_detection)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if tls_decrypt is not None:
            pulumi.set(__self__, "tls_decrypt", tls_decrypt)

    @_builtins.property
    @pulumi.getter(name="activityLog")
    def activity_log(self) -> Optional[pulumi.Input['TeamsAccountSettingsActivityLogArgs']]:
        """
        Activity log settings.
        """
        return pulumi.get(self, "activity_log")

    @activity_log.setter
    def activity_log(self, value: Optional[pulumi.Input['TeamsAccountSettingsActivityLogArgs']]):
        pulumi.set(self, "activity_log", value)

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional[pulumi.Input['TeamsAccountSettingsAntivirusArgs']]:
        """
        Anti-virus settings.
        """
        return pulumi.get(self, "antivirus")

    @antivirus.setter
    def antivirus(self, value: Optional[pulumi.Input['TeamsAccountSettingsAntivirusArgs']]):
        pulumi.set(self, "antivirus", value)

    @_builtins.property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> Optional[pulumi.Input['TeamsAccountSettingsBlockPageArgs']]:
        """
        Block page layout settings.
        """
        return pulumi.get(self, "block_page")

    @block_page.setter
    def block_page(self, value: Optional[pulumi.Input['TeamsAccountSettingsBlockPageArgs']]):
        pulumi.set(self, "block_page", value)

    @_builtins.property
    @pulumi.getter(name="bodyScanning")
    def body_scanning(self) -> Optional[pulumi.Input['TeamsAccountSettingsBodyScanningArgs']]:
        """
        DLP body scanning settings.
        """
        return pulumi.get(self, "body_scanning")

    @body_scanning.setter
    def body_scanning(self, value: Optional[pulumi.Input['TeamsAccountSettingsBodyScanningArgs']]):
        pulumi.set(self, "body_scanning", value)

    @_builtins.property
    @pulumi.getter(name="browserIsolation")
    def browser_isolation(self) -> Optional[pulumi.Input['TeamsAccountSettingsBrowserIsolationArgs']]:
        """
        Browser isolation settings.
        """
        return pulumi.get(self, "browser_isolation")

    @browser_isolation.setter
    def browser_isolation(self, value: Optional[pulumi.Input['TeamsAccountSettingsBrowserIsolationArgs']]):
        pulumi.set(self, "browser_isolation", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['TeamsAccountSettingsCertificateArgs']]:
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['TeamsAccountSettingsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="customCertificate")
    @_utilities.deprecated("""This attribute is deprecated.""")
    def custom_certificate(self) -> Optional[pulumi.Input['TeamsAccountSettingsCustomCertificateArgs']]:
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`).
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input['TeamsAccountSettingsCustomCertificateArgs']]):
        pulumi.set(self, "custom_certificate", value)

    @_builtins.property
    @pulumi.getter(name="extendedEmailMatching")
    def extended_email_matching(self) -> Optional[pulumi.Input['TeamsAccountSettingsExtendedEmailMatchingArgs']]:
        """
        Extended e-mail matching settings.
        """
        return pulumi.get(self, "extended_email_matching")

    @extended_email_matching.setter
    def extended_email_matching(self, value: Optional[pulumi.Input['TeamsAccountSettingsExtendedEmailMatchingArgs']]):
        pulumi.set(self, "extended_email_matching", value)

    @_builtins.property
    @pulumi.getter
    def fips(self) -> Optional[pulumi.Input['TeamsAccountSettingsFipsArgs']]:
        """
        FIPS settings.
        """
        return pulumi.get(self, "fips")

    @fips.setter
    def fips(self, value: Optional[pulumi.Input['TeamsAccountSettingsFipsArgs']]):
        pulumi.set(self, "fips", value)

    @_builtins.property
    @pulumi.getter(name="hostSelector")
    def host_selector(self) -> Optional[pulumi.Input['TeamsAccountSettingsHostSelectorArgs']]:
        """
        Setting to enable host selector in egress policies.
        """
        return pulumi.get(self, "host_selector")

    @host_selector.setter
    def host_selector(self, value: Optional[pulumi.Input['TeamsAccountSettingsHostSelectorArgs']]):
        pulumi.set(self, "host_selector", value)

    @_builtins.property
    @pulumi.getter
    def inspection(self) -> Optional[pulumi.Input['TeamsAccountSettingsInspectionArgs']]:
        """
        Setting to define inspection settings.
        """
        return pulumi.get(self, "inspection")

    @inspection.setter
    def inspection(self, value: Optional[pulumi.Input['TeamsAccountSettingsInspectionArgs']]):
        pulumi.set(self, "inspection", value)

    @_builtins.property
    @pulumi.getter(name="protocolDetection")
    def protocol_detection(self) -> Optional[pulumi.Input['TeamsAccountSettingsProtocolDetectionArgs']]:
        """
        Protocol Detection settings.
        """
        return pulumi.get(self, "protocol_detection")

    @protocol_detection.setter
    def protocol_detection(self, value: Optional[pulumi.Input['TeamsAccountSettingsProtocolDetectionArgs']]):
        pulumi.set(self, "protocol_detection", value)

    @_builtins.property
    @pulumi.getter
    def sandbox(self) -> Optional[pulumi.Input['TeamsAccountSettingsSandboxArgs']]:
        """
        Sandbox settings.
        """
        return pulumi.get(self, "sandbox")

    @sandbox.setter
    def sandbox(self, value: Optional[pulumi.Input['TeamsAccountSettingsSandboxArgs']]):
        pulumi.set(self, "sandbox", value)

    @_builtins.property
    @pulumi.getter(name="tlsDecrypt")
    def tls_decrypt(self) -> Optional[pulumi.Input['TeamsAccountSettingsTlsDecryptArgs']]:
        """
        TLS interception settings.
        """
        return pulumi.get(self, "tls_decrypt")

    @tls_decrypt.setter
    def tls_decrypt(self, value: Optional[pulumi.Input['TeamsAccountSettingsTlsDecryptArgs']]):
        pulumi.set(self, "tls_decrypt", value)


if not MYPY:
    class TeamsAccountSettingsActivityLogArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable activity logging.
        """
elif False:
    TeamsAccountSettingsActivityLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsActivityLogArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable activity logging.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable activity logging.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsAccountSettingsAntivirusArgsDict(TypedDict):
        enabled_download_phase: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable anti-virus scanning on downloads.
        """
        enabled_upload_phase: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable anti-virus scanning on uploads.
        """
        fail_closed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block requests for files that cannot be scanned.
        """
        notification_settings: NotRequired[pulumi.Input['TeamsAccountSettingsAntivirusNotificationSettingsArgsDict']]
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
elif False:
    TeamsAccountSettingsAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsAntivirusArgs:
    def __init__(__self__, *,
                 enabled_download_phase: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled_upload_phase: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_closed: Optional[pulumi.Input[_builtins.bool]] = None,
                 notification_settings: Optional[pulumi.Input['TeamsAccountSettingsAntivirusNotificationSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled_download_phase: Enable anti-virus scanning on downloads.
        :param pulumi.Input[_builtins.bool] enabled_upload_phase: Enable anti-virus scanning on uploads.
        :param pulumi.Input[_builtins.bool] fail_closed: Block requests for files that cannot be scanned.
        :param pulumi.Input['TeamsAccountSettingsAntivirusNotificationSettingsArgs'] notification_settings: Configure a message to display on the user's device when an antivirus search is performed.
        """
        if enabled_download_phase is not None:
            pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        if enabled_upload_phase is not None:
            pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        if fail_closed is not None:
            pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @_builtins.property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable anti-virus scanning on downloads.
        """
        return pulumi.get(self, "enabled_download_phase")

    @enabled_download_phase.setter
    def enabled_download_phase(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_download_phase", value)

    @_builtins.property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable anti-virus scanning on uploads.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @enabled_upload_phase.setter
    def enabled_upload_phase(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_upload_phase", value)

    @_builtins.property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @fail_closed.setter
    def fail_closed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_closed", value)

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['TeamsAccountSettingsAntivirusNotificationSettingsArgs']]:
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['TeamsAccountSettingsAntivirusNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)


if not MYPY:
    class TeamsAccountSettingsAntivirusNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set notification on.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
        msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customize the message shown in the notification.
        """
        support_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
elif False:
    TeamsAccountSettingsAntivirusNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsAntivirusNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 msg: Optional[pulumi.Input[_builtins.str]] = None,
                 support_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Set notification on.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        :param pulumi.Input[_builtins.str] msg: Customize the message shown in the notification.
        :param pulumi.Input[_builtins.str] support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set notification on.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "msg", value)

    @_builtins.property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class TeamsAccountSettingsBlockPageArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page background color in #rrggbb format.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        footer_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page footer text.
        """
        header_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page header text.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
        """
        logo_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: full URL to the logo file.
        """
        mailto_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: admin email for users to contact.
        """
        mailto_subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: subject line for emails created from block page.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
        Available values: "", "customized_block_page", "redirect_uri".
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page title.
        """
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        source_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account tag of account that shared this setting.
        """
        suppress_footer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If mode is customized_block_page: suppress detailed info at the bottom of the block page.
        """
        target_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is redirect_uri: URI to which the user should be redirected.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Version number of the setting.
        """
elif False:
    TeamsAccountSettingsBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsBlockPageArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 footer_text: Optional[pulumi.Input[_builtins.str]] = None,
                 header_text: Optional[pulumi.Input[_builtins.str]] = None,
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 logo_path: Optional[pulumi.Input[_builtins.str]] = None,
                 mailto_address: Optional[pulumi.Input[_builtins.str]] = None,
                 mailto_subject: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_account: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_footer: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] background_color: If mode is customized_block_page: block page background color in #rrggbb format.
        :param pulumi.Input[_builtins.bool] enabled: Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        :param pulumi.Input[_builtins.str] footer_text: If mode is customized_block_page: block page footer text.
        :param pulumi.Input[_builtins.str] header_text: If mode is customized_block_page: block page header text.
        :param pulumi.Input[_builtins.bool] include_context: If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
        :param pulumi.Input[_builtins.str] logo_path: If mode is customized_block_page: full URL to the logo file.
        :param pulumi.Input[_builtins.str] mailto_address: If mode is customized_block_page: admin email for users to contact.
        :param pulumi.Input[_builtins.str] mailto_subject: If mode is customized_block_page: subject line for emails created from block page.
        :param pulumi.Input[_builtins.str] mode: Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
               Available values: "", "customized_block_page", "redirect_uri".
        :param pulumi.Input[_builtins.str] name: If mode is customized_block_page: block page title.
        :param pulumi.Input[_builtins.bool] read_only: This setting was shared via the Orgs API and cannot be edited by the current account.
        :param pulumi.Input[_builtins.str] source_account: Account tag of account that shared this setting.
        :param pulumi.Input[_builtins.bool] suppress_footer: If mode is customized_block_page: suppress detailed info at the bottom of the block page.
        :param pulumi.Input[_builtins.str] target_uri: If mode is redirect_uri: URI to which the user should be redirected.
        :param pulumi.Input[_builtins.int] version: Version number of the setting.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_account is not None:
            pulumi.set(__self__, "source_account", source_account)
        if suppress_footer is not None:
            pulumi.set(__self__, "suppress_footer", suppress_footer)
        if target_uri is not None:
            pulumi.set(__self__, "target_uri", target_uri)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page background color in #rrggbb format.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "background_color", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "footer_text", value)

    @_builtins.property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page header text.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_text", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: full URL to the logo file.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo_path", value)

    @_builtins.property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @mailto_address.setter
    def mailto_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mailto_address", value)

    @_builtins.property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @mailto_subject.setter
    def mailto_subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mailto_subject", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
        Available values: "", "customized_block_page", "redirect_uri".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page title.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="sourceAccount")
    def source_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account tag of account that shared this setting.
        """
        return pulumi.get(self, "source_account")

    @source_account.setter
    def source_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_account", value)

    @_builtins.property
    @pulumi.getter(name="suppressFooter")
    def suppress_footer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If mode is customized_block_page: suppress detailed info at the bottom of the block page.
        """
        return pulumi.get(self, "suppress_footer")

    @suppress_footer.setter
    def suppress_footer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suppress_footer", value)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is redirect_uri: URI to which the user should be redirected.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_uri", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Version number of the setting.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TeamsAccountSettingsBodyScanningArgsDict(TypedDict):
        inspection_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set the inspection mode to either `deep` or `shallow`.
        Available values: "deep", "shallow".
        """
elif False:
    TeamsAccountSettingsBodyScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsBodyScanningArgs:
    def __init__(__self__, *,
                 inspection_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inspection_mode: Set the inspection mode to either `deep` or `shallow`.
               Available values: "deep", "shallow".
        """
        if inspection_mode is not None:
            pulumi.set(__self__, "inspection_mode", inspection_mode)

    @_builtins.property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set the inspection mode to either `deep` or `shallow`.
        Available values: "deep", "shallow".
        """
        return pulumi.get(self, "inspection_mode")

    @inspection_mode.setter
    def inspection_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inspection_mode", value)


if not MYPY:
    class TeamsAccountSettingsBrowserIsolationArgsDict(TypedDict):
        non_identity_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        url_browser_isolation_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Clientless Browser Isolation.
        """
elif False:
    TeamsAccountSettingsBrowserIsolationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsBrowserIsolationArgs:
    def __init__(__self__, *,
                 non_identity_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 url_browser_isolation_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] non_identity_enabled: Enable non-identity onramp support for Browser Isolation.
        :param pulumi.Input[_builtins.bool] url_browser_isolation_enabled: Enable Clientless Browser Isolation.
        """
        if non_identity_enabled is not None:
            pulumi.set(__self__, "non_identity_enabled", non_identity_enabled)
        if url_browser_isolation_enabled is not None:
            pulumi.set(__self__, "url_browser_isolation_enabled", url_browser_isolation_enabled)

    @_builtins.property
    @pulumi.getter(name="nonIdentityEnabled")
    def non_identity_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        return pulumi.get(self, "non_identity_enabled")

    @non_identity_enabled.setter
    def non_identity_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "non_identity_enabled", value)

    @_builtins.property
    @pulumi.getter(name="urlBrowserIsolationEnabled")
    def url_browser_isolation_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Clientless Browser Isolation.
        """
        return pulumi.get(self, "url_browser_isolation_enabled")

    @url_browser_isolation_enabled.setter
    def url_browser_isolation_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "url_browser_isolation_enabled", value)


if not MYPY:
    class TeamsAccountSettingsCertificateArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
elif False:
    TeamsAccountSettingsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsCertificateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TeamsAccountSettingsCustomCertificateArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable use of custom certificate authority for signing Gateway. traffic.
        """
        binding_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate status (internal).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TeamsAccountSettingsCustomCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsCustomCertificateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 binding_status: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable use of custom certificate authority for signing Gateway. traffic.
        :param pulumi.Input[_builtins.str] binding_status: Certificate status (internal).
        :param pulumi.Input[_builtins.str] id: UUID of certificate (ID from MTLS certificate store).
        """
        pulumi.set(__self__, "enabled", enabled)
        if binding_status is not None:
            pulumi.set(__self__, "binding_status", binding_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable use of custom certificate authority for signing Gateway. traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="bindingStatus")
    def binding_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate status (internal).
        """
        return pulumi.get(self, "binding_status")

    @binding_status.setter
    def binding_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "binding_status", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class TeamsAccountSettingsExtendedEmailMatchingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        source_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account tag of account that shared this setting.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Version number of the setting.
        """
elif False:
    TeamsAccountSettingsExtendedEmailMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsExtendedEmailMatchingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_account: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        :param pulumi.Input[_builtins.bool] read_only: This setting was shared via the Orgs API and cannot be edited by the current account.
        :param pulumi.Input[_builtins.str] source_account: Account tag of account that shared this setting.
        :param pulumi.Input[_builtins.int] version: Version number of the setting.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_account is not None:
            pulumi.set(__self__, "source_account", source_account)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="sourceAccount")
    def source_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account tag of account that shared this setting.
        """
        return pulumi.get(self, "source_account")

    @source_account.setter
    def source_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_account", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Version number of the setting.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TeamsAccountSettingsFipsArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
elif False:
    TeamsAccountSettingsFipsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsFipsArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] tls: Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class TeamsAccountSettingsHostSelectorArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable filtering via hosts for egress policies.
        """
elif False:
    TeamsAccountSettingsHostSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsHostSelectorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable filtering via hosts for egress policies.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable filtering via hosts for egress policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsAccountSettingsInspectionArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the mode of inspection the proxy will use.
        - static: Gateway will use static inspection to inspect HTTP on TCP(80). If TLS decryption is on, Gateway will inspect HTTPS traffic on TCP(443) & UDP(443).
        - dynamic: Gateway will use protocol detection to dynamically inspect HTTP and HTTPS traffic on any port. TLS decryption must be on to inspect HTTPS traffic.
        Available values: "static", "dynamic".
        """
elif False:
    TeamsAccountSettingsInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsInspectionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Defines the mode of inspection the proxy will use.
               - static: Gateway will use static inspection to inspect HTTP on TCP(80). If TLS decryption is on, Gateway will inspect HTTPS traffic on TCP(443) & UDP(443).
               - dynamic: Gateway will use protocol detection to dynamically inspect HTTP and HTTPS traffic on any port. TLS decryption must be on to inspect HTTPS traffic.
               Available values: "static", "dynamic".
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the mode of inspection the proxy will use.
        - static: Gateway will use static inspection to inspect HTTP on TCP(80). If TLS decryption is on, Gateway will inspect HTTPS traffic on TCP(443) & UDP(443).
        - dynamic: Gateway will use protocol detection to dynamically inspect HTTP and HTTPS traffic on any port. TLS decryption must be on to inspect HTTPS traffic.
        Available values: "static", "dynamic".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class TeamsAccountSettingsProtocolDetectionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
elif False:
    TeamsAccountSettingsProtocolDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsProtocolDetectionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable detecting protocol on initial bytes of client traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsAccountSettingsSandboxArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable sandbox.
        """
        fallback_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when the file cannot be scanned.
        Available values: "allow", "block".
        """
elif False:
    TeamsAccountSettingsSandboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsSandboxArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 fallback_action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable sandbox.
        :param pulumi.Input[_builtins.str] fallback_action: Action to take when the file cannot be scanned.
               Available values: "allow", "block".
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable sandbox.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when the file cannot be scanned.
        Available values: "allow", "block".
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_action", value)


if not MYPY:
    class TeamsAccountSettingsTlsDecryptArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable inspecting encrypted HTTP traffic.
        """
elif False:
    TeamsAccountSettingsTlsDecryptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsAccountSettingsTlsDecryptArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable inspecting encrypted HTTP traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable inspecting encrypted HTTP traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsListItemArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the list item, if present.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the item in a list.
        """
elif False:
    TeamsListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsListItemArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the list item, if present.
        :param pulumi.Input[_builtins.str] value: The value of the item in a list.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the list item, if present.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the item in a list.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TeamsLocationEndpointsArgsDict(TypedDict):
        doh: pulumi.Input['TeamsLocationEndpointsDohArgsDict']
        dot: pulumi.Input['TeamsLocationEndpointsDotArgsDict']
        ipv4: pulumi.Input['TeamsLocationEndpointsIpv4ArgsDict']
        ipv6: pulumi.Input['TeamsLocationEndpointsIpv6ArgsDict']
elif False:
    TeamsLocationEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsArgs:
    def __init__(__self__, *,
                 doh: pulumi.Input['TeamsLocationEndpointsDohArgs'],
                 dot: pulumi.Input['TeamsLocationEndpointsDotArgs'],
                 ipv4: pulumi.Input['TeamsLocationEndpointsIpv4Args'],
                 ipv6: pulumi.Input['TeamsLocationEndpointsIpv6Args']):
        pulumi.set(__self__, "doh", doh)
        pulumi.set(__self__, "dot", dot)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def doh(self) -> pulumi.Input['TeamsLocationEndpointsDohArgs']:
        return pulumi.get(self, "doh")

    @doh.setter
    def doh(self, value: pulumi.Input['TeamsLocationEndpointsDohArgs']):
        pulumi.set(self, "doh", value)

    @_builtins.property
    @pulumi.getter
    def dot(self) -> pulumi.Input['TeamsLocationEndpointsDotArgs']:
        return pulumi.get(self, "dot")

    @dot.setter
    def dot(self, value: pulumi.Input['TeamsLocationEndpointsDotArgs']):
        pulumi.set(self, "dot", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input['TeamsLocationEndpointsIpv4Args']:
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input['TeamsLocationEndpointsIpv4Args']):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> pulumi.Input['TeamsLocationEndpointsIpv6Args']:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: pulumi.Input['TeamsLocationEndpointsIpv6Args']):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class TeamsLocationEndpointsDohArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDohNetworkArgsDict']]]]
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        require_token: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
elif False:
    TeamsLocationEndpointsDohArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsDohArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDohNetworkArgs']]]] = None,
                 require_token: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDohNetworkArgs']]] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        :param pulumi.Input[_builtins.bool] require_token: True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDohNetworkArgs']]]]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDohNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @_builtins.property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        return pulumi.get(self, "require_token")

    @require_token.setter
    def require_token(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_token", value)


if not MYPY:
    class TeamsLocationEndpointsDohNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IP address or IP CIDR.
        """
elif False:
    TeamsLocationEndpointsDohNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsDohNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class TeamsLocationEndpointsDotArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDotNetworkArgsDict']]]]
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
elif False:
    TeamsLocationEndpointsDotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsDotArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDotNetworkArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDotNetworkArgs']]] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDotNetworkArgs']]]]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsDotNetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class TeamsLocationEndpointsDotNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IP address or IP CIDR.
        """
elif False:
    TeamsLocationEndpointsDotNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsDotNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class TeamsLocationEndpointsIpv4ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
elif False:
    TeamsLocationEndpointsIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsIpv4Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsLocationEndpointsIpv6ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsIpv6NetworkArgsDict']]]]
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
elif False:
    TeamsLocationEndpointsIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsIpv6Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsIpv6NetworkArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsIpv6NetworkArgs']]] networks: A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsIpv6NetworkArgs']]]]:
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsLocationEndpointsIpv6NetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class TeamsLocationEndpointsIpv6NetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IPv6 address or IPv6 CIDR.
        """
elif False:
    TeamsLocationEndpointsIpv6NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationEndpointsIpv6NetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IPv6 address or IPv6 CIDR.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv6 address or IPv6 CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class TeamsLocationNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
elif False:
    TeamsLocationNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsLocationNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class TeamsRuleExpirationArgsDict(TypedDict):
        expires_at: pulumi.Input[_builtins.str]
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        expired: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the policy has expired.
        """
elif False:
    TeamsRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleExpirationArgs:
    def __init__(__self__, *,
                 expires_at: pulumi.Input[_builtins.str],
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 expired: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] expires_at: The time stamp at which the policy will expire and cease to be
               applied.
        :param pulumi.Input[_builtins.int] duration: The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        :param pulumi.Input[_builtins.bool] expired: Whether the policy has expired.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> pulumi.Input[_builtins.str]:
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the policy has expired.
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired", value)


if not MYPY:
    class TeamsRuleRuleSettingsArgsDict(TypedDict):
        add_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        allow_child_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        audit_ssh: NotRequired[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgsDict']]
        """
        Settings for the Audit SSH action.
        """
        biso_admin_controls: NotRequired[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgsDict']]
        """
        Configure how browser isolation behaves.
        """
        block_page: NotRequired[pulumi.Input['TeamsRuleRuleSettingsBlockPageArgsDict']]
        """
        Custom block page settings. If missing/null, blocking will use the the account settings.
        """
        block_page_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the custom block page.
        """
        block_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        bypass_parent_rule: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        check_session: NotRequired[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgsDict']]
        """
        Configure how session check behaves.
        """
        dns_resolvers: NotRequired[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgsDict']]
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        egress: NotRequired[pulumi.Input['TeamsRuleRuleSettingsEgressArgsDict']]
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        ignore_cname_category_matches: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        insecure_disable_dnssec_validation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        ip_categories: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        ip_indicator_feeds: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        l4override: NotRequired[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgsDict']]
        """
        Send matching traffic to the supplied destination IP address. and port.
        """
        notification_settings: NotRequired[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgsDict']]
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        override_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Override matching DNS queries with a hostname.
        """
        override_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        payload_log: NotRequired[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgsDict']]
        """
        Configure DLP payload logging.
        """
        quarantine: NotRequired[pulumi.Input['TeamsRuleRuleSettingsQuarantineArgsDict']]
        """
        Settings that apply to quarantine rules.
        """
        redirect: NotRequired[pulumi.Input['TeamsRuleRuleSettingsRedirectArgsDict']]
        """
        Settings that apply to redirect rules.
        """
        resolve_dns_internally: NotRequired[pulumi.Input['TeamsRuleRuleSettingsResolveDnsInternallyArgsDict']]
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        resolve_dns_through_cloudflare: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        untrusted_cert: NotRequired[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgsDict']]
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
elif False:
    TeamsRuleRuleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 allow_child_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_ssh: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']] = None,
                 biso_admin_controls: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']] = None,
                 block_page: Optional[pulumi.Input['TeamsRuleRuleSettingsBlockPageArgs']] = None,
                 block_page_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 bypass_parent_rule: Optional[pulumi.Input[_builtins.bool]] = None,
                 check_session: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']] = None,
                 dns_resolvers: Optional[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs']] = None,
                 egress: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']] = None,
                 ignore_cname_category_matches: Optional[pulumi.Input[_builtins.bool]] = None,
                 insecure_disable_dnssec_validation: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_categories: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_indicator_feeds: Optional[pulumi.Input[_builtins.bool]] = None,
                 l4override: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']] = None,
                 notification_settings: Optional[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs']] = None,
                 override_host: Optional[pulumi.Input[_builtins.str]] = None,
                 override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 payload_log: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']] = None,
                 quarantine: Optional[pulumi.Input['TeamsRuleRuleSettingsQuarantineArgs']] = None,
                 redirect: Optional[pulumi.Input['TeamsRuleRuleSettingsRedirectArgs']] = None,
                 resolve_dns_internally: Optional[pulumi.Input['TeamsRuleRuleSettingsResolveDnsInternallyArgs']] = None,
                 resolve_dns_through_cloudflare: Optional[pulumi.Input[_builtins.bool]] = None,
                 untrusted_cert: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] add_headers: Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        :param pulumi.Input[_builtins.bool] allow_child_bypass: Set by parent MSP accounts to enable their children to bypass this rule.
        :param pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs'] audit_ssh: Settings for the Audit SSH action.
        :param pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs'] biso_admin_controls: Configure how browser isolation behaves.
        :param pulumi.Input['TeamsRuleRuleSettingsBlockPageArgs'] block_page: Custom block page settings. If missing/null, blocking will use the the account settings.
        :param pulumi.Input[_builtins.bool] block_page_enabled: Enable the custom block page.
        :param pulumi.Input[_builtins.str] block_reason: The text describing why this block occurred, displayed on the custom block page (if enabled).
        :param pulumi.Input[_builtins.bool] bypass_parent_rule: Set by children MSP accounts to bypass their parent's rules.
        :param pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs'] check_session: Configure how session check behaves.
        :param pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs'] dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input['TeamsRuleRuleSettingsEgressArgs'] egress: Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        :param pulumi.Input[_builtins.bool] ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        :param pulumi.Input[_builtins.bool] insecure_disable_dnssec_validation: INSECURE - disable DNSSEC validation (for Allow actions).
        :param pulumi.Input[_builtins.bool] ip_categories: Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        :param pulumi.Input[_builtins.bool] ip_indicator_feeds: Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        :param pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs'] l4override: Send matching traffic to the supplied destination IP address. and port.
        :param pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs'] notification_settings: Configure a notification to display on the user's device when this rule is matched.
        :param pulumi.Input[_builtins.str] override_host: Override matching DNS queries with a hostname.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] override_ips: Override matching DNS queries with an IP or set of IPs.
        :param pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs'] payload_log: Configure DLP payload logging.
        :param pulumi.Input['TeamsRuleRuleSettingsQuarantineArgs'] quarantine: Settings that apply to quarantine rules.
        :param pulumi.Input['TeamsRuleRuleSettingsRedirectArgs'] redirect: Settings that apply to redirect rules.
        :param pulumi.Input['TeamsRuleRuleSettingsResolveDnsInternallyArgs'] resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input[_builtins.bool] resolve_dns_through_cloudflare: Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs'] untrusted_cert: Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page is not None:
            pulumi.set(__self__, "block_page", block_page)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_reason is not None:
            pulumi.set(__self__, "block_reason", block_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if ip_indicator_feeds is not None:
            pulumi.set(__self__, "ip_indicator_feeds", ip_indicator_feeds)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if resolve_dns_internally is not None:
            pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @_builtins.property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "add_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        return pulumi.get(self, "allow_child_bypass")

    @allow_child_bypass.setter
    def allow_child_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_child_bypass", value)

    @_builtins.property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']]:
        """
        Settings for the Audit SSH action.
        """
        return pulumi.get(self, "audit_ssh")

    @audit_ssh.setter
    def audit_ssh(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsAuditSshArgs']]):
        pulumi.set(self, "audit_ssh", value)

    @_builtins.property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']]:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @biso_admin_controls.setter
    def biso_admin_controls(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsBisoAdminControlsArgs']]):
        pulumi.set(self, "biso_admin_controls", value)

    @_builtins.property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsBlockPageArgs']]:
        """
        Custom block page settings. If missing/null, blocking will use the the account settings.
        """
        return pulumi.get(self, "block_page")

    @block_page.setter
    def block_page(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsBlockPageArgs']]):
        pulumi.set(self, "block_page", value)

    @_builtins.property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the custom block page.
        """
        return pulumi.get(self, "block_page_enabled")

    @block_page_enabled.setter
    def block_page_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_page_enabled", value)

    @_builtins.property
    @pulumi.getter(name="blockReason")
    def block_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        return pulumi.get(self, "block_reason")

    @block_reason.setter
    def block_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "block_reason", value)

    @_builtins.property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @bypass_parent_rule.setter
    def bypass_parent_rule(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bypass_parent_rule", value)

    @_builtins.property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']]:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @check_session.setter
    def check_session(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsCheckSessionArgs']]):
        pulumi.set(self, "check_session", value)

    @_builtins.property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs']]:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "dns_resolvers")

    @dns_resolvers.setter
    def dns_resolvers(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsDnsResolversArgs']]):
        pulumi.set(self, "dns_resolvers", value)

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']]:
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsEgressArgs']]):
        pulumi.set(self, "egress", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @ignore_cname_category_matches.setter
    def ignore_cname_category_matches(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_cname_category_matches", value)

    @_builtins.property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @insecure_disable_dnssec_validation.setter
    def insecure_disable_dnssec_validation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_disable_dnssec_validation", value)

    @_builtins.property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        return pulumi.get(self, "ip_categories")

    @ip_categories.setter
    def ip_categories(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ip_categories", value)

    @_builtins.property
    @pulumi.getter(name="ipIndicatorFeeds")
    def ip_indicator_feeds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        return pulumi.get(self, "ip_indicator_feeds")

    @ip_indicator_feeds.setter
    def ip_indicator_feeds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ip_indicator_feeds", value)

    @_builtins.property
    @pulumi.getter
    def l4override(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']]:
        """
        Send matching traffic to the supplied destination IP address. and port.
        """
        return pulumi.get(self, "l4override")

    @l4override.setter
    def l4override(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsL4overrideArgs']]):
        pulumi.set(self, "l4override", value)

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs']]:
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @_builtins.property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Override matching DNS queries with a hostname.
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_host", value)

    @_builtins.property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        return pulumi.get(self, "override_ips")

    @override_ips.setter
    def override_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "override_ips", value)

    @_builtins.property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']]:
        """
        Configure DLP payload logging.
        """
        return pulumi.get(self, "payload_log")

    @payload_log.setter
    def payload_log(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsPayloadLogArgs']]):
        pulumi.set(self, "payload_log", value)

    @_builtins.property
    @pulumi.getter
    def quarantine(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsQuarantineArgs']]:
        """
        Settings that apply to quarantine rules.
        """
        return pulumi.get(self, "quarantine")

    @quarantine.setter
    def quarantine(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsQuarantineArgs']]):
        pulumi.set(self, "quarantine", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsRedirectArgs']]:
        """
        Settings that apply to redirect rules.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsRedirectArgs']]):
        pulumi.set(self, "redirect", value)

    @_builtins.property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsResolveDnsInternallyArgs']]:
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @resolve_dns_internally.setter
    def resolve_dns_internally(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsResolveDnsInternallyArgs']]):
        pulumi.set(self, "resolve_dns_internally", value)

    @_builtins.property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @resolve_dns_through_cloudflare.setter
    def resolve_dns_through_cloudflare(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "resolve_dns_through_cloudflare", value)

    @_builtins.property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']]:
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        return pulumi.get(self, "untrusted_cert")

    @untrusted_cert.setter
    def untrusted_cert(self, value: Optional[pulumi.Input['TeamsRuleRuleSettingsUntrustedCertArgs']]):
        pulumi.set(self, "untrusted_cert", value)


if not MYPY:
    class TeamsRuleRuleSettingsAuditSshArgsDict(TypedDict):
        command_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to turn on SSH command logging.
        """
elif False:
    TeamsRuleRuleSettingsAuditSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsAuditSshArgs:
    def __init__(__self__, *,
                 command_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] command_logging: Enable to turn on SSH command logging.
        """
        if command_logging is not None:
            pulumi.set(__self__, "command_logging", command_logging)

    @_builtins.property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to turn on SSH command logging.
        """
        return pulumi.get(self, "command_logging")

    @command_logging.setter
    def command_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "command_logging", value)


if not MYPY:
    class TeamsRuleRuleSettingsBisoAdminControlsArgsDict(TypedDict):
        copy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether copy is enabled or not. When set with "remote*only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        dcp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        dd: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        dk: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        download: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether downloading enabled or not. When set with "remote*only", downloads are only available for viewing. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        dp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        du: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        keyboard: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        paste: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether pasting is enabled or not. When set with "remote*only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        printing: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        upload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates which version of the browser isolation controls should apply.
        Available values: "v1", "v2".
        """
elif False:
    TeamsRuleRuleSettingsBisoAdminControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsBisoAdminControlsArgs:
    def __init__(__self__, *,
                 copy: Optional[pulumi.Input[_builtins.str]] = None,
                 dcp: Optional[pulumi.Input[_builtins.bool]] = None,
                 dd: Optional[pulumi.Input[_builtins.bool]] = None,
                 dk: Optional[pulumi.Input[_builtins.bool]] = None,
                 download: Optional[pulumi.Input[_builtins.str]] = None,
                 dp: Optional[pulumi.Input[_builtins.bool]] = None,
                 du: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyboard: Optional[pulumi.Input[_builtins.str]] = None,
                 paste: Optional[pulumi.Input[_builtins.str]] = None,
                 printing: Optional[pulumi.Input[_builtins.str]] = None,
                 upload: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] copy: Configure whether copy is enabled or not. When set with "remote*only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled", "remote*only".
        :param pulumi.Input[_builtins.bool] dcp: Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.bool] dd: Set to false to enable downloading. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.bool] dk: Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.str] download: Configure whether downloading enabled or not. When set with "remote*only", downloads are only available for viewing. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled", "remote*only".
        :param pulumi.Input[_builtins.bool] dp: Set to false to enable printing. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.bool] du: Set to false to enable uploading. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.str] keyboard: Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled".
        :param pulumi.Input[_builtins.str] paste: Configure whether pasting is enabled or not. When set with "remote*only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled", "remote*only".
        :param pulumi.Input[_builtins.str] printing: Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled".
        :param pulumi.Input[_builtins.str] upload: Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled".
        :param pulumi.Input[_builtins.str] version: Indicates which version of the browser isolation controls should apply.
               Available values: "v1", "v2".
        """
        if copy is not None:
            pulumi.set(__self__, "copy", copy)
        if dcp is not None:
            pulumi.set(__self__, "dcp", dcp)
        if dd is not None:
            pulumi.set(__self__, "dd", dd)
        if dk is not None:
            pulumi.set(__self__, "dk", dk)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if dp is not None:
            pulumi.set(__self__, "dp", dp)
        if du is not None:
            pulumi.set(__self__, "du", du)
        if keyboard is not None:
            pulumi.set(__self__, "keyboard", keyboard)
        if paste is not None:
            pulumi.set(__self__, "paste", paste)
        if printing is not None:
            pulumi.set(__self__, "printing", printing)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def copy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether copy is enabled or not. When set with "remote*only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        return pulumi.get(self, "copy")

    @copy.setter
    def copy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "copy", value)

    @_builtins.property
    @pulumi.getter
    def dcp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dcp")

    @dcp.setter
    def dcp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dcp", value)

    @_builtins.property
    @pulumi.getter
    def dd(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dd")

    @dd.setter
    def dd(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dd", value)

    @_builtins.property
    @pulumi.getter
    def dk(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dk")

    @dk.setter
    def dk(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dk", value)

    @_builtins.property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether downloading enabled or not. When set with "remote*only", downloads are only available for viewing. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "download", value)

    @_builtins.property
    @pulumi.getter
    def dp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dp")

    @dp.setter
    def dp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dp", value)

    @_builtins.property
    @pulumi.getter
    def du(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "du")

    @du.setter
    def du(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "du", value)

    @_builtins.property
    @pulumi.getter
    def keyboard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        return pulumi.get(self, "keyboard")

    @keyboard.setter
    def keyboard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyboard", value)

    @_builtins.property
    @pulumi.getter
    def paste(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether pasting is enabled or not. When set with "remote*only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        return pulumi.get(self, "paste")

    @paste.setter
    def paste(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "paste", value)

    @_builtins.property
    @pulumi.getter
    def printing(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        return pulumi.get(self, "printing")

    @printing.setter
    def printing(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "printing", value)

    @_builtins.property
    @pulumi.getter
    def upload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        return pulumi.get(self, "upload")

    @upload.setter
    def upload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates which version of the browser isolation controls should apply.
        Available values: "v1", "v2".
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TeamsRuleRuleSettingsBlockPageArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        URI to which the user will be redirected.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
elif False:
    TeamsRuleRuleSettingsBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsBlockPageArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str],
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] target_uri: URI to which the user will be redirected.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        """
        pulumi.set(__self__, "target_uri", target_uri)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI to which the user will be redirected.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)


if not MYPY:
    class TeamsRuleRuleSettingsCheckSessionArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.str]]
        enforce: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to enable session enforcement.
        """
elif False:
    TeamsRuleRuleSettingsCheckSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsCheckSessionArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enforce: Set to true to enable session enforcement.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to enable session enforcement.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce", value)


if not MYPY:
    class TeamsRuleRuleSettingsDnsResolversArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict']]]]
elif False:
    TeamsRuleRuleSettingsDnsResolversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsDnsResolversArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @_builtins.property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @_builtins.property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TeamsRuleRuleSettingsDnsResolversIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IPv4 address of upstream resolver.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        route_through_private_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    TeamsRuleRuleSettingsDnsResolversIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsDnsResolversIpv4Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 route_through_private_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv4 address of upstream resolver.
        :param pulumi.Input[_builtins.int] port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param pulumi.Input[_builtins.bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param pulumi.Input[_builtins.str] vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IPv6 address of upstream resolver.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        route_through_private_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    TeamsRuleRuleSettingsDnsResolversIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsDnsResolversIpv6Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 route_through_private_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv6 address of upstream resolver.
        :param pulumi.Input[_builtins.int] port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param pulumi.Input[_builtins.bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param pulumi.Input[_builtins.str] vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IPv6 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class TeamsRuleRuleSettingsEgressArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 address to be used for egress.
        """
        ipv4_fallback: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 range to be used for egress.
        """
elif False:
    TeamsRuleRuleSettingsEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsEgressArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4_fallback: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: The IPv4 address to be used for egress.
        :param pulumi.Input[_builtins.str] ipv4_fallback: The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        :param pulumi.Input[_builtins.str] ipv6: The IPv6 range to be used for egress.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @ipv4_fallback.setter
    def ipv4_fallback(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4_fallback", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class TeamsRuleRuleSettingsL4overrideArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 or IPv6 address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A port number to use for TCP/UDP overrides.
        """
elif False:
    TeamsRuleRuleSettingsL4overrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsL4overrideArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv4 or IPv6 address.
        :param pulumi.Input[_builtins.int] port: A port number to use for TCP/UDP overrides.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A port number to use for TCP/UDP overrides.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class TeamsRuleRuleSettingsNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set notification on.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
        msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customize the message shown in the notification.
        """
        support_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
elif False:
    TeamsRuleRuleSettingsNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 msg: Optional[pulumi.Input[_builtins.str]] = None,
                 support_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Set notification on.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        :param pulumi.Input[_builtins.str] msg: Customize the message shown in the notification.
        :param pulumi.Input[_builtins.str] support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set notification on.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "msg", value)

    @_builtins.property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class TeamsRuleRuleSettingsPayloadLogArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to enable DLP payload logging for this rule.
        """
elif False:
    TeamsRuleRuleSettingsPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsPayloadLogArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Set to true to enable DLP payload logging for this rule.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to enable DLP payload logging for this rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TeamsRuleRuleSettingsQuarantineArgsDict(TypedDict):
        file_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Types of files to sandbox.
        """
elif False:
    TeamsRuleRuleSettingsQuarantineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsQuarantineArgs:
    def __init__(__self__, *,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] file_types: Types of files to sandbox.
        """
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)

    @_builtins.property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Types of files to sandbox.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "file_types", value)


if not MYPY:
    class TeamsRuleRuleSettingsRedirectArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        URI to which the user will be redirected.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
        preserve_path_and_query: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the path and query parameters from the original request will be appended to target_uri.
        """
elif False:
    TeamsRuleRuleSettingsRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsRedirectArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str],
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 preserve_path_and_query: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] target_uri: URI to which the user will be redirected.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        :param pulumi.Input[_builtins.bool] preserve_path_and_query: If true, the path and query parameters from the original request will be appended to target_uri.
        """
        pulumi.set(__self__, "target_uri", target_uri)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if preserve_path_and_query is not None:
            pulumi.set(__self__, "preserve_path_and_query", preserve_path_and_query)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI to which the user will be redirected.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter(name="preservePathAndQuery")
    def preserve_path_and_query(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the path and query parameters from the original request will be appended to target_uri.
        """
        return pulumi.get(self, "preserve_path_and_query")

    @preserve_path_and_query.setter
    def preserve_path_and_query(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_and_query", value)


if not MYPY:
    class TeamsRuleRuleSettingsResolveDnsInternallyArgsDict(TypedDict):
        fallback: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        Available values: "none", "public_dns".
        """
        view_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
elif False:
    TeamsRuleRuleSettingsResolveDnsInternallyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsResolveDnsInternallyArgs:
    def __init__(__self__, *,
                 fallback: Optional[pulumi.Input[_builtins.str]] = None,
                 view_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
               Available values: "none", "public_dns".
        :param pulumi.Input[_builtins.str] view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if view_id is not None:
            pulumi.set(__self__, "view_id", view_id)

    @_builtins.property
    @pulumi.getter
    def fallback(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        Available values: "none", "public_dns".
        """
        return pulumi.get(self, "fallback")

    @fallback.setter
    def fallback(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback", value)

    @_builtins.property
    @pulumi.getter(name="viewId")
    def view_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")

    @view_id.setter
    def view_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "view_id", value)


if not MYPY:
    class TeamsRuleRuleSettingsUntrustedCertArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        Available values: "pass_through", "block", "error".
        """
elif False:
    TeamsRuleRuleSettingsUntrustedCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleRuleSettingsUntrustedCertArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
               Available values: "pass_through", "block", "error".
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        Available values: "pass_through", "block", "error".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class TeamsRuleScheduleArgsDict(TypedDict):
        fri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        mon: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        sat: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        sun: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        thu: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        tue: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        wed: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
elif False:
    TeamsRuleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamsRuleScheduleArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[_builtins.str]] = None,
                 mon: Optional[pulumi.Input[_builtins.str]] = None,
                 sat: Optional[pulumi.Input[_builtins.str]] = None,
                 sun: Optional[pulumi.Input[_builtins.str]] = None,
                 thu: Optional[pulumi.Input[_builtins.str]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 tue: Optional[pulumi.Input[_builtins.str]] = None,
                 wed: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fri: The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        :param pulumi.Input[_builtins.str] mon: The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        :param pulumi.Input[_builtins.str] sat: The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        :param pulumi.Input[_builtins.str] sun: The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        :param pulumi.Input[_builtins.str] thu: The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        :param pulumi.Input[_builtins.str] time_zone: The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        :param pulumi.Input[_builtins.str] tue: The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        :param pulumi.Input[_builtins.str] wed: The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @_builtins.property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fri", value)

    @_builtins.property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mon", value)

    @_builtins.property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sat", value)

    @_builtins.property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sun", value)

    @_builtins.property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "thu", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tue", value)

    @_builtins.property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wed", value)


if not MYPY:
    class TunnelConfigConfigArgsDict(TypedDict):
        ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressArgsDict']]]]
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        origin_request: NotRequired[pulumi.Input['TunnelConfigConfigOriginRequestArgsDict']]
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        warp_routing: NotRequired[pulumi.Input['TunnelConfigConfigWarpRoutingArgsDict']]
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
elif False:
    TunnelConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigArgs:
    def __init__(__self__, *,
                 ingresses: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressArgs']]]] = None,
                 origin_request: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']] = None,
                 warp_routing: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressArgs']]] ingresses: List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        :param pulumi.Input['TunnelConfigConfigOriginRequestArgs'] origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param pulumi.Input['TunnelConfigConfigWarpRoutingArgs'] warp_routing: Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        if ingresses is not None:
            pulumi.set(__self__, "ingresses", ingresses)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @_builtins.property
    @pulumi.getter
    def ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressArgs']]]]:
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        return pulumi.get(self, "ingresses")

    @ingresses.setter
    def ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TunnelConfigConfigIngressArgs']]]]):
        pulumi.set(self, "ingresses", value)

    @_builtins.property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']]:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['TunnelConfigConfigOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @_builtins.property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']]:
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        return pulumi.get(self, "warp_routing")

    @warp_routing.setter
    def warp_routing(self, value: Optional[pulumi.Input['TunnelConfigConfigWarpRoutingArgs']]):
        pulumi.set(self, "warp_routing", value)


if not MYPY:
    class TunnelConfigConfigIngressArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public hostname for this service.
        """
        origin_request: NotRequired[pulumi.Input['TunnelConfigConfigIngressOriginRequestArgsDict']]
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Requests with this path route to this public hostname.
        """
elif False:
    TunnelConfigConfigIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str],
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_request: Optional[pulumi.Input['TunnelConfigConfigIngressOriginRequestArgs']] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        :param pulumi.Input[_builtins.str] hostname: Public hostname for this service.
        :param pulumi.Input['TunnelConfigConfigIngressOriginRequestArgs'] origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param pulumi.Input[_builtins.str] path: Requests with this path route to this public hostname.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public hostname for this service.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['TunnelConfigConfigIngressOriginRequestArgs']]:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['TunnelConfigConfigIngressOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Requests with this path route to this public hostname.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TunnelConfigConfigIngressOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['TunnelConfigConfigIngressOriginRequestAccessArgsDict']]
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        ca_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        connect_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        http2_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        http_host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        no_tls_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        origin_server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        proxy_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        tls_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
elif False:
    TunnelConfigConfigIngressOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['TunnelConfigConfigIngressOriginRequestAccessArgs']] = None,
                 ca_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_alive_connections: Optional[pulumi.Input[_builtins.int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[_builtins.bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[_builtins.int]] = None,
                 tls_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['TunnelConfigConfigIngressOriginRequestAccessArgs'] access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param pulumi.Input[_builtins.str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param pulumi.Input[_builtins.int] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param pulumi.Input[_builtins.bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param pulumi.Input[_builtins.bool] http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param pulumi.Input[_builtins.str] http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param pulumi.Input[_builtins.int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param pulumi.Input[_builtins.int] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param pulumi.Input[_builtins.bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param pulumi.Input[_builtins.bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param pulumi.Input[_builtins.str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param pulumi.Input[_builtins.str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param pulumi.Input[_builtins.int] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param pulumi.Input[_builtins.int] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['TunnelConfigConfigIngressOriginRequestAccessArgs']]:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['TunnelConfigConfigIngressOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_pool", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @_builtins.property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @_builtins.property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_origin", value)

    @_builtins.property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_host_header", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @_builtins.property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @_builtins.property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_server_name", value)

    @_builtins.property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_type", value)

    @_builtins.property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @_builtins.property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class TunnelConfigConfigIngressOriginRequestAccessArgsDict(TypedDict):
        aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        team_name: pulumi.Input[_builtins.str]
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deny traffic that has not fulfilled Access authorization.
        """
elif False:
    TunnelConfigConfigIngressOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigIngressOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 team_name: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param pulumi.Input[_builtins.bool] required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        pulumi.set(__self__, "team_name", team_name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "aud_tags", value)

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class TunnelConfigConfigOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgsDict']]
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        ca_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        connect_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        http2_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        http_host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        no_tls_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        origin_server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        proxy_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        tls_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
elif False:
    TunnelConfigConfigOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']] = None,
                 ca_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_alive_connections: Optional[pulumi.Input[_builtins.int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[_builtins.bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[_builtins.int]] = None,
                 tls_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs'] access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param pulumi.Input[_builtins.str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param pulumi.Input[_builtins.int] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param pulumi.Input[_builtins.bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param pulumi.Input[_builtins.bool] http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param pulumi.Input[_builtins.str] http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param pulumi.Input[_builtins.int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param pulumi.Input[_builtins.int] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param pulumi.Input[_builtins.bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param pulumi.Input[_builtins.bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param pulumi.Input[_builtins.str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param pulumi.Input[_builtins.str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param pulumi.Input[_builtins.int] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param pulumi.Input[_builtins.int] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']]:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['TunnelConfigConfigOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_pool", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @_builtins.property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @_builtins.property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_origin", value)

    @_builtins.property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_host_header", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @_builtins.property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @_builtins.property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_server_name", value)

    @_builtins.property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_type", value)

    @_builtins.property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @_builtins.property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class TunnelConfigConfigOriginRequestAccessArgsDict(TypedDict):
        aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        team_name: pulumi.Input[_builtins.str]
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deny traffic that has not fulfilled Access authorization.
        """
elif False:
    TunnelConfigConfigOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 team_name: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param pulumi.Input[_builtins.bool] required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        pulumi.set(__self__, "team_name", team_name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "aud_tags", value)

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class TunnelConfigConfigWarpRoutingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TunnelConfigConfigWarpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConfigConfigWarpRoutingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class TunnelConnectionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connector.
        """
        client_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloudflared version used to establish this connection.
        """
        colo_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloudflare data center used for this connection.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
        is_pending_reconnect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        opened_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of when the connection was established.
        """
        origin_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address of the host running cloudflared.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
elif False:
    TunnelConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TunnelConnectionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_version: Optional[pulumi.Input[_builtins.str]] = None,
                 colo_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_pending_reconnect: Optional[pulumi.Input[_builtins.bool]] = None,
                 opened_at: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: UUID of the Cloudflare Tunnel connector.
        :param pulumi.Input[_builtins.str] client_version: The cloudflared version used to establish this connection.
        :param pulumi.Input[_builtins.str] colo_name: The Cloudflare data center used for this connection.
        :param pulumi.Input[_builtins.str] id: UUID of the Cloudflare Tunnel connection.
        :param pulumi.Input[_builtins.bool] is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param pulumi.Input[_builtins.str] opened_at: Timestamp of when the connection was established.
        :param pulumi.Input[_builtins.str] origin_ip: The public IP address of the host running cloudflared.
        :param pulumi.Input[_builtins.str] uuid: UUID of the Cloudflare Tunnel connection.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_version is not None:
            pulumi.set(__self__, "client_version", client_version)
        if colo_name is not None:
            pulumi.set(__self__, "colo_name", colo_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_pending_reconnect is not None:
            pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        if opened_at is not None:
            pulumi.set(__self__, "opened_at", opened_at)
        if origin_ip is not None:
            pulumi.set(__self__, "origin_ip", origin_ip)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @client_version.setter
    def client_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_version", value)

    @_builtins.property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @colo_name.setter
    def colo_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "colo_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @is_pending_reconnect.setter
    def is_pending_reconnect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_pending_reconnect", value)

    @_builtins.property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @opened_at.setter
    def opened_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opened_at", value)

    @_builtins.property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @origin_ip.setter
    def origin_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_ip", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class UserAgentBlockingRuleConfigurationArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The configuration target. You must set the target to `ua` when specifying a user agent in the rule.
        Available values: "ua".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        the user agent to exactly match
        """
elif False:
    UserAgentBlockingRuleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAgentBlockingRuleConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target: The configuration target. You must set the target to `ua` when specifying a user agent in the rule.
               Available values: "ua".
        :param pulumi.Input[_builtins.str] value: the user agent to exactly match
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The configuration target. You must set the target to `ua` when specifying a user agent in the rule.
        Available values: "ua".
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        the user agent to exactly match
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UserOrganizationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization name.
        """
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Access permissions for this User.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of roles that a user has within an organization.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the user is a member of the organization or has an invitation pending.
        Available values: "member", "invited".
        """
elif False:
    UserOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserOrganizationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier
        :param pulumi.Input[_builtins.str] name: Organization name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: Access permissions for this User.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] roles: List of roles that a user has within an organization.
        :param pulumi.Input[_builtins.str] status: Whether the user is a member of the organization or has an invitation pending.
               Available values: "member", "invited".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Access permissions for this User.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of roles that a user has within an organization.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "roles", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the user is a member of the organization or has an invitation pending.
        Available values: "member", "invited".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class WaitingRoomAdditionalRouteArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
elif False:
    WaitingRoomAdditionalRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomAdditionalRouteArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        :param pulumi.Input[_builtins.str] path: Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class WaitingRoomCookieAttributesArgsDict(TypedDict):
        samesite: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        Available values: "auto", "lax", "none", "strict".
        """
        secure: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        Available values: "auto", "always", "never".
        """
elif False:
    WaitingRoomCookieAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomCookieAttributesArgs:
    def __init__(__self__, *,
                 samesite: Optional[pulumi.Input[_builtins.str]] = None,
                 secure: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] samesite: Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
               Available values: "auto", "lax", "none", "strict".
        :param pulumi.Input[_builtins.str] secure: Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
               Available values: "auto", "always", "never".
        """
        if samesite is not None:
            pulumi.set(__self__, "samesite", samesite)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @_builtins.property
    @pulumi.getter
    def samesite(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
        Available values: "auto", "lax", "none", "strict".
        """
        return pulumi.get(self, "samesite")

    @samesite.setter
    def samesite(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "samesite", value)

    @_builtins.property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
        Available values: "auto", "always", "never".
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secure", value)


if not MYPY:
    class WaitingRoomRulesRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to take when the expression matches.
        Available values: "bypass*waiting*room".
        """
        expression: pulumi.Input[_builtins.str]
        """
        Criteria defining when there is a match for the current rule.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the rule.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to true, the rule is enabled.
        """
elif False:
    WaitingRoomRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WaitingRoomRulesRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 expression: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action to take when the expression matches.
               Available values: "bypass*waiting*room".
        :param pulumi.Input[_builtins.str] expression: Criteria defining when there is a match for the current rule.
        :param pulumi.Input[_builtins.str] description: The description of the rule.
        :param pulumi.Input[_builtins.bool] enabled: When set to true, the rule is enabled.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take when the expression matches.
        Available values: "bypass*waiting*room".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Criteria defining when there is a match for the current rule.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to true, the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WebAnalyticsSiteRuleArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[_builtins.str]]
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname the rule will be applied to.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Web Analytics rule identifier.
        """
        inclusive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        is_paused: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the rule is paused or not.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The paths the rule will be applied to.
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    WebAnalyticsSiteRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAnalyticsSiteRuleArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusive: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_paused: Optional[pulumi.Input[_builtins.bool]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The hostname the rule will be applied to.
        :param pulumi.Input[_builtins.str] id: The Web Analytics rule identifier.
        :param pulumi.Input[_builtins.bool] inclusive: Whether the rule includes or excludes traffic from being measured.
        :param pulumi.Input[_builtins.bool] is_paused: Whether the rule is paused or not.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] paths: The paths the rule will be applied to.
        """
        if created is not None:
            pulumi.set(__self__, "created", created)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inclusive is not None:
            pulumi.set(__self__, "inclusive", inclusive)
        if is_paused is not None:
            pulumi.set(__self__, "is_paused", is_paused)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname the rule will be applied to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Web Analytics rule identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def inclusive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the rule includes or excludes traffic from being measured.
        """
        return pulumi.get(self, "inclusive")

    @inclusive.setter
    def inclusive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "inclusive", value)

    @_builtins.property
    @pulumi.getter(name="isPaused")
    def is_paused(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the rule is paused or not.
        """
        return pulumi.get(self, "is_paused")

    @is_paused.setter
    def is_paused(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_paused", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The paths the rule will be applied to.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class WebAnalyticsSiteRulesetArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the ruleset is enabled.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Web Analytics ruleset identifier.
        """
        zone_name: NotRequired[pulumi.Input[_builtins.str]]
        zone_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The zone identifier.
        """
elif False:
    WebAnalyticsSiteRulesetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebAnalyticsSiteRulesetArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_name: Optional[pulumi.Input[_builtins.str]] = None,
                 zone_tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the ruleset is enabled.
        :param pulumi.Input[_builtins.str] id: The Web Analytics ruleset identifier.
        :param pulumi.Input[_builtins.str] zone_tag: The zone identifier.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)
        if zone_tag is not None:
            pulumi.set(__self__, "zone_tag", zone_tag)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the ruleset is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Web Analytics ruleset identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_name", value)

    @_builtins.property
    @pulumi.getter(name="zoneTag")
    def zone_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The zone identifier.
        """
        return pulumi.get(self, "zone_tag")

    @zone_tag.setter
    def zone_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone_tag", value)


if not MYPY:
    class WorkerCronTriggerScheduleArgsDict(TypedDict):
        cron: pulumi.Input[_builtins.str]
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        modified_on: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkerCronTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerCronTriggerScheduleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[_builtins.str],
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 modified_on: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "cron", cron)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modified_on", value)


if not MYPY:
    class WorkerObservabilityArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether observability is enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
        """
        logs: NotRequired[pulumi.Input['WorkerObservabilityLogsArgsDict']]
        """
        Log settings for the Worker.
        """
elif False:
    WorkerObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerObservabilityArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 head_sampling_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 logs: Optional[pulumi.Input['WorkerObservabilityLogsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether observability is enabled for the Worker.
        :param pulumi.Input[_builtins.float] head_sampling_rate: The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
        :param pulumi.Input['WorkerObservabilityLogsArgs'] logs: Log settings for the Worker.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether observability is enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "head_sampling_rate", value)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['WorkerObservabilityLogsArgs']]:
        """
        Log settings for the Worker.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['WorkerObservabilityLogsArgs']]):
        pulumi.set(self, "logs", value)


if not MYPY:
    class WorkerObservabilityLogsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether logs are enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%).
        """
        invocation_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
elif False:
    WorkerObservabilityLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerObservabilityLogsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 head_sampling_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 invocation_logs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether logs are enabled for the Worker.
        :param pulumi.Input[_builtins.float] head_sampling_rate: The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%).
        :param pulumi.Input[_builtins.bool] invocation_logs: Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)
        if invocation_logs is not None:
            pulumi.set(__self__, "invocation_logs", invocation_logs)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether logs are enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%).
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "head_sampling_rate", value)

    @_builtins.property
    @pulumi.getter(name="invocationLogs")
    def invocation_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
        return pulumi.get(self, "invocation_logs")

    @invocation_logs.setter
    def invocation_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invocation_logs", value)


if not MYPY:
    class WorkerScriptAssetsArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['WorkerScriptAssetsConfigArgsDict']]
        """
        Configuration for assets within a Worker.
        """
        jwt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
elif False:
    WorkerScriptAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptAssetsArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['WorkerScriptAssetsConfigArgs']] = None,
                 jwt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WorkerScriptAssetsConfigArgs'] config: Configuration for assets within a Worker.
        :param pulumi.Input[_builtins.str] jwt: Token provided upon successful upload of all files from a registered manifest.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['WorkerScriptAssetsConfigArgs']]:
        """
        Configuration for assets within a Worker.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['WorkerScriptAssetsConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def jwt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
        return pulumi.get(self, "jwt")

    @jwt.setter
    def jwt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwt", value)


if not MYPY:
    class WorkerScriptAssetsConfigArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of a _headers file (used to attach custom headers on asset responses).
        """
        html_handling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the redirects and rewrites of requests for HTML content.
        Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        """
        not_found_handling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        Available values: "none", "404-page", "single-page-application".
        """
        redirects: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
        """
        run_worker_first: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        serve_directly: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
elif False:
    WorkerScriptAssetsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptAssetsConfigArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[_builtins.str]] = None,
                 html_handling: Optional[pulumi.Input[_builtins.str]] = None,
                 not_found_handling: Optional[pulumi.Input[_builtins.str]] = None,
                 redirects: Optional[pulumi.Input[_builtins.str]] = None,
                 run_worker_first: Optional[pulumi.Input[_builtins.bool]] = None,
                 serve_directly: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] headers: The contents of a _headers file (used to attach custom headers on asset responses).
        :param pulumi.Input[_builtins.str] html_handling: Determines the redirects and rewrites of requests for HTML content.
               Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        :param pulumi.Input[_builtins.str] not_found_handling: Determines the response when a request does not match a static asset, and there is no Worker script.
               Available values: "none", "404-page", "single-page-application".
        :param pulumi.Input[_builtins.str] redirects: The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
        :param pulumi.Input[_builtins.bool] run_worker_first: When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        :param pulumi.Input[_builtins.bool] serve_directly: When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if html_handling is not None:
            pulumi.set(__self__, "html_handling", html_handling)
        if not_found_handling is not None:
            pulumi.set(__self__, "not_found_handling", not_found_handling)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)
        if run_worker_first is not None:
            pulumi.set(__self__, "run_worker_first", run_worker_first)
        if serve_directly is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""serve_directly is deprecated: This attribute is deprecated.""")
        if serve_directly is not None:
            pulumi.set(__self__, "serve_directly", serve_directly)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of a _headers file (used to attach custom headers on asset responses).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="htmlHandling")
    def html_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the redirects and rewrites of requests for HTML content.
        Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        """
        return pulumi.get(self, "html_handling")

    @html_handling.setter
    def html_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_handling", value)

    @_builtins.property
    @pulumi.getter(name="notFoundHandling")
    def not_found_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        Available values: "none", "404-page", "single-page-application".
        """
        return pulumi.get(self, "not_found_handling")

    @not_found_handling.setter
    def not_found_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_found_handling", value)

    @_builtins.property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirects", value)

    @_builtins.property
    @pulumi.getter(name="runWorkerFirst")
    def run_worker_first(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        return pulumi.get(self, "run_worker_first")

    @run_worker_first.setter
    def run_worker_first(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_worker_first", value)

    @_builtins.property
    @pulumi.getter(name="serveDirectly")
    @_utilities.deprecated("""This attribute is deprecated.""")
    def serve_directly(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        return pulumi.get(self, "serve_directly")

    @serve_directly.setter
    def serve_directly(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "serve_directly", value)


if not MYPY:
    class WorkerScriptBindingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A JavaScript variable name for the binding.
        """
        type: pulumi.Input[_builtins.str]
        """
        The kind of resource that the binding provides.
        Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        """
        algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        R2 bucket to bind to.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the certificate to bind to.
        """
        class_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The exported class name of the Durable Object.
        """
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the dataset to bind to.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment of the script_name to bind to.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
        Available values: "raw", "pkcs8", "spki", "jwk".
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the D1 database to bind to.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Vectorize index to bind to.
        """
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON data to use.
        """
        key_base64: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        """
        key_jwk: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to bind to.
        """
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace identifier tag.
        """
        outbound: NotRequired[pulumi.Input['WorkerScriptBindingOutboundArgsDict']]
        """
        Outbound worker.
        """
        pipeline: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pipeline to bind to.
        """
        queue_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Queue to bind to.
        """
        script_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the secret in the store.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of Worker to bind to.
        """
        store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the store containing the secret.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text value to use.
        """
        usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        """
        workflow_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Workflow to bind to.
        """
elif False:
    WorkerScriptBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 class_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None,
                 json: Optional[pulumi.Input[_builtins.str]] = None,
                 key_base64: Optional[pulumi.Input[_builtins.str]] = None,
                 key_jwk: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input['WorkerScriptBindingOutboundArgs']] = None,
                 pipeline: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_name: Optional[pulumi.Input[_builtins.str]] = None,
                 script_name: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 workflow_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A JavaScript variable name for the binding.
        :param pulumi.Input[_builtins.str] type: The kind of resource that the binding provides.
               Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        :param pulumi.Input[_builtins.str] algorithm: Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        :param pulumi.Input[_builtins.str] bucket_name: R2 bucket to bind to.
        :param pulumi.Input[_builtins.str] certificate_id: Identifier of the certificate to bind to.
        :param pulumi.Input[_builtins.str] class_name: The exported class name of the Durable Object.
        :param pulumi.Input[_builtins.str] dataset: The name of the dataset to bind to.
        :param pulumi.Input[_builtins.str] environment: The environment of the script_name to bind to.
        :param pulumi.Input[_builtins.str] format: Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
               Available values: "raw", "pkcs8", "spki", "jwk".
        :param pulumi.Input[_builtins.str] id: Identifier of the D1 database to bind to.
        :param pulumi.Input[_builtins.str] index_name: Name of the Vectorize index to bind to.
        :param pulumi.Input[_builtins.str] json: JSON data to use.
        :param pulumi.Input[_builtins.str] key_base64: Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        :param pulumi.Input[_builtins.str] key_jwk: Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        :param pulumi.Input[_builtins.str] namespace: Namespace to bind to.
        :param pulumi.Input[_builtins.str] namespace_id: Namespace identifier tag.
        :param pulumi.Input['WorkerScriptBindingOutboundArgs'] outbound: Outbound worker.
        :param pulumi.Input[_builtins.str] pipeline: Name of the Pipeline to bind to.
        :param pulumi.Input[_builtins.str] queue_name: Name of the Queue to bind to.
        :param pulumi.Input[_builtins.str] script_name: The script where the Durable Object is defined, if it is external to this Worker.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret in the store.
        :param pulumi.Input[_builtins.str] service: Name of Worker to bind to.
        :param pulumi.Input[_builtins.str] store_id: ID of the store containing the secret.
        :param pulumi.Input[_builtins.str] text: The text value to use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usages: Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        :param pulumi.Input[_builtins.str] workflow_name: Name of the Workflow to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if key_base64 is not None:
            pulumi.set(__self__, "key_base64", key_base64)
        if key_jwk is not None:
            pulumi.set(__self__, "key_jwk", key_jwk)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if store_id is not None:
            pulumi.set(__self__, "store_id", store_id)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if usages is not None:
            pulumi.set(__self__, "usages", usages)
        if workflow_name is not None:
            pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A JavaScript variable name for the binding.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The kind of resource that the binding provides.
        Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        R2 bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the certificate to bind to.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The exported class name of the Durable Object.
        """
        return pulumi.get(self, "class_name")

    @class_name.setter
    def class_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "class_name", value)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the dataset to bind to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment of the script_name to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
        Available values: "raw", "pkcs8", "spki", "jwk".
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the D1 database to bind to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Vectorize index to bind to.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON data to use.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter(name="keyBase64")
    def key_base64(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        """
        return pulumi.get(self, "key_base64")

    @key_base64.setter
    def key_base64(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_base64", value)

    @_builtins.property
    @pulumi.getter(name="keyJwk")
    def key_jwk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        """
        return pulumi.get(self, "key_jwk")

    @key_jwk.setter
    def key_jwk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_jwk", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to bind to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace identifier tag.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input['WorkerScriptBindingOutboundArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input['WorkerScriptBindingOutboundArgs']]):
        pulumi.set(self, "outbound", value)

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pipeline to bind to.
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline", value)

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Queue to bind to.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "queue_name", value)

    @_builtins.property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        return pulumi.get(self, "script_name")

    @script_name.setter
    def script_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script_name", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the secret in the store.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="storeId")
    def store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the store containing the secret.
        """
        return pulumi.get(self, "store_id")

    @store_id.setter
    def store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_id", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text value to use.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usages", value)

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Workflow to bind to.
        """
        return pulumi.get(self, "workflow_name")

    @workflow_name.setter
    def workflow_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_name", value)


if not MYPY:
    class WorkerScriptBindingOutboundArgsDict(TypedDict):
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        worker: NotRequired[pulumi.Input['WorkerScriptBindingOutboundWorkerArgsDict']]
        """
        Outbound worker.
        """
elif False:
    WorkerScriptBindingOutboundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptBindingOutboundArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 worker: Optional[pulumi.Input['WorkerScriptBindingOutboundWorkerArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] params: Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        :param pulumi.Input['WorkerScriptBindingOutboundWorkerArgs'] worker: Outbound worker.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['WorkerScriptBindingOutboundWorkerArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['WorkerScriptBindingOutboundWorkerArgs']]):
        pulumi.set(self, "worker", value)


if not MYPY:
    class WorkerScriptBindingOutboundWorkerArgsDict(TypedDict):
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Environment of the outbound worker.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the outbound worker.
        """
elif False:
    WorkerScriptBindingOutboundWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptBindingOutboundWorkerArgs:
    def __init__(__self__, *,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] environment: Environment of the outbound worker.
        :param pulumi.Input[_builtins.str] service: Name of the outbound worker.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Environment of the outbound worker.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the outbound worker.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class WorkerScriptLimitsArgsDict(TypedDict):
        cpu_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of CPU time this Worker can use in milliseconds.
        """
elif False:
    WorkerScriptLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptLimitsArgs:
    def __init__(__self__, *,
                 cpu_ms: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_ms: The amount of CPU time this Worker can use in milliseconds.
        """
        if cpu_ms is not None:
            pulumi.set(__self__, "cpu_ms", cpu_ms)

    @_builtins.property
    @pulumi.getter(name="cpuMs")
    def cpu_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of CPU time this Worker can use in milliseconds.
        """
        return pulumi.get(self, "cpu_ms")

    @cpu_ms.setter
    def cpu_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_ms", value)


if not MYPY:
    class WorkerScriptNamedHandlerArgsDict(TypedDict):
        handlers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The names of handlers exported as part of the named export.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the export.
        """
elif False:
    WorkerScriptNamedHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptNamedHandlerArgs:
    def __init__(__self__, *,
                 handlers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] handlers: The names of handlers exported as part of the named export.
        :param pulumi.Input[_builtins.str] name: The name of the export.
        """
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def handlers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The names of handlers exported as part of the named export.
        """
        return pulumi.get(self, "handlers")

    @handlers.setter
    def handlers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "handlers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the export.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkerScriptObservabilityArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether observability is enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        logs: NotRequired[pulumi.Input['WorkerScriptObservabilityLogsArgsDict']]
        """
        Log settings for the Worker.
        """
elif False:
    WorkerScriptObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptObservabilityArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 head_sampling_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 logs: Optional[pulumi.Input['WorkerScriptObservabilityLogsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether observability is enabled for the Worker.
        :param pulumi.Input[_builtins.float] head_sampling_rate: The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        :param pulumi.Input['WorkerScriptObservabilityLogsArgs'] logs: Log settings for the Worker.
        """
        pulumi.set(__self__, "enabled", enabled)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether observability is enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "head_sampling_rate", value)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['WorkerScriptObservabilityLogsArgs']]:
        """
        Log settings for the Worker.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['WorkerScriptObservabilityLogsArgs']]):
        pulumi.set(self, "logs", value)


if not MYPY:
    class WorkerScriptObservabilityLogsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether logs are enabled for the Worker.
        """
        invocation_logs: pulumi.Input[_builtins.bool]
        """
        Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
elif False:
    WorkerScriptObservabilityLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptObservabilityLogsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 invocation_logs: pulumi.Input[_builtins.bool],
                 head_sampling_rate: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether logs are enabled for the Worker.
        :param pulumi.Input[_builtins.bool] invocation_logs: Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        :param pulumi.Input[_builtins.float] head_sampling_rate: The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "invocation_logs", invocation_logs)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether logs are enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="invocationLogs")
    def invocation_logs(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
        return pulumi.get(self, "invocation_logs")

    @invocation_logs.setter
    def invocation_logs(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "invocation_logs", value)

    @_builtins.property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "head_sampling_rate", value)


if not MYPY:
    class WorkerScriptPlacementArgsDict(TypedDict):
        last_analyzed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "smart".
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
        """
elif False:
    WorkerScriptPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptPlacementArgs:
    def __init__(__self__, *,
                 last_analyzed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_analyzed_at: The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param pulumi.Input[_builtins.str] mode: Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
               Available values: "smart".
        :param pulumi.Input[_builtins.str] status: Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
               Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
        """
        if last_analyzed_at is not None:
            pulumi.set(__self__, "last_analyzed_at", last_analyzed_at)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="lastAnalyzedAt")
    def last_analyzed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "last_analyzed_at")

    @last_analyzed_at.setter
    def last_analyzed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_analyzed_at", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "smart".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class WorkerScriptTailConsumerArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        Name of Worker that is to be the consumer.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional environment if the Worker utilizes one.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional dispatch namespace the script belongs to.
        """
elif False:
    WorkerScriptTailConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerScriptTailConsumerArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str],
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: Name of Worker that is to be the consumer.
        :param pulumi.Input[_builtins.str] environment: Optional environment if the Worker utilizes one.
        :param pulumi.Input[_builtins.str] namespace: Optional dispatch namespace the script belongs to.
        """
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        Name of Worker that is to be the consumer.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional environment if the Worker utilizes one.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional dispatch namespace the script belongs to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class WorkerSubdomainArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the *.workers.dev subdomain is enabled for the Worker.
        """
        previews_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/) are enabled for the Worker.
        """
elif False:
    WorkerSubdomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerSubdomainArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 previews_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether the *.workers.dev subdomain is enabled for the Worker.
        :param pulumi.Input[_builtins.bool] previews_enabled: Whether [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/) are enabled for the Worker.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if previews_enabled is not None:
            pulumi.set(__self__, "previews_enabled", previews_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the *.workers.dev subdomain is enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="previewsEnabled")
    def previews_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/) are enabled for the Worker.
        """
        return pulumi.get(self, "previews_enabled")

    @previews_enabled.setter
    def previews_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "previews_enabled", value)


if not MYPY:
    class WorkerTailConsumerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the consumer Worker.
        """
elif False:
    WorkerTailConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerTailConsumerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of the consumer Worker.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the consumer Worker.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkerVersionAnnotationsArgsDict(TypedDict):
        workers_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable message about the version.
        """
        workers_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        User-provided identifier for the version.
        """
        workers_triggered_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operation that triggered the creation of the version.
        """
elif False:
    WorkerVersionAnnotationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionAnnotationsArgs:
    def __init__(__self__, *,
                 workers_message: Optional[pulumi.Input[_builtins.str]] = None,
                 workers_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 workers_triggered_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] workers_message: Human-readable message about the version.
        :param pulumi.Input[_builtins.str] workers_tag: User-provided identifier for the version.
        :param pulumi.Input[_builtins.str] workers_triggered_by: Operation that triggered the creation of the version.
        """
        if workers_message is not None:
            pulumi.set(__self__, "workers_message", workers_message)
        if workers_tag is not None:
            pulumi.set(__self__, "workers_tag", workers_tag)
        if workers_triggered_by is not None:
            pulumi.set(__self__, "workers_triggered_by", workers_triggered_by)

    @_builtins.property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable message about the version.
        """
        return pulumi.get(self, "workers_message")

    @workers_message.setter
    def workers_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workers_message", value)

    @_builtins.property
    @pulumi.getter(name="workersTag")
    def workers_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User-provided identifier for the version.
        """
        return pulumi.get(self, "workers_tag")

    @workers_tag.setter
    def workers_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workers_tag", value)

    @_builtins.property
    @pulumi.getter(name="workersTriggeredBy")
    def workers_triggered_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operation that triggered the creation of the version.
        """
        return pulumi.get(self, "workers_triggered_by")

    @workers_triggered_by.setter
    def workers_triggered_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workers_triggered_by", value)


if not MYPY:
    class WorkerVersionAssetsArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['WorkerVersionAssetsConfigArgsDict']]
        """
        Configuration for assets within a Worker.
        """
elif False:
    WorkerVersionAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionAssetsArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['WorkerVersionAssetsConfigArgs']] = None):
        """
        :param pulumi.Input['WorkerVersionAssetsConfigArgs'] config: Configuration for assets within a Worker.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['WorkerVersionAssetsConfigArgs']]:
        """
        Configuration for assets within a Worker.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['WorkerVersionAssetsConfigArgs']]):
        pulumi.set(self, "config", value)


if not MYPY:
    class WorkerVersionAssetsConfigArgsDict(TypedDict):
        html_handling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the redirects and rewrites of requests for HTML content.
        Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        """
        not_found_handling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        Available values: "none", "404-page", "single-page-application".
        """
        run_worker_firsts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Contains a list path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
        """
elif False:
    WorkerVersionAssetsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionAssetsConfigArgs:
    def __init__(__self__, *,
                 html_handling: Optional[pulumi.Input[_builtins.str]] = None,
                 not_found_handling: Optional[pulumi.Input[_builtins.str]] = None,
                 run_worker_firsts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] html_handling: Determines the redirects and rewrites of requests for HTML content.
               Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        :param pulumi.Input[_builtins.str] not_found_handling: Determines the response when a request does not match a static asset, and there is no Worker script.
               Available values: "none", "404-page", "single-page-application".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] run_worker_firsts: Contains a list path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
        """
        if html_handling is not None:
            pulumi.set(__self__, "html_handling", html_handling)
        if not_found_handling is not None:
            pulumi.set(__self__, "not_found_handling", not_found_handling)
        if run_worker_firsts is not None:
            pulumi.set(__self__, "run_worker_firsts", run_worker_firsts)

    @_builtins.property
    @pulumi.getter(name="htmlHandling")
    def html_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the redirects and rewrites of requests for HTML content.
        Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        """
        return pulumi.get(self, "html_handling")

    @html_handling.setter
    def html_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_handling", value)

    @_builtins.property
    @pulumi.getter(name="notFoundHandling")
    def not_found_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        Available values: "none", "404-page", "single-page-application".
        """
        return pulumi.get(self, "not_found_handling")

    @not_found_handling.setter
    def not_found_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_found_handling", value)

    @_builtins.property
    @pulumi.getter(name="runWorkerFirsts")
    def run_worker_firsts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Contains a list path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
        """
        return pulumi.get(self, "run_worker_firsts")

    @run_worker_firsts.setter
    def run_worker_firsts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "run_worker_firsts", value)


if not MYPY:
    class WorkerVersionBindingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A JavaScript variable name for the binding.
        """
        type: pulumi.Input[_builtins.str]
        """
        The kind of resource that the binding provides.
        Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        """
        algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        R2 bucket to bind to.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the certificate to bind to.
        """
        class_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The exported class name of the Durable Object.
        """
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the dataset to bind to.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment of the script_name to bind to.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
        Available values: "raw", "pkcs8", "spki", "jwk".
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the D1 database to bind to.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Vectorize index to bind to.
        """
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON data to use.
        """
        key_base64: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        """
        key_jwk: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to bind to.
        """
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace identifier tag.
        """
        outbound: NotRequired[pulumi.Input['WorkerVersionBindingOutboundArgsDict']]
        """
        Outbound worker.
        """
        pipeline: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pipeline to bind to.
        """
        queue_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Queue to bind to.
        """
        script_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the secret in the store.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of Worker to bind to.
        """
        store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the store containing the secret.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text value to use.
        """
        usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        """
        workflow_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Workflow to bind to.
        """
elif False:
    WorkerVersionBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 class_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None,
                 json: Optional[pulumi.Input[_builtins.str]] = None,
                 key_base64: Optional[pulumi.Input[_builtins.str]] = None,
                 key_jwk: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input['WorkerVersionBindingOutboundArgs']] = None,
                 pipeline: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_name: Optional[pulumi.Input[_builtins.str]] = None,
                 script_name: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 workflow_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A JavaScript variable name for the binding.
        :param pulumi.Input[_builtins.str] type: The kind of resource that the binding provides.
               Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        :param pulumi.Input[_builtins.str] algorithm: Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        :param pulumi.Input[_builtins.str] bucket_name: R2 bucket to bind to.
        :param pulumi.Input[_builtins.str] certificate_id: Identifier of the certificate to bind to.
        :param pulumi.Input[_builtins.str] class_name: The exported class name of the Durable Object.
        :param pulumi.Input[_builtins.str] dataset: The name of the dataset to bind to.
        :param pulumi.Input[_builtins.str] environment: The environment of the script_name to bind to.
        :param pulumi.Input[_builtins.str] format: Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
               Available values: "raw", "pkcs8", "spki", "jwk".
        :param pulumi.Input[_builtins.str] id: Identifier of the D1 database to bind to.
        :param pulumi.Input[_builtins.str] index_name: Name of the Vectorize index to bind to.
        :param pulumi.Input[_builtins.str] json: JSON data to use.
        :param pulumi.Input[_builtins.str] key_base64: Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        :param pulumi.Input[_builtins.str] key_jwk: Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        :param pulumi.Input[_builtins.str] namespace: Namespace to bind to.
        :param pulumi.Input[_builtins.str] namespace_id: Namespace identifier tag.
        :param pulumi.Input['WorkerVersionBindingOutboundArgs'] outbound: Outbound worker.
        :param pulumi.Input[_builtins.str] pipeline: Name of the Pipeline to bind to.
        :param pulumi.Input[_builtins.str] queue_name: Name of the Queue to bind to.
        :param pulumi.Input[_builtins.str] script_name: The script where the Durable Object is defined, if it is external to this Worker.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret in the store.
        :param pulumi.Input[_builtins.str] service: Name of Worker to bind to.
        :param pulumi.Input[_builtins.str] store_id: ID of the store containing the secret.
        :param pulumi.Input[_builtins.str] text: The text value to use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usages: Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        :param pulumi.Input[_builtins.str] workflow_name: Name of the Workflow to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if key_base64 is not None:
            pulumi.set(__self__, "key_base64", key_base64)
        if key_jwk is not None:
            pulumi.set(__self__, "key_jwk", key_jwk)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if store_id is not None:
            pulumi.set(__self__, "store_id", store_id)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if usages is not None:
            pulumi.set(__self__, "usages", usages)
        if workflow_name is not None:
            pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A JavaScript variable name for the binding.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The kind of resource that the binding provides.
        Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        R2 bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the certificate to bind to.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The exported class name of the Durable Object.
        """
        return pulumi.get(self, "class_name")

    @class_name.setter
    def class_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "class_name", value)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the dataset to bind to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment of the script_name to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
        Available values: "raw", "pkcs8", "spki", "jwk".
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the D1 database to bind to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Vectorize index to bind to.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON data to use.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter(name="keyBase64")
    def key_base64(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        """
        return pulumi.get(self, "key_base64")

    @key_base64.setter
    def key_base64(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_base64", value)

    @_builtins.property
    @pulumi.getter(name="keyJwk")
    def key_jwk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        """
        return pulumi.get(self, "key_jwk")

    @key_jwk.setter
    def key_jwk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_jwk", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to bind to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace identifier tag.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input['WorkerVersionBindingOutboundArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input['WorkerVersionBindingOutboundArgs']]):
        pulumi.set(self, "outbound", value)

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pipeline to bind to.
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline", value)

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Queue to bind to.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "queue_name", value)

    @_builtins.property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        return pulumi.get(self, "script_name")

    @script_name.setter
    def script_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script_name", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the secret in the store.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="storeId")
    def store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the store containing the secret.
        """
        return pulumi.get(self, "store_id")

    @store_id.setter
    def store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_id", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text value to use.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usages", value)

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Workflow to bind to.
        """
        return pulumi.get(self, "workflow_name")

    @workflow_name.setter
    def workflow_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_name", value)


if not MYPY:
    class WorkerVersionBindingOutboundArgsDict(TypedDict):
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        worker: NotRequired[pulumi.Input['WorkerVersionBindingOutboundWorkerArgsDict']]
        """
        Outbound worker.
        """
elif False:
    WorkerVersionBindingOutboundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionBindingOutboundArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 worker: Optional[pulumi.Input['WorkerVersionBindingOutboundWorkerArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] params: Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        :param pulumi.Input['WorkerVersionBindingOutboundWorkerArgs'] worker: Outbound worker.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['WorkerVersionBindingOutboundWorkerArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['WorkerVersionBindingOutboundWorkerArgs']]):
        pulumi.set(self, "worker", value)


if not MYPY:
    class WorkerVersionBindingOutboundWorkerArgsDict(TypedDict):
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Environment of the outbound worker.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the outbound worker.
        """
elif False:
    WorkerVersionBindingOutboundWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionBindingOutboundWorkerArgs:
    def __init__(__self__, *,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] environment: Environment of the outbound worker.
        :param pulumi.Input[_builtins.str] service: Name of the outbound worker.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Environment of the outbound worker.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the outbound worker.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class WorkerVersionLimitsArgsDict(TypedDict):
        cpu_ms: pulumi.Input[_builtins.int]
        """
        CPU time limit in milliseconds.
        """
elif False:
    WorkerVersionLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionLimitsArgs:
    def __init__(__self__, *,
                 cpu_ms: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] cpu_ms: CPU time limit in milliseconds.
        """
        pulumi.set(__self__, "cpu_ms", cpu_ms)

    @_builtins.property
    @pulumi.getter(name="cpuMs")
    def cpu_ms(self) -> pulumi.Input[_builtins.int]:
        """
        CPU time limit in milliseconds.
        """
        return pulumi.get(self, "cpu_ms")

    @cpu_ms.setter
    def cpu_ms(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "cpu_ms", value)


if not MYPY:
    class WorkerVersionMigrationsArgsDict(TypedDict):
        deleted_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of classes to delete Durable Object namespaces from.
        """
        new_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of classes to create Durable Object namespaces from.
        """
        new_sqlite_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        new_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tag to set as the latest migration tag.
        """
        old_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        """
        renamed_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsRenamedClassArgsDict']]]]
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepArgsDict']]]]
        """
        Migrations to apply in order.
        """
        transferred_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsTransferredClassArgsDict']]]]
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
elif False:
    WorkerVersionMigrationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionMigrationsArgs:
    def __init__(__self__, *,
                 deleted_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_sqlite_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 old_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 renamed_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsRenamedClassArgs']]]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepArgs']]]] = None,
                 transferred_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsTransferredClassArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] deleted_classes: A list of classes to delete Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] new_classes: A list of classes to create Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] new_sqlite_classes: A list of classes to create Durable Object namespaces with SQLite from.
        :param pulumi.Input[_builtins.str] new_tag: Tag to set as the latest migration tag.
        :param pulumi.Input[_builtins.str] old_tag: Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        :param pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsRenamedClassArgs']]] renamed_classes: A list of classes with Durable Object namespaces that were renamed.
        :param pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepArgs']]] steps: Migrations to apply in order.
        :param pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsTransferredClassArgs']]] transferred_classes: A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        if deleted_classes is not None:
            pulumi.set(__self__, "deleted_classes", deleted_classes)
        if new_classes is not None:
            pulumi.set(__self__, "new_classes", new_classes)
        if new_sqlite_classes is not None:
            pulumi.set(__self__, "new_sqlite_classes", new_sqlite_classes)
        if new_tag is not None:
            pulumi.set(__self__, "new_tag", new_tag)
        if old_tag is not None:
            pulumi.set(__self__, "old_tag", old_tag)
        if renamed_classes is not None:
            pulumi.set(__self__, "renamed_classes", renamed_classes)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if transferred_classes is not None:
            pulumi.set(__self__, "transferred_classes", transferred_classes)

    @_builtins.property
    @pulumi.getter(name="deletedClasses")
    def deleted_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of classes to delete Durable Object namespaces from.
        """
        return pulumi.get(self, "deleted_classes")

    @deleted_classes.setter
    def deleted_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "deleted_classes", value)

    @_builtins.property
    @pulumi.getter(name="newClasses")
    def new_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of classes to create Durable Object namespaces from.
        """
        return pulumi.get(self, "new_classes")

    @new_classes.setter
    def new_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "new_classes", value)

    @_builtins.property
    @pulumi.getter(name="newSqliteClasses")
    def new_sqlite_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        return pulumi.get(self, "new_sqlite_classes")

    @new_sqlite_classes.setter
    def new_sqlite_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "new_sqlite_classes", value)

    @_builtins.property
    @pulumi.getter(name="newTag")
    def new_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tag to set as the latest migration tag.
        """
        return pulumi.get(self, "new_tag")

    @new_tag.setter
    def new_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "new_tag", value)

    @_builtins.property
    @pulumi.getter(name="oldTag")
    def old_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
        """
        return pulumi.get(self, "old_tag")

    @old_tag.setter
    def old_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "old_tag", value)

    @_builtins.property
    @pulumi.getter(name="renamedClasses")
    def renamed_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsRenamedClassArgs']]]]:
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        return pulumi.get(self, "renamed_classes")

    @renamed_classes.setter
    def renamed_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsRenamedClassArgs']]]]):
        pulumi.set(self, "renamed_classes", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepArgs']]]]:
        """
        Migrations to apply in order.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepArgs']]]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter(name="transferredClasses")
    def transferred_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsTransferredClassArgs']]]]:
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        return pulumi.get(self, "transferred_classes")

    @transferred_classes.setter
    def transferred_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsTransferredClassArgs']]]]):
        pulumi.set(self, "transferred_classes", value)


if not MYPY:
    class WorkerVersionMigrationsRenamedClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        to: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkerVersionMigrationsRenamedClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionMigrationsRenamedClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkerVersionMigrationsStepArgsDict(TypedDict):
        deleted_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of classes to delete Durable Object namespaces from.
        """
        new_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of classes to create Durable Object namespaces from.
        """
        new_sqlite_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        renamed_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepRenamedClassArgsDict']]]]
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        transferred_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepTransferredClassArgsDict']]]]
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
elif False:
    WorkerVersionMigrationsStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionMigrationsStepArgs:
    def __init__(__self__, *,
                 deleted_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 new_sqlite_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 renamed_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepRenamedClassArgs']]]] = None,
                 transferred_classes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepTransferredClassArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] deleted_classes: A list of classes to delete Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] new_classes: A list of classes to create Durable Object namespaces from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] new_sqlite_classes: A list of classes to create Durable Object namespaces with SQLite from.
        :param pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepRenamedClassArgs']]] renamed_classes: A list of classes with Durable Object namespaces that were renamed.
        :param pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepTransferredClassArgs']]] transferred_classes: A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        if deleted_classes is not None:
            pulumi.set(__self__, "deleted_classes", deleted_classes)
        if new_classes is not None:
            pulumi.set(__self__, "new_classes", new_classes)
        if new_sqlite_classes is not None:
            pulumi.set(__self__, "new_sqlite_classes", new_sqlite_classes)
        if renamed_classes is not None:
            pulumi.set(__self__, "renamed_classes", renamed_classes)
        if transferred_classes is not None:
            pulumi.set(__self__, "transferred_classes", transferred_classes)

    @_builtins.property
    @pulumi.getter(name="deletedClasses")
    def deleted_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of classes to delete Durable Object namespaces from.
        """
        return pulumi.get(self, "deleted_classes")

    @deleted_classes.setter
    def deleted_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "deleted_classes", value)

    @_builtins.property
    @pulumi.getter(name="newClasses")
    def new_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of classes to create Durable Object namespaces from.
        """
        return pulumi.get(self, "new_classes")

    @new_classes.setter
    def new_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "new_classes", value)

    @_builtins.property
    @pulumi.getter(name="newSqliteClasses")
    def new_sqlite_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of classes to create Durable Object namespaces with SQLite from.
        """
        return pulumi.get(self, "new_sqlite_classes")

    @new_sqlite_classes.setter
    def new_sqlite_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "new_sqlite_classes", value)

    @_builtins.property
    @pulumi.getter(name="renamedClasses")
    def renamed_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepRenamedClassArgs']]]]:
        """
        A list of classes with Durable Object namespaces that were renamed.
        """
        return pulumi.get(self, "renamed_classes")

    @renamed_classes.setter
    def renamed_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepRenamedClassArgs']]]]):
        pulumi.set(self, "renamed_classes", value)

    @_builtins.property
    @pulumi.getter(name="transferredClasses")
    def transferred_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepTransferredClassArgs']]]]:
        """
        A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
        """
        return pulumi.get(self, "transferred_classes")

    @transferred_classes.setter
    def transferred_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkerVersionMigrationsStepTransferredClassArgs']]]]):
        pulumi.set(self, "transferred_classes", value)


if not MYPY:
    class WorkerVersionMigrationsStepRenamedClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        to: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkerVersionMigrationsStepRenamedClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionMigrationsStepRenamedClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkerVersionMigrationsStepTransferredClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        from_script: NotRequired[pulumi.Input[_builtins.str]]
        to: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkerVersionMigrationsStepTransferredClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionMigrationsStepTransferredClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 from_script: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if from_script is not None:
            pulumi.set(__self__, "from_script", from_script)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter(name="fromScript")
    def from_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "from_script")

    @from_script.setter
    def from_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_script", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkerVersionMigrationsTransferredClassArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input[_builtins.str]]
        from_script: NotRequired[pulumi.Input[_builtins.str]]
        to: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkerVersionMigrationsTransferredClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionMigrationsTransferredClassArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input[_builtins.str]] = None,
                 from_script: Optional[pulumi.Input[_builtins.str]] = None,
                 to: Optional[pulumi.Input[_builtins.str]] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if from_script is not None:
            pulumi.set(__self__, "from_script", from_script)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter(name="fromScript")
    def from_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "from_script")

    @from_script.setter
    def from_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "from_script", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class WorkerVersionModuleArgsDict(TypedDict):
        content_file: pulumi.Input[_builtins.str]
        """
        The file path of the module content.
        """
        content_type: pulumi.Input[_builtins.str]
        """
        The content type of the module.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the module.
        """
        content_sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SHA-256 hash of the module content.
        """
elif False:
    WorkerVersionModuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionModuleArgs:
    def __init__(__self__, *,
                 content_file: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 content_sha256: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content_file: The file path of the module content.
        :param pulumi.Input[_builtins.str] content_type: The content type of the module.
        :param pulumi.Input[_builtins.str] name: The name of the module.
        :param pulumi.Input[_builtins.str] content_sha256: The SHA-256 hash of the module content.
        """
        pulumi.set(__self__, "content_file", content_file)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "name", name)
        if content_sha256 is not None:
            pulumi.set(__self__, "content_sha256", content_sha256)

    @_builtins.property
    @pulumi.getter(name="contentFile")
    def content_file(self) -> pulumi.Input[_builtins.str]:
        """
        The file path of the module content.
        """
        return pulumi.get(self, "content_file")

    @content_file.setter
    def content_file(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_file", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        The content type of the module.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the module.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="contentSha256")
    def content_sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SHA-256 hash of the module content.
        """
        return pulumi.get(self, "content_sha256")

    @content_sha256.setter
    def content_sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_sha256", value)


if not MYPY:
    class WorkerVersionPlacementArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Placement mode for the version.
        Available values: "smart".
        """
elif False:
    WorkerVersionPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkerVersionPlacementArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Placement mode for the version.
               Available values: "smart".
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Placement mode for the version.
        Available values: "smart".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class WorkersCronTriggerScheduleArgsDict(TypedDict):
        cron: pulumi.Input[_builtins.str]
        created_on: NotRequired[pulumi.Input[_builtins.str]]
        modified_on: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkersCronTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersCronTriggerScheduleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[_builtins.str],
                 created_on: Optional[pulumi.Input[_builtins.str]] = None,
                 modified_on: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "cron", cron)
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modified_on", value)


if not MYPY:
    class WorkersDeploymentAnnotationsArgsDict(TypedDict):
        workers_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        workers_triggered_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operation that triggered the creation of the deployment.
        """
elif False:
    WorkersDeploymentAnnotationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentAnnotationsArgs:
    def __init__(__self__, *,
                 workers_message: Optional[pulumi.Input[_builtins.str]] = None,
                 workers_triggered_by: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] workers_message: Human-readable message about the deployment. Truncated to 100 bytes.
        :param pulumi.Input[_builtins.str] workers_triggered_by: Operation that triggered the creation of the deployment.
        """
        if workers_message is not None:
            pulumi.set(__self__, "workers_message", workers_message)
        if workers_triggered_by is not None:
            pulumi.set(__self__, "workers_triggered_by", workers_triggered_by)

    @_builtins.property
    @pulumi.getter(name="workersMessage")
    def workers_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable message about the deployment. Truncated to 100 bytes.
        """
        return pulumi.get(self, "workers_message")

    @workers_message.setter
    def workers_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workers_message", value)

    @_builtins.property
    @pulumi.getter(name="workersTriggeredBy")
    def workers_triggered_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operation that triggered the creation of the deployment.
        """
        return pulumi.get(self, "workers_triggered_by")

    @workers_triggered_by.setter
    def workers_triggered_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workers_triggered_by", value)


if not MYPY:
    class WorkersDeploymentVersionArgsDict(TypedDict):
        percentage: pulumi.Input[_builtins.float]
        version_id: pulumi.Input[_builtins.str]
elif False:
    WorkersDeploymentVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersDeploymentVersionArgs:
    def __init__(__self__, *,
                 percentage: pulumi.Input[_builtins.float],
                 version_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "version_id", version_id)

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "percentage", value)

    @_builtins.property
    @pulumi.getter(name="versionId")
    def version_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class WorkersScriptAssetsArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['WorkersScriptAssetsConfigArgsDict']]
        """
        Configuration for assets within a Worker.
        """
        jwt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
elif False:
    WorkersScriptAssetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptAssetsArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['WorkersScriptAssetsConfigArgs']] = None,
                 jwt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WorkersScriptAssetsConfigArgs'] config: Configuration for assets within a Worker.
        :param pulumi.Input[_builtins.str] jwt: Token provided upon successful upload of all files from a registered manifest.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['WorkersScriptAssetsConfigArgs']]:
        """
        Configuration for assets within a Worker.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['WorkersScriptAssetsConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def jwt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Token provided upon successful upload of all files from a registered manifest.
        """
        return pulumi.get(self, "jwt")

    @jwt.setter
    def jwt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwt", value)


if not MYPY:
    class WorkersScriptAssetsConfigArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of a _headers file (used to attach custom headers on asset responses).
        """
        html_handling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the redirects and rewrites of requests for HTML content.
        Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        """
        not_found_handling: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        Available values: "none", "404-page", "single-page-application".
        """
        redirects: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
        """
        run_worker_first: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        serve_directly: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
elif False:
    WorkersScriptAssetsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptAssetsConfigArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[_builtins.str]] = None,
                 html_handling: Optional[pulumi.Input[_builtins.str]] = None,
                 not_found_handling: Optional[pulumi.Input[_builtins.str]] = None,
                 redirects: Optional[pulumi.Input[_builtins.str]] = None,
                 run_worker_first: Optional[pulumi.Input[_builtins.bool]] = None,
                 serve_directly: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] headers: The contents of a _headers file (used to attach custom headers on asset responses).
        :param pulumi.Input[_builtins.str] html_handling: Determines the redirects and rewrites of requests for HTML content.
               Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        :param pulumi.Input[_builtins.str] not_found_handling: Determines the response when a request does not match a static asset, and there is no Worker script.
               Available values: "none", "404-page", "single-page-application".
        :param pulumi.Input[_builtins.str] redirects: The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
        :param pulumi.Input[_builtins.bool] run_worker_first: When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        :param pulumi.Input[_builtins.bool] serve_directly: When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if html_handling is not None:
            pulumi.set(__self__, "html_handling", html_handling)
        if not_found_handling is not None:
            pulumi.set(__self__, "not_found_handling", not_found_handling)
        if redirects is not None:
            pulumi.set(__self__, "redirects", redirects)
        if run_worker_first is not None:
            pulumi.set(__self__, "run_worker_first", run_worker_first)
        if serve_directly is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""serve_directly is deprecated: This attribute is deprecated.""")
        if serve_directly is not None:
            pulumi.set(__self__, "serve_directly", serve_directly)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of a _headers file (used to attach custom headers on asset responses).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="htmlHandling")
    def html_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the redirects and rewrites of requests for HTML content.
        Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
        """
        return pulumi.get(self, "html_handling")

    @html_handling.setter
    def html_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_handling", value)

    @_builtins.property
    @pulumi.getter(name="notFoundHandling")
    def not_found_handling(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines the response when a request does not match a static asset, and there is no Worker script.
        Available values: "none", "404-page", "single-page-application".
        """
        return pulumi.get(self, "not_found_handling")

    @not_found_handling.setter
    def not_found_handling(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_found_handling", value)

    @_builtins.property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirects", value)

    @_builtins.property
    @pulumi.getter(name="runWorkerFirst")
    def run_worker_first(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script.
        """
        return pulumi.get(self, "run_worker_first")

    @run_worker_first.setter
    def run_worker_first(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_worker_first", value)

    @_builtins.property
    @pulumi.getter(name="serveDirectly")
    @_utilities.deprecated("""This attribute is deprecated.""")
    def serve_directly(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
        """
        return pulumi.get(self, "serve_directly")

    @serve_directly.setter
    def serve_directly(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "serve_directly", value)


if not MYPY:
    class WorkersScriptBindingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A JavaScript variable name for the binding.
        """
        type: pulumi.Input[_builtins.str]
        """
        The kind of resource that the binding provides.
        Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        """
        algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        R2 bucket to bind to.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the certificate to bind to.
        """
        class_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The exported class name of the Durable Object.
        """
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the dataset to bind to.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment of the script_name to bind to.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
        Available values: "raw", "pkcs8", "spki", "jwk".
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier of the D1 database to bind to.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Vectorize index to bind to.
        """
        json: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON data to use.
        """
        key_base64: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        """
        key_jwk: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to bind to.
        """
        namespace_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace identifier tag.
        """
        outbound: NotRequired[pulumi.Input['WorkersScriptBindingOutboundArgsDict']]
        """
        Outbound worker.
        """
        pipeline: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pipeline to bind to.
        """
        queue_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Queue to bind to.
        """
        script_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the secret in the store.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of Worker to bind to.
        """
        store_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the store containing the secret.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text value to use.
        """
        usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        """
        workflow_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Workflow to bind to.
        """
elif False:
    WorkersScriptBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptBindingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 class_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None,
                 json: Optional[pulumi.Input[_builtins.str]] = None,
                 key_base64: Optional[pulumi.Input[_builtins.str]] = None,
                 key_jwk: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace_id: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound: Optional[pulumi.Input['WorkersScriptBindingOutboundArgs']] = None,
                 pipeline: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_name: Optional[pulumi.Input[_builtins.str]] = None,
                 script_name: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None,
                 store_id: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 workflow_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A JavaScript variable name for the binding.
        :param pulumi.Input[_builtins.str] type: The kind of resource that the binding provides.
               Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        :param pulumi.Input[_builtins.str] algorithm: Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        :param pulumi.Input[_builtins.str] bucket_name: R2 bucket to bind to.
        :param pulumi.Input[_builtins.str] certificate_id: Identifier of the certificate to bind to.
        :param pulumi.Input[_builtins.str] class_name: The exported class name of the Durable Object.
        :param pulumi.Input[_builtins.str] dataset: The name of the dataset to bind to.
        :param pulumi.Input[_builtins.str] environment: The environment of the script_name to bind to.
        :param pulumi.Input[_builtins.str] format: Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
               Available values: "raw", "pkcs8", "spki", "jwk".
        :param pulumi.Input[_builtins.str] id: Identifier of the D1 database to bind to.
        :param pulumi.Input[_builtins.str] index_name: Name of the Vectorize index to bind to.
        :param pulumi.Input[_builtins.str] json: JSON data to use.
        :param pulumi.Input[_builtins.str] key_base64: Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        :param pulumi.Input[_builtins.str] key_jwk: Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        :param pulumi.Input[_builtins.str] namespace: Namespace to bind to.
        :param pulumi.Input[_builtins.str] namespace_id: Namespace identifier tag.
        :param pulumi.Input['WorkersScriptBindingOutboundArgs'] outbound: Outbound worker.
        :param pulumi.Input[_builtins.str] pipeline: Name of the Pipeline to bind to.
        :param pulumi.Input[_builtins.str] queue_name: Name of the Queue to bind to.
        :param pulumi.Input[_builtins.str] script_name: The script where the Durable Object is defined, if it is external to this Worker.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret in the store.
        :param pulumi.Input[_builtins.str] service: Name of Worker to bind to.
        :param pulumi.Input[_builtins.str] store_id: ID of the store containing the secret.
        :param pulumi.Input[_builtins.str] text: The text value to use.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usages: Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        :param pulumi.Input[_builtins.str] workflow_name: Name of the Workflow to bind to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if class_name is not None:
            pulumi.set(__self__, "class_name", class_name)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if key_base64 is not None:
            pulumi.set(__self__, "key_base64", key_base64)
        if key_jwk is not None:
            pulumi.set(__self__, "key_jwk", key_jwk)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if script_name is not None:
            pulumi.set(__self__, "script_name", script_name)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if store_id is not None:
            pulumi.set(__self__, "store_id", store_id)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if usages is not None:
            pulumi.set(__self__, "usages", usages)
        if workflow_name is not None:
            pulumi.set(__self__, "workflow_name", workflow_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A JavaScript variable name for the binding.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The kind of resource that the binding provides.
        Available values: "ai", "analytics*engine", "assets", "browser", "d1", "dispatch*namespace", "durable*object*namespace", "hyperdrive", "json", "kv*namespace", "mtls*certificate", "plain*text", "pipelines", "queue", "r2*bucket", "secret*text", "service", "tail*consumer", "vectorize", "version*metadata", "secrets*store*secret", "secret*key", "workflow".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        R2 bucket to bind to.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the certificate to bind to.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="className")
    def class_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The exported class name of the Durable Object.
        """
        return pulumi.get(self, "class_name")

    @class_name.setter
    def class_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "class_name", value)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the dataset to bind to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment of the script_name to bind to.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
        Available values: "raw", "pkcs8", "spki", "jwk".
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier of the D1 database to bind to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Vectorize index to bind to.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON data to use.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter(name="keyBase64")
    def key_base64(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
        """
        return pulumi.get(self, "key_base64")

    @key_base64.setter
    def key_base64(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_base64", value)

    @_builtins.property
    @pulumi.getter(name="keyJwk")
    def key_jwk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
        """
        return pulumi.get(self, "key_jwk")

    @key_jwk.setter
    def key_jwk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_jwk", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to bind to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace identifier tag.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace_id", value)

    @_builtins.property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input['WorkersScriptBindingOutboundArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input['WorkersScriptBindingOutboundArgs']]):
        pulumi.set(self, "outbound", value)

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pipeline to bind to.
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline", value)

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Queue to bind to.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "queue_name", value)

    @_builtins.property
    @pulumi.getter(name="scriptName")
    def script_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The script where the Durable Object is defined, if it is external to this Worker.
        """
        return pulumi.get(self, "script_name")

    @script_name.setter
    def script_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script_name", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the secret in the store.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of Worker to bind to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="storeId")
    def store_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the store containing the secret.
        """
        return pulumi.get(self, "store_id")

    @store_id.setter
    def store_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "store_id", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text value to use.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usages", value)

    @_builtins.property
    @pulumi.getter(name="workflowName")
    def workflow_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Workflow to bind to.
        """
        return pulumi.get(self, "workflow_name")

    @workflow_name.setter
    def workflow_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workflow_name", value)


if not MYPY:
    class WorkersScriptBindingOutboundArgsDict(TypedDict):
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        worker: NotRequired[pulumi.Input['WorkersScriptBindingOutboundWorkerArgsDict']]
        """
        Outbound worker.
        """
elif False:
    WorkersScriptBindingOutboundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptBindingOutboundArgs:
    def __init__(__self__, *,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 worker: Optional[pulumi.Input['WorkersScriptBindingOutboundWorkerArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] params: Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        :param pulumi.Input['WorkersScriptBindingOutboundWorkerArgs'] worker: Outbound worker.
        """
        if params is not None:
            pulumi.set(__self__, "params", params)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['WorkersScriptBindingOutboundWorkerArgs']]:
        """
        Outbound worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['WorkersScriptBindingOutboundWorkerArgs']]):
        pulumi.set(self, "worker", value)


if not MYPY:
    class WorkersScriptBindingOutboundWorkerArgsDict(TypedDict):
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Environment of the outbound worker.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the outbound worker.
        """
elif False:
    WorkersScriptBindingOutboundWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptBindingOutboundWorkerArgs:
    def __init__(__self__, *,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] environment: Environment of the outbound worker.
        :param pulumi.Input[_builtins.str] service: Name of the outbound worker.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Environment of the outbound worker.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the outbound worker.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class WorkersScriptLimitsArgsDict(TypedDict):
        cpu_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of CPU time this Worker can use in milliseconds.
        """
elif False:
    WorkersScriptLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptLimitsArgs:
    def __init__(__self__, *,
                 cpu_ms: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_ms: The amount of CPU time this Worker can use in milliseconds.
        """
        if cpu_ms is not None:
            pulumi.set(__self__, "cpu_ms", cpu_ms)

    @_builtins.property
    @pulumi.getter(name="cpuMs")
    def cpu_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of CPU time this Worker can use in milliseconds.
        """
        return pulumi.get(self, "cpu_ms")

    @cpu_ms.setter
    def cpu_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_ms", value)


if not MYPY:
    class WorkersScriptNamedHandlerArgsDict(TypedDict):
        handlers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The names of handlers exported as part of the named export.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the export.
        """
elif False:
    WorkersScriptNamedHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptNamedHandlerArgs:
    def __init__(__self__, *,
                 handlers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] handlers: The names of handlers exported as part of the named export.
        :param pulumi.Input[_builtins.str] name: The name of the export.
        """
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def handlers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The names of handlers exported as part of the named export.
        """
        return pulumi.get(self, "handlers")

    @handlers.setter
    def handlers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "handlers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the export.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkersScriptObservabilityArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether observability is enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        logs: NotRequired[pulumi.Input['WorkersScriptObservabilityLogsArgsDict']]
        """
        Log settings for the Worker.
        """
elif False:
    WorkersScriptObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptObservabilityArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 head_sampling_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 logs: Optional[pulumi.Input['WorkersScriptObservabilityLogsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether observability is enabled for the Worker.
        :param pulumi.Input[_builtins.float] head_sampling_rate: The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        :param pulumi.Input['WorkersScriptObservabilityLogsArgs'] logs: Log settings for the Worker.
        """
        pulumi.set(__self__, "enabled", enabled)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether observability is enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "head_sampling_rate", value)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['WorkersScriptObservabilityLogsArgs']]:
        """
        Log settings for the Worker.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['WorkersScriptObservabilityLogsArgs']]):
        pulumi.set(self, "logs", value)


if not MYPY:
    class WorkersScriptObservabilityLogsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether logs are enabled for the Worker.
        """
        invocation_logs: pulumi.Input[_builtins.bool]
        """
        Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
        head_sampling_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
elif False:
    WorkersScriptObservabilityLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptObservabilityLogsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 invocation_logs: pulumi.Input[_builtins.bool],
                 head_sampling_rate: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether logs are enabled for the Worker.
        :param pulumi.Input[_builtins.bool] invocation_logs: Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        :param pulumi.Input[_builtins.float] head_sampling_rate: The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "invocation_logs", invocation_logs)
        if head_sampling_rate is not None:
            pulumi.set(__self__, "head_sampling_rate", head_sampling_rate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether logs are enabled for the Worker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="invocationLogs")
    def invocation_logs(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
        """
        return pulumi.get(self, "invocation_logs")

    @invocation_logs.setter
    def invocation_logs(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "invocation_logs", value)

    @_builtins.property
    @pulumi.getter(name="headSamplingRate")
    def head_sampling_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
        """
        return pulumi.get(self, "head_sampling_rate")

    @head_sampling_rate.setter
    def head_sampling_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "head_sampling_rate", value)


if not MYPY:
    class WorkersScriptPlacementArgsDict(TypedDict):
        last_analyzed_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "smart".
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
        """
elif False:
    WorkersScriptPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptPlacementArgs:
    def __init__(__self__, *,
                 last_analyzed_at: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_analyzed_at: The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        :param pulumi.Input[_builtins.str] mode: Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
               Available values: "smart".
        :param pulumi.Input[_builtins.str] status: Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
               Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
        """
        if last_analyzed_at is not None:
            pulumi.set(__self__, "last_analyzed_at", last_analyzed_at)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="lastAnalyzedAt")
    def last_analyzed_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        """
        return pulumi.get(self, "last_analyzed_at")

    @last_analyzed_at.setter
    def last_analyzed_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_analyzed_at", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "smart".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
        Available values: "SUCCESS", "UNSUPPORTED*APPLICATION", "INSUFFICIENT*INVOCATIONS".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class WorkersScriptTailConsumerArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        Name of Worker that is to be the consumer.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional environment if the Worker utilizes one.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional dispatch namespace the script belongs to.
        """
elif False:
    WorkersScriptTailConsumerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkersScriptTailConsumerArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str],
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: Name of Worker that is to be the consumer.
        :param pulumi.Input[_builtins.str] environment: Optional environment if the Worker utilizes one.
        :param pulumi.Input[_builtins.str] namespace: Optional dispatch namespace the script belongs to.
        """
        pulumi.set(__self__, "service", service)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        Name of Worker that is to be the consumer.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional environment if the Worker utilizes one.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional dispatch namespace the script belongs to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ZeroTrustAccessApplicationCorsHeadersArgsDict(TypedDict):
        allow_all_headers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows all HTTP request headers.
        """
        allow_all_methods: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows all HTTP request methods.
        """
        allow_all_origins: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows all origins.
        """
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed HTTP request headers.
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed HTTP request methods.
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed origins.
        """
        max_age: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
elif False:
    ZeroTrustAccessApplicationCorsHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationCorsHeadersArgs:
    def __init__(__self__, *,
                 allow_all_headers: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_all_methods: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_all_origins: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_all_headers: Allows all HTTP request headers.
        :param pulumi.Input[_builtins.bool] allow_all_methods: Allows all HTTP request methods.
        :param pulumi.Input[_builtins.bool] allow_all_origins: Allows all origins.
        :param pulumi.Input[_builtins.bool] allow_credentials: When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: Allowed HTTP request headers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: Allowed HTTP request methods.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Allowed origins.
        :param pulumi.Input[_builtins.float] max_age: The maximum number of seconds the results of a preflight request can be cached.
        """
        if allow_all_headers is not None:
            pulumi.set(__self__, "allow_all_headers", allow_all_headers)
        if allow_all_methods is not None:
            pulumi.set(__self__, "allow_all_methods", allow_all_methods)
        if allow_all_origins is not None:
            pulumi.set(__self__, "allow_all_origins", allow_all_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowAllHeaders")
    def allow_all_headers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows all HTTP request headers.
        """
        return pulumi.get(self, "allow_all_headers")

    @allow_all_headers.setter
    def allow_all_headers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowAllMethods")
    def allow_all_methods(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows all HTTP request methods.
        """
        return pulumi.get(self, "allow_all_methods")

    @allow_all_methods.setter
    def allow_all_methods(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowAllOrigins")
    def allow_all_origins(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows all origins.
        """
        return pulumi.get(self, "allow_all_origins")

    @allow_all_origins.setter
    def allow_all_origins(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed HTTP request headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed HTTP request methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed origins.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum number of seconds the results of a preflight request can be cached.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class ZeroTrustAccessApplicationDestinationArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        l4_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        Available values: "tcp", "udp".
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "public", "private".
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
elif False:
    ZeroTrustAccessApplicationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationDestinationArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 l4_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: The CIDR range of the destination. Single IPs will be computed as /32.
        :param pulumi.Input[_builtins.str] hostname: The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        :param pulumi.Input[_builtins.str] l4_protocol: The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
               Available values: "tcp", "udp".
        :param pulumi.Input[_builtins.str] port_range: The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        :param pulumi.Input[_builtins.str] type: Available values: "public", "private".
        :param pulumi.Input[_builtins.str] uri: The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        :param pulumi.Input[_builtins.str] vnet_id: The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if l4_protocol is not None:
            pulumi.set(__self__, "l4_protocol", l4_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR range of the destination. Single IPs will be computed as /32.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="l4Protocol")
    def l4_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
        Available values: "tcp", "udp".
        """
        return pulumi.get(self, "l4_protocol")

    @l4_protocol.setter
    def l4_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "l4_protocol", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "public", "private".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VNET ID to match the destination. When omitted, all VNETs will match.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationFooterLinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The hypertext in the footer link.
        """
        url: pulumi.Input[_builtins.str]
        """
        the hyperlink in the footer link.
        """
elif False:
    ZeroTrustAccessApplicationFooterLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationFooterLinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The hypertext in the footer link.
        :param pulumi.Input[_builtins.str] url: the hyperlink in the footer link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The hypertext in the footer link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        the hyperlink in the footer link.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ZeroTrustAccessApplicationLandingPageDesignArgsDict(TypedDict):
        button_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color of the log in button on the landing page.
        """
        button_text_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The color of the text in the log in button on the landing page.
        """
        image_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the image shown on the landing page.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The message shown on the landing page.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title shown on the landing page.
        """
elif False:
    ZeroTrustAccessApplicationLandingPageDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationLandingPageDesignArgs:
    def __init__(__self__, *,
                 button_color: Optional[pulumi.Input[_builtins.str]] = None,
                 button_text_color: Optional[pulumi.Input[_builtins.str]] = None,
                 image_url: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] button_color: The background color of the log in button on the landing page.
        :param pulumi.Input[_builtins.str] button_text_color: The color of the text in the log in button on the landing page.
        :param pulumi.Input[_builtins.str] image_url: The URL of the image shown on the landing page.
        :param pulumi.Input[_builtins.str] message: The message shown on the landing page.
        :param pulumi.Input[_builtins.str] title: The title shown on the landing page.
        """
        if button_color is not None:
            pulumi.set(__self__, "button_color", button_color)
        if button_text_color is not None:
            pulumi.set(__self__, "button_text_color", button_text_color)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="buttonColor")
    def button_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color of the log in button on the landing page.
        """
        return pulumi.get(self, "button_color")

    @button_color.setter
    def button_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_color", value)

    @_builtins.property
    @pulumi.getter(name="buttonTextColor")
    def button_text_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The color of the text in the log in button on the landing page.
        """
        return pulumi.get(self, "button_text_color")

    @button_text_color.setter
    def button_text_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_text_color", value)

    @_builtins.property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the image shown on the landing page.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_url", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The message shown on the landing page.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title shown on the landing page.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyArgsDict(TypedDict):
        connection_rules: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict']]
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        decision: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        Available values: "allow", "deny", "non_identity", "bypass".
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgsDict']]]]
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UUID of the policy
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgsDict']]]]
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Access policy.
        """
        precedence: NotRequired[pulumi.Input[_builtins.int]]
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        requires: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgsDict']]]]
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
elif False:
    ZeroTrustAccessApplicationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyArgs:
    def __init__(__self__, *,
                 connection_rules: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs']] = None,
                 decision: Optional[pulumi.Input[_builtins.str]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 precedence: Optional[pulumi.Input[_builtins.int]] = None,
                 requires: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]]] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs'] connection_rules: The rules that define how users may connect to the targets secured by your application.
        :param pulumi.Input[_builtins.str] decision: The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
               Available values: "allow", "deny", "non_identity", "bypass".
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]] excludes: Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        :param pulumi.Input[_builtins.str] id: The UUID of the policy
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]] includes: Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        :param pulumi.Input[_builtins.str] name: The name of the Access policy.
        :param pulumi.Input[_builtins.int] precedence: The order of execution for this policy. Must be unique for each policy within an app.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]] requires: Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        if connection_rules is not None:
            pulumi.set(__self__, "connection_rules", connection_rules)
        if decision is not None:
            pulumi.set(__self__, "decision", decision)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if requires is not None:
            pulumi.set(__self__, "requires", requires)

    @_builtins.property
    @pulumi.getter(name="connectionRules")
    def connection_rules(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs']]:
        """
        The rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "connection_rules")

    @connection_rules.setter
    def connection_rules(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesArgs']]):
        pulumi.set(self, "connection_rules", value)

    @_builtins.property
    @pulumi.getter
    def decision(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
        Available values: "allow", "deny", "non_identity", "bypass".
        """
        return pulumi.get(self, "decision")

    @decision.setter
    def decision(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "decision", value)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]]]:
        """
        Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeArgs']]]]):
        pulumi.set(self, "excludes", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UUID of the policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]]]:
        """
        Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeArgs']]]]):
        pulumi.set(self, "includes", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Access policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The order of execution for this policy. Must be unique for each policy within an app.
        """
        return pulumi.get(self, "precedence")

    @precedence.setter
    def precedence(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "precedence", value)

    @_builtins.property
    @pulumi.getter
    def requires(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]]]:
        """
        Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
        """
        return pulumi.get(self, "requires")

    @requires.setter
    def requires(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireArgs']]]]):
        pulumi.set(self, "requires", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict(TypedDict):
        ssh: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict']]
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
elif False:
    ZeroTrustAccessApplicationPolicyConnectionRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyConnectionRulesArgs:
    def __init__(__self__, *,
                 ssh: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs'] ssh: The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @_builtins.property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs']]:
        """
        The SSH-specific rules that define how users may connect to the targets secured by your application.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict(TypedDict):
        usernames: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        allow_email_alias: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables using Identity Provider email alias as SSH username.
        """
elif False:
    ZeroTrustAccessApplicationPolicyConnectionRulesSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyConnectionRulesSshArgs:
    def __init__(__self__, *,
                 usernames: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allow_email_alias: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usernames: Contains the Unix usernames that may be used when connecting over SSH.
        :param pulumi.Input[_builtins.bool] allow_email_alias: Enables using Identity Provider email alias as SSH username.
        """
        pulumi.set(__self__, "usernames", usernames)
        if allow_email_alias is not None:
            pulumi.set(__self__, "allow_email_alias", allow_email_alias)

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Contains the Unix usernames that may be used when connecting over SSH.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "usernames", value)

    @_builtins.property
    @pulumi.getter(name="allowEmailAlias")
    def allow_email_alias(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables using Identity Provider email alias as SSH username.
        """
        return pulumi.get(self, "allow_email_alias")

    @allow_email_alias.setter
    def allow_email_alias(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_email_alias", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessApplicationPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessApplicationPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessApplicationPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessApplicationPolicyRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessApplicationPolicyRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationPolicyRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppArgsDict(TypedDict):
        access_token_lifetime: NotRequired[pulumi.Input[_builtins.str]]
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        allow_pkce_without_client_secret: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        app_launcher_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where this applications tile redirects users
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        Available values: "saml", "oidc".
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The application client id
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The application client secret, only returned on POST request.
        """
        consumer_service_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict']]]]
        custom_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict']]]]
        default_relay_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OIDC flows supported by this application
        """
        group_filter_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        hybrid_and_implicit_options: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict']]
        idp_entity_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier for your SaaS application.
        """
        name_id_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the name identifier sent to the SaaS application.
        Available values: "id", "email".
        """
        name_id_transform_jsonata: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Access public certificate that will be used to verify your identity.
        """
        redirect_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        refresh_token_options: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict']]
        saml_attribute_transform_jsonata: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        sp_entity_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A globally unique name for an identity or service provider.
        """
        sso_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The endpoint where your SaaS application will send login requests.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ZeroTrustAccessApplicationSaasAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppArgs:
    def __init__(__self__, *,
                 access_token_lifetime: Optional[pulumi.Input[_builtins.str]] = None,
                 allow_pkce_without_client_secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 app_launcher_url: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_service_url: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]] = None,
                 custom_claims: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[_builtins.str]] = None,
                 grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_filter_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 hybrid_and_implicit_options: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']] = None,
                 idp_entity_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name_id_format: Optional[pulumi.Input[_builtins.str]] = None,
                 name_id_transform_jsonata: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 refresh_token_options: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs']] = None,
                 saml_attribute_transform_jsonata: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sp_entity_id: Optional[pulumi.Input[_builtins.str]] = None,
                 sso_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_token_lifetime: The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        :param pulumi.Input[_builtins.bool] allow_pkce_without_client_secret: If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        :param pulumi.Input[_builtins.str] app_launcher_url: The URL where this applications tile redirects users
        :param pulumi.Input[_builtins.str] auth_type: Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
               Available values: "saml", "oidc".
        :param pulumi.Input[_builtins.str] client_id: The application client id
        :param pulumi.Input[_builtins.str] client_secret: The application client secret, only returned on POST request.
        :param pulumi.Input[_builtins.str] consumer_service_url: The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        :param pulumi.Input[_builtins.str] default_relay_state: The URL that the user will be redirected to after a successful login for IDP initiated logins.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] grant_types: The OIDC flows supported by this application
        :param pulumi.Input[_builtins.str] group_filter_regex: A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        :param pulumi.Input[_builtins.str] idp_entity_id: The unique identifier for your SaaS application.
        :param pulumi.Input[_builtins.str] name_id_format: The format of the name identifier sent to the SaaS application.
               Available values: "id", "email".
        :param pulumi.Input[_builtins.str] name_id_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        :param pulumi.Input[_builtins.str] public_key: The Access public certificate that will be used to verify your identity.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] redirect_uris: The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        :param pulumi.Input[_builtins.str] saml_attribute_transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        :param pulumi.Input[_builtins.str] sp_entity_id: A globally unique name for an identity or service provider.
        :param pulumi.Input[_builtins.str] sso_endpoint: The endpoint where your SaaS application will send login requests.
        """
        if access_token_lifetime is not None:
            pulumi.set(__self__, "access_token_lifetime", access_token_lifetime)
        if allow_pkce_without_client_secret is not None:
            pulumi.set(__self__, "allow_pkce_without_client_secret", allow_pkce_without_client_secret)
        if app_launcher_url is not None:
            pulumi.set(__self__, "app_launcher_url", app_launcher_url)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if consumer_service_url is not None:
            pulumi.set(__self__, "consumer_service_url", consumer_service_url)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if custom_claims is not None:
            pulumi.set(__self__, "custom_claims", custom_claims)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if grant_types is not None:
            pulumi.set(__self__, "grant_types", grant_types)
        if group_filter_regex is not None:
            pulumi.set(__self__, "group_filter_regex", group_filter_regex)
        if hybrid_and_implicit_options is not None:
            pulumi.set(__self__, "hybrid_and_implicit_options", hybrid_and_implicit_options)
        if idp_entity_id is not None:
            pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        if name_id_format is not None:
            pulumi.set(__self__, "name_id_format", name_id_format)
        if name_id_transform_jsonata is not None:
            pulumi.set(__self__, "name_id_transform_jsonata", name_id_transform_jsonata)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if refresh_token_options is not None:
            pulumi.set(__self__, "refresh_token_options", refresh_token_options)
        if saml_attribute_transform_jsonata is not None:
            pulumi.set(__self__, "saml_attribute_transform_jsonata", saml_attribute_transform_jsonata)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sso_endpoint is not None:
            pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="accessTokenLifetime")
    def access_token_lifetime(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
        """
        return pulumi.get(self, "access_token_lifetime")

    @access_token_lifetime.setter
    def access_token_lifetime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="allowPkceWithoutClientSecret")
    def allow_pkce_without_client_secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If client secret should be required on the token endpoint when authorization*code*with_pkce grant is used.
        """
        return pulumi.get(self, "allow_pkce_without_client_secret")

    @allow_pkce_without_client_secret.setter
    def allow_pkce_without_client_secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_pkce_without_client_secret", value)

    @_builtins.property
    @pulumi.getter(name="appLauncherUrl")
    def app_launcher_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where this applications tile redirects users
        """
        return pulumi.get(self, "app_launcher_url")

    @app_launcher_url.setter
    def app_launcher_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_launcher_url", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
        Available values: "saml", "oidc".
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The application client id
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The application client secret, only returned on POST request.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="consumerServiceUrl")
    def consumer_service_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
        """
        return pulumi.get(self, "consumer_service_url")

    @consumer_service_url.setter
    def consumer_service_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_service_url", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]]:
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @_builtins.property
    @pulumi.getter(name="customClaims")
    def custom_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]]:
        return pulumi.get(self, "custom_claims")

    @custom_claims.setter
    def custom_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimArgs']]]]):
        pulumi.set(self, "custom_claims", value)

    @_builtins.property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that the user will be redirected to after a successful login for IDP initiated logins.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_relay_state", value)

    @_builtins.property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OIDC flows supported by this application
        """
        return pulumi.get(self, "grant_types")

    @grant_types.setter
    def grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "grant_types", value)

    @_builtins.property
    @pulumi.getter(name="groupFilterRegex")
    def group_filter_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
        """
        return pulumi.get(self, "group_filter_regex")

    @group_filter_regex.setter
    def group_filter_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_filter_regex", value)

    @_builtins.property
    @pulumi.getter(name="hybridAndImplicitOptions")
    def hybrid_and_implicit_options(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']]:
        return pulumi.get(self, "hybrid_and_implicit_options")

    @hybrid_and_implicit_options.setter
    def hybrid_and_implicit_options(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs']]):
        pulumi.set(self, "hybrid_and_implicit_options", value)

    @_builtins.property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier for your SaaS application.
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idp_entity_id", value)

    @_builtins.property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the name identifier sent to the SaaS application.
        Available values: "id", "email".
        """
        return pulumi.get(self, "name_id_format")

    @name_id_format.setter
    def name_id_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_id_format", value)

    @_builtins.property
    @pulumi.getter(name="nameIdTransformJsonata")
    def name_id_transform_jsonata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
        """
        return pulumi.get(self, "name_id_transform_jsonata")

    @name_id_transform_jsonata.setter
    def name_id_transform_jsonata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_id_transform_jsonata", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Access public certificate that will be used to verify your identity.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "redirect_uris", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenOptions")
    def refresh_token_options(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs']]:
        return pulumi.get(self, "refresh_token_options")

    @refresh_token_options.setter
    def refresh_token_options(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs']]):
        pulumi.set(self, "refresh_token_options", value)

    @_builtins.property
    @pulumi.getter(name="samlAttributeTransformJsonata")
    def saml_attribute_transform_jsonata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml*attributes or oidc*fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
        """
        return pulumi.get(self, "saml_attribute_transform_jsonata")

    @saml_attribute_transform_jsonata.setter
    def saml_attribute_transform_jsonata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "saml_attribute_transform_jsonata", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A globally unique name for an identity or service provider.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sp_entity_id", value)

    @_builtins.property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The endpoint where your SaaS application will send login requests.
        """
        return pulumi.get(self, "sso_endpoint")

    @sso_endpoint.setter
    def sso_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sso_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict(TypedDict):
        friendly_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SAML FriendlyName of the attribute.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the attribute.
        """
        name_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        A globally unique name for an identity or service provider.
        Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the attribute is required when building a SAML assertion.
        """
        source: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict']]
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeArgs:
    def __init__(__self__, *,
                 friendly_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_format: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 source: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] friendly_name: The SAML FriendlyName of the attribute.
        :param pulumi.Input[_builtins.str] name: The name of the attribute.
        :param pulumi.Input[_builtins.str] name_format: A globally unique name for an identity or service provider.
               Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
        :param pulumi.Input[_builtins.bool] required: If the attribute is required when building a SAML assertion.
        """
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_format is not None:
            pulumi.set(__self__, "name_format", name_format)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SAML FriendlyName of the attribute.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "friendly_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameFormat")
    def name_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A globally unique name for an identity or service provider.
        Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
        """
        return pulumi.get(self, "name_format")

    @name_format.setter
    def name_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_format", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the attribute is required when building a SAML assertion.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the IdP attribute.
        """
        name_by_idps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict']]]]
        """
        A mapping from IdP ID to attribute name.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_by_idps: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the IdP attribute.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]] name_by_idps: A mapping from IdP ID to attribute name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idps is not None:
            pulumi.set(__self__, "name_by_idps", name_by_idps)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the IdP attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameByIdps")
    def name_by_idps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]]:
        """
        A mapping from IdP ID to attribute name.
        """
        return pulumi.get(self, "name_by_idps")

    @name_by_idps.setter
    def name_by_idps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs']]]]):
        pulumi.set(self, "name_by_idps", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict(TypedDict):
        idp_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UID of the IdP.
        """
        source_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the IdP provided attribute.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomAttributeSourceNameByIdpArgs:
    def __init__(__self__, *,
                 idp_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] idp_id: The UID of the IdP.
        :param pulumi.Input[_builtins.str] source_name: The name of the IdP provided attribute.
        """
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @_builtins.property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UID of the IdP.
        """
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "idp_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the IdP provided attribute.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_name", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the claim.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the claim is required when building an OIDC token.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope of the claim.
        Available values: "groups", "profile", "email", "openid".
        """
        source: NotRequired[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict']]
elif False:
    ZeroTrustAccessApplicationSaasAppCustomClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomClaimArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the claim.
        :param pulumi.Input[_builtins.bool] required: If the claim is required when building an OIDC token.
        :param pulumi.Input[_builtins.str] scope: The scope of the claim.
               Available values: "groups", "profile", "email", "openid".
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the claim is required when building an OIDC token.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope of the claim.
        Available values: "groups", "profile", "email", "openid".
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the IdP claim.
        """
        name_by_idp: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A mapping from IdP ID to claim name.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppCustomClaimSourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 name_by_idp: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the IdP claim.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] name_by_idp: A mapping from IdP ID to claim name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_by_idp is not None:
            pulumi.set(__self__, "name_by_idp", name_by_idp)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the IdP claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nameByIdp")
    def name_by_idp(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A mapping from IdP ID to claim name.
        """
        return pulumi.get(self, "name_by_idp")

    @name_by_idp.setter
    def name_by_idp(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "name_by_idp", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict(TypedDict):
        return_access_token_from_authorization_endpoint: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return_id_token_from_authorization_endpoint: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
elif False:
    ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptionsArgs:
    def __init__(__self__, *,
                 return_access_token_from_authorization_endpoint: Optional[pulumi.Input[_builtins.bool]] = None,
                 return_id_token_from_authorization_endpoint: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] return_access_token_from_authorization_endpoint: If an Access Token should be returned from the OIDC Authorization endpoint
        :param pulumi.Input[_builtins.bool] return_id_token_from_authorization_endpoint: If an ID Token should be returned from the OIDC Authorization endpoint
        """
        if return_access_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_access_token_from_authorization_endpoint", return_access_token_from_authorization_endpoint)
        if return_id_token_from_authorization_endpoint is not None:
            pulumi.set(__self__, "return_id_token_from_authorization_endpoint", return_id_token_from_authorization_endpoint)

    @_builtins.property
    @pulumi.getter(name="returnAccessTokenFromAuthorizationEndpoint")
    def return_access_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an Access Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_access_token_from_authorization_endpoint")

    @return_access_token_from_authorization_endpoint.setter
    def return_access_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_access_token_from_authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="returnIdTokenFromAuthorizationEndpoint")
    def return_id_token_from_authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an ID Token should be returned from the OIDC Authorization endpoint
        """
        return pulumi.get(self, "return_id_token_from_authorization_endpoint")

    @return_id_token_from_authorization_endpoint.setter
    def return_id_token_from_authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_id_token_from_authorization_endpoint", value)


if not MYPY:
    class ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict(TypedDict):
        lifetime: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
elif False:
    ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationSaasAppRefreshTokenOptionsArgs:
    def __init__(__self__, *,
                 lifetime: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] lifetime: How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        if lifetime is not None:
            pulumi.set(__self__, "lifetime", lifetime)

    @_builtins.property
    @pulumi.getter
    def lifetime(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
        """
        return pulumi.get(self, "lifetime")

    @lifetime.setter
    def lifetime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lifetime", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigArgsDict(TypedDict):
        idp_uid: pulumi.Input[_builtins.str]
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        remote_uri: pulumi.Input[_builtins.str]
        """
        The base URI for the application's SCIM-compatible API.
        """
        authentication: NotRequired[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict']]
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        deactivate_on_delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether SCIM provisioning is turned on for this application.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgsDict']]]]
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigArgs:
    def __init__(__self__, *,
                 idp_uid: pulumi.Input[_builtins.str],
                 remote_uri: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']] = None,
                 deactivate_on_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] idp_uid: The UID of the IdP to use as the source for SCIM resources to provision to this application.
        :param pulumi.Input[_builtins.str] remote_uri: The base URI for the application's SCIM-compatible API.
        :param pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs'] authentication: Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        :param pulumi.Input[_builtins.bool] deactivate_on_delete: If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        :param pulumi.Input[_builtins.bool] enabled: Whether SCIM provisioning is turned on for this application.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]] mappings: A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        pulumi.set(__self__, "idp_uid", idp_uid)
        pulumi.set(__self__, "remote_uri", remote_uri)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if deactivate_on_delete is not None:
            pulumi.set(__self__, "deactivate_on_delete", deactivate_on_delete)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @_builtins.property
    @pulumi.getter(name="idpUid")
    def idp_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The UID of the IdP to use as the source for SCIM resources to provision to this application.
        """
        return pulumi.get(self, "idp_uid")

    @idp_uid.setter
    def idp_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "idp_uid", value)

    @_builtins.property
    @pulumi.getter(name="remoteUri")
    def remote_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The base URI for the application's SCIM-compatible API.
        """
        return pulumi.get(self, "remote_uri")

    @remote_uri.setter
    def remote_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "remote_uri", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']]:
        """
        Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter(name="deactivateOnDelete")
    def deactivate_on_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
        """
        return pulumi.get(self, "deactivate_on_delete")

    @deactivate_on_delete.setter
    def deactivate_on_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deactivate_on_delete", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether SCIM provisioning is turned on for this application.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]]:
        """
        A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict(TypedDict):
        scheme: pulumi.Input[_builtins.str]
        """
        The authentication scheme to use when making SCIM requests to this application.
        Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
        """
        authorization_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL used to generate the auth code used during token generation.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password used to authenticate with the remote SCIM service.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Token used to authenticate with the remote SCIM service.
        """
        token_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        User name used to authenticate with the remote SCIM service.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigAuthenticationArgs:
    def __init__(__self__, *,
                 scheme: pulumi.Input[_builtins.str],
                 authorization_url: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 token_url: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] scheme: The authentication scheme to use when making SCIM requests to this application.
               Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
        :param pulumi.Input[_builtins.str] authorization_url: URL used to generate the auth code used during token generation.
        :param pulumi.Input[_builtins.str] client_id: Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        :param pulumi.Input[_builtins.str] client_secret: Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        :param pulumi.Input[_builtins.str] password: Password used to authenticate with the remote SCIM service.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        :param pulumi.Input[_builtins.str] token: Token used to authenticate with the remote SCIM service.
        :param pulumi.Input[_builtins.str] token_url: URL used to generate the token used to authenticate with the remote SCIM service.
        :param pulumi.Input[_builtins.str] user: User name used to authenticate with the remote SCIM service.
        """
        pulumi.set(__self__, "scheme", scheme)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication scheme to use when making SCIM requests to this application.
        Available values: "httpbasic", "oauthbearertoken", "oauth2", "access*service*token".
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL used to generate the auth code used during token generation.
        """
        return pulumi.get(self, "authorization_url")

    @authorization_url.setter
    def authorization_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL used to generate the token used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User name used to authenticate with the remote SCIM service.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigMappingArgsDict(TypedDict):
        schema: pulumi.Input[_builtins.str]
        """
        Which SCIM resource type this mapping applies to.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping is enabled.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        operations: NotRequired[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict']]
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        strictness: NotRequired[pulumi.Input[_builtins.str]]
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        Available values: "strict", "passthrough".
        """
        transform_jsonata: NotRequired[pulumi.Input[_builtins.str]]
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigMappingArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 operations: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']] = None,
                 strictness: Optional[pulumi.Input[_builtins.str]] = None,
                 transform_jsonata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] schema: Which SCIM resource type this mapping applies to.
        :param pulumi.Input[_builtins.bool] enabled: Whether or not this mapping is enabled.
        :param pulumi.Input[_builtins.str] filter: A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        :param pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs'] operations: Whether or not this mapping applies to creates, updates, or deletes.
        :param pulumi.Input[_builtins.str] strictness: The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
               Available values: "strict", "passthrough".
        :param pulumi.Input[_builtins.str] transform_jsonata: A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        pulumi.set(__self__, "schema", schema)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if strictness is not None:
            pulumi.set(__self__, "strictness", strictness)
        if transform_jsonata is not None:
            pulumi.set(__self__, "transform_jsonata", transform_jsonata)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> pulumi.Input[_builtins.str]:
        """
        Which SCIM resource type this mapping applies to.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']]:
        """
        Whether or not this mapping applies to creates, updates, or deletes.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input['ZeroTrustAccessApplicationScimConfigMappingOperationsArgs']]):
        pulumi.set(self, "operations", value)

    @_builtins.property
    @pulumi.getter
    def strictness(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
        Available values: "strict", "passthrough".
        """
        return pulumi.get(self, "strictness")

    @strictness.setter
    def strictness(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strictness", value)

    @_builtins.property
    @pulumi.getter(name="transformJsonata")
    def transform_jsonata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
        """
        return pulumi.get(self, "transform_jsonata")

    @transform_jsonata.setter
    def transform_jsonata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transform_jsonata", value)


if not MYPY:
    class ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping applies to DELETE operations.
        """
        update: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
elif False:
    ZeroTrustAccessApplicationScimConfigMappingOperationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationScimConfigMappingOperationsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 update: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] create: Whether or not this mapping applies to create (POST) operations.
        :param pulumi.Input[_builtins.bool] delete: Whether or not this mapping applies to DELETE operations.
        :param pulumi.Input[_builtins.bool] update: Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping applies to create (POST) operations.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping applies to DELETE operations.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not this mapping applies to update (PATCH/PUT) operations.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class ZeroTrustAccessApplicationTargetCriteriaArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The communication protocol your application secures.
        Available values: "SSH", "RDP".
        """
        target_attributes: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]
        """
        Contains a map of target attribute keys to target attribute values.
        """
elif False:
    ZeroTrustAccessApplicationTargetCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessApplicationTargetCriteriaArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 target_attributes: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]):
        """
        :param pulumi.Input[_builtins.int] port: The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        :param pulumi.Input[_builtins.str] protocol: The communication protocol your application secures.
               Available values: "SSH", "RDP".
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] target_attributes: Contains a map of target attribute keys to target attribute values.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_attributes", target_attributes)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The communication protocol your application secures.
        Available values: "SSH", "RDP".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetAttributes")
    def target_attributes(self) -> pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]:
        """
        Contains a map of target attribute keys to target attribute values.
        """
        return pulumi.get(self, "target_attributes")

    @target_attributes.setter
    def target_attributes(self, value: pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]):
        pulumi.set(self, "target_attributes", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessGroupExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessGroupExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessGroupExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessGroupExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessGroupExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessGroupExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessGroupExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessGroupExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessGroupExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessGroupExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessGroupExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessGroupExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessGroupExcludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessGroupExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessGroupExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessGroupIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessGroupIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessGroupIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessGroupIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessGroupIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessGroupIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessGroupIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessGroupIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessGroupIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessGroupIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessGroupIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessGroupIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessGroupIncludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessGroupIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessGroupIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessGroupRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessGroupRequireLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessGroupRequireOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessGroupRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessGroupRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessGroupRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessGroupRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessGroupRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessGroupRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessGroupRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessGroupRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessGroupRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessGroupRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessGroupRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessGroupRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessGroupRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessGroupRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessGroupRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessGroupRequireLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessGroupRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessGroupRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessGroupRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessGroupRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessGroupRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderConfigArgsDict(TypedDict):
        apps_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your companies TLD
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        auth_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authorization_endpoint URL of your IdP
        """
        authorization_server_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your okta authorization server id
        """
        centrify_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your centrify account url
        """
        centrify_app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your centrify app id
        """
        certs_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom claims
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your OAuth Client ID
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your OAuth Client Secret
        """
        conditional_access_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        directory_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your Azure directory uuid
        """
        email_attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attribute name for email in the SAML response.
        """
        email_claim_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The claim name for email in the id_token response.
        """
        header_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict']]]]
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        idp_public_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        issuer_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        IdP Entity ID or Issuer URL
        """
        okta_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your okta account url
        """
        onelogin_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your OneLogin account url
        """
        ping_env_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your PingOne environment identifier
        """
        pkce_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        Available values: "login", "select_account", "none".
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        OAuth scopes
        """
        sign_request: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        sso_target_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL to send the SAML authentication requests to
        """
        support_groups: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Should Cloudflare try to load groups from your account
        """
        token_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The token_endpoint URL of your IdP
        """
elif False:
    ZeroTrustAccessIdentityProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderConfigArgs:
    def __init__(__self__, *,
                 apps_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 auth_url: Optional[pulumi.Input[_builtins.str]] = None,
                 authorization_server_id: Optional[pulumi.Input[_builtins.str]] = None,
                 centrify_account: Optional[pulumi.Input[_builtins.str]] = None,
                 centrify_app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certs_url: Optional[pulumi.Input[_builtins.str]] = None,
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 conditional_access_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 directory_id: Optional[pulumi.Input[_builtins.str]] = None,
                 email_attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 email_claim_name: Optional[pulumi.Input[_builtins.str]] = None,
                 header_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]]] = None,
                 idp_public_certs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 issuer_url: Optional[pulumi.Input[_builtins.str]] = None,
                 okta_account: Optional[pulumi.Input[_builtins.str]] = None,
                 onelogin_account: Optional[pulumi.Input[_builtins.str]] = None,
                 ping_env_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pkce_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sign_request: Optional[pulumi.Input[_builtins.bool]] = None,
                 sso_target_url: Optional[pulumi.Input[_builtins.str]] = None,
                 support_groups: Optional[pulumi.Input[_builtins.bool]] = None,
                 token_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apps_domain: Your companies TLD
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] attributes: A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        :param pulumi.Input[_builtins.str] auth_url: The authorization_endpoint URL of your IdP
        :param pulumi.Input[_builtins.str] authorization_server_id: Your okta authorization server id
        :param pulumi.Input[_builtins.str] centrify_account: Your centrify account url
        :param pulumi.Input[_builtins.str] centrify_app_id: Your centrify app id
        :param pulumi.Input[_builtins.str] certs_url: The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] claims: Custom claims
        :param pulumi.Input[_builtins.str] client_id: Your OAuth Client ID
        :param pulumi.Input[_builtins.str] client_secret: Your OAuth Client Secret
        :param pulumi.Input[_builtins.bool] conditional_access_enabled: Should Cloudflare try to load authentication contexts from your account
        :param pulumi.Input[_builtins.str] directory_id: Your Azure directory uuid
        :param pulumi.Input[_builtins.str] email_attribute_name: The attribute name for email in the SAML response.
        :param pulumi.Input[_builtins.str] email_claim_name: The claim name for email in the id_token response.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]] header_attributes: Add a list of attribute names that will be returned in the response header from the Access callback.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] idp_public_certs: X509 certificate to verify the signature in the SAML authentication response
        :param pulumi.Input[_builtins.str] issuer_url: IdP Entity ID or Issuer URL
        :param pulumi.Input[_builtins.str] okta_account: Your okta account url
        :param pulumi.Input[_builtins.str] onelogin_account: Your OneLogin account url
        :param pulumi.Input[_builtins.str] ping_env_id: Your PingOne environment identifier
        :param pulumi.Input[_builtins.bool] pkce_enabled: Enable Proof Key for Code Exchange (PKCE)
        :param pulumi.Input[_builtins.str] prompt: Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
               Available values: "login", "select_account", "none".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: OAuth scopes
        :param pulumi.Input[_builtins.bool] sign_request: Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        :param pulumi.Input[_builtins.str] sso_target_url: URL to send the SAML authentication requests to
        :param pulumi.Input[_builtins.bool] support_groups: Should Cloudflare try to load groups from your account
        :param pulumi.Input[_builtins.str] token_url: The token_endpoint URL of your IdP
        """
        if apps_domain is not None:
            pulumi.set(__self__, "apps_domain", apps_domain)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if centrify_account is not None:
            pulumi.set(__self__, "centrify_account", centrify_account)
        if centrify_app_id is not None:
            pulumi.set(__self__, "centrify_app_id", centrify_app_id)
        if certs_url is not None:
            pulumi.set(__self__, "certs_url", certs_url)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if conditional_access_enabled is not None:
            pulumi.set(__self__, "conditional_access_enabled", conditional_access_enabled)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if email_attribute_name is not None:
            pulumi.set(__self__, "email_attribute_name", email_attribute_name)
        if email_claim_name is not None:
            pulumi.set(__self__, "email_claim_name", email_claim_name)
        if header_attributes is not None:
            pulumi.set(__self__, "header_attributes", header_attributes)
        if idp_public_certs is not None:
            pulumi.set(__self__, "idp_public_certs", idp_public_certs)
        if issuer_url is not None:
            pulumi.set(__self__, "issuer_url", issuer_url)
        if okta_account is not None:
            pulumi.set(__self__, "okta_account", okta_account)
        if onelogin_account is not None:
            pulumi.set(__self__, "onelogin_account", onelogin_account)
        if ping_env_id is not None:
            pulumi.set(__self__, "ping_env_id", ping_env_id)
        if pkce_enabled is not None:
            pulumi.set(__self__, "pkce_enabled", pkce_enabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)
        if sso_target_url is not None:
            pulumi.set(__self__, "sso_target_url", sso_target_url)
        if support_groups is not None:
            pulumi.set(__self__, "support_groups", support_groups)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @_builtins.property
    @pulumi.getter(name="appsDomain")
    def apps_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your companies TLD
        """
        return pulumi.get(self, "apps_domain")

    @apps_domain.setter
    def apps_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apps_domain", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authorization_endpoint URL of your IdP
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_url", value)

    @_builtins.property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your okta authorization server id
        """
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_server_id", value)

    @_builtins.property
    @pulumi.getter(name="centrifyAccount")
    def centrify_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your centrify account url
        """
        return pulumi.get(self, "centrify_account")

    @centrify_account.setter
    def centrify_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "centrify_account", value)

    @_builtins.property
    @pulumi.getter(name="centrifyAppId")
    def centrify_app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your centrify app id
        """
        return pulumi.get(self, "centrify_app_id")

    @centrify_app_id.setter
    def centrify_app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "centrify_app_id", value)

    @_builtins.property
    @pulumi.getter(name="certsUrl")
    def certs_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
        """
        return pulumi.get(self, "certs_url")

    @certs_url.setter
    def certs_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certs_url", value)

    @_builtins.property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom claims
        """
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claims", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your OAuth Client ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your OAuth Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="conditionalAccessEnabled")
    def conditional_access_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Should Cloudflare try to load authentication contexts from your account
        """
        return pulumi.get(self, "conditional_access_enabled")

    @conditional_access_enabled.setter
    def conditional_access_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "conditional_access_enabled", value)

    @_builtins.property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your Azure directory uuid
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "directory_id", value)

    @_builtins.property
    @pulumi.getter(name="emailAttributeName")
    def email_attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attribute name for email in the SAML response.
        """
        return pulumi.get(self, "email_attribute_name")

    @email_attribute_name.setter
    def email_attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="emailClaimName")
    def email_claim_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The claim name for email in the id_token response.
        """
        return pulumi.get(self, "email_claim_name")

    @email_claim_name.setter
    def email_claim_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_claim_name", value)

    @_builtins.property
    @pulumi.getter(name="headerAttributes")
    def header_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]]]:
        """
        Add a list of attribute names that will be returned in the response header from the Access callback.
        """
        return pulumi.get(self, "header_attributes")

    @header_attributes.setter
    def header_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs']]]]):
        pulumi.set(self, "header_attributes", value)

    @_builtins.property
    @pulumi.getter(name="idpPublicCerts")
    def idp_public_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        X509 certificate to verify the signature in the SAML authentication response
        """
        return pulumi.get(self, "idp_public_certs")

    @idp_public_certs.setter
    def idp_public_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "idp_public_certs", value)

    @_builtins.property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IdP Entity ID or Issuer URL
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer_url", value)

    @_builtins.property
    @pulumi.getter(name="oktaAccount")
    def okta_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your okta account url
        """
        return pulumi.get(self, "okta_account")

    @okta_account.setter
    def okta_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "okta_account", value)

    @_builtins.property
    @pulumi.getter(name="oneloginAccount")
    def onelogin_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your OneLogin account url
        """
        return pulumi.get(self, "onelogin_account")

    @onelogin_account.setter
    def onelogin_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "onelogin_account", value)

    @_builtins.property
    @pulumi.getter(name="pingEnvId")
    def ping_env_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your PingOne environment identifier
        """
        return pulumi.get(self, "ping_env_id")

    @ping_env_id.setter
    def ping_env_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ping_env_id", value)

    @_builtins.property
    @pulumi.getter(name="pkceEnabled")
    def pkce_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Proof Key for Code Exchange (PKCE)
        """
        return pulumi.get(self, "pkce_enabled")

    @pkce_enabled.setter
    def pkce_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pkce_enabled", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction*required error. prompt=select*account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
        Available values: "login", "select_account", "none".
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sign_request", value)

    @_builtins.property
    @pulumi.getter(name="ssoTargetUrl")
    def sso_target_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL to send the SAML authentication requests to
        """
        return pulumi.get(self, "sso_target_url")

    @sso_target_url.setter
    def sso_target_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sso_target_url", value)

    @_builtins.property
    @pulumi.getter(name="supportGroups")
    def support_groups(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Should Cloudflare try to load groups from your account
        """
        return pulumi.get(self, "support_groups")

    @support_groups.setter
    def support_groups(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "support_groups", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The token_endpoint URL of your IdP
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        attribute name from the IDP
        """
        header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        header that will be added on the request to the origin
        """
elif False:
    ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderConfigHeaderAttributeArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 header_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_name: attribute name from the IDP
        :param pulumi.Input[_builtins.str] header_name: header that will be added on the request to the origin
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        attribute name from the IDP
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        header that will be added on the request to the origin
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_name", value)


if not MYPY:
    class ZeroTrustAccessIdentityProviderScimConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        identity_update_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        Available values: "automatic", "reauth", "no*action".
        """
        scim_base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        seat_deprovision: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        user_deprovision: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
elif False:
    ZeroTrustAccessIdentityProviderScimConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessIdentityProviderScimConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 identity_update_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 scim_base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 seat_deprovision: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 user_deprovision: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: A flag to enable or disable SCIM for the identity provider.
        :param pulumi.Input[_builtins.str] identity_update_behavior: Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
               Available values: "automatic", "reauth", "no*action".
        :param pulumi.Input[_builtins.str] scim_base_url: The base URL of Cloudflare's SCIM V2.0 API endpoint.
        :param pulumi.Input[_builtins.bool] seat_deprovision: A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        :param pulumi.Input[_builtins.str] secret: A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        :param pulumi.Input[_builtins.bool] user_deprovision: A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if identity_update_behavior is not None:
            pulumi.set(__self__, "identity_update_behavior", identity_update_behavior)
        if scim_base_url is not None:
            pulumi.set(__self__, "scim_base_url", scim_base_url)
        if seat_deprovision is not None:
            pulumi.set(__self__, "seat_deprovision", seat_deprovision)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if user_deprovision is not None:
            pulumi.set(__self__, "user_deprovision", user_deprovision)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to enable or disable SCIM for the identity provider.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="identityUpdateBehavior")
    def identity_update_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no*action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
        Available values: "automatic", "reauth", "no*action".
        """
        return pulumi.get(self, "identity_update_behavior")

    @identity_update_behavior.setter
    def identity_update_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_update_behavior", value)

    @_builtins.property
    @pulumi.getter(name="scimBaseUrl")
    def scim_base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL of Cloudflare's SCIM V2.0 API endpoint.
        """
        return pulumi.get(self, "scim_base_url")

    @scim_base_url.setter
    def scim_base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scim_base_url", value)

    @_builtins.property
    @pulumi.getter(name="seatDeprovision")
    def seat_deprovision(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
        """
        return pulumi.get(self, "seat_deprovision")

    @seat_deprovision.setter
    def seat_deprovision(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "seat_deprovision", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity*providers/:idpID/refresh*scim_secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="userDeprovision")
    def user_deprovision(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
        """
        return pulumi.get(self, "user_deprovision")

    @user_deprovision.setter
    def user_deprovision(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "user_deprovision", value)


if not MYPY:
    class ZeroTrustAccessInfrastructureTargetIpArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict']]
        """
        The target's IPv4 address
        """
        ipv6: NotRequired[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict']]
        """
        The target's IPv6 address
        """
elif False:
    ZeroTrustAccessInfrastructureTargetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessInfrastructureTargetIpArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args'] ipv4: The target's IPv4 address
        :param pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args'] ipv6: The target's IPv6 address
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args']]:
        """
        The target's IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args']]:
        """
        The target's IPv6 address
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['ZeroTrustAccessInfrastructureTargetIpIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict(TypedDict):
        ip_addr: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address of the target
        """
        virtual_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
elif False:
    ZeroTrustAccessInfrastructureTargetIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessInfrastructureTargetIpIpv4Args:
    def __init__(__self__, *,
                 ip_addr: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_network_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_addr: IP address of the target
        :param pulumi.Input[_builtins.str] virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        if ip_addr is not None:
            pulumi.set(__self__, "ip_addr", ip_addr)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @_builtins.property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_addr", value)

    @_builtins.property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict(TypedDict):
        ip_addr: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address of the target
        """
        virtual_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
elif False:
    ZeroTrustAccessInfrastructureTargetIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessInfrastructureTargetIpIpv6Args:
    def __init__(__self__, *,
                 ip_addr: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_network_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_addr: IP address of the target
        :param pulumi.Input[_builtins.str] virtual_network_id: (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        if ip_addr is not None:
            pulumi.set(__self__, "ip_addr", ip_addr)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @_builtins.property
    @pulumi.getter(name="ipAddr")
    def ip_addr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address of the target
        """
        return pulumi.get(self, "ip_addr")

    @ip_addr.setter
    def ip_addr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_addr", value)

    @_builtins.property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict(TypedDict):
        china_network: pulumi.Input[_builtins.bool]
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        client_certificate_forwarding: pulumi.Input[_builtins.bool]
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        hostname: pulumi.Input[_builtins.str]
        """
        The hostname that these settings apply to.
        """
elif False:
    ZeroTrustAccessMtlsHostnameSettingsSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessMtlsHostnameSettingsSettingArgs:
    def __init__(__self__, *,
                 china_network: pulumi.Input[_builtins.bool],
                 client_certificate_forwarding: pulumi.Input[_builtins.bool],
                 hostname: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] china_network: Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        :param pulumi.Input[_builtins.bool] client_certificate_forwarding: Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        :param pulumi.Input[_builtins.str] hostname: The hostname that these settings apply to.
        """
        pulumi.set(__self__, "china_network", china_network)
        pulumi.set(__self__, "client_certificate_forwarding", client_certificate_forwarding)
        pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter(name="chinaNetwork")
    def china_network(self) -> pulumi.Input[_builtins.bool]:
        """
        Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
        """
        return pulumi.get(self, "china_network")

    @china_network.setter
    def china_network(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "china_network", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificateForwarding")
    def client_certificate_forwarding(self) -> pulumi.Input[_builtins.bool]:
        """
        Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
        """
        return pulumi.get(self, "client_certificate_forwarding")

    @client_certificate_forwarding.setter
    def client_certificate_forwarding(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "client_certificate_forwarding", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname that these settings apply to.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class ZeroTrustAccessPolicyApprovalGroupArgsDict(TypedDict):
        approvals_needed: pulumi.Input[_builtins.float]
        """
        The number of approvals needed to obtain access.
        """
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of emails that can approve the access request.
        """
        email_list_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UUID of an re-usable email list.
        """
elif False:
    ZeroTrustAccessPolicyApprovalGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyApprovalGroupArgs:
    def __init__(__self__, *,
                 approvals_needed: pulumi.Input[_builtins.float],
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 email_list_uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] approvals_needed: The number of approvals needed to obtain access.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] email_addresses: A list of emails that can approve the access request.
        :param pulumi.Input[_builtins.str] email_list_uuid: The UUID of an re-usable email list.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)
        if email_list_uuid is not None:
            pulumi.set(__self__, "email_list_uuid", email_list_uuid)

    @_builtins.property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> pulumi.Input[_builtins.float]:
        """
        The number of approvals needed to obtain access.
        """
        return pulumi.get(self, "approvals_needed")

    @approvals_needed.setter
    def approvals_needed(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "approvals_needed", value)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of emails that can approve the access request.
        """
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "email_addresses", value)

    @_builtins.property
    @pulumi.getter(name="emailListUuid")
    def email_list_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UUID of an re-usable email list.
        """
        return pulumi.get(self, "email_list_uuid")

    @email_list_uuid.setter
    def email_list_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email_list_uuid", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessPolicyExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyExcludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyExcludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyExcludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessPolicyExcludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessPolicyExcludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessPolicyExcludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessPolicyExcludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessPolicyExcludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyExcludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyExcludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessPolicyExcludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessPolicyExcludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessPolicyExcludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessPolicyExcludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessPolicyExcludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyExcludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyExcludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessPolicyExcludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyExcludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessPolicyIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyIncludeServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyIncludeCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyIncludeCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessPolicyIncludeCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessPolicyIncludeDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessPolicyIncludeEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessPolicyIncludeEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessPolicyIncludeEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyIncludeEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyIncludeExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessPolicyIncludeGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessPolicyIncludeIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessPolicyIncludeIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessPolicyIncludeLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessPolicyIncludeOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyIncludeSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyIncludeServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessPolicyIncludeServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyIncludeServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireArgsDict(TypedDict):
        any_valid_service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict']]
        """
        An empty object which matches on all service tokens.
        """
        auth_context: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgsDict']]
        auth_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgsDict']]
        azure_ad: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgsDict']]
        certificate: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgsDict']]
        common_name: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgsDict']]
        device_posture: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgsDict']]
        email: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgsDict']]
        email_domain: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgsDict']]
        email_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgsDict']]
        everyone: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgsDict']]
        """
        An empty object which matches on all users.
        """
        external_evaluation: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict']]
        geo: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgsDict']]
        github_organization: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict']]
        group: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgsDict']]
        gsuite: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgsDict']]
        ip: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgsDict']]
        ip_list: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgsDict']]
        linked_app_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireLinkedAppTokenArgsDict']]
        login_method: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgsDict']]
        oidc: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireOidcArgsDict']]
        okta: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgsDict']]
        saml: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgsDict']]
        service_token: NotRequired[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgsDict']]
elif False:
    ZeroTrustAccessPolicyRequireArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireArgs:
    def __init__(__self__, *,
                 any_valid_service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs']] = None,
                 auth_context: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']] = None,
                 auth_method: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgs']] = None,
                 azure_ad: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgs']] = None,
                 common_name: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgs']] = None,
                 device_posture: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgs']] = None,
                 email: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgs']] = None,
                 email_domain: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgs']] = None,
                 email_list: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgs']] = None,
                 everyone: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs']] = None,
                 external_evaluation: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']] = None,
                 geo: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgs']] = None,
                 github_organization: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgs']] = None,
                 group: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgs']] = None,
                 gsuite: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']] = None,
                 ip: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgs']] = None,
                 ip_list: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgs']] = None,
                 linked_app_token: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLinkedAppTokenArgs']] = None,
                 login_method: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgs']] = None,
                 oidc: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOidcArgs']] = None,
                 okta: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']] = None,
                 saml: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']] = None,
                 service_token: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs'] any_valid_service_token: An empty object which matches on all service tokens.
        :param pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs'] everyone: An empty object which matches on all users.
        """
        if any_valid_service_token is not None:
            pulumi.set(__self__, "any_valid_service_token", any_valid_service_token)
        if auth_context is not None:
            pulumi.set(__self__, "auth_context", auth_context)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if azure_ad is not None:
            pulumi.set(__self__, "azure_ad", azure_ad)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if device_posture is not None:
            pulumi.set(__self__, "device_posture", device_posture)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_domain is not None:
            pulumi.set(__self__, "email_domain", email_domain)
        if email_list is not None:
            pulumi.set(__self__, "email_list", email_list)
        if everyone is not None:
            pulumi.set(__self__, "everyone", everyone)
        if external_evaluation is not None:
            pulumi.set(__self__, "external_evaluation", external_evaluation)
        if geo is not None:
            pulumi.set(__self__, "geo", geo)
        if github_organization is not None:
            pulumi.set(__self__, "github_organization", github_organization)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if gsuite is not None:
            pulumi.set(__self__, "gsuite", gsuite)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_list is not None:
            pulumi.set(__self__, "ip_list", ip_list)
        if linked_app_token is not None:
            pulumi.set(__self__, "linked_app_token", linked_app_token)
        if login_method is not None:
            pulumi.set(__self__, "login_method", login_method)
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)
        if okta is not None:
            pulumi.set(__self__, "okta", okta)
        if saml is not None:
            pulumi.set(__self__, "saml", saml)
        if service_token is not None:
            pulumi.set(__self__, "service_token", service_token)

    @_builtins.property
    @pulumi.getter(name="anyValidServiceToken")
    def any_valid_service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs']]:
        """
        An empty object which matches on all service tokens.
        """
        return pulumi.get(self, "any_valid_service_token")

    @any_valid_service_token.setter
    def any_valid_service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs']]):
        pulumi.set(self, "any_valid_service_token", value)

    @_builtins.property
    @pulumi.getter(name="authContext")
    def auth_context(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]:
        return pulumi.get(self, "auth_context")

    @auth_context.setter
    def auth_context(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthContextArgs']]):
        pulumi.set(self, "auth_context", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgs']]:
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="azureAd")
    def azure_ad(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgs']]:
        return pulumi.get(self, "azure_ad")

    @azure_ad.setter
    def azure_ad(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireAzureAdArgs']]):
        pulumi.set(self, "azure_ad", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgs']]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgs']]:
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="devicePosture")
    def device_posture(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgs']]:
        return pulumi.get(self, "device_posture")

    @device_posture.setter
    def device_posture(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireDevicePostureArgs']]):
        pulumi.set(self, "device_posture", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgs']]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailArgs']]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="emailDomain")
    def email_domain(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgs']]:
        return pulumi.get(self, "email_domain")

    @email_domain.setter
    def email_domain(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailDomainArgs']]):
        pulumi.set(self, "email_domain", value)

    @_builtins.property
    @pulumi.getter(name="emailList")
    def email_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgs']]:
        return pulumi.get(self, "email_list")

    @email_list.setter
    def email_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEmailListArgs']]):
        pulumi.set(self, "email_list", value)

    @_builtins.property
    @pulumi.getter
    def everyone(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs']]:
        """
        An empty object which matches on all users.
        """
        return pulumi.get(self, "everyone")

    @everyone.setter
    def everyone(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireEveryoneArgs']]):
        pulumi.set(self, "everyone", value)

    @_builtins.property
    @pulumi.getter(name="externalEvaluation")
    def external_evaluation(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]:
        return pulumi.get(self, "external_evaluation")

    @external_evaluation.setter
    def external_evaluation(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireExternalEvaluationArgs']]):
        pulumi.set(self, "external_evaluation", value)

    @_builtins.property
    @pulumi.getter
    def geo(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgs']]:
        return pulumi.get(self, "geo")

    @geo.setter
    def geo(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGeoArgs']]):
        pulumi.set(self, "geo", value)

    @_builtins.property
    @pulumi.getter(name="githubOrganization")
    def github_organization(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgs']]:
        return pulumi.get(self, "github_organization")

    @github_organization.setter
    def github_organization(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGithubOrganizationArgs']]):
        pulumi.set(self, "github_organization", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgs']]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGroupArgs']]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def gsuite(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]:
        return pulumi.get(self, "gsuite")

    @gsuite.setter
    def gsuite(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireGsuiteArgs']]):
        pulumi.set(self, "gsuite", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgs']]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpArgs']]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipList")
    def ip_list(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgs']]:
        return pulumi.get(self, "ip_list")

    @ip_list.setter
    def ip_list(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireIpListArgs']]):
        pulumi.set(self, "ip_list", value)

    @_builtins.property
    @pulumi.getter(name="linkedAppToken")
    def linked_app_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLinkedAppTokenArgs']]:
        return pulumi.get(self, "linked_app_token")

    @linked_app_token.setter
    def linked_app_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLinkedAppTokenArgs']]):
        pulumi.set(self, "linked_app_token", value)

    @_builtins.property
    @pulumi.getter(name="loginMethod")
    def login_method(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgs']]:
        return pulumi.get(self, "login_method")

    @login_method.setter
    def login_method(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireLoginMethodArgs']]):
        pulumi.set(self, "login_method", value)

    @_builtins.property
    @pulumi.getter
    def oidc(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOidcArgs']]:
        return pulumi.get(self, "oidc")

    @oidc.setter
    def oidc(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOidcArgs']]):
        pulumi.set(self, "oidc", value)

    @_builtins.property
    @pulumi.getter
    def okta(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]:
        return pulumi.get(self, "okta")

    @okta.setter
    def okta(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireOktaArgs']]):
        pulumi.set(self, "okta", value)

    @_builtins.property
    @pulumi.getter
    def saml(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]:
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireSamlArgs']]):
        pulumi.set(self, "saml", value)

    @_builtins.property
    @pulumi.getter(name="serviceToken")
    def service_token(self) -> Optional[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgs']]:
        return pulumi.get(self, "service_token")

    @service_token.setter
    def service_token(self, value: Optional[pulumi.Input['ZeroTrustAccessPolicyRequireServiceTokenArgs']]):
        pulumi.set(self, "service_token", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAnyValidServiceTokenArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyRequireAuthContextArgsDict(TypedDict):
        ac_id: pulumi.Input[_builtins.str]
        """
        The ACID of an Authentication context.
        """
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Authentication context.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireAuthContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAuthContextArgs:
    def __init__(__self__, *,
                 ac_id: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ac_id: The ACID of an Authentication context.
        :param pulumi.Input[_builtins.str] id: The ID of an Authentication context.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "ac_id", ac_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="acId")
    def ac_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ACID of an Authentication context.
        """
        return pulumi.get(self, "ac_id")

    @ac_id.setter
    def ac_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ac_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Authentication context.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAuthMethodArgsDict(TypedDict):
        auth_method: pulumi.Input[_builtins.str]
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
elif False:
    ZeroTrustAccessPolicyRequireAuthMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAuthMethodArgs:
    def __init__(__self__, *,
                 auth_method: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_method: The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        pulumi.set(__self__, "auth_method", auth_method)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> pulumi.Input[_builtins.str]:
        """
        The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_method", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireAzureAdArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an Azure group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Azure identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireAzureAdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireAzureAdArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an Azure group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Azure identity provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Azure group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Azure identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireCertificateArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyRequireCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireCertificateArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyRequireCommonNameArgsDict(TypedDict):
        common_name: pulumi.Input[_builtins.str]
        """
        The common name to match.
        """
elif False:
    ZeroTrustAccessPolicyRequireCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireCommonNameArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] common_name: The common name to match.
        """
        pulumi.set(__self__, "common_name", common_name)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[_builtins.str]:
        """
        The common name to match.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "common_name", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireDevicePostureArgsDict(TypedDict):
        integration_uid: pulumi.Input[_builtins.str]
        """
        The ID of a device posture integration.
        """
elif False:
    ZeroTrustAccessPolicyRequireDevicePostureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireDevicePostureArgs:
    def __init__(__self__, *,
                 integration_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] integration_uid: The ID of a device posture integration.
        """
        pulumi.set(__self__, "integration_uid", integration_uid)

    @_builtins.property
    @pulumi.getter(name="integrationUid")
    def integration_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a device posture integration.
        """
        return pulumi.get(self, "integration_uid")

    @integration_uid.setter
    def integration_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "integration_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEmailArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the user.
        """
elif False:
    ZeroTrustAccessPolicyRequireEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEmailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the user.
        """
        pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEmailDomainArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The email domain to match.
        """
elif False:
    ZeroTrustAccessPolicyRequireEmailDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEmailDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] domain: The email domain to match.
        """
        pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The email domain to match.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEmailListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created email list.
        """
elif False:
    ZeroTrustAccessPolicyRequireEmailListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEmailListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created email list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created email list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireEveryoneArgsDict(TypedDict):
        pass
elif False:
    ZeroTrustAccessPolicyRequireEveryoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireEveryoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict(TypedDict):
        evaluate_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing your business logic.
        """
        keys_url: pulumi.Input[_builtins.str]
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
elif False:
    ZeroTrustAccessPolicyRequireExternalEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireExternalEvaluationArgs:
    def __init__(__self__, *,
                 evaluate_url: pulumi.Input[_builtins.str],
                 keys_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] evaluate_url: The API endpoint containing your business logic.
        :param pulumi.Input[_builtins.str] keys_url: The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        pulumi.set(__self__, "evaluate_url", evaluate_url)
        pulumi.set(__self__, "keys_url", keys_url)

    @_builtins.property
    @pulumi.getter(name="evaluateUrl")
    def evaluate_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing your business logic.
        """
        return pulumi.get(self, "evaluate_url")

    @evaluate_url.setter
    def evaluate_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluate_url", value)

    @_builtins.property
    @pulumi.getter(name="keysUrl")
    def keys_url(self) -> pulumi.Input[_builtins.str]:
        """
        The API endpoint containing the key that Access uses to verify that the response came from your API.
        """
        return pulumi.get(self, "keys_url")

    @keys_url.setter
    def keys_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keys_url", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGeoArgsDict(TypedDict):
        country_code: pulumi.Input[_builtins.str]
        """
        The country code that should be matched.
        """
elif False:
    ZeroTrustAccessPolicyRequireGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGeoArgs:
    def __init__(__self__, *,
                 country_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] country_code: The country code that should be matched.
        """
        pulumi.set(__self__, "country_code", country_code)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> pulumi.Input[_builtins.str]:
        """
        The country code that should be matched.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "country_code", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Github identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the organization.
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the team
        """
elif False:
    ZeroTrustAccessPolicyRequireGithubOrganizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGithubOrganizationArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Github identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the organization.
        :param pulumi.Input[_builtins.str] team: The name of the team
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Github identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the team
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created Access group.
        """
elif False:
    ZeroTrustAccessPolicyRequireGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created Access group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created Access group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireGsuiteArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email of the Google Workspace group.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Workspace identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireGsuiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireGsuiteArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] email: The email of the Google Workspace group.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Google Workspace identity provider.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email of the Google Workspace group.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Workspace identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireIpArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IPv4 or IPv6 CIDR block.
        """
elif False:
    ZeroTrustAccessPolicyRequireIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip: An IPv4 or IPv6 CIDR block.
        """
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4 or IPv6 CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireIpListArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of a previously created IP list.
        """
elif False:
    ZeroTrustAccessPolicyRequireIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireIpListArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of a previously created IP list.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a previously created IP list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireLinkedAppTokenArgsDict(TypedDict):
        app_uid: pulumi.Input[_builtins.str]
        """
        The ID of an Access OIDC SaaS application
        """
elif False:
    ZeroTrustAccessPolicyRequireLinkedAppTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireLinkedAppTokenArgs:
    def __init__(__self__, *,
                 app_uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] app_uid: The ID of an Access OIDC SaaS application
        """
        pulumi.set(__self__, "app_uid", app_uid)

    @_builtins.property
    @pulumi.getter(name="appUid")
    def app_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an Access OIDC SaaS application
        """
        return pulumi.get(self, "app_uid")

    @app_uid.setter
    def app_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_uid", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireLoginMethodArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of an identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireLoginMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireLoginMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of an identity provider.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of an identity provider.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireOidcArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the OIDC claim.
        """
        claim_value: pulumi.Input[_builtins.str]
        """
        The OIDC claim value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your OIDC identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireOidcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireOidcArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 claim_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] claim_name: The name of the OIDC claim.
        :param pulumi.Input[_builtins.str] claim_value: The OIDC claim value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your OIDC identity provider.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "claim_value", claim_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the OIDC claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="claimValue")
    def claim_value(self) -> pulumi.Input[_builtins.str]:
        """
        The OIDC claim value to look for.
        """
        return pulumi.get(self, "claim_value")

    @claim_value.setter
    def claim_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your OIDC identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireOktaArgsDict(TypedDict):
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your Okta identity provider.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the Okta group.
        """
elif False:
    ZeroTrustAccessPolicyRequireOktaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireOktaArgs:
    def __init__(__self__, *,
                 identity_provider_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your Okta identity provider.
        :param pulumi.Input[_builtins.str] name: The name of the Okta group.
        """
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Okta identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Okta group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireSamlArgsDict(TypedDict):
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the SAML attribute.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The SAML attribute value to look for.
        """
        identity_provider_id: pulumi.Input[_builtins.str]
        """
        The ID of your SAML identity provider.
        """
elif False:
    ZeroTrustAccessPolicyRequireSamlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireSamlArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 identity_provider_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] attribute_name: The name of the SAML attribute.
        :param pulumi.Input[_builtins.str] attribute_value: The SAML attribute value to look for.
        :param pulumi.Input[_builtins.str] identity_provider_id: The ID of your SAML identity provider.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SAML attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The SAML attribute value to look for.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your SAML identity provider.
        """
        return pulumi.get(self, "identity_provider_id")

    @identity_provider_id.setter
    def identity_provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identity_provider_id", value)


if not MYPY:
    class ZeroTrustAccessPolicyRequireServiceTokenArgsDict(TypedDict):
        token_id: pulumi.Input[_builtins.str]
        """
        The ID of a Service Token.
        """
elif False:
    ZeroTrustAccessPolicyRequireServiceTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustAccessPolicyRequireServiceTokenArgs:
    def __init__(__self__, *,
                 token_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token_id: The ID of a Service Token.
        """
        pulumi.set(__self__, "token_id", token_id)

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a Service Token.
        """
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_id", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileExcludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
elif False:
    ZeroTrustDeviceCustomProfileExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileExcludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param pulumi.Input[_builtins.str] description: A description of the Split Tunnel item, displayed in the client UI.
        :param pulumi.Input[_builtins.str] host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileFallbackDomainArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain suffix to match when resolving locally.
        """
elif False:
    ZeroTrustDeviceCustomProfileFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileFallbackDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[_builtins.str] suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileIncludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name to include in the tunnel. If `host` is present, `address` must not be present.
        """
elif False:
    ZeroTrustDeviceCustomProfileIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileIncludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
        :param pulumi.Input[_builtins.str] description: A description of the Split Tunnel item, displayed in the client UI.
        :param pulumi.Input[_builtins.str] host: The domain name to include in the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name to include in the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgsDict(TypedDict):
        suffix: pulumi.Input[_builtins.str]
        """
        The domain suffix to match when resolving locally.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
elif False:
    ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileLocalDomainFallbackDomainArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] suffix: The domain suffix to match when resolving locally.
        :param pulumi.Input[_builtins.str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[_builtins.str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileServiceModeV2ArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mode to run the WARP client under.
        """
        port: NotRequired[pulumi.Input[_builtins.float]]
        """
        The port number when used with proxy mode.
        """
elif False:
    ZeroTrustDeviceCustomProfileServiceModeV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileServiceModeV2Args:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The mode to run the WARP client under.
        :param pulumi.Input[_builtins.float] port: The port number when used with proxy mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustDeviceCustomProfileTargetTestArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the DEX test targeting this policy.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the DEX test targeting this policy.
        """
elif False:
    ZeroTrustDeviceCustomProfileTargetTestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceCustomProfileTargetTestArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The id of the DEX test targeting this policy.
        :param pulumi.Input[_builtins.str] name: The name of the DEX test targeting this policy.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the DEX test targeting this policy.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the DEX test targeting this policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileExcludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
elif False:
    ZeroTrustDeviceDefaultProfileExcludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileExcludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        :param pulumi.Input[_builtins.str] description: A description of the Split Tunnel item, displayed in the client UI.
        :param pulumi.Input[_builtins.str] host: The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileFallbackDomainArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain suffix to match when resolving locally.
        """
elif False:
    ZeroTrustDeviceDefaultProfileFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileFallbackDomainArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_servers: A list of IP addresses to handle domain resolution.
        :param pulumi.Input[_builtins.str] suffix: The domain suffix to match when resolving locally.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileIncludeArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name to include in the tunnel. If `host` is present, `address` must not be present.
        """
elif False:
    ZeroTrustDeviceDefaultProfileIncludeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileIncludeArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
        :param pulumi.Input[_builtins.str] description: A description of the Split Tunnel item, displayed in the client UI.
        :param pulumi.Input[_builtins.str] host: The domain name to include in the tunnel. If `host` is present, `address` must not be present.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the Split Tunnel item, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name to include in the tunnel. If `host` is present, `address` must not be present.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgsDict(TypedDict):
        suffix: pulumi.Input[_builtins.str]
        """
        The domain suffix to match when resolving locally.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
elif False:
    ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileLocalDomainFallbackDomainArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] suffix: The domain suffix to match when resolving locally.
        :param pulumi.Input[_builtins.str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[_builtins.str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ZeroTrustDeviceDefaultProfileServiceModeV2ArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mode to run the WARP client under.
        """
        port: NotRequired[pulumi.Input[_builtins.float]]
        """
        The port number when used with proxy mode.
        """
elif False:
    ZeroTrustDeviceDefaultProfileServiceModeV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceDefaultProfileServiceModeV2Args:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The mode to run the WARP client under.
        :param pulumi.Input[_builtins.float] port: The port number when used with proxy mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mode to run the WARP client under.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The port number when used with proxy mode.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustDeviceManagedNetworksConfigArgsDict(TypedDict):
        tls_sockaddr: pulumi.Input[_builtins.str]
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
elif False:
    ZeroTrustDeviceManagedNetworksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDeviceManagedNetworksConfigArgs:
    def __init__(__self__, *,
                 tls_sockaddr: pulumi.Input[_builtins.str],
                 sha256: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tls_sockaddr: A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        :param pulumi.Input[_builtins.str] sha256: The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        pulumi.set(__self__, "tls_sockaddr", tls_sockaddr)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter(name="tlsSockaddr")
    def tls_sockaddr(self) -> pulumi.Input[_builtins.str]:
        """
        A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
        """
        return pulumi.get(self, "tls_sockaddr")

    @tls_sockaddr.setter
    def tls_sockaddr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_sockaddr", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class ZeroTrustDevicePostureIntegrationConfigArgsDict(TypedDict):
        access_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
        """
        access_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
        """
        api_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        auth_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One Authorization URL depending on your region.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Uptycs client secret.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        customer_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Crowdstrike customer ID.
        """
elif False:
    ZeroTrustDevicePostureIntegrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureIntegrationConfigArgs:
    def __init__(__self__, *,
                 access_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 access_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 api_url: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_url: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 customer_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_client_id: If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
        :param pulumi.Input[_builtins.str] access_client_secret: If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
        :param pulumi.Input[_builtins.str] api_url: The Workspace One API URL provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[_builtins.str] auth_url: The Workspace One Authorization URL depending on your region.
        :param pulumi.Input[_builtins.str] client_id: The Workspace One client ID provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[_builtins.str] client_key: The Uptycs client secret.
        :param pulumi.Input[_builtins.str] client_secret: The Workspace One client secret provided in the Workspace One Admin Dashboard.
        :param pulumi.Input[_builtins.str] customer_id: The Crowdstrike customer ID.
        """
        if access_client_id is not None:
            pulumi.set(__self__, "access_client_id", access_client_id)
        if access_client_secret is not None:
            pulumi.set(__self__, "access_client_secret", access_client_secret)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @_builtins.property
    @pulumi.getter(name="accessClientId")
    def access_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
        """
        return pulumi.get(self, "access_client_id")

    @access_client_id.setter
    def access_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_client_id", value)

    @_builtins.property
    @pulumi.getter(name="accessClientSecret")
    def access_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
        """
        return pulumi.get(self, "access_client_secret")

    @access_client_secret.setter
    def access_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_client_secret", value)

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One API URL provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_url", value)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One Authorization URL depending on your region.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One client ID provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Uptycs client secret.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Workspace One client secret provided in the Workspace One Admin Dashboard.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Crowdstrike customer ID.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "customer_id", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleInputArgsDict(TypedDict):
        active_threats: NotRequired[pulumi.Input[_builtins.float]]
        """
        The Number of active threats.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of Cloudflare managed certificate.
        """
        check_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of volume names to be checked for encryption.
        """
        check_private_key: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        cn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Common Name that is protected by the certificate.
        """
        compliance_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Compliance Status.
        Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
        """
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Posture Integration ID.
        """
        count_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Count Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Domain.
        """
        eid_last_seen: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled.
        """
        exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not file exists.
        """
        extended_key_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of values indicating purposes for which the certificate public key can be used.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        List ID.
        """
        infected: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether device is infected.
        """
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether device is active.
        """
        issue_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Number of Issues.
        """
        last_seen: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        locations: NotRequired[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgsDict']]
        network_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Network status of device.
        Available values: "connected", "disconnected", "disconnecting", "connecting".
        """
        operating_system: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operating system.
        Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
        """
        operational_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent operational state.
        Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        os: NotRequired[pulumi.Input[_builtins.str]]
        """
        Os Version.
        """
        os_distro_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Operating System Distribution Name (linux only).
        """
        os_distro_revision: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of OS Distribution (linux only).
        """
        os_version_extra: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
        """
        overall: NotRequired[pulumi.Input[_builtins.str]]
        """
        Overall.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        File path.
        """
        require_all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to check all disks for encryption.
        """
        risk_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on risk level, refer to the Tanium documentation.
        Available values: "low", "medium", "high", "critical".
        """
        score: NotRequired[pulumi.Input[_builtins.float]]
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        score_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Score Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        sensor_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        SensorConfig.
        """
        sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        SHA-256.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        For more details on state, please refer to the Crowdstrike documentation.
        Available values: "online", "offline", "unknown".
        """
        subject_alternative_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of certificate Subject Alternative Names.
        """
        thumbprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Signing certificate thumbprint.
        """
        total_score: NotRequired[pulumi.Input[_builtins.float]]
        """
        For more details on total score, refer to the Tanium documentation.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of OS.
        """
        version_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
elif False:
    ZeroTrustDevicePostureRuleInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleInputArgs:
    def __init__(__self__, *,
                 active_threats: Optional[pulumi.Input[_builtins.float]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 check_disks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 check_private_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 cn: Optional[pulumi.Input[_builtins.str]] = None,
                 compliance_status: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 count_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 eid_last_seen: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 exists: Optional[pulumi.Input[_builtins.bool]] = None,
                 extended_key_usages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 infected: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None,
                 issue_count: Optional[pulumi.Input[_builtins.str]] = None,
                 last_seen: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgs']] = None,
                 network_status: Optional[pulumi.Input[_builtins.str]] = None,
                 operating_system: Optional[pulumi.Input[_builtins.str]] = None,
                 operational_state: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 os: Optional[pulumi.Input[_builtins.str]] = None,
                 os_distro_name: Optional[pulumi.Input[_builtins.str]] = None,
                 os_distro_revision: Optional[pulumi.Input[_builtins.str]] = None,
                 os_version_extra: Optional[pulumi.Input[_builtins.str]] = None,
                 overall: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 require_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 risk_level: Optional[pulumi.Input[_builtins.str]] = None,
                 score: Optional[pulumi.Input[_builtins.float]] = None,
                 score_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 sensor_config: Optional[pulumi.Input[_builtins.str]] = None,
                 sha256: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 thumbprint: Optional[pulumi.Input[_builtins.str]] = None,
                 total_score: Optional[pulumi.Input[_builtins.float]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None,
                 version_operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] active_threats: The Number of active threats.
        :param pulumi.Input[_builtins.str] certificate_id: UUID of Cloudflare managed certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] check_disks: List of volume names to be checked for encryption.
        :param pulumi.Input[_builtins.bool] check_private_key: Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        :param pulumi.Input[_builtins.str] cn: Common Name that is protected by the certificate.
        :param pulumi.Input[_builtins.str] compliance_status: Compliance Status.
               Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
        :param pulumi.Input[_builtins.str] connection_id: Posture Integration ID.
        :param pulumi.Input[_builtins.str] count_operator: Count Operator.
               Available values: "<", "<=", ">", ">=", "==".
        :param pulumi.Input[_builtins.str] domain: Domain.
        :param pulumi.Input[_builtins.str] eid_last_seen: For more details on eid last seen, refer to the Tanium documentation.
        :param pulumi.Input[_builtins.bool] enabled: Enabled.
        :param pulumi.Input[_builtins.bool] exists: Whether or not file exists.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] extended_key_usages: List of values indicating purposes for which the certificate public key can be used.
        :param pulumi.Input[_builtins.str] id: List ID.
        :param pulumi.Input[_builtins.bool] infected: Whether device is infected.
        :param pulumi.Input[_builtins.bool] is_active: Whether device is active.
        :param pulumi.Input[_builtins.str] issue_count: The Number of Issues.
        :param pulumi.Input[_builtins.str] last_seen: For more details on last seen, please refer to the Crowdstrike documentation.
        :param pulumi.Input[_builtins.str] network_status: Network status of device.
               Available values: "connected", "disconnected", "disconnecting", "connecting".
        :param pulumi.Input[_builtins.str] operating_system: Operating system.
               Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
        :param pulumi.Input[_builtins.str] operational_state: Agent operational state.
               Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
        :param pulumi.Input[_builtins.str] operator: Operator.
               Available values: "<", "<=", ">", ">=", "==".
        :param pulumi.Input[_builtins.str] os: Os Version.
        :param pulumi.Input[_builtins.str] os_distro_name: Operating System Distribution Name (linux only).
        :param pulumi.Input[_builtins.str] os_distro_revision: Version of OS Distribution (linux only).
        :param pulumi.Input[_builtins.str] os_version_extra: Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
        :param pulumi.Input[_builtins.str] overall: Overall.
        :param pulumi.Input[_builtins.str] path: File path.
        :param pulumi.Input[_builtins.bool] require_all: Whether to check all disks for encryption.
        :param pulumi.Input[_builtins.str] risk_level: For more details on risk level, refer to the Tanium documentation.
               Available values: "low", "medium", "high", "critical".
        :param pulumi.Input[_builtins.float] score: A value between 0-100 assigned to devices set by the 3rd party posture provider.
        :param pulumi.Input[_builtins.str] score_operator: Score Operator.
               Available values: "<", "<=", ">", ">=", "==".
        :param pulumi.Input[_builtins.str] sensor_config: SensorConfig.
        :param pulumi.Input[_builtins.str] sha256: SHA-256.
        :param pulumi.Input[_builtins.str] state: For more details on state, please refer to the Crowdstrike documentation.
               Available values: "online", "offline", "unknown".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subject_alternative_names: List of certificate Subject Alternative Names.
        :param pulumi.Input[_builtins.str] thumbprint: Signing certificate thumbprint.
        :param pulumi.Input[_builtins.float] total_score: For more details on total score, refer to the Tanium documentation.
        :param pulumi.Input[_builtins.str] version: Version of OS.
        :param pulumi.Input[_builtins.str] version_operator: Version Operator.
               Available values: "<", "<=", ">", ">=", "==".
        """
        if active_threats is not None:
            pulumi.set(__self__, "active_threats", active_threats)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if check_disks is not None:
            pulumi.set(__self__, "check_disks", check_disks)
        if check_private_key is not None:
            pulumi.set(__self__, "check_private_key", check_private_key)
        if cn is not None:
            pulumi.set(__self__, "cn", cn)
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if count_operator is not None:
            pulumi.set(__self__, "count_operator", count_operator)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if eid_last_seen is not None:
            pulumi.set(__self__, "eid_last_seen", eid_last_seen)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infected is not None:
            pulumi.set(__self__, "infected", infected)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if issue_count is not None:
            pulumi.set(__self__, "issue_count", issue_count)
        if last_seen is not None:
            pulumi.set(__self__, "last_seen", last_seen)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if network_status is not None:
            pulumi.set(__self__, "network_status", network_status)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if operational_state is not None:
            pulumi.set(__self__, "operational_state", operational_state)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if os_distro_name is not None:
            pulumi.set(__self__, "os_distro_name", os_distro_name)
        if os_distro_revision is not None:
            pulumi.set(__self__, "os_distro_revision", os_distro_revision)
        if os_version_extra is not None:
            pulumi.set(__self__, "os_version_extra", os_version_extra)
        if overall is not None:
            pulumi.set(__self__, "overall", overall)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if require_all is not None:
            pulumi.set(__self__, "require_all", require_all)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if score_operator is not None:
            pulumi.set(__self__, "score_operator", score_operator)
        if sensor_config is not None:
            pulumi.set(__self__, "sensor_config", sensor_config)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if total_score is not None:
            pulumi.set(__self__, "total_score", total_score)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_operator is not None:
            pulumi.set(__self__, "version_operator", version_operator)

    @_builtins.property
    @pulumi.getter(name="activeThreats")
    def active_threats(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The Number of active threats.
        """
        return pulumi.get(self, "active_threats")

    @active_threats.setter
    def active_threats(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "active_threats", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of Cloudflare managed certificate.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="checkDisks")
    def check_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of volume names to be checked for encryption.
        """
        return pulumi.get(self, "check_disks")

    @check_disks.setter
    def check_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "check_disks", value)

    @_builtins.property
    @pulumi.getter(name="checkPrivateKey")
    def check_private_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
        """
        return pulumi.get(self, "check_private_key")

    @check_private_key.setter
    def check_private_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "check_private_key", value)

    @_builtins.property
    @pulumi.getter
    def cn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Common Name that is protected by the certificate.
        """
        return pulumi.get(self, "cn")

    @cn.setter
    def cn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cn", value)

    @_builtins.property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Compliance Status.
        Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
        """
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compliance_status", value)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Posture Integration ID.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="countOperator")
    def count_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Count Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "count_operator")

    @count_operator.setter
    def count_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "count_operator", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="eidLastSeen")
    def eid_last_seen(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on eid last seen, refer to the Tanium documentation.
        """
        return pulumi.get(self, "eid_last_seen")

    @eid_last_seen.setter
    def eid_last_seen(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eid_last_seen", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not file exists.
        """
        return pulumi.get(self, "exists")

    @exists.setter
    def exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exists", value)

    @_builtins.property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of values indicating purposes for which the certificate public key can be used.
        """
        return pulumi.get(self, "extended_key_usages")

    @extended_key_usages.setter
    def extended_key_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extended_key_usages", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        List ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def infected(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether device is infected.
        """
        return pulumi.get(self, "infected")

    @infected.setter
    def infected(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "infected", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether device is active.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter(name="issueCount")
    def issue_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Number of Issues.
        """
        return pulumi.get(self, "issue_count")

    @issue_count.setter
    def issue_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issue_count", value)

    @_builtins.property
    @pulumi.getter(name="lastSeen")
    def last_seen(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on last seen, please refer to the Crowdstrike documentation.
        """
        return pulumi.get(self, "last_seen")

    @last_seen.setter
    def last_seen(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_seen", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgs']]:
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['ZeroTrustDevicePostureRuleInputLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="networkStatus")
    def network_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Network status of device.
        Available values: "connected", "disconnected", "disconnecting", "connecting".
        """
        return pulumi.get(self, "network_status")

    @network_status.setter
    def network_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_status", value)

    @_builtins.property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operating system.
        Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operating_system", value)

    @_builtins.property
    @pulumi.getter(name="operationalState")
    def operational_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent operational state.
        Available values: "na", "partially*disabled", "auto*fully*disabled", "fully*disabled", "auto*partially*disabled", "disabled*error", "db*corruption".
        """
        return pulumi.get(self, "operational_state")

    @operational_state.setter
    def operational_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operational_state", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Os Version.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os", value)

    @_builtins.property
    @pulumi.getter(name="osDistroName")
    def os_distro_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Operating System Distribution Name (linux only).
        """
        return pulumi.get(self, "os_distro_name")

    @os_distro_name.setter
    def os_distro_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_distro_name", value)

    @_builtins.property
    @pulumi.getter(name="osDistroRevision")
    def os_distro_revision(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of OS Distribution (linux only).
        """
        return pulumi.get(self, "os_distro_revision")

    @os_distro_revision.setter
    def os_distro_revision(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_distro_revision", value)

    @_builtins.property
    @pulumi.getter(name="osVersionExtra")
    def os_version_extra(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
        """
        return pulumi.get(self, "os_version_extra")

    @os_version_extra.setter
    def os_version_extra(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "os_version_extra", value)

    @_builtins.property
    @pulumi.getter
    def overall(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Overall.
        """
        return pulumi.get(self, "overall")

    @overall.setter
    def overall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overall", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        File path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="requireAll")
    def require_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to check all disks for encryption.
        """
        return pulumi.get(self, "require_all")

    @require_all.setter
    def require_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_all", value)

    @_builtins.property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on risk level, refer to the Tanium documentation.
        Available values: "low", "medium", "high", "critical".
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "risk_level", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A value between 0-100 assigned to devices set by the 3rd party posture provider.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "score", value)

    @_builtins.property
    @pulumi.getter(name="scoreOperator")
    def score_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Score Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "score_operator")

    @score_operator.setter
    def score_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "score_operator", value)

    @_builtins.property
    @pulumi.getter(name="sensorConfig")
    def sensor_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SensorConfig.
        """
        return pulumi.get(self, "sensor_config")

    @sensor_config.setter
    def sensor_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sensor_config", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SHA-256.
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For more details on state, please refer to the Crowdstrike documentation.
        Available values: "online", "offline", "unknown".
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of certificate Subject Alternative Names.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subject_alternative_names", value)

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Signing certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "thumbprint", value)

    @_builtins.property
    @pulumi.getter(name="totalScore")
    def total_score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        For more details on total score, refer to the Tanium documentation.
        """
        return pulumi.get(self, "total_score")

    @total_score.setter
    def total_score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "total_score", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of OS.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="versionOperator")
    def version_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version Operator.
        Available values: "<", "<=", ">", ">=", "==".
        """
        return pulumi.get(self, "version_operator")

    @version_operator.setter
    def version_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version_operator", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleInputLocationsArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of paths to check for client certificate on linux.
        """
        trust_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of trust stores to check for client certificate.
        """
elif False:
    ZeroTrustDevicePostureRuleInputLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleInputLocationsArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 trust_stores: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] paths: List of paths to check for client certificate on linux.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] trust_stores: List of trust stores to check for client certificate.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if trust_stores is not None:
            pulumi.set(__self__, "trust_stores", trust_stores)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of paths to check for client certificate on linux.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter(name="trustStores")
    def trust_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of trust stores to check for client certificate.
        """
        return pulumi.get(self, "trust_stores")

    @trust_stores.setter
    def trust_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "trust_stores", value)


if not MYPY:
    class ZeroTrustDevicePostureRuleMatchArgsDict(TypedDict):
        platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
        """
elif False:
    ZeroTrustDevicePostureRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDevicePostureRuleMatchArgs:
    def __init__(__self__, *,
                 platform: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] platform: Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
        """
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "windows", "mac", "linux", "android", "ios", "chromeos".
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "platform", value)


if not MYPY:
    class ZeroTrustDexTestDataArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The desired endpoint to test.
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of test.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP request method type.
        """
elif False:
    ZeroTrustDexTestDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDexTestDataArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The desired endpoint to test.
        :param pulumi.Input[_builtins.str] kind: The type of test.
        :param pulumi.Input[_builtins.str] method: The HTTP request method type.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The desired endpoint to test.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of test.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP request method type.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class ZeroTrustDexTestTargetPolicyArgsDict(TypedDict):
        default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the DEX rule is the account default
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the DEX rule
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the DEX rule
        """
elif False:
    ZeroTrustDexTestTargetPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDexTestTargetPolicyArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] default: Whether the DEX rule is the account default
        :param pulumi.Input[_builtins.str] id: The id of the DEX rule
        :param pulumi.Input[_builtins.str] name: The name of the DEX rule
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the DEX rule is the account default
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the DEX rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the DEX rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZeroTrustDlpCustomEntryConfidenceArgsDict(TypedDict):
        ai_context_available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has AI remote service validation.
        """
        available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
elif False:
    ZeroTrustDlpCustomEntryConfidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomEntryConfidenceArgs:
    def __init__(__self__, *,
                 ai_context_available: Optional[pulumi.Input[_builtins.bool]] = None,
                 available: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] ai_context_available: Indicates whether this entry has AI remote service validation.
        :param pulumi.Input[_builtins.bool] available: Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        if ai_context_available is not None:
            pulumi.set(__self__, "ai_context_available", ai_context_available)
        if available is not None:
            pulumi.set(__self__, "available", available)

    @_builtins.property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has AI remote service validation.
        """
        return pulumi.get(self, "ai_context_available")

    @ai_context_available.setter
    def ai_context_available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ai_context_available", value)

    @_builtins.property
    @pulumi.getter
    def available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        return pulumi.get(self, "available")

    @available.setter
    def available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "available", value)


if not MYPY:
    class ZeroTrustDlpCustomEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[_builtins.str]
        validation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "luhn".
        """
elif False:
    ZeroTrustDlpCustomEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[_builtins.str],
                 validation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] validation: Available values: "luhn".
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""validation is deprecated: This attribute is deprecated.""")
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute is deprecated.""")
    def validation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "luhn".
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpCustomEntryVariantArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        topic_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "Intent", "Content".
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "PromptTopic".
        """
elif False:
    ZeroTrustDlpCustomEntryVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomEntryVariantArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 topic_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_type: Available values: "Intent", "Content".
        :param pulumi.Input[_builtins.str] type: Available values: "PromptTopic".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if topic_type is not None:
            pulumi.set(__self__, "topic_type", topic_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="topicType")
    def topic_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "Intent", "Content".
        """
        return pulumi.get(self, "topic_type")

    @topic_type.setter
    def topic_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "PromptTopic".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpCustomProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 skip: pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def skip(self) -> pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['ZeroTrustDlpCustomProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[_builtins.bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpCustomProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @_builtins.property
    @pulumi.getter
    def files(self) -> pulumi.Input[_builtins.bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        name: pulumi.Input[_builtins.str]
        pattern: pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgsDict']
        entry_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ZeroTrustDlpCustomProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str],
                 pattern: pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgs'],
                 entry_id: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgs']:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input['ZeroTrustDlpCustomProfileEntryPatternArgs']):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry_id", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[_builtins.str]
        validation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "luhn".
        """
elif False:
    ZeroTrustDlpCustomProfileEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[_builtins.str],
                 validation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] validation: Available values: "luhn".
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""validation is deprecated: This attribute is deprecated.""")
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute is deprecated.""")
    def validation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "luhn".
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpCustomProfileSharedEntryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        entry_id: pulumi.Input[_builtins.str]
        entry_type: pulumi.Input[_builtins.str]
        """
        Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
        """
elif False:
    ZeroTrustDlpCustomProfileSharedEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpCustomProfileSharedEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 entry_id: pulumi.Input[_builtins.str],
                 entry_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] entry_type: Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "entry_id", entry_id)
        pulumi.set(__self__, "entry_type", entry_type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entry_id", value)

    @_builtins.property
    @pulumi.getter(name="entryType")
    def entry_type(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "custom", "predefined", "integration", "exact*data", "document*fingerprint".
        """
        return pulumi.get(self, "entry_type")

    @entry_type.setter
    def entry_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entry_type", value)


if not MYPY:
    class ZeroTrustDlpDatasetColumnArgsDict(TypedDict):
        entry_id: NotRequired[pulumi.Input[_builtins.str]]
        header_name: NotRequired[pulumi.Input[_builtins.str]]
        num_cells: NotRequired[pulumi.Input[_builtins.int]]
        upload_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
elif False:
    ZeroTrustDlpDatasetColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetColumnArgs:
    def __init__(__self__, *,
                 entry_id: Optional[pulumi.Input[_builtins.str]] = None,
                 header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 num_cells: Optional[pulumi.Input[_builtins.int]] = None,
                 upload_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] upload_status: Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if upload_status is not None:
            pulumi.set(__self__, "upload_status", upload_status)

    @_builtins.property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry_id", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_cells", value)

    @_builtins.property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        return pulumi.get(self, "upload_status")

    @upload_status.setter
    def upload_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload_status", value)


if not MYPY:
    class ZeroTrustDlpDatasetDatasetArgsDict(TypedDict):
        case_sensitive: NotRequired[pulumi.Input[_builtins.bool]]
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgsDict']]]]
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the dataset.
        """
        encoding_version: NotRequired[pulumi.Input[_builtins.int]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        num_cells: NotRequired[pulumi.Input[_builtins.int]]
        secret: NotRequired[pulumi.Input[_builtins.bool]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the dataset was last updated.
        """
        uploads: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgsDict']]]]
elif False:
    ZeroTrustDlpDatasetDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetDatasetArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[_builtins.bool]] = None,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgs']]]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 encoding_version: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 num_cells: Optional[pulumi.Input[_builtins.int]] = None,
                 secret: Optional[pulumi.Input[_builtins.bool]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uploads: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the dataset.
        :param pulumi.Input[_builtins.str] status: Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        :param pulumi.Input[_builtins.str] updated_at: When the dataset was last updated.
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encoding_version is not None:
            pulumi.set(__self__, "encoding_version", encoding_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uploads is not None:
            pulumi.set(__self__, "uploads", uploads)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgs']]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the dataset.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="encodingVersion")
    def encoding_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "encoding_version")

    @encoding_version.setter
    def encoding_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "encoding_version", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_cells", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the dataset was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uploads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgs']]]]:
        return pulumi.get(self, "uploads")

    @uploads.setter
    def uploads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDlpDatasetDatasetUploadArgs']]]]):
        pulumi.set(self, "uploads", value)


if not MYPY:
    class ZeroTrustDlpDatasetDatasetColumnArgsDict(TypedDict):
        entry_id: NotRequired[pulumi.Input[_builtins.str]]
        header_name: NotRequired[pulumi.Input[_builtins.str]]
        num_cells: NotRequired[pulumi.Input[_builtins.int]]
        upload_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
elif False:
    ZeroTrustDlpDatasetDatasetColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetDatasetColumnArgs:
    def __init__(__self__, *,
                 entry_id: Optional[pulumi.Input[_builtins.str]] = None,
                 header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 num_cells: Optional[pulumi.Input[_builtins.int]] = None,
                 upload_status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] upload_status: Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if upload_status is not None:
            pulumi.set(__self__, "upload_status", upload_status)

    @_builtins.property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry_id", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_cells", value)

    @_builtins.property
    @pulumi.getter(name="uploadStatus")
    def upload_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        return pulumi.get(self, "upload_status")

    @upload_status.setter
    def upload_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload_status", value)


if not MYPY:
    class ZeroTrustDlpDatasetDatasetUploadArgsDict(TypedDict):
        num_cells: NotRequired[pulumi.Input[_builtins.int]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ZeroTrustDlpDatasetDatasetUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetDatasetUploadArgs:
    def __init__(__self__, *,
                 num_cells: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_cells", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustDlpDatasetUploadArgsDict(TypedDict):
        num_cells: NotRequired[pulumi.Input[_builtins.int]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ZeroTrustDlpDatasetUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpDatasetUploadArgs:
    def __init__(__self__, *,
                 num_cells: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] status: Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        if num_cells is not None:
            pulumi.set(__self__, "num_cells", num_cells)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="numCells")
    def num_cells(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "num_cells")

    @num_cells.setter
    def num_cells(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_cells", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "empty", "uploading", "pending", "processing", "failed", "complete".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustDlpEntryConfidenceArgsDict(TypedDict):
        ai_context_available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has AI remote service validation.
        """
        available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
elif False:
    ZeroTrustDlpEntryConfidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpEntryConfidenceArgs:
    def __init__(__self__, *,
                 ai_context_available: Optional[pulumi.Input[_builtins.bool]] = None,
                 available: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] ai_context_available: Indicates whether this entry has AI remote service validation.
        :param pulumi.Input[_builtins.bool] available: Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        if ai_context_available is not None:
            pulumi.set(__self__, "ai_context_available", ai_context_available)
        if available is not None:
            pulumi.set(__self__, "available", available)

    @_builtins.property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has AI remote service validation.
        """
        return pulumi.get(self, "ai_context_available")

    @ai_context_available.setter
    def ai_context_available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ai_context_available", value)

    @_builtins.property
    @pulumi.getter
    def available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        return pulumi.get(self, "available")

    @available.setter
    def available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "available", value)


if not MYPY:
    class ZeroTrustDlpEntryPatternArgsDict(TypedDict):
        regex: pulumi.Input[_builtins.str]
        validation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "luhn".
        """
elif False:
    ZeroTrustDlpEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpEntryPatternArgs:
    def __init__(__self__, *,
                 regex: pulumi.Input[_builtins.str],
                 validation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] validation: Available values: "luhn".
        """
        pulumi.set(__self__, "regex", regex)
        if validation is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""validation is deprecated: This attribute is deprecated.""")
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute is deprecated.""")
    def validation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "luhn".
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpEntryVariantArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        topic_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "Intent", "Content".
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "PromptTopic".
        """
elif False:
    ZeroTrustDlpEntryVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpEntryVariantArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 topic_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_type: Available values: "Intent", "Content".
        :param pulumi.Input[_builtins.str] type: Available values: "PromptTopic".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if topic_type is not None:
            pulumi.set(__self__, "topic_type", topic_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="topicType")
    def topic_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "Intent", "Content".
        """
        return pulumi.get(self, "topic_type")

    @topic_type.setter
    def topic_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "PromptTopic".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZeroTrustDlpIntegrationEntryConfidenceArgsDict(TypedDict):
        ai_context_available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has AI remote service validation.
        """
        available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
elif False:
    ZeroTrustDlpIntegrationEntryConfidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpIntegrationEntryConfidenceArgs:
    def __init__(__self__, *,
                 ai_context_available: Optional[pulumi.Input[_builtins.bool]] = None,
                 available: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] ai_context_available: Indicates whether this entry has AI remote service validation.
        :param pulumi.Input[_builtins.bool] available: Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        if ai_context_available is not None:
            pulumi.set(__self__, "ai_context_available", ai_context_available)
        if available is not None:
            pulumi.set(__self__, "available", available)

    @_builtins.property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has AI remote service validation.
        """
        return pulumi.get(self, "ai_context_available")

    @ai_context_available.setter
    def ai_context_available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ai_context_available", value)

    @_builtins.property
    @pulumi.getter
    def available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        return pulumi.get(self, "available")

    @available.setter
    def available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "available", value)


if not MYPY:
    class ZeroTrustDlpIntegrationEntryPatternArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        validation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "luhn".
        """
elif False:
    ZeroTrustDlpIntegrationEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpIntegrationEntryPatternArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None,
                 validation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] validation: Available values: "luhn".
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if validation is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""validation is deprecated: This attribute is deprecated.""")
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute is deprecated.""")
    def validation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "luhn".
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpIntegrationEntryVariantArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        topic_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "Intent", "Content".
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "PromptTopic".
        """
elif False:
    ZeroTrustDlpIntegrationEntryVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpIntegrationEntryVariantArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 topic_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_type: Available values: "Intent", "Content".
        :param pulumi.Input[_builtins.str] type: Available values: "PromptTopic".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if topic_type is not None:
            pulumi.set(__self__, "topic_type", topic_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="topicType")
    def topic_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "Intent", "Content".
        """
        return pulumi.get(self, "topic_type")

    @topic_type.setter
    def topic_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "PromptTopic".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZeroTrustDlpPredefinedEntryConfidenceArgsDict(TypedDict):
        ai_context_available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has AI remote service validation.
        """
        available: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
elif False:
    ZeroTrustDlpPredefinedEntryConfidenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedEntryConfidenceArgs:
    def __init__(__self__, *,
                 ai_context_available: Optional[pulumi.Input[_builtins.bool]] = None,
                 available: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] ai_context_available: Indicates whether this entry has AI remote service validation.
        :param pulumi.Input[_builtins.bool] available: Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        if ai_context_available is not None:
            pulumi.set(__self__, "ai_context_available", ai_context_available)
        if available is not None:
            pulumi.set(__self__, "available", available)

    @_builtins.property
    @pulumi.getter(name="aiContextAvailable")
    def ai_context_available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has AI remote service validation.
        """
        return pulumi.get(self, "ai_context_available")

    @ai_context_available.setter
    def ai_context_available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ai_context_available", value)

    @_builtins.property
    @pulumi.getter
    def available(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether this entry has any form of validation that is not an AI remote service.
        """
        return pulumi.get(self, "available")

    @available.setter
    def available(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "available", value)


if not MYPY:
    class ZeroTrustDlpPredefinedEntryPatternArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[_builtins.str]]
        validation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "luhn".
        """
elif False:
    ZeroTrustDlpPredefinedEntryPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedEntryPatternArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[_builtins.str]] = None,
                 validation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] validation: Available values: "luhn".
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if validation is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""validation is deprecated: This attribute is deprecated.""")
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute is deprecated.""")
    def validation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "luhn".
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ZeroTrustDlpPredefinedEntryVariantArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        topic_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "Intent", "Content".
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available values: "PromptTopic".
        """
elif False:
    ZeroTrustDlpPredefinedEntryVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedEntryVariantArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 topic_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_type: Available values: "Intent", "Content".
        :param pulumi.Input[_builtins.str] type: Available values: "PromptTopic".
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if topic_type is not None:
            pulumi.set(__self__, "topic_type", topic_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="topicType")
    def topic_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "Intent", "Content".
        """
        return pulumi.get(self, "topic_type")

    @topic_type.setter
    def topic_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available values: "PromptTopic".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZeroTrustDlpPredefinedProfileContextAwarenessArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        skip: pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict']
        """
        Content types to exclude from context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpPredefinedProfileContextAwarenessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedProfileContextAwarenessArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 skip: pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs']):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, scan the context of predefined entries to only return matches surrounded by keywords.
        :param pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs'] skip: Content types to exclude from context analysis and return all matches.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "skip", skip)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        If true, scan the context of predefined entries to only return matches surrounded by keywords.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def skip(self) -> pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs']:
        """
        Content types to exclude from context analysis and return all matches.
        """
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: pulumi.Input['ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs']):
        pulumi.set(self, "skip", value)


if not MYPY:
    class ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict(TypedDict):
        files: pulumi.Input[_builtins.bool]
        """
        If the content type is a file, skip context analysis and return all matches.
        """
elif False:
    ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedProfileContextAwarenessSkipArgs:
    def __init__(__self__, *,
                 files: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] files: If the content type is a file, skip context analysis and return all matches.
        """
        pulumi.set(__self__, "files", files)

    @_builtins.property
    @pulumi.getter
    def files(self) -> pulumi.Input[_builtins.bool]:
        """
        If the content type is a file, skip context analysis and return all matches.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ZeroTrustDlpPredefinedProfileEntryArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        id: pulumi.Input[_builtins.str]
elif False:
    ZeroTrustDlpPredefinedProfileEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDlpPredefinedProfileEntryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsArgsDict(TypedDict):
        doh: pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgsDict']
        dot: pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgsDict']
        ipv4: pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4ArgsDict']
        ipv6: pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6ArgsDict']
elif False:
    ZeroTrustDnsLocationEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsArgs:
    def __init__(__self__, *,
                 doh: pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgs'],
                 dot: pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgs'],
                 ipv4: pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4Args'],
                 ipv6: pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6Args']):
        pulumi.set(__self__, "doh", doh)
        pulumi.set(__self__, "dot", dot)
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def doh(self) -> pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgs']:
        return pulumi.get(self, "doh")

    @doh.setter
    def doh(self, value: pulumi.Input['ZeroTrustDnsLocationEndpointsDohArgs']):
        pulumi.set(self, "doh", value)

    @_builtins.property
    @pulumi.getter
    def dot(self) -> pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgs']:
        return pulumi.get(self, "dot")

    @dot.setter
    def dot(self, value: pulumi.Input['ZeroTrustDnsLocationEndpointsDotArgs']):
        pulumi.set(self, "dot", value)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4Args']:
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input['ZeroTrustDnsLocationEndpointsIpv4Args']):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6Args']:
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6Args']):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDohArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgsDict']]]]
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        require_token: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDohArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDohArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]]] = None,
                 require_token: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        :param pulumi.Input[_builtins.bool] require_token: True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if require_token is not None:
            pulumi.set(__self__, "require_token", require_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]]]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDohNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @_builtins.property
    @pulumi.getter(name="requireToken")
    def require_token(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
        """
        return pulumi.get(self, "require_token")

    @require_token.setter
    def require_token(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_token", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDohNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IP address or IP CIDR.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDohNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDohNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDotArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgsDict']]]]
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDotArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]] networks: A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]]]:
        """
        A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsDotNetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsDotNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IP address or IP CIDR.
        """
elif False:
    ZeroTrustDnsLocationEndpointsDotNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsDotNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IP address or IP CIDR.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IP address or IP CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsIpv4ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
elif False:
    ZeroTrustDnsLocationEndpointsIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsIpv4Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsIpv6ArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        True if the endpoint is enabled for this location.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict']]]]
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
elif False:
    ZeroTrustDnsLocationEndpointsIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsIpv6Args:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: True if the endpoint is enabled for this location.
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]] networks: A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        True if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]]]:
        """
        A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustDnsLocationEndpointsIpv6NetworkArgs']]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IPv6 address or IPv6 CIDR.
        """
elif False:
    ZeroTrustDnsLocationEndpointsIpv6NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationEndpointsIpv6NetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IPv6 address or IPv6 CIDR.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv6 address or IPv6 CIDR.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustDnsLocationNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
elif False:
    ZeroTrustDnsLocationNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustDnsLocationNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network: The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ZeroTrustGatewayLoggingSettingsByRuleTypeArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgsDict']]
        http: NotRequired[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgsDict']]
        l4: NotRequired[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeL4ArgsDict']]
elif False:
    ZeroTrustGatewayLoggingSettingsByRuleTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayLoggingSettingsByRuleTypeArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgs']] = None,
                 http: Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgs']] = None,
                 l4: Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeL4Args']] = None):
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if l4 is not None:
            pulumi.set(__self__, "l4", l4)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgs']]:
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgs']]):
        pulumi.set(self, "dns", value)

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgs']]:
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgs']]):
        pulumi.set(self, "http", value)

    @_builtins.property
    @pulumi.getter
    def l4(self) -> Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeL4Args']]:
        return pulumi.get(self, "l4")

    @l4.setter
    def l4(self, value: Optional[pulumi.Input['ZeroTrustGatewayLoggingSettingsByRuleTypeL4Args']]):
        pulumi.set(self, "l4", value)


if not MYPY:
    class ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgsDict(TypedDict):
        log_all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log all requests to this service.
        """
        log_blocks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log only blocking requests to this service.
        """
elif False:
    ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayLoggingSettingsByRuleTypeDnsArgs:
    def __init__(__self__, *,
                 log_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_blocks: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] log_all: Log all requests to this service.
        :param pulumi.Input[_builtins.bool] log_blocks: Log only blocking requests to this service.
        """
        if log_all is not None:
            pulumi.set(__self__, "log_all", log_all)
        if log_blocks is not None:
            pulumi.set(__self__, "log_blocks", log_blocks)

    @_builtins.property
    @pulumi.getter(name="logAll")
    def log_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log all requests to this service.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_all", value)

    @_builtins.property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log only blocking requests to this service.
        """
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgsDict(TypedDict):
        log_all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log all requests to this service.
        """
        log_blocks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log only blocking requests to this service.
        """
elif False:
    ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayLoggingSettingsByRuleTypeHttpArgs:
    def __init__(__self__, *,
                 log_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_blocks: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] log_all: Log all requests to this service.
        :param pulumi.Input[_builtins.bool] log_blocks: Log only blocking requests to this service.
        """
        if log_all is not None:
            pulumi.set(__self__, "log_all", log_all)
        if log_blocks is not None:
            pulumi.set(__self__, "log_blocks", log_blocks)

    @_builtins.property
    @pulumi.getter(name="logAll")
    def log_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log all requests to this service.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_all", value)

    @_builtins.property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log only blocking requests to this service.
        """
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class ZeroTrustGatewayLoggingSettingsByRuleTypeL4ArgsDict(TypedDict):
        log_all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log all requests to this service.
        """
        log_blocks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Log only blocking requests to this service.
        """
elif False:
    ZeroTrustGatewayLoggingSettingsByRuleTypeL4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayLoggingSettingsByRuleTypeL4Args:
    def __init__(__self__, *,
                 log_all: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_blocks: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] log_all: Log all requests to this service.
        :param pulumi.Input[_builtins.bool] log_blocks: Log only blocking requests to this service.
        """
        if log_all is not None:
            pulumi.set(__self__, "log_all", log_all)
        if log_blocks is not None:
            pulumi.set(__self__, "log_blocks", log_blocks)

    @_builtins.property
    @pulumi.getter(name="logAll")
    def log_all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log all requests to this service.
        """
        return pulumi.get(self, "log_all")

    @log_all.setter
    def log_all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_all", value)

    @_builtins.property
    @pulumi.getter(name="logBlocks")
    def log_blocks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Log only blocking requests to this service.
        """
        return pulumi.get(self, "log_blocks")

    @log_blocks.setter
    def log_blocks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_blocks", value)


if not MYPY:
    class ZeroTrustGatewayPolicyExpirationArgsDict(TypedDict):
        expires_at: pulumi.Input[_builtins.str]
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        expired: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the policy has expired.
        """
elif False:
    ZeroTrustGatewayPolicyExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyExpirationArgs:
    def __init__(__self__, *,
                 expires_at: pulumi.Input[_builtins.str],
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 expired: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] expires_at: The time stamp at which the policy will expire and cease to be
               applied.
        :param pulumi.Input[_builtins.int] duration: The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        :param pulumi.Input[_builtins.bool] expired: Whether the policy has expired.
        """
        pulumi.set(__self__, "expires_at", expires_at)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expired is not None:
            pulumi.set(__self__, "expired", expired)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> pulumi.Input[_builtins.str]:
        """
        The time stamp at which the policy will expire and cease to be
        applied.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def expired(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the policy has expired.
        """
        return pulumi.get(self, "expired")

    @expired.setter
    def expired(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsArgsDict(TypedDict):
        add_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        allow_child_bypass: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        audit_ssh: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict']]
        """
        Settings for the Audit SSH action.
        """
        biso_admin_controls: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict']]
        """
        Configure how browser isolation behaves.
        """
        block_page: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBlockPageArgsDict']]
        """
        Custom block page settings. If missing/null, blocking will use the the account settings.
        """
        block_page_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the custom block page.
        """
        block_reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        bypass_parent_rule: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        check_session: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict']]
        """
        Configure how session check behaves.
        """
        dns_resolvers: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict']]
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        egress: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict']]
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        ignore_cname_category_matches: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        insecure_disable_dnssec_validation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        ip_categories: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        ip_indicator_feeds: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        l4override: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict']]
        """
        Send matching traffic to the supplied destination IP address. and port.
        """
        notification_settings: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict']]
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        override_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Override matching DNS queries with a hostname.
        """
        override_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        payload_log: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict']]
        """
        Configure DLP payload logging.
        """
        quarantine: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict']]
        """
        Settings that apply to quarantine rules.
        """
        redirect: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsRedirectArgsDict']]
        """
        Settings that apply to redirect rules.
        """
        resolve_dns_internally: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict']]
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        resolve_dns_through_cloudflare: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        untrusted_cert: NotRequired[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict']]
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsArgs:
    def __init__(__self__, *,
                 add_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 allow_child_bypass: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_ssh: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']] = None,
                 biso_admin_controls: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']] = None,
                 block_page: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs']] = None,
                 block_page_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 block_reason: Optional[pulumi.Input[_builtins.str]] = None,
                 bypass_parent_rule: Optional[pulumi.Input[_builtins.bool]] = None,
                 check_session: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']] = None,
                 dns_resolvers: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']] = None,
                 egress: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']] = None,
                 ignore_cname_category_matches: Optional[pulumi.Input[_builtins.bool]] = None,
                 insecure_disable_dnssec_validation: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_categories: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_indicator_feeds: Optional[pulumi.Input[_builtins.bool]] = None,
                 l4override: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']] = None,
                 notification_settings: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']] = None,
                 override_host: Optional[pulumi.Input[_builtins.str]] = None,
                 override_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 payload_log: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']] = None,
                 quarantine: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs']] = None,
                 redirect: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsRedirectArgs']] = None,
                 resolve_dns_internally: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs']] = None,
                 resolve_dns_through_cloudflare: Optional[pulumi.Input[_builtins.bool]] = None,
                 untrusted_cert: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] add_headers: Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        :param pulumi.Input[_builtins.bool] allow_child_bypass: Set by parent MSP accounts to enable their children to bypass this rule.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs'] audit_ssh: Settings for the Audit SSH action.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs'] biso_admin_controls: Configure how browser isolation behaves.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs'] block_page: Custom block page settings. If missing/null, blocking will use the the account settings.
        :param pulumi.Input[_builtins.bool] block_page_enabled: Enable the custom block page.
        :param pulumi.Input[_builtins.str] block_reason: The text describing why this block occurred, displayed on the custom block page (if enabled).
        :param pulumi.Input[_builtins.bool] bypass_parent_rule: Set by children MSP accounts to bypass their parent's rules.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs'] check_session: Configure how session check behaves.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs'] dns_resolvers: Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs'] egress: Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        :param pulumi.Input[_builtins.bool] ignore_cname_category_matches: Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        :param pulumi.Input[_builtins.bool] insecure_disable_dnssec_validation: INSECURE - disable DNSSEC validation (for Allow actions).
        :param pulumi.Input[_builtins.bool] ip_categories: Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        :param pulumi.Input[_builtins.bool] ip_indicator_feeds: Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs'] l4override: Send matching traffic to the supplied destination IP address. and port.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs'] notification_settings: Configure a notification to display on the user's device when this rule is matched.
        :param pulumi.Input[_builtins.str] override_host: Override matching DNS queries with a hostname.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] override_ips: Override matching DNS queries with an IP or set of IPs.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs'] payload_log: Configure DLP payload logging.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs'] quarantine: Settings that apply to quarantine rules.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsRedirectArgs'] redirect: Settings that apply to redirect rules.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs'] resolve_dns_internally: Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input[_builtins.bool] resolve_dns_through_cloudflare: Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        :param pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs'] untrusted_cert: Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        if add_headers is not None:
            pulumi.set(__self__, "add_headers", add_headers)
        if allow_child_bypass is not None:
            pulumi.set(__self__, "allow_child_bypass", allow_child_bypass)
        if audit_ssh is not None:
            pulumi.set(__self__, "audit_ssh", audit_ssh)
        if biso_admin_controls is not None:
            pulumi.set(__self__, "biso_admin_controls", biso_admin_controls)
        if block_page is not None:
            pulumi.set(__self__, "block_page", block_page)
        if block_page_enabled is not None:
            pulumi.set(__self__, "block_page_enabled", block_page_enabled)
        if block_reason is not None:
            pulumi.set(__self__, "block_reason", block_reason)
        if bypass_parent_rule is not None:
            pulumi.set(__self__, "bypass_parent_rule", bypass_parent_rule)
        if check_session is not None:
            pulumi.set(__self__, "check_session", check_session)
        if dns_resolvers is not None:
            pulumi.set(__self__, "dns_resolvers", dns_resolvers)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ignore_cname_category_matches is not None:
            pulumi.set(__self__, "ignore_cname_category_matches", ignore_cname_category_matches)
        if insecure_disable_dnssec_validation is not None:
            pulumi.set(__self__, "insecure_disable_dnssec_validation", insecure_disable_dnssec_validation)
        if ip_categories is not None:
            pulumi.set(__self__, "ip_categories", ip_categories)
        if ip_indicator_feeds is not None:
            pulumi.set(__self__, "ip_indicator_feeds", ip_indicator_feeds)
        if l4override is not None:
            pulumi.set(__self__, "l4override", l4override)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if override_ips is not None:
            pulumi.set(__self__, "override_ips", override_ips)
        if payload_log is not None:
            pulumi.set(__self__, "payload_log", payload_log)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if resolve_dns_internally is not None:
            pulumi.set(__self__, "resolve_dns_internally", resolve_dns_internally)
        if resolve_dns_through_cloudflare is not None:
            pulumi.set(__self__, "resolve_dns_through_cloudflare", resolve_dns_through_cloudflare)
        if untrusted_cert is not None:
            pulumi.set(__self__, "untrusted_cert", untrusted_cert)

    @_builtins.property
    @pulumi.getter(name="addHeaders")
    def add_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
        """
        return pulumi.get(self, "add_headers")

    @add_headers.setter
    def add_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "add_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowChildBypass")
    def allow_child_bypass(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set by parent MSP accounts to enable their children to bypass this rule.
        """
        return pulumi.get(self, "allow_child_bypass")

    @allow_child_bypass.setter
    def allow_child_bypass(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_child_bypass", value)

    @_builtins.property
    @pulumi.getter(name="auditSsh")
    def audit_ssh(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']]:
        """
        Settings for the Audit SSH action.
        """
        return pulumi.get(self, "audit_ssh")

    @audit_ssh.setter
    def audit_ssh(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs']]):
        pulumi.set(self, "audit_ssh", value)

    @_builtins.property
    @pulumi.getter(name="bisoAdminControls")
    def biso_admin_controls(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']]:
        """
        Configure how browser isolation behaves.
        """
        return pulumi.get(self, "biso_admin_controls")

    @biso_admin_controls.setter
    def biso_admin_controls(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs']]):
        pulumi.set(self, "biso_admin_controls", value)

    @_builtins.property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs']]:
        """
        Custom block page settings. If missing/null, blocking will use the the account settings.
        """
        return pulumi.get(self, "block_page")

    @block_page.setter
    def block_page(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs']]):
        pulumi.set(self, "block_page", value)

    @_builtins.property
    @pulumi.getter(name="blockPageEnabled")
    def block_page_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the custom block page.
        """
        return pulumi.get(self, "block_page_enabled")

    @block_page_enabled.setter
    def block_page_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_page_enabled", value)

    @_builtins.property
    @pulumi.getter(name="blockReason")
    def block_reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text describing why this block occurred, displayed on the custom block page (if enabled).
        """
        return pulumi.get(self, "block_reason")

    @block_reason.setter
    def block_reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "block_reason", value)

    @_builtins.property
    @pulumi.getter(name="bypassParentRule")
    def bypass_parent_rule(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set by children MSP accounts to bypass their parent's rules.
        """
        return pulumi.get(self, "bypass_parent_rule")

    @bypass_parent_rule.setter
    def bypass_parent_rule(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bypass_parent_rule", value)

    @_builtins.property
    @pulumi.getter(name="checkSession")
    def check_session(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']]:
        """
        Configure how session check behaves.
        """
        return pulumi.get(self, "check_session")

    @check_session.setter
    def check_session(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs']]):
        pulumi.set(self, "check_session", value)

    @_builtins.property
    @pulumi.getter(name="dnsResolvers")
    def dns_resolvers(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']]:
        """
        Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve*dns*through*cloudflare' or 'resolve*dns*internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "dns_resolvers")

    @dns_resolvers.setter
    def dns_resolvers(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs']]):
        pulumi.set(self, "dns_resolvers", value)

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']]:
        """
        Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsEgressArgs']]):
        pulumi.set(self, "egress", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCnameCategoryMatches")
    def ignore_cname_category_matches(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
        """
        return pulumi.get(self, "ignore_cname_category_matches")

    @ignore_cname_category_matches.setter
    def ignore_cname_category_matches(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_cname_category_matches", value)

    @_builtins.property
    @pulumi.getter(name="insecureDisableDnssecValidation")
    def insecure_disable_dnssec_validation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        INSECURE - disable DNSSEC validation (for Allow actions).
        """
        return pulumi.get(self, "insecure_disable_dnssec_validation")

    @insecure_disable_dnssec_validation.setter
    def insecure_disable_dnssec_validation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_disable_dnssec_validation", value)

    @_builtins.property
    @pulumi.getter(name="ipCategories")
    def ip_categories(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
        """
        return pulumi.get(self, "ip_categories")

    @ip_categories.setter
    def ip_categories(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ip_categories", value)

    @_builtins.property
    @pulumi.getter(name="ipIndicatorFeeds")
    def ip_indicator_feeds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
        """
        return pulumi.get(self, "ip_indicator_feeds")

    @ip_indicator_feeds.setter
    def ip_indicator_feeds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ip_indicator_feeds", value)

    @_builtins.property
    @pulumi.getter
    def l4override(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']]:
        """
        Send matching traffic to the supplied destination IP address. and port.
        """
        return pulumi.get(self, "l4override")

    @l4override.setter
    def l4override(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs']]):
        pulumi.set(self, "l4override", value)

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']]:
        """
        Configure a notification to display on the user's device when this rule is matched.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @_builtins.property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Override matching DNS queries with a hostname.
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_host", value)

    @_builtins.property
    @pulumi.getter(name="overrideIps")
    def override_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Override matching DNS queries with an IP or set of IPs.
        """
        return pulumi.get(self, "override_ips")

    @override_ips.setter
    def override_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "override_ips", value)

    @_builtins.property
    @pulumi.getter(name="payloadLog")
    def payload_log(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']]:
        """
        Configure DLP payload logging.
        """
        return pulumi.get(self, "payload_log")

    @payload_log.setter
    def payload_log(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs']]):
        pulumi.set(self, "payload_log", value)

    @_builtins.property
    @pulumi.getter
    def quarantine(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs']]:
        """
        Settings that apply to quarantine rules.
        """
        return pulumi.get(self, "quarantine")

    @quarantine.setter
    def quarantine(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs']]):
        pulumi.set(self, "quarantine", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsRedirectArgs']]:
        """
        Settings that apply to redirect rules.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsRedirectArgs']]):
        pulumi.set(self, "redirect", value)

    @_builtins.property
    @pulumi.getter(name="resolveDnsInternally")
    def resolve_dns_internally(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs']]:
        """
        Configure to forward the query to the internal DNS service, passing the specified 'view*id' as input. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns*through*cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_internally")

    @resolve_dns_internally.setter
    def resolve_dns_internally(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs']]):
        pulumi.set(self, "resolve_dns_internally", value)

    @_builtins.property
    @pulumi.getter(name="resolveDnsThroughCloudflare")
    def resolve_dns_through_cloudflare(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns*resolvers' are specified or 'resolve*dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
        """
        return pulumi.get(self, "resolve_dns_through_cloudflare")

    @resolve_dns_through_cloudflare.setter
    def resolve_dns_through_cloudflare(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "resolve_dns_through_cloudflare", value)

    @_builtins.property
    @pulumi.getter(name="untrustedCert")
    def untrusted_cert(self) -> Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']]:
        """
        Configure behavior when an upstream cert is invalid or an SSL error occurs.
        """
        return pulumi.get(self, "untrusted_cert")

    @untrusted_cert.setter
    def untrusted_cert(self, value: Optional[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs']]):
        pulumi.set(self, "untrusted_cert", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict(TypedDict):
        command_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to turn on SSH command logging.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsAuditSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsAuditSshArgs:
    def __init__(__self__, *,
                 command_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] command_logging: Enable to turn on SSH command logging.
        """
        if command_logging is not None:
            pulumi.set(__self__, "command_logging", command_logging)

    @_builtins.property
    @pulumi.getter(name="commandLogging")
    def command_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to turn on SSH command logging.
        """
        return pulumi.get(self, "command_logging")

    @command_logging.setter
    def command_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "command_logging", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict(TypedDict):
        copy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether copy is enabled or not. When set with "remote*only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        dcp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        dd: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        dk: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        download: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether downloading enabled or not. When set with "remote*only", downloads are only available for viewing. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        dp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        du: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        keyboard: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        paste: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether pasting is enabled or not. When set with "remote*only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        printing: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        upload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates which version of the browser isolation controls should apply.
        Available values: "v1", "v2".
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsBisoAdminControlsArgs:
    def __init__(__self__, *,
                 copy: Optional[pulumi.Input[_builtins.str]] = None,
                 dcp: Optional[pulumi.Input[_builtins.bool]] = None,
                 dd: Optional[pulumi.Input[_builtins.bool]] = None,
                 dk: Optional[pulumi.Input[_builtins.bool]] = None,
                 download: Optional[pulumi.Input[_builtins.str]] = None,
                 dp: Optional[pulumi.Input[_builtins.bool]] = None,
                 du: Optional[pulumi.Input[_builtins.bool]] = None,
                 keyboard: Optional[pulumi.Input[_builtins.str]] = None,
                 paste: Optional[pulumi.Input[_builtins.str]] = None,
                 printing: Optional[pulumi.Input[_builtins.str]] = None,
                 upload: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] copy: Configure whether copy is enabled or not. When set with "remote*only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled", "remote*only".
        :param pulumi.Input[_builtins.bool] dcp: Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.bool] dd: Set to false to enable downloading. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.bool] dk: Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.str] download: Configure whether downloading enabled or not. When set with "remote*only", downloads are only available for viewing. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled", "remote*only".
        :param pulumi.Input[_builtins.bool] dp: Set to false to enable printing. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.bool] du: Set to false to enable uploading. Only applies when `version == "v1"`.
        :param pulumi.Input[_builtins.str] keyboard: Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled".
        :param pulumi.Input[_builtins.str] paste: Configure whether pasting is enabled or not. When set with "remote*only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled", "remote*only".
        :param pulumi.Input[_builtins.str] printing: Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled".
        :param pulumi.Input[_builtins.str] upload: Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
               Available values: "enabled", "disabled".
        :param pulumi.Input[_builtins.str] version: Indicates which version of the browser isolation controls should apply.
               Available values: "v1", "v2".
        """
        if copy is not None:
            pulumi.set(__self__, "copy", copy)
        if dcp is not None:
            pulumi.set(__self__, "dcp", dcp)
        if dd is not None:
            pulumi.set(__self__, "dd", dd)
        if dk is not None:
            pulumi.set(__self__, "dk", dk)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if dp is not None:
            pulumi.set(__self__, "dp", dp)
        if du is not None:
            pulumi.set(__self__, "du", du)
        if keyboard is not None:
            pulumi.set(__self__, "keyboard", keyboard)
        if paste is not None:
            pulumi.set(__self__, "paste", paste)
        if printing is not None:
            pulumi.set(__self__, "printing", printing)
        if upload is not None:
            pulumi.set(__self__, "upload", upload)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def copy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether copy is enabled or not. When set with "remote*only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        return pulumi.get(self, "copy")

    @copy.setter
    def copy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "copy", value)

    @_builtins.property
    @pulumi.getter
    def dcp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable copy-pasting. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dcp")

    @dcp.setter
    def dcp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dcp", value)

    @_builtins.property
    @pulumi.getter
    def dd(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable downloading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dd")

    @dd.setter
    def dd(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dd", value)

    @_builtins.property
    @pulumi.getter
    def dk(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable keyboard usage. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dk")

    @dk.setter
    def dk(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dk", value)

    @_builtins.property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether downloading enabled or not. When set with "remote*only", downloads are only available for viewing. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "download", value)

    @_builtins.property
    @pulumi.getter
    def dp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable printing. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "dp")

    @dp.setter
    def dp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dp", value)

    @_builtins.property
    @pulumi.getter
    def du(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to false to enable uploading. Only applies when `version == "v1"`.
        """
        return pulumi.get(self, "du")

    @du.setter
    def du(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "du", value)

    @_builtins.property
    @pulumi.getter
    def keyboard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        return pulumi.get(self, "keyboard")

    @keyboard.setter
    def keyboard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyboard", value)

    @_builtins.property
    @pulumi.getter
    def paste(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether pasting is enabled or not. When set with "remote*only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled", "remote*only".
        """
        return pulumi.get(self, "paste")

    @paste.setter
    def paste(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "paste", value)

    @_builtins.property
    @pulumi.getter
    def printing(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        return pulumi.get(self, "printing")

    @printing.setter
    def printing(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "printing", value)

    @_builtins.property
    @pulumi.getter
    def upload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
        Available values: "enabled", "disabled".
        """
        return pulumi.get(self, "upload")

    @upload.setter
    def upload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upload", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates which version of the browser isolation controls should apply.
        Available values: "v1", "v2".
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsBlockPageArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        URI to which the user will be redirected.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsBlockPageArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str],
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] target_uri: URI to which the user will be redirected.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        """
        pulumi.set(__self__, "target_uri", target_uri)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI to which the user will be redirected.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[_builtins.str]]
        enforce: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to enable session enforcement.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsCheckSessionArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enforce: Set to true to enable session enforcement.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to enable session enforcement.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict']]]]
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @_builtins.property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @_builtins.property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IPv4 address of upstream resolver.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        route_through_private_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 route_through_private_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv4 address of upstream resolver.
        :param pulumi.Input[_builtins.int] port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param pulumi.Input[_builtins.bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param pulumi.Input[_builtins.str] vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IPv4 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IPv6 address of upstream resolver.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        route_through_private_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        vnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6Args:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 route_through_private_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 vnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv6 address of upstream resolver.
        :param pulumi.Input[_builtins.int] port: A port number to use for upstream resolver. Defaults to 53 if unspecified.
        :param pulumi.Input[_builtins.bool] route_through_private_network: Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        :param pulumi.Input[_builtins.str] vnet_id: Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if route_through_private_network is not None:
            pulumi.set(__self__, "route_through_private_network", route_through_private_network)
        if vnet_id is not None:
            pulumi.set(__self__, "vnet_id", vnet_id)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IPv6 address of upstream resolver.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A port number to use for upstream resolver. Defaults to 53 if unspecified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="routeThroughPrivateNetwork")
    def route_through_private_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
        """
        return pulumi.get(self, "route_through_private_network")

    @route_through_private_network.setter
    def route_through_private_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_through_private_network", value)

    @_builtins.property
    @pulumi.getter(name="vnetId")
    def vnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
        """
        return pulumi.get(self, "vnet_id")

    @vnet_id.setter
    def vnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vnet_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 address to be used for egress.
        """
        ipv4_fallback: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 range to be used for egress.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsEgressArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4_fallback: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: The IPv4 address to be used for egress.
        :param pulumi.Input[_builtins.str] ipv4_fallback: The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        :param pulumi.Input[_builtins.str] ipv6: The IPv6 range to be used for egress.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv4_fallback is not None:
            pulumi.set(__self__, "ipv4_fallback", ipv4_fallback)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 address to be used for egress.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Fallback")
    def ipv4_fallback(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
        """
        return pulumi.get(self, "ipv4_fallback")

    @ipv4_fallback.setter
    def ipv4_fallback(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4_fallback", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 range to be used for egress.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 or IPv6 address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        A port number to use for TCP/UDP overrides.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsL4overrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsL4overrideArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IPv4 or IPv6 address.
        :param pulumi.Input[_builtins.int] port: A port number to use for TCP/UDP overrides.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A port number to use for TCP/UDP overrides.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set notification on.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
        msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customize the message shown in the notification.
        """
        support_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 msg: Optional[pulumi.Input[_builtins.str]] = None,
                 support_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Set notification on.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        :param pulumi.Input[_builtins.str] msg: Customize the message shown in the notification.
        :param pulumi.Input[_builtins.str] support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set notification on.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "msg", value)

    @_builtins.property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set to true to enable DLP payload logging for this rule.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsPayloadLogArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Set to true to enable DLP payload logging for this rule.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set to true to enable DLP payload logging for this rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict(TypedDict):
        file_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Types of files to sandbox.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsQuarantineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsQuarantineArgs:
    def __init__(__self__, *,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] file_types: Types of files to sandbox.
        """
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)

    @_builtins.property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Types of files to sandbox.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "file_types", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsRedirectArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        URI to which the user will be redirected.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
        preserve_path_and_query: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the path and query parameters from the original request will be appended to target_uri.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsRedirectArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str],
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 preserve_path_and_query: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] target_uri: URI to which the user will be redirected.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        :param pulumi.Input[_builtins.bool] preserve_path_and_query: If true, the path and query parameters from the original request will be appended to target_uri.
        """
        pulumi.set(__self__, "target_uri", target_uri)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if preserve_path_and_query is not None:
            pulumi.set(__self__, "preserve_path_and_query", preserve_path_and_query)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI to which the user will be redirected.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter(name="preservePathAndQuery")
    def preserve_path_and_query(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the path and query parameters from the original request will be appended to target_uri.
        """
        return pulumi.get(self, "preserve_path_and_query")

    @preserve_path_and_query.setter
    def preserve_path_and_query(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_and_query", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict(TypedDict):
        fallback: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        Available values: "none", "public_dns".
        """
        view_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsResolveDnsInternallyArgs:
    def __init__(__self__, *,
                 fallback: Optional[pulumi.Input[_builtins.str]] = None,
                 view_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fallback: The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
               Available values: "none", "public_dns".
        :param pulumi.Input[_builtins.str] view_id: The internal DNS view identifier that's passed to the internal DNS service.
        """
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if view_id is not None:
            pulumi.set(__self__, "view_id", view_id)

    @_builtins.property
    @pulumi.getter
    def fallback(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
        Available values: "none", "public_dns".
        """
        return pulumi.get(self, "fallback")

    @fallback.setter
    def fallback(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback", value)

    @_builtins.property
    @pulumi.getter(name="viewId")
    def view_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The internal DNS view identifier that's passed to the internal DNS service.
        """
        return pulumi.get(self, "view_id")

    @view_id.setter
    def view_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "view_id", value)


if not MYPY:
    class ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        Available values: "pass_through", "block", "error".
        """
elif False:
    ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyRuleSettingsUntrustedCertArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
               Available values: "pass_through", "block", "error".
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
        Available values: "pass_through", "block", "error".
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)


if not MYPY:
    class ZeroTrustGatewayPolicyScheduleArgsDict(TypedDict):
        fri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        mon: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        sat: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        sun: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        thu: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        tue: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        wed: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
elif False:
    ZeroTrustGatewayPolicyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewayPolicyScheduleArgs:
    def __init__(__self__, *,
                 fri: Optional[pulumi.Input[_builtins.str]] = None,
                 mon: Optional[pulumi.Input[_builtins.str]] = None,
                 sat: Optional[pulumi.Input[_builtins.str]] = None,
                 sun: Optional[pulumi.Input[_builtins.str]] = None,
                 thu: Optional[pulumi.Input[_builtins.str]] = None,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 tue: Optional[pulumi.Input[_builtins.str]] = None,
                 wed: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] fri: The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        :param pulumi.Input[_builtins.str] mon: The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        :param pulumi.Input[_builtins.str] sat: The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        :param pulumi.Input[_builtins.str] sun: The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        :param pulumi.Input[_builtins.str] thu: The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        :param pulumi.Input[_builtins.str] time_zone: The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        :param pulumi.Input[_builtins.str] tue: The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        :param pulumi.Input[_builtins.str] wed: The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        if fri is not None:
            pulumi.set(__self__, "fri", fri)
        if mon is not None:
            pulumi.set(__self__, "mon", mon)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if sun is not None:
            pulumi.set(__self__, "sun", sun)
        if thu is not None:
            pulumi.set(__self__, "thu", thu)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if tue is not None:
            pulumi.set(__self__, "tue", tue)
        if wed is not None:
            pulumi.set(__self__, "wed", wed)

    @_builtins.property
    @pulumi.getter
    def fri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
        """
        return pulumi.get(self, "fri")

    @fri.setter
    def fri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fri", value)

    @_builtins.property
    @pulumi.getter
    def mon(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
        """
        return pulumi.get(self, "mon")

    @mon.setter
    def mon(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mon", value)

    @_builtins.property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
        """
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sat", value)

    @_builtins.property
    @pulumi.getter
    def sun(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
        """
        return pulumi.get(self, "sun")

    @sun.setter
    def sun(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sun", value)

    @_builtins.property
    @pulumi.getter
    def thu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
        """
        return pulumi.get(self, "thu")

    @thu.setter
    def thu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "thu", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def tue(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
        """
        return pulumi.get(self, "tue")

    @tue.setter
    def tue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tue", value)

    @_builtins.property
    @pulumi.getter
    def wed(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
        """
        return pulumi.get(self, "wed")

    @wed.setter
    def wed(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wed", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsArgsDict(TypedDict):
        activity_log: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgsDict']]
        """
        Activity log settings.
        """
        antivirus: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgsDict']]
        """
        Anti-virus settings.
        """
        block_page: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgsDict']]
        """
        Block page layout settings.
        """
        body_scanning: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict']]
        """
        DLP body scanning settings.
        """
        browser_isolation: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict']]
        """
        Browser isolation settings.
        """
        certificate: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgsDict']]
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        custom_certificate: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict']]
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`).
        """
        extended_email_matching: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict']]
        """
        Extended e-mail matching settings.
        """
        fips: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgsDict']]
        """
        FIPS settings.
        """
        host_selector: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsHostSelectorArgsDict']]
        """
        Setting to enable host selector in egress policies.
        """
        inspection: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsInspectionArgsDict']]
        """
        Setting to define inspection settings.
        """
        protocol_detection: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict']]
        """
        Protocol Detection settings.
        """
        sandbox: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgsDict']]
        """
        Sandbox settings.
        """
        tls_decrypt: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict']]
        """
        TLS interception settings.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsArgs:
    def __init__(__self__, *,
                 activity_log: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs']] = None,
                 antivirus: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs']] = None,
                 block_page: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs']] = None,
                 body_scanning: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs']] = None,
                 browser_isolation: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs']] = None,
                 certificate: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs']] = None,
                 custom_certificate: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs']] = None,
                 extended_email_matching: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs']] = None,
                 fips: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs']] = None,
                 host_selector: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsHostSelectorArgs']] = None,
                 inspection: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsInspectionArgs']] = None,
                 protocol_detection: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs']] = None,
                 sandbox: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs']] = None,
                 tls_decrypt: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs']] = None):
        """
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs'] activity_log: Activity log settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs'] antivirus: Anti-virus settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs'] block_page: Block page layout settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs'] body_scanning: DLP body scanning settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs'] browser_isolation: Browser isolation settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs'] certificate: Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs'] custom_certificate: Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`).
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs'] extended_email_matching: Extended e-mail matching settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs'] fips: FIPS settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsHostSelectorArgs'] host_selector: Setting to enable host selector in egress policies.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsInspectionArgs'] inspection: Setting to define inspection settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs'] protocol_detection: Protocol Detection settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs'] sandbox: Sandbox settings.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs'] tls_decrypt: TLS interception settings.
        """
        if activity_log is not None:
            pulumi.set(__self__, "activity_log", activity_log)
        if antivirus is not None:
            pulumi.set(__self__, "antivirus", antivirus)
        if block_page is not None:
            pulumi.set(__self__, "block_page", block_page)
        if body_scanning is not None:
            pulumi.set(__self__, "body_scanning", body_scanning)
        if browser_isolation is not None:
            pulumi.set(__self__, "browser_isolation", browser_isolation)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if custom_certificate is not None:
            warnings.warn("""This attribute is deprecated.""", DeprecationWarning)
            pulumi.log.warn("""custom_certificate is deprecated: This attribute is deprecated.""")
        if custom_certificate is not None:
            pulumi.set(__self__, "custom_certificate", custom_certificate)
        if extended_email_matching is not None:
            pulumi.set(__self__, "extended_email_matching", extended_email_matching)
        if fips is not None:
            pulumi.set(__self__, "fips", fips)
        if host_selector is not None:
            pulumi.set(__self__, "host_selector", host_selector)
        if inspection is not None:
            pulumi.set(__self__, "inspection", inspection)
        if protocol_detection is not None:
            pulumi.set(__self__, "protocol_detection", protocol_detection)
        if sandbox is not None:
            pulumi.set(__self__, "sandbox", sandbox)
        if tls_decrypt is not None:
            pulumi.set(__self__, "tls_decrypt", tls_decrypt)

    @_builtins.property
    @pulumi.getter(name="activityLog")
    def activity_log(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs']]:
        """
        Activity log settings.
        """
        return pulumi.get(self, "activity_log")

    @activity_log.setter
    def activity_log(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsActivityLogArgs']]):
        pulumi.set(self, "activity_log", value)

    @_builtins.property
    @pulumi.getter
    def antivirus(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs']]:
        """
        Anti-virus settings.
        """
        return pulumi.get(self, "antivirus")

    @antivirus.setter
    def antivirus(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusArgs']]):
        pulumi.set(self, "antivirus", value)

    @_builtins.property
    @pulumi.getter(name="blockPage")
    def block_page(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs']]:
        """
        Block page layout settings.
        """
        return pulumi.get(self, "block_page")

    @block_page.setter
    def block_page(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBlockPageArgs']]):
        pulumi.set(self, "block_page", value)

    @_builtins.property
    @pulumi.getter(name="bodyScanning")
    def body_scanning(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs']]:
        """
        DLP body scanning settings.
        """
        return pulumi.get(self, "body_scanning")

    @body_scanning.setter
    def body_scanning(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBodyScanningArgs']]):
        pulumi.set(self, "body_scanning", value)

    @_builtins.property
    @pulumi.getter(name="browserIsolation")
    def browser_isolation(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs']]:
        """
        Browser isolation settings.
        """
        return pulumi.get(self, "browser_isolation")

    @browser_isolation.setter
    def browser_isolation(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs']]):
        pulumi.set(self, "browser_isolation", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs']]:
        """
        Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="customCertificate")
    @_utilities.deprecated("""This attribute is deprecated.""")
    def custom_certificate(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs']]:
        """
        Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`).
        """
        return pulumi.get(self, "custom_certificate")

    @custom_certificate.setter
    def custom_certificate(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsCustomCertificateArgs']]):
        pulumi.set(self, "custom_certificate", value)

    @_builtins.property
    @pulumi.getter(name="extendedEmailMatching")
    def extended_email_matching(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs']]:
        """
        Extended e-mail matching settings.
        """
        return pulumi.get(self, "extended_email_matching")

    @extended_email_matching.setter
    def extended_email_matching(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs']]):
        pulumi.set(self, "extended_email_matching", value)

    @_builtins.property
    @pulumi.getter
    def fips(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs']]:
        """
        FIPS settings.
        """
        return pulumi.get(self, "fips")

    @fips.setter
    def fips(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsFipsArgs']]):
        pulumi.set(self, "fips", value)

    @_builtins.property
    @pulumi.getter(name="hostSelector")
    def host_selector(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsHostSelectorArgs']]:
        """
        Setting to enable host selector in egress policies.
        """
        return pulumi.get(self, "host_selector")

    @host_selector.setter
    def host_selector(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsHostSelectorArgs']]):
        pulumi.set(self, "host_selector", value)

    @_builtins.property
    @pulumi.getter
    def inspection(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsInspectionArgs']]:
        """
        Setting to define inspection settings.
        """
        return pulumi.get(self, "inspection")

    @inspection.setter
    def inspection(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsInspectionArgs']]):
        pulumi.set(self, "inspection", value)

    @_builtins.property
    @pulumi.getter(name="protocolDetection")
    def protocol_detection(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs']]:
        """
        Protocol Detection settings.
        """
        return pulumi.get(self, "protocol_detection")

    @protocol_detection.setter
    def protocol_detection(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs']]):
        pulumi.set(self, "protocol_detection", value)

    @_builtins.property
    @pulumi.getter
    def sandbox(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs']]:
        """
        Sandbox settings.
        """
        return pulumi.get(self, "sandbox")

    @sandbox.setter
    def sandbox(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsSandboxArgs']]):
        pulumi.set(self, "sandbox", value)

    @_builtins.property
    @pulumi.getter(name="tlsDecrypt")
    def tls_decrypt(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs']]:
        """
        TLS interception settings.
        """
        return pulumi.get(self, "tls_decrypt")

    @tls_decrypt.setter
    def tls_decrypt(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsTlsDecryptArgs']]):
        pulumi.set(self, "tls_decrypt", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsActivityLogArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable activity logging.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsActivityLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsActivityLogArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable activity logging.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable activity logging.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsAntivirusArgsDict(TypedDict):
        enabled_download_phase: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable anti-virus scanning on downloads.
        """
        enabled_upload_phase: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable anti-virus scanning on uploads.
        """
        fail_closed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Block requests for files that cannot be scanned.
        """
        notification_settings: NotRequired[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict']]
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsAntivirusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsAntivirusArgs:
    def __init__(__self__, *,
                 enabled_download_phase: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled_upload_phase: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_closed: Optional[pulumi.Input[_builtins.bool]] = None,
                 notification_settings: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled_download_phase: Enable anti-virus scanning on downloads.
        :param pulumi.Input[_builtins.bool] enabled_upload_phase: Enable anti-virus scanning on uploads.
        :param pulumi.Input[_builtins.bool] fail_closed: Block requests for files that cannot be scanned.
        :param pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs'] notification_settings: Configure a message to display on the user's device when an antivirus search is performed.
        """
        if enabled_download_phase is not None:
            pulumi.set(__self__, "enabled_download_phase", enabled_download_phase)
        if enabled_upload_phase is not None:
            pulumi.set(__self__, "enabled_upload_phase", enabled_upload_phase)
        if fail_closed is not None:
            pulumi.set(__self__, "fail_closed", fail_closed)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)

    @_builtins.property
    @pulumi.getter(name="enabledDownloadPhase")
    def enabled_download_phase(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable anti-virus scanning on downloads.
        """
        return pulumi.get(self, "enabled_download_phase")

    @enabled_download_phase.setter
    def enabled_download_phase(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_download_phase", value)

    @_builtins.property
    @pulumi.getter(name="enabledUploadPhase")
    def enabled_upload_phase(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable anti-virus scanning on uploads.
        """
        return pulumi.get(self, "enabled_upload_phase")

    @enabled_upload_phase.setter
    def enabled_upload_phase(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled_upload_phase", value)

    @_builtins.property
    @pulumi.getter(name="failClosed")
    def fail_closed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Block requests for files that cannot be scanned.
        """
        return pulumi.get(self, "fail_closed")

    @fail_closed.setter
    def fail_closed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_closed", value)

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs']]:
        """
        Configure a message to display on the user's device when an antivirus search is performed.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set notification on.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, context information will be passed as query parameters.
        """
        msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customize the message shown in the notification.
        """
        support_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsAntivirusNotificationSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 msg: Optional[pulumi.Input[_builtins.str]] = None,
                 support_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Set notification on.
        :param pulumi.Input[_builtins.bool] include_context: If true, context information will be passed as query parameters.
        :param pulumi.Input[_builtins.str] msg: Customize the message shown in the notification.
        :param pulumi.Input[_builtins.str] support_url: Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if support_url is not None:
            pulumi.set(__self__, "support_url", support_url)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set notification on.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, context information will be passed as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customize the message shown in the notification.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "msg", value)

    @_builtins.property
    @pulumi.getter(name="supportUrl")
    def support_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional URL to direct users to additional information. If not set, the notification will open a block page.
        """
        return pulumi.get(self, "support_url")

    @support_url.setter
    def support_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_url", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsBlockPageArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page background color in #rrggbb format.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        footer_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page footer text.
        """
        header_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page header text.
        """
        include_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
        """
        logo_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: full URL to the logo file.
        """
        mailto_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: admin email for users to contact.
        """
        mailto_subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: subject line for emails created from block page.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
        Available values: "", "customized_block_page", "redirect_uri".
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is customized_block_page: block page title.
        """
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        source_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account tag of account that shared this setting.
        """
        suppress_footer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If mode is customized_block_page: suppress detailed info at the bottom of the block page.
        """
        target_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        If mode is redirect_uri: URI to which the user should be redirected.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Version number of the setting.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsBlockPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsBlockPageArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 footer_text: Optional[pulumi.Input[_builtins.str]] = None,
                 header_text: Optional[pulumi.Input[_builtins.str]] = None,
                 include_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 logo_path: Optional[pulumi.Input[_builtins.str]] = None,
                 mailto_address: Optional[pulumi.Input[_builtins.str]] = None,
                 mailto_subject: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_account: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_footer: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] background_color: If mode is customized_block_page: block page background color in #rrggbb format.
        :param pulumi.Input[_builtins.bool] enabled: Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        :param pulumi.Input[_builtins.str] footer_text: If mode is customized_block_page: block page footer text.
        :param pulumi.Input[_builtins.str] header_text: If mode is customized_block_page: block page header text.
        :param pulumi.Input[_builtins.bool] include_context: If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
        :param pulumi.Input[_builtins.str] logo_path: If mode is customized_block_page: full URL to the logo file.
        :param pulumi.Input[_builtins.str] mailto_address: If mode is customized_block_page: admin email for users to contact.
        :param pulumi.Input[_builtins.str] mailto_subject: If mode is customized_block_page: subject line for emails created from block page.
        :param pulumi.Input[_builtins.str] mode: Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
               Available values: "", "customized_block_page", "redirect_uri".
        :param pulumi.Input[_builtins.str] name: If mode is customized_block_page: block page title.
        :param pulumi.Input[_builtins.bool] read_only: This setting was shared via the Orgs API and cannot be edited by the current account.
        :param pulumi.Input[_builtins.str] source_account: Account tag of account that shared this setting.
        :param pulumi.Input[_builtins.bool] suppress_footer: If mode is customized_block_page: suppress detailed info at the bottom of the block page.
        :param pulumi.Input[_builtins.str] target_uri: If mode is redirect_uri: URI to which the user should be redirected.
        :param pulumi.Input[_builtins.int] version: Version number of the setting.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if include_context is not None:
            pulumi.set(__self__, "include_context", include_context)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if mailto_address is not None:
            pulumi.set(__self__, "mailto_address", mailto_address)
        if mailto_subject is not None:
            pulumi.set(__self__, "mailto_subject", mailto_subject)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_account is not None:
            pulumi.set(__self__, "source_account", source_account)
        if suppress_footer is not None:
            pulumi.set(__self__, "suppress_footer", suppress_footer)
        if target_uri is not None:
            pulumi.set(__self__, "target_uri", target_uri)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page background color in #rrggbb format.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "background_color", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page footer text.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "footer_text", value)

    @_builtins.property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page header text.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_text", value)

    @_builtins.property
    @pulumi.getter(name="includeContext")
    def include_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
        """
        return pulumi.get(self, "include_context")

    @include_context.setter
    def include_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_context", value)

    @_builtins.property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: full URL to the logo file.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo_path", value)

    @_builtins.property
    @pulumi.getter(name="mailtoAddress")
    def mailto_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: admin email for users to contact.
        """
        return pulumi.get(self, "mailto_address")

    @mailto_address.setter
    def mailto_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mailto_address", value)

    @_builtins.property
    @pulumi.getter(name="mailtoSubject")
    def mailto_subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: subject line for emails created from block page.
        """
        return pulumi.get(self, "mailto_subject")

    @mailto_subject.setter
    def mailto_subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mailto_subject", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
        Available values: "", "customized_block_page", "redirect_uri".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is customized_block_page: block page title.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="sourceAccount")
    def source_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account tag of account that shared this setting.
        """
        return pulumi.get(self, "source_account")

    @source_account.setter
    def source_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_account", value)

    @_builtins.property
    @pulumi.getter(name="suppressFooter")
    def suppress_footer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If mode is customized_block_page: suppress detailed info at the bottom of the block page.
        """
        return pulumi.get(self, "suppress_footer")

    @suppress_footer.setter
    def suppress_footer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suppress_footer", value)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If mode is redirect_uri: URI to which the user should be redirected.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_uri", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Version number of the setting.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict(TypedDict):
        inspection_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set the inspection mode to either `deep` or `shallow`.
        Available values: "deep", "shallow".
        """
elif False:
    ZeroTrustGatewaySettingsSettingsBodyScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsBodyScanningArgs:
    def __init__(__self__, *,
                 inspection_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] inspection_mode: Set the inspection mode to either `deep` or `shallow`.
               Available values: "deep", "shallow".
        """
        if inspection_mode is not None:
            pulumi.set(__self__, "inspection_mode", inspection_mode)

    @_builtins.property
    @pulumi.getter(name="inspectionMode")
    def inspection_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set the inspection mode to either `deep` or `shallow`.
        Available values: "deep", "shallow".
        """
        return pulumi.get(self, "inspection_mode")

    @inspection_mode.setter
    def inspection_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inspection_mode", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict(TypedDict):
        non_identity_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        url_browser_isolation_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Clientless Browser Isolation.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsBrowserIsolationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsBrowserIsolationArgs:
    def __init__(__self__, *,
                 non_identity_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 url_browser_isolation_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] non_identity_enabled: Enable non-identity onramp support for Browser Isolation.
        :param pulumi.Input[_builtins.bool] url_browser_isolation_enabled: Enable Clientless Browser Isolation.
        """
        if non_identity_enabled is not None:
            pulumi.set(__self__, "non_identity_enabled", non_identity_enabled)
        if url_browser_isolation_enabled is not None:
            pulumi.set(__self__, "url_browser_isolation_enabled", url_browser_isolation_enabled)

    @_builtins.property
    @pulumi.getter(name="nonIdentityEnabled")
    def non_identity_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable non-identity onramp support for Browser Isolation.
        """
        return pulumi.get(self, "non_identity_enabled")

    @non_identity_enabled.setter
    def non_identity_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "non_identity_enabled", value)

    @_builtins.property
    @pulumi.getter(name="urlBrowserIsolationEnabled")
    def url_browser_isolation_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Clientless Browser Isolation.
        """
        return pulumi.get(self, "url_browser_isolation_enabled")

    @url_browser_isolation_enabled.setter
    def url_browser_isolation_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "url_browser_isolation_enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsCertificateArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsCertificateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable use of custom certificate authority for signing Gateway. traffic.
        """
        binding_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Certificate status (internal).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ZeroTrustGatewaySettingsSettingsCustomCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsCustomCertificateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 binding_status: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable use of custom certificate authority for signing Gateway. traffic.
        :param pulumi.Input[_builtins.str] binding_status: Certificate status (internal).
        :param pulumi.Input[_builtins.str] id: UUID of certificate (ID from MTLS certificate store).
        """
        pulumi.set(__self__, "enabled", enabled)
        if binding_status is not None:
            pulumi.set(__self__, "binding_status", binding_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable use of custom certificate authority for signing Gateway. traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="bindingStatus")
    def binding_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Certificate status (internal).
        """
        return pulumi.get(self, "binding_status")

    @binding_status.setter
    def binding_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "binding_status", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of certificate (ID from MTLS certificate store).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        source_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account tag of account that shared this setting.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Version number of the setting.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsExtendedEmailMatchingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_account: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        :param pulumi.Input[_builtins.bool] read_only: This setting was shared via the Orgs API and cannot be edited by the current account.
        :param pulumi.Input[_builtins.str] source_account: Account tag of account that shared this setting.
        :param pulumi.Input[_builtins.int] version: Version number of the setting.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_account is not None:
            pulumi.set(__self__, "source_account", source_account)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        This setting was shared via the Orgs API and cannot be edited by the current account.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="sourceAccount")
    def source_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account tag of account that shared this setting.
        """
        return pulumi.get(self, "source_account")

    @source_account.setter
    def source_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_account", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Version number of the setting.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsFipsArgsDict(TypedDict):
        tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsFipsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsFipsArgs:
    def __init__(__self__, *,
                 tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] tls: Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable only cipher suites and TLS versions compliant with FIPS. 140-2.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsHostSelectorArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable filtering via hosts for egress policies.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsHostSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsHostSelectorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable filtering via hosts for egress policies.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable filtering via hosts for egress policies.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsInspectionArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the mode of inspection the proxy will use.
        - static: Gateway will use static inspection to inspect HTTP on TCP(80). If TLS decryption is on, Gateway will inspect HTTPS traffic on TCP(443) & UDP(443).
        - dynamic: Gateway will use protocol detection to dynamically inspect HTTP and HTTPS traffic on any port. TLS decryption must be on to inspect HTTPS traffic.
        Available values: "static", "dynamic".
        """
elif False:
    ZeroTrustGatewaySettingsSettingsInspectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsInspectionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Defines the mode of inspection the proxy will use.
               - static: Gateway will use static inspection to inspect HTTP on TCP(80). If TLS decryption is on, Gateway will inspect HTTPS traffic on TCP(443) & UDP(443).
               - dynamic: Gateway will use protocol detection to dynamically inspect HTTP and HTTPS traffic on any port. TLS decryption must be on to inspect HTTPS traffic.
               Available values: "static", "dynamic".
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the mode of inspection the proxy will use.
        - static: Gateway will use static inspection to inspect HTTP on TCP(80). If TLS decryption is on, Gateway will inspect HTTPS traffic on TCP(443) & UDP(443).
        - dynamic: Gateway will use protocol detection to dynamically inspect HTTP and HTTPS traffic on any port. TLS decryption must be on to inspect HTTPS traffic.
        Available values: "static", "dynamic".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsProtocolDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsProtocolDetectionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable detecting protocol on initial bytes of client traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable detecting protocol on initial bytes of client traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsSandboxArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable sandbox.
        """
        fallback_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take when the file cannot be scanned.
        Available values: "allow", "block".
        """
elif False:
    ZeroTrustGatewaySettingsSettingsSandboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsSandboxArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 fallback_action: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable sandbox.
        :param pulumi.Input[_builtins.str] fallback_action: Action to take when the file cannot be scanned.
               Available values: "allow", "block".
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable sandbox.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take when the file cannot be scanned.
        Available values: "allow", "block".
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_action", value)


if not MYPY:
    class ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable inspecting encrypted HTTP traffic.
        """
elif False:
    ZeroTrustGatewaySettingsSettingsTlsDecryptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustGatewaySettingsSettingsTlsDecryptArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable inspecting encrypted HTTP traffic.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable inspecting encrypted HTTP traffic.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustListItemArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the list item, if present.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the item in a list.
        """
elif False:
    ZeroTrustListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustListItemArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the list item, if present.
        :param pulumi.Input[_builtins.str] value: The value of the item in a list.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the list item, if present.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the item in a list.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ZeroTrustLocalFallbackDomainDomainArgsDict(TypedDict):
        suffix: pulumi.Input[_builtins.str]
        """
        The domain suffix to match when resolving locally.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the fallback domain, displayed in the client UI.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IP addresses to handle domain resolution.
        """
elif False:
    ZeroTrustLocalFallbackDomainDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustLocalFallbackDomainDomainArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] suffix: The domain suffix to match when resolving locally.
        :param pulumi.Input[_builtins.str] description: A description of the fallback domain, displayed in the client UI.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns_servers: A list of IP addresses to handle domain resolution.
        """
        pulumi.set(__self__, "suffix", suffix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[_builtins.str]:
        """
        The domain suffix to match when resolving locally.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "suffix", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the fallback domain, displayed in the client UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses to handle domain resolution.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class ZeroTrustOrganizationCustomPagesArgsDict(TypedDict):
        forbidden: NotRequired[pulumi.Input[_builtins.str]]
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        identity_denied: NotRequired[pulumi.Input[_builtins.str]]
        """
        The uid of the custom page to use when a user is denied access.
        """
elif False:
    ZeroTrustOrganizationCustomPagesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustOrganizationCustomPagesArgs:
    def __init__(__self__, *,
                 forbidden: Optional[pulumi.Input[_builtins.str]] = None,
                 identity_denied: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] forbidden: The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        :param pulumi.Input[_builtins.str] identity_denied: The uid of the custom page to use when a user is denied access.
        """
        if forbidden is not None:
            pulumi.set(__self__, "forbidden", forbidden)
        if identity_denied is not None:
            pulumi.set(__self__, "identity_denied", identity_denied)

    @_builtins.property
    @pulumi.getter
    def forbidden(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The uid of the custom page to use when a user is denied access after failing a non-identity rule.
        """
        return pulumi.get(self, "forbidden")

    @forbidden.setter
    def forbidden(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "forbidden", value)

    @_builtins.property
    @pulumi.getter(name="identityDenied")
    def identity_denied(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The uid of the custom page to use when a user is denied access.
        """
        return pulumi.get(self, "identity_denied")

    @identity_denied.setter
    def identity_denied(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_denied", value)


if not MYPY:
    class ZeroTrustOrganizationLoginDesignArgsDict(TypedDict):
        background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color on your login page.
        """
        footer_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text at the bottom of your login page.
        """
        header_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text at the top of your login page.
        """
        logo_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo on your login page.
        """
        text_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color on your login page.
        """
elif False:
    ZeroTrustOrganizationLoginDesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustOrganizationLoginDesignArgs:
    def __init__(__self__, *,
                 background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 footer_text: Optional[pulumi.Input[_builtins.str]] = None,
                 header_text: Optional[pulumi.Input[_builtins.str]] = None,
                 logo_path: Optional[pulumi.Input[_builtins.str]] = None,
                 text_color: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] background_color: The background color on your login page.
        :param pulumi.Input[_builtins.str] footer_text: The text at the bottom of your login page.
        :param pulumi.Input[_builtins.str] header_text: The text at the top of your login page.
        :param pulumi.Input[_builtins.str] logo_path: The URL of the logo on your login page.
        :param pulumi.Input[_builtins.str] text_color: The text color on your login page.
        """
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)
        if logo_path is not None:
            pulumi.set(__self__, "logo_path", logo_path)
        if text_color is not None:
            pulumi.set(__self__, "text_color", text_color)

    @_builtins.property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color on your login page.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "background_color", value)

    @_builtins.property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text at the bottom of your login page.
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "footer_text", value)

    @_builtins.property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text at the top of your login page.
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_text", value)

    @_builtins.property
    @pulumi.getter(name="logoPath")
    def logo_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo on your login page.
        """
        return pulumi.get(self, "logo_path")

    @logo_path.setter
    def logo_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo_path", value)

    @_builtins.property
    @pulumi.getter(name="textColor")
    def text_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color on your login page.
        """
        return pulumi.get(self, "text_color")

    @text_color.setter
    def text_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_color", value)


if not MYPY:
    class ZeroTrustRiskBehaviorBehaviorsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        risk_level: pulumi.Input[_builtins.str]
        """
        Available values: "low", "medium", "high".
        """
elif False:
    ZeroTrustRiskBehaviorBehaviorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustRiskBehaviorBehaviorsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 risk_level: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] risk_level: Available values: "low", "medium", "high".
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "risk_level", risk_level)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[_builtins.str]:
        """
        Available values: "low", "medium", "high".
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "risk_level", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigArgsDict(TypedDict):
        ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict']]]]
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        origin_request: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict']]
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        warp_routing: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict']]
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigArgs:
    def __init__(__self__, *,
                 ingresses: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]]] = None,
                 origin_request: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']] = None,
                 warp_routing: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]] ingresses: List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs'] origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs'] warp_routing: Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        if ingresses is not None:
            pulumi.set(__self__, "ingresses", ingresses)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if warp_routing is not None:
            pulumi.set(__self__, "warp_routing", warp_routing)

    @_builtins.property
    @pulumi.getter
    def ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]]]:
        """
        List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
        """
        return pulumi.get(self, "ingresses")

    @ingresses.setter
    def ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressArgs']]]]):
        pulumi.set(self, "ingresses", value)

    @_builtins.property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']]:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @_builtins.property
    @pulumi.getter(name="warpRouting")
    def warp_routing(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']]:
        """
        Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
        """
        return pulumi.get(self, "warp_routing")

    @warp_routing.setter
    def warp_routing(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs']]):
        pulumi.set(self, "warp_routing", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public hostname for this service.
        """
        origin_request: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict']]
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Requests with this path route to this public hostname.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str],
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_request: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs']] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        :param pulumi.Input[_builtins.str] hostname: Public hostname for this service.
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs'] origin_request: Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        :param pulumi.Input[_builtins.str] path: Requests with this path route to this public hostname.
        """
        pulumi.set(__self__, "service", service)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if origin_request is not None:
            pulumi.set(__self__, "origin_request", origin_request)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http*status:[code] e.g. 'http*status:404'.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public hostname for this service.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="originRequest")
    def origin_request(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs']]:
        """
        Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
        """
        return pulumi.get(self, "origin_request")

    @origin_request.setter
    def origin_request(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs']]):
        pulumi.set(self, "origin_request", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Requests with this path route to this public hostname.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict']]
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        ca_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        connect_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        http2_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        http_host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        no_tls_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        origin_server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        proxy_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        tls_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs']] = None,
                 ca_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_alive_connections: Optional[pulumi.Input[_builtins.int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[_builtins.bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[_builtins.int]] = None,
                 tls_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs'] access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param pulumi.Input[_builtins.str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param pulumi.Input[_builtins.int] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param pulumi.Input[_builtins.bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param pulumi.Input[_builtins.bool] http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param pulumi.Input[_builtins.str] http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param pulumi.Input[_builtins.int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param pulumi.Input[_builtins.int] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param pulumi.Input[_builtins.bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param pulumi.Input[_builtins.bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param pulumi.Input[_builtins.str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param pulumi.Input[_builtins.str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param pulumi.Input[_builtins.int] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param pulumi.Input[_builtins.int] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs']]:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_pool", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @_builtins.property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @_builtins.property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_origin", value)

    @_builtins.property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_host_header", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @_builtins.property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @_builtins.property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_server_name", value)

    @_builtins.property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_type", value)

    @_builtins.property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @_builtins.property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict(TypedDict):
        aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        team_name: pulumi.Input[_builtins.str]
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deny traffic that has not fulfilled Access authorization.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigIngressOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 team_name: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param pulumi.Input[_builtins.bool] required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        pulumi.set(__self__, "team_name", team_name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "aud_tags", value)

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict(TypedDict):
        access: NotRequired[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict']]
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        ca_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        connect_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        disable_chunked_encoding: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        http2_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        http_host_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        keep_alive_connections: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        keep_alive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        no_happy_eyeballs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        no_tls_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        origin_server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        proxy_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        tcp_keep_alive: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        tls_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']] = None,
                 ca_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 connect_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 disable_chunked_encoding: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_host_header: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_alive_connections: Optional[pulumi.Input[_builtins.int]] = None,
                 keep_alive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 no_happy_eyeballs: Optional[pulumi.Input[_builtins.bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tcp_keep_alive: Optional[pulumi.Input[_builtins.int]] = None,
                 tls_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs'] access: For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        :param pulumi.Input[_builtins.str] ca_pool: Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        :param pulumi.Input[_builtins.int] connect_timeout: Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        :param pulumi.Input[_builtins.bool] disable_chunked_encoding: Disables chunked transfer encoding. Useful if you are running a WSGI server.
        :param pulumi.Input[_builtins.bool] http2_origin: Attempt to connect to origin using HTTP2. Origin must be configured as https.
        :param pulumi.Input[_builtins.str] http_host_header: Sets the HTTP Host header on requests sent to the local service.
        :param pulumi.Input[_builtins.int] keep_alive_connections: Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        :param pulumi.Input[_builtins.int] keep_alive_timeout: Timeout after which an idle keepalive connection can be discarded.
        :param pulumi.Input[_builtins.bool] no_happy_eyeballs: Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        :param pulumi.Input[_builtins.bool] no_tls_verify: Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        :param pulumi.Input[_builtins.str] origin_server_name: Hostname that cloudflared should expect from your origin server certificate.
        :param pulumi.Input[_builtins.str] proxy_type: cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        :param pulumi.Input[_builtins.int] tcp_keep_alive: The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        :param pulumi.Input[_builtins.int] tls_timeout: Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if ca_pool is not None:
            pulumi.set(__self__, "ca_pool", ca_pool)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if disable_chunked_encoding is not None:
            pulumi.set(__self__, "disable_chunked_encoding", disable_chunked_encoding)
        if http2_origin is not None:
            pulumi.set(__self__, "http2_origin", http2_origin)
        if http_host_header is not None:
            pulumi.set(__self__, "http_host_header", http_host_header)
        if keep_alive_connections is not None:
            pulumi.set(__self__, "keep_alive_connections", keep_alive_connections)
        if keep_alive_timeout is not None:
            pulumi.set(__self__, "keep_alive_timeout", keep_alive_timeout)
        if no_happy_eyeballs is not None:
            pulumi.set(__self__, "no_happy_eyeballs", no_happy_eyeballs)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)
        if origin_server_name is not None:
            pulumi.set(__self__, "origin_server_name", origin_server_name)
        if proxy_type is not None:
            pulumi.set(__self__, "proxy_type", proxy_type)
        if tcp_keep_alive is not None:
            pulumi.set(__self__, "tcp_keep_alive", tcp_keep_alive)
        if tls_timeout is not None:
            pulumi.set(__self__, "tls_timeout", tls_timeout)

    @_builtins.property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']]:
        """
        For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs']]):
        pulumi.set(self, "access", value)

    @_builtins.property
    @pulumi.getter(name="caPool")
    def ca_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
        """
        return pulumi.get(self, "ca_pool")

    @ca_pool.setter
    def ca_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_pool", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @_builtins.property
    @pulumi.getter(name="disableChunkedEncoding")
    def disable_chunked_encoding(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables chunked transfer encoding. Useful if you are running a WSGI server.
        """
        return pulumi.get(self, "disable_chunked_encoding")

    @disable_chunked_encoding.setter
    def disable_chunked_encoding(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_chunked_encoding", value)

    @_builtins.property
    @pulumi.getter(name="http2Origin")
    def http2_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Attempt to connect to origin using HTTP2. Origin must be configured as https.
        """
        return pulumi.get(self, "http2_origin")

    @http2_origin.setter
    def http2_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_origin", value)

    @_builtins.property
    @pulumi.getter(name="httpHostHeader")
    def http_host_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets the HTTP Host header on requests sent to the local service.
        """
        return pulumi.get(self, "http_host_header")

    @http_host_header.setter
    def http_host_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_host_header", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveConnections")
    def keep_alive_connections(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
        """
        return pulumi.get(self, "keep_alive_connections")

    @keep_alive_connections.setter
    def keep_alive_connections(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_connections", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveTimeout")
    def keep_alive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout after which an idle keepalive connection can be discarded.
        """
        return pulumi.get(self, "keep_alive_timeout")

    @keep_alive_timeout.setter
    def keep_alive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="noHappyEyeballs")
    def no_happy_eyeballs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
        """
        return pulumi.get(self, "no_happy_eyeballs")

    @no_happy_eyeballs.setter
    def no_happy_eyeballs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_happy_eyeballs", value)

    @_builtins.property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_tls_verify", value)

    @_builtins.property
    @pulumi.getter(name="originServerName")
    def origin_server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Hostname that cloudflared should expect from your origin server certificate.
        """
        return pulumi.get(self, "origin_server_name")

    @origin_server_name.setter
    def origin_server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_server_name", value)

    @_builtins.property
    @pulumi.getter(name="proxyType")
    def proxy_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
        """
        return pulumi.get(self, "proxy_type")

    @proxy_type.setter
    def proxy_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy_type", value)

    @_builtins.property
    @pulumi.getter(name="tcpKeepAlive")
    def tcp_keep_alive(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
        """
        return pulumi.get(self, "tcp_keep_alive")

    @tcp_keep_alive.setter
    def tcp_keep_alive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_keep_alive", value)

    @_builtins.property
    @pulumi.getter(name="tlsTimeout")
    def tls_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
        """
        return pulumi.get(self, "tls_timeout")

    @tls_timeout.setter
    def tls_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tls_timeout", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict(TypedDict):
        aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        team_name: pulumi.Input[_builtins.str]
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Deny traffic that has not fulfilled Access authorization.
        """
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccessArgs:
    def __init__(__self__, *,
                 aud_tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 team_name: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aud_tags: Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        :param pulumi.Input[_builtins.bool] required: Deny traffic that has not fulfilled Access authorization.
        """
        pulumi.set(__self__, "aud_tags", aud_tags)
        pulumi.set(__self__, "team_name", team_name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="audTags")
    def aud_tags(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
        """
        return pulumi.get(self, "aud_tags")

    @aud_tags.setter
    def aud_tags(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "aud_tags", value)

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_name", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Deny traffic that has not fulfilled Access authorization.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConfigConfigWarpRoutingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ZeroTrustTunnelCloudflaredConnectionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connector.
        """
        client_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloudflared version used to establish this connection.
        """
        colo_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloudflare data center used for this connection.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
        is_pending_reconnect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        opened_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of when the connection was established.
        """
        origin_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address of the host running cloudflared.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
elif False:
    ZeroTrustTunnelCloudflaredConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelCloudflaredConnectionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_version: Optional[pulumi.Input[_builtins.str]] = None,
                 colo_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_pending_reconnect: Optional[pulumi.Input[_builtins.bool]] = None,
                 opened_at: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: UUID of the Cloudflare Tunnel connector.
        :param pulumi.Input[_builtins.str] client_version: The cloudflared version used to establish this connection.
        :param pulumi.Input[_builtins.str] colo_name: The Cloudflare data center used for this connection.
        :param pulumi.Input[_builtins.str] id: UUID of the Cloudflare Tunnel connection.
        :param pulumi.Input[_builtins.bool] is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param pulumi.Input[_builtins.str] opened_at: Timestamp of when the connection was established.
        :param pulumi.Input[_builtins.str] origin_ip: The public IP address of the host running cloudflared.
        :param pulumi.Input[_builtins.str] uuid: UUID of the Cloudflare Tunnel connection.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_version is not None:
            pulumi.set(__self__, "client_version", client_version)
        if colo_name is not None:
            pulumi.set(__self__, "colo_name", colo_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_pending_reconnect is not None:
            pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        if opened_at is not None:
            pulumi.set(__self__, "opened_at", opened_at)
        if origin_ip is not None:
            pulumi.set(__self__, "origin_ip", origin_ip)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @client_version.setter
    def client_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_version", value)

    @_builtins.property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @colo_name.setter
    def colo_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "colo_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @is_pending_reconnect.setter
    def is_pending_reconnect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_pending_reconnect", value)

    @_builtins.property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @opened_at.setter
    def opened_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opened_at", value)

    @_builtins.property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @origin_ip.setter
    def origin_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_ip", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ZeroTrustTunnelWarpConnectorConnectionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connector.
        """
        client_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloudflared version used to establish this connection.
        """
        colo_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloudflare data center used for this connection.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
        is_pending_reconnect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        opened_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp of when the connection was established.
        """
        origin_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address of the host running cloudflared.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Cloudflare Tunnel connection.
        """
elif False:
    ZeroTrustTunnelWarpConnectorConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZeroTrustTunnelWarpConnectorConnectionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_version: Optional[pulumi.Input[_builtins.str]] = None,
                 colo_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_pending_reconnect: Optional[pulumi.Input[_builtins.bool]] = None,
                 opened_at: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: UUID of the Cloudflare Tunnel connector.
        :param pulumi.Input[_builtins.str] client_version: The cloudflared version used to establish this connection.
        :param pulumi.Input[_builtins.str] colo_name: The Cloudflare data center used for this connection.
        :param pulumi.Input[_builtins.str] id: UUID of the Cloudflare Tunnel connection.
        :param pulumi.Input[_builtins.bool] is_pending_reconnect: Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        :param pulumi.Input[_builtins.str] opened_at: Timestamp of when the connection was established.
        :param pulumi.Input[_builtins.str] origin_ip: The public IP address of the host running cloudflared.
        :param pulumi.Input[_builtins.str] uuid: UUID of the Cloudflare Tunnel connection.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_version is not None:
            pulumi.set(__self__, "client_version", client_version)
        if colo_name is not None:
            pulumi.set(__self__, "colo_name", colo_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_pending_reconnect is not None:
            pulumi.set(__self__, "is_pending_reconnect", is_pending_reconnect)
        if opened_at is not None:
            pulumi.set(__self__, "opened_at", opened_at)
        if origin_ip is not None:
            pulumi.set(__self__, "origin_ip", origin_ip)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connector.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientVersion")
    def client_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloudflared version used to establish this connection.
        """
        return pulumi.get(self, "client_version")

    @client_version.setter
    def client_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_version", value)

    @_builtins.property
    @pulumi.getter(name="coloName")
    def colo_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloudflare data center used for this connection.
        """
        return pulumi.get(self, "colo_name")

    @colo_name.setter
    def colo_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "colo_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isPendingReconnect")
    def is_pending_reconnect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
        """
        return pulumi.get(self, "is_pending_reconnect")

    @is_pending_reconnect.setter
    def is_pending_reconnect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_pending_reconnect", value)

    @_builtins.property
    @pulumi.getter(name="openedAt")
    def opened_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp of when the connection was established.
        """
        return pulumi.get(self, "opened_at")

    @opened_at.setter
    def opened_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "opened_at", value)

    @_builtins.property
    @pulumi.getter(name="originIp")
    def origin_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address of the host running cloudflared.
        """
        return pulumi.get(self, "origin_ip")

    @origin_ip.setter
    def origin_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_ip", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Cloudflare Tunnel connection.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ZoneAccountArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
elif False:
    ZoneAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneAccountArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ZoneCacheVariantsValueArgsDict(TypedDict):
        avifs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for avif.
        """
        bmps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for bmp.
        """
        gifs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for gif.
        """
        jp2s: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jp2.
        """
        jpegs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jpeg.
        """
        jpg2s: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jpg2.
        """
        jpgs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for jpg.
        """
        pngs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for png.
        """
        tiffs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for tiff.
        """
        tifs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for tif.
        """
        webps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of strings with the MIME types of all the variants that should be served for webp.
        """
elif False:
    ZoneCacheVariantsValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneCacheVariantsValueArgs:
    def __init__(__self__, *,
                 avifs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bmps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 gifs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 jp2s: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 jpegs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 jpg2s: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 jpgs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pngs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tiffs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tifs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 webps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] avifs: List of strings with the MIME types of all the variants that should be served for avif.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bmps: List of strings with the MIME types of all the variants that should be served for bmp.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] gifs: List of strings with the MIME types of all the variants that should be served for gif.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] jp2s: List of strings with the MIME types of all the variants that should be served for jp2.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] jpegs: List of strings with the MIME types of all the variants that should be served for jpeg.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] jpg2s: List of strings with the MIME types of all the variants that should be served for jpg2.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] jpgs: List of strings with the MIME types of all the variants that should be served for jpg.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pngs: List of strings with the MIME types of all the variants that should be served for png.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tiffs: List of strings with the MIME types of all the variants that should be served for tiff.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tifs: List of strings with the MIME types of all the variants that should be served for tif.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] webps: List of strings with the MIME types of all the variants that should be served for webp.
        """
        if avifs is not None:
            pulumi.set(__self__, "avifs", avifs)
        if bmps is not None:
            pulumi.set(__self__, "bmps", bmps)
        if gifs is not None:
            pulumi.set(__self__, "gifs", gifs)
        if jp2s is not None:
            pulumi.set(__self__, "jp2s", jp2s)
        if jpegs is not None:
            pulumi.set(__self__, "jpegs", jpegs)
        if jpg2s is not None:
            pulumi.set(__self__, "jpg2s", jpg2s)
        if jpgs is not None:
            pulumi.set(__self__, "jpgs", jpgs)
        if pngs is not None:
            pulumi.set(__self__, "pngs", pngs)
        if tiffs is not None:
            pulumi.set(__self__, "tiffs", tiffs)
        if tifs is not None:
            pulumi.set(__self__, "tifs", tifs)
        if webps is not None:
            pulumi.set(__self__, "webps", webps)

    @_builtins.property
    @pulumi.getter
    def avifs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for avif.
        """
        return pulumi.get(self, "avifs")

    @avifs.setter
    def avifs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "avifs", value)

    @_builtins.property
    @pulumi.getter
    def bmps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for bmp.
        """
        return pulumi.get(self, "bmps")

    @bmps.setter
    def bmps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bmps", value)

    @_builtins.property
    @pulumi.getter
    def gifs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for gif.
        """
        return pulumi.get(self, "gifs")

    @gifs.setter
    def gifs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "gifs", value)

    @_builtins.property
    @pulumi.getter
    def jp2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jp2.
        """
        return pulumi.get(self, "jp2s")

    @jp2s.setter
    def jp2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "jp2s", value)

    @_builtins.property
    @pulumi.getter
    def jpegs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpeg.
        """
        return pulumi.get(self, "jpegs")

    @jpegs.setter
    def jpegs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "jpegs", value)

    @_builtins.property
    @pulumi.getter
    def jpg2s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpg2.
        """
        return pulumi.get(self, "jpg2s")

    @jpg2s.setter
    def jpg2s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "jpg2s", value)

    @_builtins.property
    @pulumi.getter
    def jpgs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for jpg.
        """
        return pulumi.get(self, "jpgs")

    @jpgs.setter
    def jpgs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "jpgs", value)

    @_builtins.property
    @pulumi.getter
    def pngs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for png.
        """
        return pulumi.get(self, "pngs")

    @pngs.setter
    def pngs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "pngs", value)

    @_builtins.property
    @pulumi.getter
    def tiffs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for tiff.
        """
        return pulumi.get(self, "tiffs")

    @tiffs.setter
    def tiffs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tiffs", value)

    @_builtins.property
    @pulumi.getter
    def tifs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for tif.
        """
        return pulumi.get(self, "tifs")

    @tifs.setter
    def tifs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tifs", value)

    @_builtins.property
    @pulumi.getter
    def webps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of strings with the MIME types of all the variants that should be served for webp.
        """
        return pulumi.get(self, "webps")

    @webps.setter
    def webps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "webps", value)


if not MYPY:
    class ZoneDnsSettingsInternalDnsArgsDict(TypedDict):
        reference_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the zone to fallback to.
        """
elif False:
    ZoneDnsSettingsInternalDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDnsSettingsInternalDnsArgs:
    def __init__(__self__, *,
                 reference_zone_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] reference_zone_id: The ID of the zone to fallback to.
        """
        if reference_zone_id is not None:
            pulumi.set(__self__, "reference_zone_id", reference_zone_id)

    @_builtins.property
    @pulumi.getter(name="referenceZoneId")
    def reference_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the zone to fallback to.
        """
        return pulumi.get(self, "reference_zone_id")

    @reference_zone_id.setter
    def reference_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reference_zone_id", value)


if not MYPY:
    class ZoneDnsSettingsNameserversArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Nameserver type
        Available values: "cloudflare.standard", "custom.account", "custom.tenant", "custom.zone".
        """
        ns_set: NotRequired[pulumi.Input[_builtins.int]]
        """
        Configured nameserver set to be used for this zone
        """
elif False:
    ZoneDnsSettingsNameserversArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDnsSettingsNameserversArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 ns_set: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Nameserver type
               Available values: "cloudflare.standard", "custom.account", "custom.tenant", "custom.zone".
        :param pulumi.Input[_builtins.int] ns_set: Configured nameserver set to be used for this zone
        """
        pulumi.set(__self__, "type", type)
        if ns_set is not None:
            pulumi.set(__self__, "ns_set", ns_set)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Nameserver type
        Available values: "cloudflare.standard", "custom.account", "custom.tenant", "custom.zone".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="nsSet")
    def ns_set(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Configured nameserver set to be used for this zone
        """
        return pulumi.get(self, "ns_set")

    @ns_set.setter
    def ns_set(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ns_set", value)


if not MYPY:
    class ZoneDnsSettingsSoaArgsDict(TypedDict):
        expire: pulumi.Input[_builtins.float]
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        min_ttl: pulumi.Input[_builtins.float]
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        mname: pulumi.Input[_builtins.str]
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        refresh: pulumi.Input[_builtins.float]
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        retry: pulumi.Input[_builtins.float]
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        rname: pulumi.Input[_builtins.str]
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        ttl: pulumi.Input[_builtins.float]
        """
        The time to live (TTL) of the SOA record itself.
        """
elif False:
    ZoneDnsSettingsSoaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneDnsSettingsSoaArgs:
    def __init__(__self__, *,
                 expire: pulumi.Input[_builtins.float],
                 min_ttl: pulumi.Input[_builtins.float],
                 mname: pulumi.Input[_builtins.str],
                 refresh: pulumi.Input[_builtins.float],
                 retry: pulumi.Input[_builtins.float],
                 rname: pulumi.Input[_builtins.str],
                 ttl: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] expire: Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        :param pulumi.Input[_builtins.float] min_ttl: The time to live (TTL) for negative caching of records within the zone.
        :param pulumi.Input[_builtins.str] mname: The primary nameserver, which may be used for outbound zone transfers.
        :param pulumi.Input[_builtins.float] refresh: Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        :param pulumi.Input[_builtins.float] retry: Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        :param pulumi.Input[_builtins.str] rname: The email address of the zone administrator, with the first label representing the local part of the email address.
        :param pulumi.Input[_builtins.float] ttl: The time to live (TTL) of the SOA record itself.
        """
        pulumi.set(__self__, "expire", expire)
        pulumi.set(__self__, "min_ttl", min_ttl)
        pulumi.set(__self__, "mname", mname)
        pulumi.set(__self__, "refresh", refresh)
        pulumi.set(__self__, "retry", retry)
        pulumi.set(__self__, "rname", rname)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def expire(self) -> pulumi.Input[_builtins.float]:
        """
        Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
        """
        return pulumi.get(self, "expire")

    @expire.setter
    def expire(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "expire", value)

    @_builtins.property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> pulumi.Input[_builtins.float]:
        """
        The time to live (TTL) for negative caching of records within the zone.
        """
        return pulumi.get(self, "min_ttl")

    @min_ttl.setter
    def min_ttl(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "min_ttl", value)

    @_builtins.property
    @pulumi.getter
    def mname(self) -> pulumi.Input[_builtins.str]:
        """
        The primary nameserver, which may be used for outbound zone transfers.
        """
        return pulumi.get(self, "mname")

    @mname.setter
    def mname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mname", value)

    @_builtins.property
    @pulumi.getter
    def refresh(self) -> pulumi.Input[_builtins.float]:
        """
        Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
        """
        return pulumi.get(self, "refresh")

    @refresh.setter
    def refresh(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "refresh", value)

    @_builtins.property
    @pulumi.getter
    def retry(self) -> pulumi.Input[_builtins.float]:
        """
        Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "retry", value)

    @_builtins.property
    @pulumi.getter
    def rname(self) -> pulumi.Input[_builtins.str]:
        """
        The email address of the zone administrator, with the first label representing the local part of the email address.
        """
        return pulumi.get(self, "rname")

    @rname.setter
    def rname(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rname", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.float]:
        """
        The time to live (TTL) of the SOA record itself.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ZoneLockdownConfigurationArgsDict(TypedDict):
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        Available values: "ip", "ip_range".
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
elif False:
    ZoneLockdownConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneLockdownConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target: The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
               Available values: "ip", "ip_range".
        :param pulumi.Input[_builtins.str] value: The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
        Available values: "ip", "ip_range".
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address to match. This address will be compared to the IP address of incoming requests.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ZoneMetaArgsDict(TypedDict):
        cdn_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The zone is only configured for CDN.
        """
        custom_certificate_quota: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of Custom Certificates the zone can have.
        """
        dns_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The zone is only configured for DNS.
        """
        foundation_dns: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The zone is setup with Foundation DNS.
        """
        page_rule_quota: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of Page Rules a zone can have.
        """
        phishing_detected: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The zone has been flagged for phishing.
        """
        step: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ZoneMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneMetaArgs:
    def __init__(__self__, *,
                 cdn_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_certificate_quota: Optional[pulumi.Input[_builtins.int]] = None,
                 dns_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 foundation_dns: Optional[pulumi.Input[_builtins.bool]] = None,
                 page_rule_quota: Optional[pulumi.Input[_builtins.int]] = None,
                 phishing_detected: Optional[pulumi.Input[_builtins.bool]] = None,
                 step: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] cdn_only: The zone is only configured for CDN.
        :param pulumi.Input[_builtins.int] custom_certificate_quota: Number of Custom Certificates the zone can have.
        :param pulumi.Input[_builtins.bool] dns_only: The zone is only configured for DNS.
        :param pulumi.Input[_builtins.bool] foundation_dns: The zone is setup with Foundation DNS.
        :param pulumi.Input[_builtins.int] page_rule_quota: Number of Page Rules a zone can have.
        :param pulumi.Input[_builtins.bool] phishing_detected: The zone has been flagged for phishing.
        """
        if cdn_only is not None:
            pulumi.set(__self__, "cdn_only", cdn_only)
        if custom_certificate_quota is not None:
            pulumi.set(__self__, "custom_certificate_quota", custom_certificate_quota)
        if dns_only is not None:
            pulumi.set(__self__, "dns_only", dns_only)
        if foundation_dns is not None:
            pulumi.set(__self__, "foundation_dns", foundation_dns)
        if page_rule_quota is not None:
            pulumi.set(__self__, "page_rule_quota", page_rule_quota)
        if phishing_detected is not None:
            pulumi.set(__self__, "phishing_detected", phishing_detected)
        if step is not None:
            pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter(name="cdnOnly")
    def cdn_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The zone is only configured for CDN.
        """
        return pulumi.get(self, "cdn_only")

    @cdn_only.setter
    def cdn_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cdn_only", value)

    @_builtins.property
    @pulumi.getter(name="customCertificateQuota")
    def custom_certificate_quota(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of Custom Certificates the zone can have.
        """
        return pulumi.get(self, "custom_certificate_quota")

    @custom_certificate_quota.setter
    def custom_certificate_quota(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "custom_certificate_quota", value)

    @_builtins.property
    @pulumi.getter(name="dnsOnly")
    def dns_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The zone is only configured for DNS.
        """
        return pulumi.get(self, "dns_only")

    @dns_only.setter
    def dns_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dns_only", value)

    @_builtins.property
    @pulumi.getter(name="foundationDns")
    def foundation_dns(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The zone is setup with Foundation DNS.
        """
        return pulumi.get(self, "foundation_dns")

    @foundation_dns.setter
    def foundation_dns(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "foundation_dns", value)

    @_builtins.property
    @pulumi.getter(name="pageRuleQuota")
    def page_rule_quota(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of Page Rules a zone can have.
        """
        return pulumi.get(self, "page_rule_quota")

    @page_rule_quota.setter
    def page_rule_quota(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "page_rule_quota", value)

    @_builtins.property
    @pulumi.getter(name="phishingDetected")
    def phishing_detected(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The zone has been flagged for phishing.
        """
        return pulumi.get(self, "phishing_detected")

    @phishing_detected.setter
    def phishing_detected(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "phishing_detected", value)

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "step", value)


if not MYPY:
    class ZoneOwnerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the owner.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of owner.
        """
elif False:
    ZoneOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneOwnerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier
        :param pulumi.Input[_builtins.str] name: Name of the owner.
        :param pulumi.Input[_builtins.str] type: The type of owner.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the owner.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of owner.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ZonePlanArgsDict(TypedDict):
        can_subscribe: NotRequired[pulumi.Input[_builtins.bool]]
        """
        States if the subscription can be activated.
        """
        currency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The denomination of the customer.
        """
        externally_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If this Zone is managed by another company.
        """
        frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        How often the customer is billed.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
        is_subscribed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        States if the subscription active.
        """
        legacy_discount: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the legacy discount applies to this Zone.
        """
        legacy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The legacy name of the plan.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the owner.
        """
        price: NotRequired[pulumi.Input[_builtins.float]]
        """
        How much the customer is paying.
        """
elif False:
    ZonePlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZonePlanArgs:
    def __init__(__self__, *,
                 can_subscribe: Optional[pulumi.Input[_builtins.bool]] = None,
                 currency: Optional[pulumi.Input[_builtins.str]] = None,
                 externally_managed: Optional[pulumi.Input[_builtins.bool]] = None,
                 frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_subscribed: Optional[pulumi.Input[_builtins.bool]] = None,
                 legacy_discount: Optional[pulumi.Input[_builtins.bool]] = None,
                 legacy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 price: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] can_subscribe: States if the subscription can be activated.
        :param pulumi.Input[_builtins.str] currency: The denomination of the customer.
        :param pulumi.Input[_builtins.bool] externally_managed: If this Zone is managed by another company.
        :param pulumi.Input[_builtins.str] frequency: How often the customer is billed.
        :param pulumi.Input[_builtins.str] id: Identifier
        :param pulumi.Input[_builtins.bool] is_subscribed: States if the subscription active.
        :param pulumi.Input[_builtins.bool] legacy_discount: If the legacy discount applies to this Zone.
        :param pulumi.Input[_builtins.str] legacy_id: The legacy name of the plan.
        :param pulumi.Input[_builtins.str] name: Name of the owner.
        :param pulumi.Input[_builtins.float] price: How much the customer is paying.
        """
        if can_subscribe is not None:
            pulumi.set(__self__, "can_subscribe", can_subscribe)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_subscribed is not None:
            pulumi.set(__self__, "is_subscribed", is_subscribed)
        if legacy_discount is not None:
            pulumi.set(__self__, "legacy_discount", legacy_discount)
        if legacy_id is not None:
            pulumi.set(__self__, "legacy_id", legacy_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if price is not None:
            pulumi.set(__self__, "price", price)

    @_builtins.property
    @pulumi.getter(name="canSubscribe")
    def can_subscribe(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        States if the subscription can be activated.
        """
        return pulumi.get(self, "can_subscribe")

    @can_subscribe.setter
    def can_subscribe(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "can_subscribe", value)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The denomination of the customer.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If this Zone is managed by another company.
        """
        return pulumi.get(self, "externally_managed")

    @externally_managed.setter
    def externally_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "externally_managed", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How often the customer is billed.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isSubscribed")
    def is_subscribed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        States if the subscription active.
        """
        return pulumi.get(self, "is_subscribed")

    @is_subscribed.setter
    def is_subscribed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_subscribed", value)

    @_builtins.property
    @pulumi.getter(name="legacyDiscount")
    def legacy_discount(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the legacy discount applies to this Zone.
        """
        return pulumi.get(self, "legacy_discount")

    @legacy_discount.setter
    def legacy_discount(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "legacy_discount", value)

    @_builtins.property
    @pulumi.getter(name="legacyId")
    def legacy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The legacy name of the plan.
        """
        return pulumi.get(self, "legacy_id")

    @legacy_id.setter
    def legacy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "legacy_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the owner.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def price(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        How much the customer is paying.
        """
        return pulumi.get(self, "price")

    @price.setter
    def price(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "price", value)


if not MYPY:
    class ZoneSubscriptionRatePlanArgsDict(TypedDict):
        currency: NotRequired[pulumi.Input[_builtins.str]]
        """
        The currency applied to the rate plan subscription.
        """
        externally_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the rate plan.
        Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partners_enterprise".
        """
        is_contract: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        public_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the rate plan.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scope that this rate plan applies to.
        """
        sets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of sets this rate plan applies to.
        """
elif False:
    ZoneSubscriptionRatePlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneSubscriptionRatePlanArgs:
    def __init__(__self__, *,
                 currency: Optional[pulumi.Input[_builtins.str]] = None,
                 externally_managed: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_contract: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_name: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 sets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] currency: The currency applied to the rate plan subscription.
        :param pulumi.Input[_builtins.bool] externally_managed: Whether this rate plan is managed externally from Cloudflare.
        :param pulumi.Input[_builtins.str] id: The ID of the rate plan.
               Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partners_enterprise".
        :param pulumi.Input[_builtins.bool] is_contract: Whether a rate plan is enterprise-based (or newly adopted term contract).
        :param pulumi.Input[_builtins.str] public_name: The full name of the rate plan.
        :param pulumi.Input[_builtins.str] scope: The scope that this rate plan applies to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] sets: The list of sets this rate plan applies to.
        """
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if externally_managed is not None:
            pulumi.set(__self__, "externally_managed", externally_managed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_contract is not None:
            pulumi.set(__self__, "is_contract", is_contract)
        if public_name is not None:
            pulumi.set(__self__, "public_name", public_name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sets is not None:
            pulumi.set(__self__, "sets", sets)

    @_builtins.property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The currency applied to the rate plan subscription.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "currency", value)

    @_builtins.property
    @pulumi.getter(name="externallyManaged")
    def externally_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this rate plan is managed externally from Cloudflare.
        """
        return pulumi.get(self, "externally_managed")

    @externally_managed.setter
    def externally_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "externally_managed", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the rate plan.
        Available values: "free", "lite", "pro", "pro*plus", "business", "enterprise", "partners*free", "partners*pro", "partners*business", "partners_enterprise".
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isContract")
    def is_contract(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether a rate plan is enterprise-based (or newly adopted term contract).
        """
        return pulumi.get(self, "is_contract")

    @is_contract.setter
    def is_contract(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_contract", value)

    @_builtins.property
    @pulumi.getter(name="publicName")
    def public_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the rate plan.
        """
        return pulumi.get(self, "public_name")

    @public_name.setter
    def public_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_name", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scope that this rate plan applies to.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of sets this rate plan applies to.
        """
        return pulumi.get(self, "sets")

    @sets.setter
    def sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "sets", value)


if not MYPY:
    class ZoneTenantArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Tenant account.
        """
elif False:
    ZoneTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneTenantArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier
        :param pulumi.Input[_builtins.str] name: The name of the Tenant account.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Tenant account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ZoneTenantUnitArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier
        """
elif False:
    ZoneTenantUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ZoneTenantUnitArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Identifier
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetAccessRuleFilterArgsDict(TypedDict):
        match: _builtins.str
        """
        Defines the search requirements. When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        Available values: "any", "all".
        """
        configuration: NotRequired['GetAccessRuleFilterConfigurationArgsDict']
        direction: NotRequired[_builtins.str]
        """
        Defines the direction used to sort returned rules.
        Available values: "asc", "desc".
        """
        mode: NotRequired[_builtins.str]
        """
        The action to apply to a matched request.
        Available values: "block", "challenge", "whitelist", "js*challenge", "managed*challenge".
        """
        notes: NotRequired[_builtins.str]
        """
        Defines the string to search for in the notes of existing IP Access rules.
        Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        """
        order: NotRequired[_builtins.str]
        """
        Defines the field used to sort returned rules.
        Available values: "configuration.target", "configuration.value", "mode".
        """
elif False:
    GetAccessRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessRuleFilterArgs:
    def __init__(__self__, *,
                 match: _builtins.str,
                 configuration: Optional['GetAccessRuleFilterConfigurationArgs'] = None,
                 direction: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None):
        """
        :param _builtins.str match: Defines the search requirements. When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
               Available values: "any", "all".
        :param _builtins.str direction: Defines the direction used to sort returned rules.
               Available values: "asc", "desc".
        :param _builtins.str mode: The action to apply to a matched request.
               Available values: "block", "challenge", "whitelist", "js*challenge", "managed*challenge".
        :param _builtins.str notes: Defines the string to search for in the notes of existing IP Access rules.
               Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        :param _builtins.str order: Defines the field used to sort returned rules.
               Available values: "configuration.target", "configuration.value", "mode".
        """
        pulumi.set(__self__, "match", match)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        Defines the search requirements. When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
        Available values: "any", "all".
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: _builtins.str):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional['GetAccessRuleFilterConfigurationArgs']:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional['GetAccessRuleFilterConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Defines the direction used to sort returned rules.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The action to apply to a matched request.
        Available values: "block", "challenge", "whitelist", "js*challenge", "managed*challenge".
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        Defines the string to search for in the notes of existing IP Access rules.
        Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[_builtins.str]):
        pulumi.set(self, "notes", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Defines the field used to sort returned rules.
        Available values: "configuration.target", "configuration.value", "mode".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetAccessRuleFilterConfigurationArgsDict(TypedDict):
        target: NotRequired[_builtins.str]
        """
        Defines the target to search in existing rules.
        Available values: "ip", "ip_range", "asn", "country".
        """
        value: NotRequired[_builtins.str]
        """
        Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
elif False:
    GetAccessRuleFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessRuleFilterConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: Defines the target to search in existing rules.
               Available values: "ip", "ip_range", "asn", "country".
        :param _builtins.str value: Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
               Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Defines the target to search in existing rules.
        Available values: "ip", "ip_range", "asn", "country".
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAccessRulesConfigurationArgsDict(TypedDict):
        target: NotRequired[_builtins.str]
        """
        Defines the target to search in existing rules.
        Available values: "ip", "ip_range", "asn", "country".
        """
        value: NotRequired[_builtins.str]
        """
        Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
elif False:
    GetAccessRulesConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessRulesConfigurationArgs:
    def __init__(__self__, *,
                 target: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: Defines the target to search in existing rules.
               Available values: "ip", "ip_range", "asn", "country".
        :param _builtins.str value: Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
               Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Defines the target to search in existing rules.
        Available values: "ip", "ip_range", "asn", "country".
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Defines the target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
        Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAccountDnsSettingsInternalViewFilterArgsDict(TypedDict):
        direction: _builtins.str
        """
        Direction to order DNS views in.
        Available values: "asc", "desc".
        """
        match: _builtins.str
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        Available values: "any", "all".
        """
        name: NotRequired['GetAccountDnsSettingsInternalViewFilterNameArgsDict']
        order: NotRequired[_builtins.str]
        """
        Field to order DNS views by.
        Available values: "name", "created*on", "modified*on".
        """
        zone_id: NotRequired[_builtins.str]
        """
        A zone ID that exists in the zones list for the view.
        """
        zone_name: NotRequired[_builtins.str]
        """
        A zone name that exists in the zones list for the view.
        """
elif False:
    GetAccountDnsSettingsInternalViewFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountDnsSettingsInternalViewFilterArgs:
    def __init__(__self__, *,
                 direction: _builtins.str,
                 match: _builtins.str,
                 name: Optional['GetAccountDnsSettingsInternalViewFilterNameArgs'] = None,
                 order: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None,
                 zone_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order DNS views in.
               Available values: "asc", "desc".
        :param _builtins.str match: Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
               Available values: "any", "all".
        :param _builtins.str order: Field to order DNS views by.
               Available values: "name", "created*on", "modified*on".
        :param _builtins.str zone_id: A zone ID that exists in the zones list for the view.
        :param _builtins.str zone_name: A zone name that exists in the zones list for the view.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "match", match)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        Direction to order DNS views in.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: _builtins.str):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
        Available values: "any", "all".
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: _builtins.str):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional['GetAccountDnsSettingsInternalViewFilterNameArgs']:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional['GetAccountDnsSettingsInternalViewFilterNameArgs']):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Field to order DNS views by.
        Available values: "name", "created*on", "modified*on".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        A zone ID that exists in the zones list for the view.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "zone_id", value)

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[_builtins.str]:
        """
        A zone name that exists in the zones list for the view.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class GetAccountDnsSettingsInternalViewFilterNameArgsDict(TypedDict):
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS view name.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS view name.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS view name.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS view name.
        """
elif False:
    GetAccountDnsSettingsInternalViewFilterNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountDnsSettingsInternalViewFilterNameArgs:
    def __init__(__self__, *,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str contains: Substring of the DNS view name.
        :param _builtins.str endswith: Suffix of the DNS view name.
        :param _builtins.str exact: Exact value of the DNS view name.
        :param _builtins.str startswith: Prefix of the DNS view name.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS view name.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS view name.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS view name.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS view name.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetAccountDnsSettingsInternalViewsNameArgsDict(TypedDict):
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS view name.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS view name.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS view name.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS view name.
        """
elif False:
    GetAccountDnsSettingsInternalViewsNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountDnsSettingsInternalViewsNameArgs:
    def __init__(__self__, *,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str contains: Substring of the DNS view name.
        :param _builtins.str endswith: Suffix of the DNS view name.
        :param _builtins.str exact: Exact value of the DNS view name.
        :param _builtins.str startswith: Prefix of the DNS view name.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS view name.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS view name.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS view name.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS view name.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetAccountFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        name: NotRequired[_builtins.str]
        """
        Name of the account.
        """
elif False:
    GetAccountFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order results.
               Available values: "asc", "desc".
        :param _builtins.str name: Name of the account.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetAccountMemberFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        order: NotRequired[_builtins.str]
        """
        Field to order results by.
        Available values: "user.first*name", "user.last*name", "user.email", "status".
        """
        status: NotRequired[_builtins.str]
        """
        A member's status in the account.
        Available values: "accepted", "pending", "rejected".
        """
elif False:
    GetAccountMemberFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountMemberFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order results.
               Available values: "asc", "desc".
        :param _builtins.str order: Field to order results by.
               Available values: "user.first*name", "user.last*name", "user.email", "status".
        :param _builtins.str status: A member's status in the account.
               Available values: "accepted", "pending", "rejected".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Field to order results by.
        Available values: "user.first*name", "user.last*name", "user.email", "status".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        A member's status in the account.
        Available values: "accepted", "pending", "rejected".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetAccountTokenFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
elif False:
    GetAccountTokenFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccountTokenFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order results.
               Available values: "asc", "desc".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetApiShieldOperationFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        endpoint: NotRequired[_builtins.str]
        """
        Filter results to only include endpoints containing this pattern.
        """
        features: NotRequired[Sequence[_builtins.str]]
        """
        Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        """
        hosts: NotRequired[Sequence[_builtins.str]]
        """
        Filter results to only include the specified hosts.
        """
        methods: NotRequired[Sequence[_builtins.str]]
        """
        Filter results to only include the specified HTTP methods.
        """
        order: NotRequired[_builtins.str]
        """
        Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        Available values: "method", "host", "endpoint", "thresholds.$key".
        """
elif False:
    GetApiShieldOperationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiShieldOperationFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 features: Optional[Sequence[_builtins.str]] = None,
                 hosts: Optional[Sequence[_builtins.str]] = None,
                 methods: Optional[Sequence[_builtins.str]] = None,
                 order: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order results.
               Available values: "asc", "desc".
        :param _builtins.str endpoint: Filter results to only include endpoints containing this pattern.
        :param Sequence[_builtins.str] features: Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        :param Sequence[_builtins.str] hosts: Filter results to only include the specified hosts.
        :param Sequence[_builtins.str] methods: Filter results to only include the specified HTTP methods.
        :param _builtins.str order: Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
               Available values: "method", "host", "endpoint", "thresholds.$key".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Filter results to only include endpoints containing this pattern.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[Sequence[_builtins.str]]:
        """
        Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
        """
        return pulumi.get(self, "features")

    @features.setter
    def features(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "features", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter results to only include the specified hosts.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filter results to only include the specified HTTP methods.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Field to order by. When requesting a feature, the feature keys are available for ordering as well, e.g., `thresholds.suggested_threshold`.
        Available values: "method", "host", "endpoint", "thresholds.$key".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetApiTokenFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
elif False:
    GetApiTokenFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApiTokenFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order results.
               Available values: "asc", "desc".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order results.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetCloudforceOneRequestFilterArgsDict(TypedDict):
        page: _builtins.int
        """
        Page number of results.
        """
        per_page: _builtins.int
        """
        Number of results per page.
        """
        completed_after: NotRequired[_builtins.str]
        """
        Retrieve requests completed after this time.
        """
        completed_before: NotRequired[_builtins.str]
        """
        Retrieve requests completed before this time.
        """
        created_after: NotRequired[_builtins.str]
        """
        Retrieve requests created after this time.
        """
        created_before: NotRequired[_builtins.str]
        """
        Retrieve requests created before this time.
        """
        request_type: NotRequired[_builtins.str]
        """
        Requested information from request.
        """
        sort_by: NotRequired[_builtins.str]
        """
        Field to sort results by.
        """
        sort_order: NotRequired[_builtins.str]
        """
        Sort order (asc or desc).
        Available values: "asc", "desc".
        """
        status: NotRequired[_builtins.str]
        """
        Request Status.
        Available values: "open", "accepted", "reported", "approved", "completed", "declined".
        """
elif False:
    GetCloudforceOneRequestFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudforceOneRequestFilterArgs:
    def __init__(__self__, *,
                 page: _builtins.int,
                 per_page: _builtins.int,
                 completed_after: Optional[_builtins.str] = None,
                 completed_before: Optional[_builtins.str] = None,
                 created_after: Optional[_builtins.str] = None,
                 created_before: Optional[_builtins.str] = None,
                 request_type: Optional[_builtins.str] = None,
                 sort_by: Optional[_builtins.str] = None,
                 sort_order: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.int page: Page number of results.
        :param _builtins.int per_page: Number of results per page.
        :param _builtins.str completed_after: Retrieve requests completed after this time.
        :param _builtins.str completed_before: Retrieve requests completed before this time.
        :param _builtins.str created_after: Retrieve requests created after this time.
        :param _builtins.str created_before: Retrieve requests created before this time.
        :param _builtins.str request_type: Requested information from request.
        :param _builtins.str sort_by: Field to sort results by.
        :param _builtins.str sort_order: Sort order (asc or desc).
               Available values: "asc", "desc".
        :param _builtins.str status: Request Status.
               Available values: "open", "accepted", "reported", "approved", "completed", "declined".
        """
        pulumi.set(__self__, "page", page)
        pulumi.set(__self__, "per_page", per_page)
        if completed_after is not None:
            pulumi.set(__self__, "completed_after", completed_after)
        if completed_before is not None:
            pulumi.set(__self__, "completed_before", completed_before)
        if created_after is not None:
            pulumi.set(__self__, "created_after", created_after)
        if created_before is not None:
            pulumi.set(__self__, "created_before", created_before)
        if request_type is not None:
            pulumi.set(__self__, "request_type", request_type)
        if sort_by is not None:
            pulumi.set(__self__, "sort_by", sort_by)
        if sort_order is not None:
            pulumi.set(__self__, "sort_order", sort_order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def page(self) -> _builtins.int:
        """
        Page number of results.
        """
        return pulumi.get(self, "page")

    @page.setter
    def page(self, value: _builtins.int):
        pulumi.set(self, "page", value)

    @_builtins.property
    @pulumi.getter(name="perPage")
    def per_page(self) -> _builtins.int:
        """
        Number of results per page.
        """
        return pulumi.get(self, "per_page")

    @per_page.setter
    def per_page(self, value: _builtins.int):
        pulumi.set(self, "per_page", value)

    @_builtins.property
    @pulumi.getter(name="completedAfter")
    def completed_after(self) -> Optional[_builtins.str]:
        """
        Retrieve requests completed after this time.
        """
        return pulumi.get(self, "completed_after")

    @completed_after.setter
    def completed_after(self, value: Optional[_builtins.str]):
        pulumi.set(self, "completed_after", value)

    @_builtins.property
    @pulumi.getter(name="completedBefore")
    def completed_before(self) -> Optional[_builtins.str]:
        """
        Retrieve requests completed before this time.
        """
        return pulumi.get(self, "completed_before")

    @completed_before.setter
    def completed_before(self, value: Optional[_builtins.str]):
        pulumi.set(self, "completed_before", value)

    @_builtins.property
    @pulumi.getter(name="createdAfter")
    def created_after(self) -> Optional[_builtins.str]:
        """
        Retrieve requests created after this time.
        """
        return pulumi.get(self, "created_after")

    @created_after.setter
    def created_after(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_after", value)

    @_builtins.property
    @pulumi.getter(name="createdBefore")
    def created_before(self) -> Optional[_builtins.str]:
        """
        Retrieve requests created before this time.
        """
        return pulumi.get(self, "created_before")

    @created_before.setter
    def created_before(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_before", value)

    @_builtins.property
    @pulumi.getter(name="requestType")
    def request_type(self) -> Optional[_builtins.str]:
        """
        Requested information from request.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "request_type", value)

    @_builtins.property
    @pulumi.getter(name="sortBy")
    def sort_by(self) -> Optional[_builtins.str]:
        """
        Field to sort results by.
        """
        return pulumi.get(self, "sort_by")

    @sort_by.setter
    def sort_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sort_by", value)

    @_builtins.property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[_builtins.str]:
        """
        Sort order (asc or desc).
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sort_order", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Request Status.
        Available values: "open", "accepted", "reported", "approved", "completed", "declined".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetCustomHostnameFilterArgsDict(TypedDict):
        order: _builtins.str
        """
        Field to order hostnames by.
        Available values: "ssl", "ssl_status".
        """
        direction: NotRequired[_builtins.str]
        """
        Direction to order hostnames.
        Available values: "asc", "desc".
        """
        hostname: NotRequired[_builtins.str]
        """
        Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        """
        id: NotRequired[_builtins.str]
        """
        Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        """
        ssl: NotRequired[_builtins.float]
        """
        Whether to filter hostnames based on if they have SSL enabled.
        Available values: 0, 1.
        """
elif False:
    GetCustomHostnameFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCustomHostnameFilterArgs:
    def __init__(__self__, *,
                 order: _builtins.str,
                 direction: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 ssl: Optional[_builtins.float] = None):
        """
        :param _builtins.str order: Field to order hostnames by.
               Available values: "ssl", "ssl_status".
        :param _builtins.str direction: Direction to order hostnames.
               Available values: "asc", "desc".
        :param _builtins.str hostname: Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        :param _builtins.str id: Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        :param _builtins.float ssl: Whether to filter hostnames based on if they have SSL enabled.
               Available values: 0, 1.
        """
        pulumi.set(__self__, "order", order)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.str:
        """
        Field to order hostnames by.
        Available values: "ssl", "ssl_status".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: _builtins.str):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order hostnames.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        Fully qualified domain name to match against. This parameter cannot be used with the 'id' parameter.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Hostname ID to match against. This ID was generated and returned during the initial custom_hostname creation. This parameter cannot be used with the 'hostname' parameter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ssl(self) -> Optional[_builtins.float]:
        """
        Whether to filter hostnames based on if they have SSL enabled.
        Available values: 0, 1.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[_builtins.float]):
        pulumi.set(self, "ssl", value)


if not MYPY:
    class GetCustomSslFilterArgsDict(TypedDict):
        match: _builtins.str
        """
        Whether to match all search requirements or at least one (any).
        Available values: "any", "all".
        """
        status: NotRequired[_builtins.str]
        """
        Status of the zone's custom SSL.
        Available values: "active", "expired", "deleted", "pending", "initializing".
        """
elif False:
    GetCustomSslFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCustomSslFilterArgs:
    def __init__(__self__, *,
                 match: _builtins.str,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str match: Whether to match all search requirements or at least one (any).
               Available values: "any", "all".
        :param _builtins.str status: Status of the zone's custom SSL.
               Available values: "active", "expired", "deleted", "pending", "initializing".
        """
        pulumi.set(__self__, "match", match)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        Whether to match all search requirements or at least one (any).
        Available values: "any", "all".
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: _builtins.str):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the zone's custom SSL.
        Available values: "active", "expired", "deleted", "pending", "initializing".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetD1DatabaseFilterArgsDict(TypedDict):
        name: NotRequired[_builtins.str]
        """
        a database name to search for.
        """
elif False:
    GetD1DatabaseFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetD1DatabaseFilterArgs:
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: a database name to search for.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        a database name to search for.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetDnsRecordFilterArgsDict(TypedDict):
        direction: _builtins.str
        """
        Direction to order DNS records in.
        Available values: "asc", "desc".
        """
        match: _builtins.str
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        Available values: "any", "all".
        """
        order: _builtins.str
        """
        Field to order DNS records by.
        Available values: "type", "name", "content", "ttl", "proxied".
        """
        proxied: _builtins.bool
        """
        Whether the record is receiving the performance and security benefits of Cloudflare.
        """
        tag_match: _builtins.str
        """
        Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        Available values: "any", "all".
        """
        comment: NotRequired['GetDnsRecordFilterCommentArgsDict']
        content: NotRequired['GetDnsRecordFilterContentArgsDict']
        name: NotRequired['GetDnsRecordFilterNameArgsDict']
        search: NotRequired[_builtins.str]
        """
        Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        """
        tag: NotRequired['GetDnsRecordFilterTagArgsDict']
        type: NotRequired[_builtins.str]
        """
        Record type.
        Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
        """
elif False:
    GetDnsRecordFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterArgs:
    def __init__(__self__, *,
                 direction: _builtins.str,
                 match: _builtins.str,
                 order: _builtins.str,
                 proxied: _builtins.bool,
                 tag_match: _builtins.str,
                 comment: Optional['GetDnsRecordFilterCommentArgs'] = None,
                 content: Optional['GetDnsRecordFilterContentArgs'] = None,
                 name: Optional['GetDnsRecordFilterNameArgs'] = None,
                 search: Optional[_builtins.str] = None,
                 tag: Optional['GetDnsRecordFilterTagArgs'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order DNS records in.
               Available values: "asc", "desc".
        :param _builtins.str match: Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
               Available values: "any", "all".
        :param _builtins.str order: Field to order DNS records by.
               Available values: "type", "name", "content", "ttl", "proxied".
        :param _builtins.bool proxied: Whether the record is receiving the performance and security benefits of Cloudflare.
        :param _builtins.str tag_match: Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
               Available values: "any", "all".
        :param _builtins.str search: Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        :param _builtins.str type: Record type.
               Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "proxied", proxied)
        pulumi.set(__self__, "tag_match", tag_match)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        Direction to order DNS records in.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: _builtins.str):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
        Available values: "any", "all".
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: _builtins.str):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.str:
        """
        Field to order DNS records by.
        Available values: "type", "name", "content", "ttl", "proxied".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: _builtins.str):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def proxied(self) -> _builtins.bool:
        """
        Whether the record is receiving the performance and security benefits of Cloudflare.
        """
        return pulumi.get(self, "proxied")

    @proxied.setter
    def proxied(self, value: _builtins.bool):
        pulumi.set(self, "proxied", value)

    @_builtins.property
    @pulumi.getter(name="tagMatch")
    def tag_match(self) -> _builtins.str:
        """
        Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
        Available values: "any", "all".
        """
        return pulumi.get(self, "tag_match")

    @tag_match.setter
    def tag_match(self, value: _builtins.str):
        pulumi.set(self, "tag_match", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional['GetDnsRecordFilterCommentArgs']:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional['GetDnsRecordFilterCommentArgs']):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional['GetDnsRecordFilterContentArgs']:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional['GetDnsRecordFilterContentArgs']):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional['GetDnsRecordFilterNameArgs']:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional['GetDnsRecordFilterNameArgs']):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional['GetDnsRecordFilterTagArgs']:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional['GetDnsRecordFilterTagArgs']):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Record type.
        Available values: "A", "AAAA", "CAA", "CERT", "CNAME", "DNSKEY", "DS", "HTTPS", "LOC", "MX", "NAPTR", "NS", "OPENPGPKEY", "PTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "TXT", "URI".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetDnsRecordFilterCommentArgsDict(TypedDict):
        absent: NotRequired[_builtins.str]
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        present: NotRequired[_builtins.str]
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterCommentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterCommentArgs:
    def __init__(__self__, *,
                 absent: Optional[_builtins.str] = None,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 present: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str absent: If this parameter is present, only records *without* a comment are returned.
        :param _builtins.str contains: Substring of the DNS record comment. Comment filters are case-insensitive.
        :param _builtins.str endswith: Suffix of the DNS record comment. Comment filters are case-insensitive.
        :param _builtins.str exact: Exact value of the DNS record comment. Comment filters are case-insensitive.
        :param _builtins.str present: If this parameter is present, only records *with* a comment are returned.
        :param _builtins.str startswith: Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def absent(self) -> Optional[_builtins.str]:
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[_builtins.str]):
        pulumi.set(self, "absent", value)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.str]:
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[_builtins.str]):
        pulumi.set(self, "present", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordFilterContentArgsDict(TypedDict):
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterContentArgs:
    def __init__(__self__, *,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str contains: Substring of the DNS record content. Content filters are case-insensitive.
        :param _builtins.str endswith: Suffix of the DNS record content. Content filters are case-insensitive.
        :param _builtins.str exact: Exact value of the DNS record content. Content filters are case-insensitive.
        :param _builtins.str startswith: Prefix of the DNS record content. Content filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordFilterNameArgsDict(TypedDict):
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterNameArgs:
    def __init__(__self__, *,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str contains: Substring of the DNS record name. Name filters are case-insensitive.
        :param _builtins.str endswith: Suffix of the DNS record name. Name filters are case-insensitive.
        :param _builtins.str exact: Exact value of the DNS record name. Name filters are case-insensitive.
        :param _builtins.str startswith: Prefix of the DNS record name. Name filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordFilterTagArgsDict(TypedDict):
        absent: NotRequired[_builtins.str]
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        contains: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        present: NotRequired[_builtins.str]
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        startswith: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
elif False:
    GetDnsRecordFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordFilterTagArgs:
    def __init__(__self__, *,
                 absent: Optional[_builtins.str] = None,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 present: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str absent: Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        :param _builtins.str contains: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        :param _builtins.str endswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        :param _builtins.str exact: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        :param _builtins.str present: Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        :param _builtins.str startswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def absent(self) -> Optional[_builtins.str]:
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[_builtins.str]):
        pulumi.set(self, "absent", value)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.str]:
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[_builtins.str]):
        pulumi.set(self, "present", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsCommentArgsDict(TypedDict):
        absent: NotRequired[_builtins.str]
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        present: NotRequired[_builtins.str]
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
elif False:
    GetDnsRecordsCommentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsCommentArgs:
    def __init__(__self__, *,
                 absent: Optional[_builtins.str] = None,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 present: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str absent: If this parameter is present, only records *without* a comment are returned.
        :param _builtins.str contains: Substring of the DNS record comment. Comment filters are case-insensitive.
        :param _builtins.str endswith: Suffix of the DNS record comment. Comment filters are case-insensitive.
        :param _builtins.str exact: Exact value of the DNS record comment. Comment filters are case-insensitive.
        :param _builtins.str present: If this parameter is present, only records *with* a comment are returned.
        :param _builtins.str startswith: Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def absent(self) -> Optional[_builtins.str]:
        """
        If this parameter is present, only records *without* a comment are returned.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[_builtins.str]):
        pulumi.set(self, "absent", value)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.str]:
        """
        If this parameter is present, only records *with* a comment are returned.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[_builtins.str]):
        pulumi.set(self, "present", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS record comment. Comment filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsContentArgsDict(TypedDict):
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
elif False:
    GetDnsRecordsContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsContentArgs:
    def __init__(__self__, *,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str contains: Substring of the DNS record content. Content filters are case-insensitive.
        :param _builtins.str endswith: Suffix of the DNS record content. Content filters are case-insensitive.
        :param _builtins.str exact: Exact value of the DNS record content. Content filters are case-insensitive.
        :param _builtins.str startswith: Prefix of the DNS record content. Content filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS record content. Content filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsNameArgsDict(TypedDict):
        contains: NotRequired[_builtins.str]
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        startswith: NotRequired[_builtins.str]
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
elif False:
    GetDnsRecordsNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsNameArgs:
    def __init__(__self__, *,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str contains: Substring of the DNS record name. Name filters are case-insensitive.
        :param _builtins.str endswith: Suffix of the DNS record name. Name filters are case-insensitive.
        :param _builtins.str exact: Exact value of the DNS record name. Name filters are case-insensitive.
        :param _builtins.str startswith: Prefix of the DNS record name. Name filters are case-insensitive.
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        Substring of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        Suffix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact value of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        Prefix of the DNS record name. Name filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetDnsRecordsTagArgsDict(TypedDict):
        absent: NotRequired[_builtins.str]
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        contains: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        endswith: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        exact: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        present: NotRequired[_builtins.str]
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        startswith: NotRequired[_builtins.str]
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
elif False:
    GetDnsRecordsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDnsRecordsTagArgs:
    def __init__(__self__, *,
                 absent: Optional[_builtins.str] = None,
                 contains: Optional[_builtins.str] = None,
                 endswith: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.str] = None,
                 present: Optional[_builtins.str] = None,
                 startswith: Optional[_builtins.str] = None):
        """
        :param _builtins.str absent: Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        :param _builtins.str contains: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        :param _builtins.str endswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        :param _builtins.str exact: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        :param _builtins.str present: Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        :param _builtins.str startswith: A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        if absent is not None:
            pulumi.set(__self__, "absent", absent)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if endswith is not None:
            pulumi.set(__self__, "endswith", endswith)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if startswith is not None:
            pulumi.set(__self__, "startswith", startswith)

    @_builtins.property
    @pulumi.getter
    def absent(self) -> Optional[_builtins.str]:
        """
        Name of a tag which must *not* be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "absent")

    @absent.setter
    def absent(self, value: Optional[_builtins.str]):
        pulumi.set(self, "absent", value)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value contains `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def endswith(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value ends with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "endswith")

    @endswith.setter
    def endswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "endswith", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value is `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.str]:
        """
        Name of a tag which must be present on the DNS record. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "present")

    @present.setter
    def present(self, value: Optional[_builtins.str]):
        pulumi.set(self, "present", value)

    @_builtins.property
    @pulumi.getter
    def startswith(self) -> Optional[_builtins.str]:
        """
        A tag and value, of the form `<tag-name>:<tag-value>`. The API will only return DNS records that have a tag named `<tag-name>` whose value starts with `<tag-value>`. Tag filters are case-insensitive.
        """
        return pulumi.get(self, "startswith")

    @startswith.setter
    def startswith(self, value: Optional[_builtins.str]):
        pulumi.set(self, "startswith", value)


if not MYPY:
    class GetEmailRoutingAddressFilterArgsDict(TypedDict):
        direction: _builtins.str
        """
        Sorts results in an ascending or descending order.
        Available values: "asc", "desc".
        """
        verified: _builtins.bool
        """
        Filter by verified destination addresses.
        """
elif False:
    GetEmailRoutingAddressFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailRoutingAddressFilterArgs:
    def __init__(__self__, *,
                 direction: _builtins.str,
                 verified: _builtins.bool):
        """
        :param _builtins.str direction: Sorts results in an ascending or descending order.
               Available values: "asc", "desc".
        :param _builtins.bool verified: Filter by verified destination addresses.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "verified", verified)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        Sorts results in an ascending or descending order.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: _builtins.str):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def verified(self) -> _builtins.bool:
        """
        Filter by verified destination addresses.
        """
        return pulumi.get(self, "verified")

    @verified.setter
    def verified(self, value: _builtins.bool):
        pulumi.set(self, "verified", value)


if not MYPY:
    class GetEmailRoutingRuleFilterArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        Filter by enabled routing rules.
        """
elif False:
    GetEmailRoutingRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailRoutingRuleFilterArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Filter by enabled routing rules.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Filter by enabled routing rules.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetEmailSecurityBlockSenderFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        order: NotRequired[_builtins.str]
        """
        The field to sort by.
        Available values: "pattern", "created_at".
        """
        pattern: NotRequired[_builtins.str]
        pattern_type: NotRequired[_builtins.str]
        """
        Available values: "EMAIL", "DOMAIN", "IP", "UNKNOWN".
        """
        search: NotRequired[_builtins.str]
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
elif False:
    GetEmailSecurityBlockSenderFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailSecurityBlockSenderFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None,
                 pattern: Optional[_builtins.str] = None,
                 pattern_type: Optional[_builtins.str] = None,
                 search: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction.
               Available values: "asc", "desc".
        :param _builtins.str order: The field to sort by.
               Available values: "pattern", "created_at".
        :param _builtins.str pattern_type: Available values: "EMAIL", "DOMAIN", "IP", "UNKNOWN".
        :param _builtins.str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if pattern_type is not None:
            pulumi.set(__self__, "pattern_type", pattern_type)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        The field to sort by.
        Available values: "pattern", "created_at".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> Optional[_builtins.str]:
        """
        Available values: "EMAIL", "DOMAIN", "IP", "UNKNOWN".
        """
        return pulumi.get(self, "pattern_type")

    @pattern_type.setter
    def pattern_type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "pattern_type", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetEmailSecurityImpersonationRegistryFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        order: NotRequired[_builtins.str]
        """
        The field to sort by.
        Available values: "name", "email", "created_at".
        """
        provenance: NotRequired[_builtins.str]
        """
        Available values: "A1S*INTERNAL", "SNOOPY-CASB*OFFICE*365", "SNOOPY-OFFICE*365", "SNOOPY-GOOGLE_DIRECTORY".
        """
        search: NotRequired[_builtins.str]
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
elif False:
    GetEmailSecurityImpersonationRegistryFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailSecurityImpersonationRegistryFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None,
                 provenance: Optional[_builtins.str] = None,
                 search: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction.
               Available values: "asc", "desc".
        :param _builtins.str order: The field to sort by.
               Available values: "name", "email", "created_at".
        :param _builtins.str provenance: Available values: "A1S*INTERNAL", "SNOOPY-CASB*OFFICE*365", "SNOOPY-OFFICE*365", "SNOOPY-GOOGLE_DIRECTORY".
        :param _builtins.str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if provenance is not None:
            pulumi.set(__self__, "provenance", provenance)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        The field to sort by.
        Available values: "name", "email", "created_at".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def provenance(self) -> Optional[_builtins.str]:
        """
        Available values: "A1S*INTERNAL", "SNOOPY-CASB*OFFICE*365", "SNOOPY-OFFICE*365", "SNOOPY-GOOGLE_DIRECTORY".
        """
        return pulumi.get(self, "provenance")

    @provenance.setter
    def provenance(self, value: Optional[_builtins.str]):
        pulumi.set(self, "provenance", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetEmailSecurityTrustedDomainsFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        is_recent: NotRequired[_builtins.bool]
        is_similarity: NotRequired[_builtins.bool]
        order: NotRequired[_builtins.str]
        """
        The field to sort by.
        Available values: "pattern", "created_at".
        """
        pattern: NotRequired[_builtins.str]
        search: NotRequired[_builtins.str]
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
elif False:
    GetEmailSecurityTrustedDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEmailSecurityTrustedDomainsFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 is_recent: Optional[_builtins.bool] = None,
                 is_similarity: Optional[_builtins.bool] = None,
                 order: Optional[_builtins.str] = None,
                 pattern: Optional[_builtins.str] = None,
                 search: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: The sorting direction.
               Available values: "asc", "desc".
        :param _builtins.str order: The field to sort by.
               Available values: "pattern", "created_at".
        :param _builtins.str search: Allows searching in multiple properties of a record simultaneously.
               This parameter is intended for human users, not automation. Its exact
               behavior is intentionally left unspecified and is subject to change
               in the future.
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if is_recent is not None:
            pulumi.set(__self__, "is_recent", is_recent)
        if is_similarity is not None:
            pulumi.set(__self__, "is_similarity", is_similarity)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter(name="isRecent")
    def is_recent(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_recent")

    @is_recent.setter
    def is_recent(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_recent", value)

    @_builtins.property
    @pulumi.getter(name="isSimilarity")
    def is_similarity(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_similarity")

    @is_similarity.setter
    def is_similarity(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_similarity", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        The field to sort by.
        Available values: "pattern", "created_at".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Allows searching in multiple properties of a record simultaneously.
        This parameter is intended for human users, not automation. Its exact
        behavior is intentionally left unspecified and is subject to change
        in the future.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetFilterFilterArgsDict(TypedDict):
        description: NotRequired[_builtins.str]
        """
        A case-insensitive string to find in the description.
        """
        expression: NotRequired[_builtins.str]
        """
        A case-insensitive string to find in the expression.
        """
        id: NotRequired[_builtins.str]
        """
        The unique identifier of the filter.
        """
        paused: NotRequired[_builtins.bool]
        """
        When true, indicates that the filter is currently paused.
        """
        ref: NotRequired[_builtins.str]
        """
        The filter ref (a short reference tag) to search for. Must be an exact match.
        """
elif False:
    GetFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFilterFilterArgs:
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 expression: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 paused: Optional[_builtins.bool] = None,
                 ref: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: A case-insensitive string to find in the description.
        :param _builtins.str expression: A case-insensitive string to find in the expression.
        :param _builtins.str id: The unique identifier of the filter.
        :param _builtins.bool paused: When true, indicates that the filter is currently paused.
        :param _builtins.str ref: The filter ref (a short reference tag) to search for. Must be an exact match.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A case-insensitive string to find in the description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        A case-insensitive string to find in the expression.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the filter.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        When true, indicates that the filter is currently paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "paused", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        The filter ref (a short reference tag) to search for. Must be an exact match.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class GetLoadBalancerPoolFilterArgsDict(TypedDict):
        monitor: NotRequired[_builtins.str]
        """
        The ID of the Monitor to use for checking the health of origins within this pool.
        """
elif False:
    GetLoadBalancerPoolFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetLoadBalancerPoolFilterArgs:
    def __init__(__self__, *,
                 monitor: Optional[_builtins.str] = None):
        """
        :param _builtins.str monitor: The ID of the Monitor to use for checking the health of origins within this pool.
        """
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)

    @_builtins.property
    @pulumi.getter
    def monitor(self) -> Optional[_builtins.str]:
        """
        The ID of the Monitor to use for checking the health of origins within this pool.
        """
        return pulumi.get(self, "monitor")

    @monitor.setter
    def monitor(self, value: Optional[_builtins.str]):
        pulumi.set(self, "monitor", value)


if not MYPY:
    class GetMagicTransitSiteFilterArgsDict(TypedDict):
        connectorid: NotRequired[_builtins.str]
        """
        Identifier
        """
elif False:
    GetMagicTransitSiteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMagicTransitSiteFilterArgs:
    def __init__(__self__, *,
                 connectorid: Optional[_builtins.str] = None):
        """
        :param _builtins.str connectorid: Identifier
        """
        if connectorid is not None:
            pulumi.set(__self__, "connectorid", connectorid)

    @_builtins.property
    @pulumi.getter
    def connectorid(self) -> Optional[_builtins.str]:
        """
        Identifier
        """
        return pulumi.get(self, "connectorid")

    @connectorid.setter
    def connectorid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "connectorid", value)


if not MYPY:
    class GetOriginCaCertificateFilterArgsDict(TypedDict):
        zone_id: _builtins.str
        """
        Identifier.
        """
        limit: NotRequired[_builtins.int]
        """
        Limit to the number of records returned.
        """
        offset: NotRequired[_builtins.int]
        """
        Offset the results
        """
elif False:
    GetOriginCaCertificateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOriginCaCertificateFilterArgs:
    def __init__(__self__, *,
                 zone_id: _builtins.str,
                 limit: Optional[_builtins.int] = None,
                 offset: Optional[_builtins.int] = None):
        """
        :param _builtins.str zone_id: Identifier.
        :param _builtins.int limit: Limit to the number of records returned.
        :param _builtins.int offset: Offset the results
        """
        pulumi.set(__self__, "zone_id", zone_id)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        Identifier.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: _builtins.str):
        pulumi.set(self, "zone_id", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[_builtins.int]:
        """
        Limit to the number of records returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.int]:
        """
        Offset the results
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[_builtins.int]):
        pulumi.set(self, "offset", value)


if not MYPY:
    class GetSchemaValidationSchemasFilterArgsDict(TypedDict):
        omit_source: _builtins.bool
        """
        Omit the source-files of schemas and only retrieve their meta-data.
        """
        validation_enabled: NotRequired[_builtins.bool]
        """
        Filter for enabled schemas
        """
elif False:
    GetSchemaValidationSchemasFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchemaValidationSchemasFilterArgs:
    def __init__(__self__, *,
                 omit_source: _builtins.bool,
                 validation_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool omit_source: Omit the source-files of schemas and only retrieve their meta-data.
        :param _builtins.bool validation_enabled: Filter for enabled schemas
        """
        pulumi.set(__self__, "omit_source", omit_source)
        if validation_enabled is not None:
            pulumi.set(__self__, "validation_enabled", validation_enabled)

    @_builtins.property
    @pulumi.getter(name="omitSource")
    def omit_source(self) -> _builtins.bool:
        """
        Omit the source-files of schemas and only retrieve their meta-data.
        """
        return pulumi.get(self, "omit_source")

    @omit_source.setter
    def omit_source(self, value: _builtins.bool):
        pulumi.set(self, "omit_source", value)

    @_builtins.property
    @pulumi.getter(name="validationEnabled")
    def validation_enabled(self) -> Optional[_builtins.bool]:
        """
        Filter for enabled schemas
        """
        return pulumi.get(self, "validation_enabled")

    @validation_enabled.setter
    def validation_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "validation_enabled", value)


if not MYPY:
    class GetTurnstileWidgetFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order widgets.
        Available values: "asc", "desc".
        """
        order: NotRequired[_builtins.str]
        """
        Field to order widgets by.
        Available values: "id", "sitekey", "name", "created*on", "modified*on".
        """
elif False:
    GetTurnstileWidgetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTurnstileWidgetFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order widgets.
               Available values: "asc", "desc".
        :param _builtins.str order: Field to order widgets by.
               Available values: "id", "sitekey", "name", "created*on", "modified*on".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order widgets.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Field to order widgets by.
        Available values: "id", "sitekey", "name", "created*on", "modified*on".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetUserAgentBlockingRuleFilterArgsDict(TypedDict):
        description: NotRequired[_builtins.str]
        """
        A string to search for in the description of existing rules.
        """
        paused: NotRequired[_builtins.bool]
        """
        When true, indicates that the rule is currently paused.
        """
        user_agent: NotRequired[_builtins.str]
        """
        A string to search for in the user agent values of existing rules.
        """
elif False:
    GetUserAgentBlockingRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserAgentBlockingRuleFilterArgs:
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 paused: Optional[_builtins.bool] = None,
                 user_agent: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: A string to search for in the description of existing rules.
        :param _builtins.bool paused: When true, indicates that the rule is currently paused.
        :param _builtins.str user_agent: A string to search for in the user agent values of existing rules.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        When true, indicates that the rule is currently paused.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "paused", value)

    @_builtins.property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[_builtins.str]:
        """
        A string to search for in the user agent values of existing rules.
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[_builtins.str]):
        pulumi.set(self, "user_agent", value)


if not MYPY:
    class GetWebAnalyticsSiteFilterArgsDict(TypedDict):
        order_by: NotRequired[_builtins.str]
        """
        The property used to sort the list of results.
        Available values: "host", "created".
        """
elif False:
    GetWebAnalyticsSiteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWebAnalyticsSiteFilterArgs:
    def __init__(__self__, *,
                 order_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str order_by: The property used to sort the list of results.
               Available values: "host", "created".
        """
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)

    @_builtins.property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[_builtins.str]:
        """
        The property used to sort the list of results.
        Available values: "host", "created".
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order_by", value)


if not MYPY:
    class GetWorkersCustomDomainFilterArgsDict(TypedDict):
        environment: NotRequired[_builtins.str]
        """
        Worker environment associated with the zone and hostname.
        """
        hostname: NotRequired[_builtins.str]
        """
        Hostname of the Worker Domain.
        """
        service: NotRequired[_builtins.str]
        """
        Worker service associated with the zone and hostname.
        """
        zone_id: NotRequired[_builtins.str]
        """
        Identifier of the zone.
        """
        zone_name: NotRequired[_builtins.str]
        """
        Name of the zone.
        """
elif False:
    GetWorkersCustomDomainFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkersCustomDomainFilterArgs:
    def __init__(__self__, *,
                 environment: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 service: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None,
                 zone_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str environment: Worker environment associated with the zone and hostname.
        :param _builtins.str hostname: Hostname of the Worker Domain.
        :param _builtins.str service: Worker service associated with the zone and hostname.
        :param _builtins.str zone_id: Identifier of the zone.
        :param _builtins.str zone_name: Name of the zone.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Worker environment associated with the zone and hostname.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[_builtins.str]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        Hostname of the Worker Domain.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Worker service associated with the zone and hostname.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the zone.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "zone_id", value)

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[_builtins.str]:
        """
        Name of the zone.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class GetWorkersKvNamespaceFilterArgsDict(TypedDict):
        direction: NotRequired[_builtins.str]
        """
        Direction to order namespaces.
        Available values: "asc", "desc".
        """
        order: NotRequired[_builtins.str]
        """
        Field to order results by.
        Available values: "id", "title".
        """
elif False:
    GetWorkersKvNamespaceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkersKvNamespaceFilterArgs:
    def __init__(__self__, *,
                 direction: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None):
        """
        :param _builtins.str direction: Direction to order namespaces.
               Available values: "asc", "desc".
        :param _builtins.str order: Field to order results by.
               Available values: "id", "title".
        """
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order namespaces.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Field to order results by.
        Available values: "id", "title".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)


if not MYPY:
    class GetZeroTrustAccessApplicationFilterArgsDict(TypedDict):
        aud: NotRequired[_builtins.str]
        """
        The aud of the app.
        """
        domain: NotRequired[_builtins.str]
        """
        The domain of the app.
        """
        exact: NotRequired[_builtins.bool]
        """
        True for only exact string matches against passed name/domain query parameters.
        """
        name: NotRequired[_builtins.str]
        """
        The name of the app.
        """
        search: NotRequired[_builtins.str]
        """
        Search for apps by other listed query parameters.
        """
elif False:
    GetZeroTrustAccessApplicationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessApplicationFilterArgs:
    def __init__(__self__, *,
                 aud: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 exact: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 search: Optional[_builtins.str] = None):
        """
        :param _builtins.str aud: The aud of the app.
        :param _builtins.str domain: The domain of the app.
        :param _builtins.bool exact: True for only exact string matches against passed name/domain query parameters.
        :param _builtins.str name: The name of the app.
        :param _builtins.str search: Search for apps by other listed query parameters.
        """
        if aud is not None:
            pulumi.set(__self__, "aud", aud)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @_builtins.property
    @pulumi.getter
    def aud(self) -> Optional[_builtins.str]:
        """
        The aud of the app.
        """
        return pulumi.get(self, "aud")

    @aud.setter
    def aud(self, value: Optional[_builtins.str]):
        pulumi.set(self, "aud", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        The domain of the app.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.bool]:
        """
        True for only exact string matches against passed name/domain query parameters.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Search for apps by other listed query parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetZeroTrustAccessGroupFilterArgsDict(TypedDict):
        name: NotRequired[_builtins.str]
        """
        The name of the group.
        """
        search: NotRequired[_builtins.str]
        """
        Search for groups by other listed query parameters.
        """
elif False:
    GetZeroTrustAccessGroupFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessGroupFilterArgs:
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 search: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the group.
        :param _builtins.str search: Search for groups by other listed query parameters.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Search for groups by other listed query parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetZeroTrustAccessIdentityProviderFilterArgsDict(TypedDict):
        scim_enabled: NotRequired[_builtins.str]
        """
        Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
elif False:
    GetZeroTrustAccessIdentityProviderFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessIdentityProviderFilterArgs:
    def __init__(__self__, *,
                 scim_enabled: Optional[_builtins.str] = None):
        """
        :param _builtins.str scim_enabled: Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
        if scim_enabled is not None:
            pulumi.set(__self__, "scim_enabled", scim_enabled)

    @_builtins.property
    @pulumi.getter(name="scimEnabled")
    def scim_enabled(self) -> Optional[_builtins.str]:
        """
        Indicates to Access to only retrieve identity providers that have the System for Cross-Domain Identity Management (SCIM) enabled.
        """
        return pulumi.get(self, "scim_enabled")

    @scim_enabled.setter
    def scim_enabled(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scim_enabled", value)


if not MYPY:
    class GetZeroTrustAccessInfrastructureTargetFilterArgsDict(TypedDict):
        created_after: NotRequired[_builtins.str]
        """
        Date and time at which the target was created after (inclusive)
        """
        created_before: NotRequired[_builtins.str]
        """
        Date and time at which the target was created before (inclusive)
        """
        direction: NotRequired[_builtins.str]
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        hostname: NotRequired[_builtins.str]
        """
        Hostname of a target
        """
        hostname_contains: NotRequired[_builtins.str]
        """
        Partial match to the hostname of a target
        """
        ip_like: NotRequired[_builtins.str]
        """
        Filters for targets whose IP addresses look like the specified string.
        Supports `*` as a wildcard character
        """
        ip_v4: NotRequired[_builtins.str]
        """
        IPv4 address of the target
        """
        ip_v6: NotRequired[_builtins.str]
        """
        IPv6 address of the target
        """
        ips: NotRequired[Sequence[_builtins.str]]
        """
        Filters for targets that have any of the following IP addresses. Specify
        `ips` multiple times in query parameter to build list of candidates.
        """
        ipv4_end: NotRequired[_builtins.str]
        """
        Defines an IPv4 filter range's ending value (inclusive). Requires
        `ipv4_start` to be specified as well.
        """
        ipv4_start: NotRequired[_builtins.str]
        """
        Defines an IPv4 filter range's starting value (inclusive). Requires
        `ipv4_end` to be specified as well.
        """
        ipv6_end: NotRequired[_builtins.str]
        """
        Defines an IPv6 filter range's ending value (inclusive). Requires
        `ipv6_start` to be specified as well.
        """
        ipv6_start: NotRequired[_builtins.str]
        """
        Defines an IPv6 filter range's starting value (inclusive). Requires
        `ipv6_end` to be specified as well.
        """
        modified_after: NotRequired[_builtins.str]
        """
        Date and time at which the target was modified after (inclusive)
        """
        modified_before: NotRequired[_builtins.str]
        """
        Date and time at which the target was modified before (inclusive)
        """
        order: NotRequired[_builtins.str]
        """
        The field to sort by.
        Available values: "hostname", "created_at".
        """
        target_ids: NotRequired[Sequence[_builtins.str]]
        """
        Filters for targets that have any of the following UUIDs. Specify
        `target_ids` multiple times in query parameter to build list of
        candidates.
        """
        virtual_network_id: NotRequired[_builtins.str]
        """
        Private virtual network identifier of the target
        """
elif False:
    GetZeroTrustAccessInfrastructureTargetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessInfrastructureTargetFilterArgs:
    def __init__(__self__, *,
                 created_after: Optional[_builtins.str] = None,
                 created_before: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 hostname_contains: Optional[_builtins.str] = None,
                 ip_like: Optional[_builtins.str] = None,
                 ip_v4: Optional[_builtins.str] = None,
                 ip_v6: Optional[_builtins.str] = None,
                 ips: Optional[Sequence[_builtins.str]] = None,
                 ipv4_end: Optional[_builtins.str] = None,
                 ipv4_start: Optional[_builtins.str] = None,
                 ipv6_end: Optional[_builtins.str] = None,
                 ipv6_start: Optional[_builtins.str] = None,
                 modified_after: Optional[_builtins.str] = None,
                 modified_before: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None,
                 target_ids: Optional[Sequence[_builtins.str]] = None,
                 virtual_network_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_after: Date and time at which the target was created after (inclusive)
        :param _builtins.str created_before: Date and time at which the target was created before (inclusive)
        :param _builtins.str direction: The sorting direction.
               Available values: "asc", "desc".
        :param _builtins.str hostname: Hostname of a target
        :param _builtins.str hostname_contains: Partial match to the hostname of a target
        :param _builtins.str ip_like: Filters for targets whose IP addresses look like the specified string.
               Supports `*` as a wildcard character
        :param _builtins.str ip_v4: IPv4 address of the target
        :param _builtins.str ip_v6: IPv6 address of the target
        :param Sequence[_builtins.str] ips: Filters for targets that have any of the following IP addresses. Specify
               `ips` multiple times in query parameter to build list of candidates.
        :param _builtins.str ipv4_end: Defines an IPv4 filter range's ending value (inclusive). Requires
               `ipv4_start` to be specified as well.
        :param _builtins.str ipv4_start: Defines an IPv4 filter range's starting value (inclusive). Requires
               `ipv4_end` to be specified as well.
        :param _builtins.str ipv6_end: Defines an IPv6 filter range's ending value (inclusive). Requires
               `ipv6_start` to be specified as well.
        :param _builtins.str ipv6_start: Defines an IPv6 filter range's starting value (inclusive). Requires
               `ipv6_end` to be specified as well.
        :param _builtins.str modified_after: Date and time at which the target was modified after (inclusive)
        :param _builtins.str modified_before: Date and time at which the target was modified before (inclusive)
        :param _builtins.str order: The field to sort by.
               Available values: "hostname", "created_at".
        :param Sequence[_builtins.str] target_ids: Filters for targets that have any of the following UUIDs. Specify
               `target_ids` multiple times in query parameter to build list of
               candidates.
        :param _builtins.str virtual_network_id: Private virtual network identifier of the target
        """
        if created_after is not None:
            pulumi.set(__self__, "created_after", created_after)
        if created_before is not None:
            pulumi.set(__self__, "created_before", created_before)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hostname_contains is not None:
            pulumi.set(__self__, "hostname_contains", hostname_contains)
        if ip_like is not None:
            pulumi.set(__self__, "ip_like", ip_like)
        if ip_v4 is not None:
            pulumi.set(__self__, "ip_v4", ip_v4)
        if ip_v6 is not None:
            pulumi.set(__self__, "ip_v6", ip_v6)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if ipv4_end is not None:
            pulumi.set(__self__, "ipv4_end", ipv4_end)
        if ipv4_start is not None:
            pulumi.set(__self__, "ipv4_start", ipv4_start)
        if ipv6_end is not None:
            pulumi.set(__self__, "ipv6_end", ipv6_end)
        if ipv6_start is not None:
            pulumi.set(__self__, "ipv6_start", ipv6_start)
        if modified_after is not None:
            pulumi.set(__self__, "modified_after", modified_after)
        if modified_before is not None:
            pulumi.set(__self__, "modified_before", modified_before)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if target_ids is not None:
            pulumi.set(__self__, "target_ids", target_ids)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @_builtins.property
    @pulumi.getter(name="createdAfter")
    def created_after(self) -> Optional[_builtins.str]:
        """
        Date and time at which the target was created after (inclusive)
        """
        return pulumi.get(self, "created_after")

    @created_after.setter
    def created_after(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_after", value)

    @_builtins.property
    @pulumi.getter(name="createdBefore")
    def created_before(self) -> Optional[_builtins.str]:
        """
        Date and time at which the target was created before (inclusive)
        """
        return pulumi.get(self, "created_before")

    @created_before.setter
    def created_before(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_before", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sorting direction.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        Hostname of a target
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="hostnameContains")
    def hostname_contains(self) -> Optional[_builtins.str]:
        """
        Partial match to the hostname of a target
        """
        return pulumi.get(self, "hostname_contains")

    @hostname_contains.setter
    def hostname_contains(self, value: Optional[_builtins.str]):
        pulumi.set(self, "hostname_contains", value)

    @_builtins.property
    @pulumi.getter(name="ipLike")
    def ip_like(self) -> Optional[_builtins.str]:
        """
        Filters for targets whose IP addresses look like the specified string.
        Supports `*` as a wildcard character
        """
        return pulumi.get(self, "ip_like")

    @ip_like.setter
    def ip_like(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ip_like", value)

    @_builtins.property
    @pulumi.getter(name="ipV4")
    def ip_v4(self) -> Optional[_builtins.str]:
        """
        IPv4 address of the target
        """
        return pulumi.get(self, "ip_v4")

    @ip_v4.setter
    def ip_v4(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ip_v4", value)

    @_builtins.property
    @pulumi.getter(name="ipV6")
    def ip_v6(self) -> Optional[_builtins.str]:
        """
        IPv6 address of the target
        """
        return pulumi.get(self, "ip_v6")

    @ip_v6.setter
    def ip_v6(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ip_v6", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filters for targets that have any of the following IP addresses. Specify
        `ips` multiple times in query parameter to build list of candidates.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter(name="ipv4End")
    def ipv4_end(self) -> Optional[_builtins.str]:
        """
        Defines an IPv4 filter range's ending value (inclusive). Requires
        `ipv4_start` to be specified as well.
        """
        return pulumi.get(self, "ipv4_end")

    @ipv4_end.setter
    def ipv4_end(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ipv4_end", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Start")
    def ipv4_start(self) -> Optional[_builtins.str]:
        """
        Defines an IPv4 filter range's starting value (inclusive). Requires
        `ipv4_end` to be specified as well.
        """
        return pulumi.get(self, "ipv4_start")

    @ipv4_start.setter
    def ipv4_start(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ipv4_start", value)

    @_builtins.property
    @pulumi.getter(name="ipv6End")
    def ipv6_end(self) -> Optional[_builtins.str]:
        """
        Defines an IPv6 filter range's ending value (inclusive). Requires
        `ipv6_start` to be specified as well.
        """
        return pulumi.get(self, "ipv6_end")

    @ipv6_end.setter
    def ipv6_end(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ipv6_end", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Start")
    def ipv6_start(self) -> Optional[_builtins.str]:
        """
        Defines an IPv6 filter range's starting value (inclusive). Requires
        `ipv6_end` to be specified as well.
        """
        return pulumi.get(self, "ipv6_start")

    @ipv6_start.setter
    def ipv6_start(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ipv6_start", value)

    @_builtins.property
    @pulumi.getter(name="modifiedAfter")
    def modified_after(self) -> Optional[_builtins.str]:
        """
        Date and time at which the target was modified after (inclusive)
        """
        return pulumi.get(self, "modified_after")

    @modified_after.setter
    def modified_after(self, value: Optional[_builtins.str]):
        pulumi.set(self, "modified_after", value)

    @_builtins.property
    @pulumi.getter(name="modifiedBefore")
    def modified_before(self) -> Optional[_builtins.str]:
        """
        Date and time at which the target was modified before (inclusive)
        """
        return pulumi.get(self, "modified_before")

    @modified_before.setter
    def modified_before(self, value: Optional[_builtins.str]):
        pulumi.set(self, "modified_before", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        The field to sort by.
        Available values: "hostname", "created_at".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter(name="targetIds")
    def target_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filters for targets that have any of the following UUIDs. Specify
        `target_ids` multiple times in query parameter to build list of
        candidates.
        """
        return pulumi.get(self, "target_ids")

    @target_ids.setter
    def target_ids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "target_ids", value)

    @_builtins.property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[_builtins.str]:
        """
        Private virtual network identifier of the target
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class GetZeroTrustAccessServiceTokenFilterArgsDict(TypedDict):
        name: NotRequired[_builtins.str]
        """
        The name of the service token.
        """
        search: NotRequired[_builtins.str]
        """
        Search for service tokens by other listed query parameters.
        """
elif False:
    GetZeroTrustAccessServiceTokenFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustAccessServiceTokenFilterArgs:
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 search: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the service token.
        :param _builtins.str search: Search for service tokens by other listed query parameters.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the service token.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[_builtins.str]:
        """
        Search for service tokens by other listed query parameters.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "search", value)


if not MYPY:
    class GetZeroTrustListFilterArgsDict(TypedDict):
        type: NotRequired[_builtins.str]
        """
        The type of list.
        Available values: "SERIAL", "URL", "DOMAIN", "EMAIL", "IP".
        """
elif False:
    GetZeroTrustListFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustListFilterArgs:
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of list.
               Available values: "SERIAL", "URL", "DOMAIN", "EMAIL", "IP".
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of list.
        Available values: "SERIAL", "URL", "DOMAIN", "EMAIL", "IP".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetZeroTrustTunnelCloudflaredFilterArgsDict(TypedDict):
        exclude_prefix: NotRequired[_builtins.str]
        existed_at: NotRequired[_builtins.str]
        """
        If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        """
        include_prefix: NotRequired[_builtins.str]
        is_deleted: NotRequired[_builtins.bool]
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        name: NotRequired[_builtins.str]
        """
        A user-friendly name for a tunnel.
        """
        status: NotRequired[_builtins.str]
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        Available values: "inactive", "degraded", "healthy", "down".
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID of the tunnel.
        """
        was_active_at: NotRequired[_builtins.str]
        was_inactive_at: NotRequired[_builtins.str]
elif False:
    GetZeroTrustTunnelCloudflaredFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelCloudflaredFilterArgs:
    def __init__(__self__, *,
                 exclude_prefix: Optional[_builtins.str] = None,
                 existed_at: Optional[_builtins.str] = None,
                 include_prefix: Optional[_builtins.str] = None,
                 is_deleted: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 was_active_at: Optional[_builtins.str] = None,
                 was_inactive_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str existed_at: If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        :param _builtins.bool is_deleted: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        :param _builtins.str name: A user-friendly name for a tunnel.
        :param _builtins.str status: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
               Available values: "inactive", "degraded", "healthy", "down".
        :param _builtins.str uuid: UUID of the tunnel.
        """
        if exclude_prefix is not None:
            pulumi.set(__self__, "exclude_prefix", exclude_prefix)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if include_prefix is not None:
            pulumi.set(__self__, "include_prefix", include_prefix)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if was_active_at is not None:
            pulumi.set(__self__, "was_active_at", was_active_at)
        if was_inactive_at is not None:
            pulumi.set(__self__, "was_inactive_at", was_inactive_at)

    @_builtins.property
    @pulumi.getter(name="excludePrefix")
    def exclude_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exclude_prefix")

    @exclude_prefix.setter
    def exclude_prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exclude_prefix", value)

    @_builtins.property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[_builtins.str]:
        """
        If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        """
        return pulumi.get(self, "existed_at")

    @existed_at.setter
    def existed_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "existed_at", value)

    @_builtins.property
    @pulumi.getter(name="includePrefix")
    def include_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "include_prefix")

    @include_prefix.setter
    def include_prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "include_prefix", value)

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[_builtins.bool]:
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_deleted", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A user-friendly name for a tunnel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        Available values: "inactive", "degraded", "healthy", "down".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="wasActiveAt")
    def was_active_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "was_active_at")

    @was_active_at.setter
    def was_active_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "was_active_at", value)

    @_builtins.property
    @pulumi.getter(name="wasInactiveAt")
    def was_inactive_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "was_inactive_at")

    @was_inactive_at.setter
    def was_inactive_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "was_inactive_at", value)


if not MYPY:
    class GetZeroTrustTunnelCloudflaredRouteFilterArgsDict(TypedDict):
        comment: _builtins.str
        """
        Optional remark describing the route.
        """
        existed_at: NotRequired[_builtins.str]
        """
        If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        """
        is_deleted: NotRequired[_builtins.bool]
        """
        If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        """
        network_subset: NotRequired[_builtins.str]
        """
        If set, only list routes that are contained within this IP range.
        """
        network_superset: NotRequired[_builtins.str]
        """
        If set, only list routes that contain this IP range.
        """
        route_id: NotRequired[_builtins.str]
        """
        UUID of the route.
        """
        tun_types: NotRequired[Sequence[_builtins.str]]
        """
        The types of tunnels to filter by, separated by commas.
        """
        tunnel_id: NotRequired[_builtins.str]
        """
        UUID of the tunnel.
        """
        virtual_network_id: NotRequired[_builtins.str]
        """
        UUID of the virtual network.
        """
elif False:
    GetZeroTrustTunnelCloudflaredRouteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelCloudflaredRouteFilterArgs:
    def __init__(__self__, *,
                 comment: _builtins.str,
                 existed_at: Optional[_builtins.str] = None,
                 is_deleted: Optional[_builtins.bool] = None,
                 network_subset: Optional[_builtins.str] = None,
                 network_superset: Optional[_builtins.str] = None,
                 route_id: Optional[_builtins.str] = None,
                 tun_types: Optional[Sequence[_builtins.str]] = None,
                 tunnel_id: Optional[_builtins.str] = None,
                 virtual_network_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Optional remark describing the route.
        :param _builtins.str existed_at: If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        :param _builtins.bool is_deleted: If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        :param _builtins.str network_subset: If set, only list routes that are contained within this IP range.
        :param _builtins.str network_superset: If set, only list routes that contain this IP range.
        :param _builtins.str route_id: UUID of the route.
        :param Sequence[_builtins.str] tun_types: The types of tunnels to filter by, separated by commas.
        :param _builtins.str tunnel_id: UUID of the tunnel.
        :param _builtins.str virtual_network_id: UUID of the virtual network.
        """
        pulumi.set(__self__, "comment", comment)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if network_subset is not None:
            pulumi.set(__self__, "network_subset", network_subset)
        if network_superset is not None:
            pulumi.set(__self__, "network_superset", network_superset)
        if route_id is not None:
            pulumi.set(__self__, "route_id", route_id)
        if tun_types is not None:
            pulumi.set(__self__, "tun_types", tun_types)
        if tunnel_id is not None:
            pulumi.set(__self__, "tunnel_id", tunnel_id)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Optional remark describing the route.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: _builtins.str):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[_builtins.str]:
        """
        If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        """
        return pulumi.get(self, "existed_at")

    @existed_at.setter
    def existed_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "existed_at", value)

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[_builtins.bool]:
        """
        If `true`, only include deleted routes. If `false`, exclude deleted routes. If empty, all routes will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_deleted", value)

    @_builtins.property
    @pulumi.getter(name="networkSubset")
    def network_subset(self) -> Optional[_builtins.str]:
        """
        If set, only list routes that are contained within this IP range.
        """
        return pulumi.get(self, "network_subset")

    @network_subset.setter
    def network_subset(self, value: Optional[_builtins.str]):
        pulumi.set(self, "network_subset", value)

    @_builtins.property
    @pulumi.getter(name="networkSuperset")
    def network_superset(self) -> Optional[_builtins.str]:
        """
        If set, only list routes that contain this IP range.
        """
        return pulumi.get(self, "network_superset")

    @network_superset.setter
    def network_superset(self, value: Optional[_builtins.str]):
        pulumi.set(self, "network_superset", value)

    @_builtins.property
    @pulumi.getter(name="routeId")
    def route_id(self) -> Optional[_builtins.str]:
        """
        UUID of the route.
        """
        return pulumi.get(self, "route_id")

    @route_id.setter
    def route_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "route_id", value)

    @_builtins.property
    @pulumi.getter(name="tunTypes")
    def tun_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The types of tunnels to filter by, separated by commas.
        """
        return pulumi.get(self, "tun_types")

    @tun_types.setter
    def tun_types(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "tun_types", value)

    @_builtins.property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> Optional[_builtins.str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "tunnel_id")

    @tunnel_id.setter
    def tunnel_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tunnel_id", value)

    @_builtins.property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[_builtins.str]:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "virtual_network_id")

    @virtual_network_id.setter
    def virtual_network_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "virtual_network_id", value)


if not MYPY:
    class GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgsDict(TypedDict):
        id: NotRequired[_builtins.str]
        """
        UUID of the virtual network.
        """
        is_default: NotRequired[_builtins.bool]
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        is_default_network: NotRequired[_builtins.bool]
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        is_deleted: NotRequired[_builtins.bool]
        """
        If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        """
        name: NotRequired[_builtins.str]
        """
        A user-friendly name for the virtual network.
        """
elif False:
    GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelCloudflaredVirtualNetworkFilterArgs:
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 is_default_network: Optional[_builtins.bool] = None,
                 is_deleted: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: UUID of the virtual network.
        :param _builtins.bool is_default: If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        :param _builtins.bool is_default_network: If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        :param _builtins.bool is_deleted: If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        :param _builtins.str name: A user-friendly name for the virtual network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if is_default_network is not None:
            pulumi.set(__self__, "is_default_network", is_default_network)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        UUID of the virtual network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter(name="isDefaultNetwork")
    def is_default_network(self) -> Optional[_builtins.bool]:
        """
        If `true`, only include the default virtual network. If `false`, exclude the default virtual network. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_default_network")

    @is_default_network.setter
    def is_default_network(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_default_network", value)

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[_builtins.bool]:
        """
        If `true`, only include deleted virtual networks. If `false`, exclude deleted virtual networks. If empty, all virtual networks will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_deleted", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A user-friendly name for the virtual network.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetZeroTrustTunnelWarpConnectorFilterArgsDict(TypedDict):
        exclude_prefix: NotRequired[_builtins.str]
        existed_at: NotRequired[_builtins.str]
        """
        If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        """
        include_prefix: NotRequired[_builtins.str]
        is_deleted: NotRequired[_builtins.bool]
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        name: NotRequired[_builtins.str]
        """
        A user-friendly name for the tunnel.
        """
        status: NotRequired[_builtins.str]
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        Available values: "inactive", "degraded", "healthy", "down".
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID of the tunnel.
        """
        was_active_at: NotRequired[_builtins.str]
        was_inactive_at: NotRequired[_builtins.str]
elif False:
    GetZeroTrustTunnelWarpConnectorFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZeroTrustTunnelWarpConnectorFilterArgs:
    def __init__(__self__, *,
                 exclude_prefix: Optional[_builtins.str] = None,
                 existed_at: Optional[_builtins.str] = None,
                 include_prefix: Optional[_builtins.str] = None,
                 is_deleted: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 was_active_at: Optional[_builtins.str] = None,
                 was_inactive_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str existed_at: If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        :param _builtins.bool is_deleted: If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        :param _builtins.str name: A user-friendly name for the tunnel.
        :param _builtins.str status: The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
               Available values: "inactive", "degraded", "healthy", "down".
        :param _builtins.str uuid: UUID of the tunnel.
        """
        if exclude_prefix is not None:
            pulumi.set(__self__, "exclude_prefix", exclude_prefix)
        if existed_at is not None:
            pulumi.set(__self__, "existed_at", existed_at)
        if include_prefix is not None:
            pulumi.set(__self__, "include_prefix", include_prefix)
        if is_deleted is not None:
            pulumi.set(__self__, "is_deleted", is_deleted)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if was_active_at is not None:
            pulumi.set(__self__, "was_active_at", was_active_at)
        if was_inactive_at is not None:
            pulumi.set(__self__, "was_inactive_at", was_inactive_at)

    @_builtins.property
    @pulumi.getter(name="excludePrefix")
    def exclude_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "exclude_prefix")

    @exclude_prefix.setter
    def exclude_prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "exclude_prefix", value)

    @_builtins.property
    @pulumi.getter(name="existedAt")
    def existed_at(self) -> Optional[_builtins.str]:
        """
        If provided, include only resources that were created (and not deleted) before this time. URL encoded.
        """
        return pulumi.get(self, "existed_at")

    @existed_at.setter
    def existed_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "existed_at", value)

    @_builtins.property
    @pulumi.getter(name="includePrefix")
    def include_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "include_prefix")

    @include_prefix.setter
    def include_prefix(self, value: Optional[_builtins.str]):
        pulumi.set(self, "include_prefix", value)

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> Optional[_builtins.bool]:
        """
        If `true`, only include deleted tunnels. If `false`, exclude deleted tunnels. If empty, all tunnels will be included.
        """
        return pulumi.get(self, "is_deleted")

    @is_deleted.setter
    def is_deleted(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_deleted", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A user-friendly name for the tunnel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
        Available values: "inactive", "degraded", "healthy", "down".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the tunnel.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="wasActiveAt")
    def was_active_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "was_active_at")

    @was_active_at.setter
    def was_active_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "was_active_at", value)

    @_builtins.property
    @pulumi.getter(name="wasInactiveAt")
    def was_inactive_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "was_inactive_at")

    @was_inactive_at.setter
    def was_inactive_at(self, value: Optional[_builtins.str]):
        pulumi.set(self, "was_inactive_at", value)


if not MYPY:
    class GetZoneFilterArgsDict(TypedDict):
        match: _builtins.str
        """
        Whether to match all search requirements or at least one (any).
        Available values: "any", "all".
        """
        account: NotRequired['GetZoneFilterAccountArgsDict']
        direction: NotRequired[_builtins.str]
        """
        Direction to order zones.
        Available values: "asc", "desc".
        """
        name: NotRequired[_builtins.str]
        """
        A domain name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        order: NotRequired[_builtins.str]
        """
        Field to order zones by.
        Available values: "name", "status", "account.id", "account.name", "plan.id".
        """
        status: NotRequired[_builtins.str]
        """
        Specify a zone status to filter by.
        Available values: "initializing", "pending", "active", "moved".
        """
elif False:
    GetZoneFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZoneFilterArgs:
    def __init__(__self__, *,
                 match: _builtins.str,
                 account: Optional['GetZoneFilterAccountArgs'] = None,
                 direction: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 order: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str match: Whether to match all search requirements or at least one (any).
               Available values: "any", "all".
        :param _builtins.str direction: Direction to order zones.
               Available values: "asc", "desc".
        :param _builtins.str name: A domain name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        :param _builtins.str order: Field to order zones by.
               Available values: "name", "status", "account.id", "account.name", "plan.id".
        :param _builtins.str status: Specify a zone status to filter by.
               Available values: "initializing", "pending", "active", "moved".
        """
        pulumi.set(__self__, "match", match)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        Whether to match all search requirements or at least one (any).
        Available values: "any", "all".
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: _builtins.str):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional['GetZoneFilterAccountArgs']:
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional['GetZoneFilterAccountArgs']):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Direction to order zones.
        Available values: "asc", "desc".
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A domain name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.str]:
        """
        Field to order zones by.
        Available values: "name", "status", "account.id", "account.name", "plan.id".
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[_builtins.str]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Specify a zone status to filter by.
        Available values: "initializing", "pending", "active", "moved".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetZoneFilterAccountArgsDict(TypedDict):
        id: NotRequired[_builtins.str]
        """
        Filter by an account ID.
        """
        name: NotRequired[_builtins.str]
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
elif False:
    GetZoneFilterAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZoneFilterAccountArgs:
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Filter by an account ID.
        :param _builtins.str name: An account Name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Filter by an account ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetZoneLockdownFilterArgsDict(TypedDict):
        created_on: NotRequired[_builtins.str]
        """
        The timestamp of when the rule was created.
        """
        description: NotRequired[_builtins.str]
        """
        A string to search for in the description of existing rules.
        """
        description_search: NotRequired[_builtins.str]
        """
        A string to search for in the description of existing rules.
        """
        ip: NotRequired[_builtins.str]
        """
        A single IP address to search for in existing rules.
        """
        ip_range_search: NotRequired[_builtins.str]
        """
        A single IP address range to search for in existing rules.
        """
        ip_search: NotRequired[_builtins.str]
        """
        A single IP address to search for in existing rules.
        """
        modified_on: NotRequired[_builtins.str]
        """
        The timestamp of when the rule was last modified.
        """
        priority: NotRequired[_builtins.float]
        """
        The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        """
        uri_search: NotRequired[_builtins.str]
        """
        A single URI to search for in the list of URLs of existing rules.
        """
elif False:
    GetZoneLockdownFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZoneLockdownFilterArgs:
    def __init__(__self__, *,
                 created_on: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 description_search: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 ip_range_search: Optional[_builtins.str] = None,
                 ip_search: Optional[_builtins.str] = None,
                 modified_on: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.float] = None,
                 uri_search: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_on: The timestamp of when the rule was created.
        :param _builtins.str description: A string to search for in the description of existing rules.
        :param _builtins.str description_search: A string to search for in the description of existing rules.
        :param _builtins.str ip: A single IP address to search for in existing rules.
        :param _builtins.str ip_range_search: A single IP address range to search for in existing rules.
        :param _builtins.str ip_search: A single IP address to search for in existing rules.
        :param _builtins.str modified_on: The timestamp of when the rule was last modified.
        :param _builtins.float priority: The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        :param _builtins.str uri_search: A single URI to search for in the list of URLs of existing rules.
        """
        if created_on is not None:
            pulumi.set(__self__, "created_on", created_on)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if description_search is not None:
            pulumi.set(__self__, "description_search", description_search)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ip_range_search is not None:
            pulumi.set(__self__, "ip_range_search", ip_range_search)
        if ip_search is not None:
            pulumi.set(__self__, "ip_search", ip_search)
        if modified_on is not None:
            pulumi.set(__self__, "modified_on", modified_on)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if uri_search is not None:
            pulumi.set(__self__, "uri_search", uri_search)

    @_builtins.property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[_builtins.str]:
        """
        The timestamp of when the rule was created.
        """
        return pulumi.get(self, "created_on")

    @created_on.setter
    def created_on(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_on", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="descriptionSearch")
    def description_search(self) -> Optional[_builtins.str]:
        """
        A string to search for in the description of existing rules.
        """
        return pulumi.get(self, "description_search")

    @description_search.setter
    def description_search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description_search", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        A single IP address to search for in existing rules.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="ipRangeSearch")
    def ip_range_search(self) -> Optional[_builtins.str]:
        """
        A single IP address range to search for in existing rules.
        """
        return pulumi.get(self, "ip_range_search")

    @ip_range_search.setter
    def ip_range_search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ip_range_search", value)

    @_builtins.property
    @pulumi.getter(name="ipSearch")
    def ip_search(self) -> Optional[_builtins.str]:
        """
        A single IP address to search for in existing rules.
        """
        return pulumi.get(self, "ip_search")

    @ip_search.setter
    def ip_search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ip_search", value)

    @_builtins.property
    @pulumi.getter(name="modifiedOn")
    def modified_on(self) -> Optional[_builtins.str]:
        """
        The timestamp of when the rule was last modified.
        """
        return pulumi.get(self, "modified_on")

    @modified_on.setter
    def modified_on(self, value: Optional[_builtins.str]):
        pulumi.set(self, "modified_on", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[_builtins.float]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="uriSearch")
    def uri_search(self) -> Optional[_builtins.str]:
        """
        A single URI to search for in the list of URLs of existing rules.
        """
        return pulumi.get(self, "uri_search")

    @uri_search.setter
    def uri_search(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uri_search", value)


if not MYPY:
    class GetZonesAccountArgsDict(TypedDict):
        id: NotRequired[_builtins.str]
        """
        Filter by an account ID.
        """
        name: NotRequired[_builtins.str]
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
elif False:
    GetZonesAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetZonesAccountArgs:
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Filter by an account ID.
        :param _builtins.str name: An account Name. Optional filter operators can be provided to extend refine the search:
                 * `equal` (default)
                 * `not_equal`
                 * `starts_with`
                 * `ends_with`
                 * `contains`
                 * `starts_with_case_sensitive`
                 * `ends_with_case_sensitive`
                 * `contains_case_sensitive`
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Filter by an account ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        An account Name. Optional filter operators can be provided to extend refine the search:
          * `equal` (default)
          * `not_equal`
          * `starts_with`
          * `ends_with`
          * `contains`
          * `starts_with_case_sensitive`
          * `ends_with_case_sensitive`
          * `contains_case_sensitive`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)


